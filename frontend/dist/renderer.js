(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined") return require.apply(this, arguments);
    throw Error('Dynamic require of "' + x + '" is not supported');
  });
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/react/cjs/react.development.js
  var require_react_development = __commonJS({
    "node_modules/react/cjs/react.development.js"(exports, module) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
          }
          var ReactVersion = "18.3.1";
          var REACT_ELEMENT_TYPE = Symbol.for("react.element");
          var REACT_PORTAL_TYPE = Symbol.for("react.portal");
          var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
          var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
          var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
          var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
          var REACT_CONTEXT_TYPE = Symbol.for("react.context");
          var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
          var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
          var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
          var REACT_MEMO_TYPE = Symbol.for("react.memo");
          var REACT_LAZY_TYPE = Symbol.for("react.lazy");
          var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
          var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
          var FAUX_ITERATOR_SYMBOL = "@@iterator";
          function getIteratorFn(maybeIterable) {
            if (maybeIterable === null || typeof maybeIterable !== "object") {
              return null;
            }
            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
            if (typeof maybeIterator === "function") {
              return maybeIterator;
            }
            return null;
          }
          var ReactCurrentDispatcher = {
            /**
             * @internal
             * @type {ReactComponent}
             */
            current: null
          };
          var ReactCurrentBatchConfig = {
            transition: null
          };
          var ReactCurrentActQueue = {
            current: null,
            // Used to reproduce behavior of `batchedUpdates` in legacy mode.
            isBatchingLegacy: false,
            didScheduleLegacyUpdate: false
          };
          var ReactCurrentOwner = {
            /**
             * @internal
             * @type {ReactComponent}
             */
            current: null
          };
          var ReactDebugCurrentFrame = {};
          var currentExtraStackFrame = null;
          function setExtraStackFrame(stack) {
            {
              currentExtraStackFrame = stack;
            }
          }
          {
            ReactDebugCurrentFrame.setExtraStackFrame = function(stack) {
              {
                currentExtraStackFrame = stack;
              }
            };
            ReactDebugCurrentFrame.getCurrentStack = null;
            ReactDebugCurrentFrame.getStackAddendum = function() {
              var stack = "";
              if (currentExtraStackFrame) {
                stack += currentExtraStackFrame;
              }
              var impl = ReactDebugCurrentFrame.getCurrentStack;
              if (impl) {
                stack += impl() || "";
              }
              return stack;
            };
          }
          var enableScopeAPI = false;
          var enableCacheElement = false;
          var enableTransitionTracing = false;
          var enableLegacyHidden = false;
          var enableDebugTracing = false;
          var ReactSharedInternals = {
            ReactCurrentDispatcher,
            ReactCurrentBatchConfig,
            ReactCurrentOwner
          };
          {
            ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
            ReactSharedInternals.ReactCurrentActQueue = ReactCurrentActQueue;
          }
          function warn(format2) {
            {
              {
                for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                  args[_key - 1] = arguments[_key];
                }
                printWarning("warn", format2, args);
              }
            }
          }
          function error(format2) {
            {
              {
                for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                  args[_key2 - 1] = arguments[_key2];
                }
                printWarning("error", format2, args);
              }
            }
          }
          function printWarning(level, format2, args) {
            {
              var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
              var stack = ReactDebugCurrentFrame2.getStackAddendum();
              if (stack !== "") {
                format2 += "%s";
                args = args.concat([stack]);
              }
              var argsWithFormat = args.map(function(item) {
                return String(item);
              });
              argsWithFormat.unshift("Warning: " + format2);
              Function.prototype.apply.call(console[level], console, argsWithFormat);
            }
          }
          var didWarnStateUpdateForUnmountedComponent = {};
          function warnNoop(publicInstance, callerName) {
            {
              var _constructor = publicInstance.constructor;
              var componentName = _constructor && (_constructor.displayName || _constructor.name) || "ReactClass";
              var warningKey = componentName + "." + callerName;
              if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
                return;
              }
              error("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", callerName, componentName);
              didWarnStateUpdateForUnmountedComponent[warningKey] = true;
            }
          }
          var ReactNoopUpdateQueue = {
            /**
             * Checks whether or not this composite component is mounted.
             * @param {ReactClass} publicInstance The instance we want to test.
             * @return {boolean} True if mounted, false otherwise.
             * @protected
             * @final
             */
            isMounted: function(publicInstance) {
              return false;
            },
            /**
             * Forces an update. This should only be invoked when it is known with
             * certainty that we are **not** in a DOM transaction.
             *
             * You may want to call this when you know that some deeper aspect of the
             * component's state has changed but `setState` was not called.
             *
             * This will not invoke `shouldComponentUpdate`, but it will invoke
             * `componentWillUpdate` and `componentDidUpdate`.
             *
             * @param {ReactClass} publicInstance The instance that should rerender.
             * @param {?function} callback Called after component is updated.
             * @param {?string} callerName name of the calling function in the public API.
             * @internal
             */
            enqueueForceUpdate: function(publicInstance, callback, callerName) {
              warnNoop(publicInstance, "forceUpdate");
            },
            /**
             * Replaces all of the state. Always use this or `setState` to mutate state.
             * You should treat `this.state` as immutable.
             *
             * There is no guarantee that `this.state` will be immediately updated, so
             * accessing `this.state` after calling this method may return the old value.
             *
             * @param {ReactClass} publicInstance The instance that should rerender.
             * @param {object} completeState Next state.
             * @param {?function} callback Called after component is updated.
             * @param {?string} callerName name of the calling function in the public API.
             * @internal
             */
            enqueueReplaceState: function(publicInstance, completeState, callback, callerName) {
              warnNoop(publicInstance, "replaceState");
            },
            /**
             * Sets a subset of the state. This only exists because _pendingState is
             * internal. This provides a merging strategy that is not available to deep
             * properties which is confusing. TODO: Expose pendingState or don't use it
             * during the merge.
             *
             * @param {ReactClass} publicInstance The instance that should rerender.
             * @param {object} partialState Next partial state to be merged with state.
             * @param {?function} callback Called after component is updated.
             * @param {?string} Name of the calling function in the public API.
             * @internal
             */
            enqueueSetState: function(publicInstance, partialState, callback, callerName) {
              warnNoop(publicInstance, "setState");
            }
          };
          var assign = Object.assign;
          var emptyObject = {};
          {
            Object.freeze(emptyObject);
          }
          function Component3(props, context3, updater) {
            this.props = props;
            this.context = context3;
            this.refs = emptyObject;
            this.updater = updater || ReactNoopUpdateQueue;
          }
          Component3.prototype.isReactComponent = {};
          Component3.prototype.setState = function(partialState, callback) {
            if (typeof partialState !== "object" && typeof partialState !== "function" && partialState != null) {
              throw new Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
            }
            this.updater.enqueueSetState(this, partialState, callback, "setState");
          };
          Component3.prototype.forceUpdate = function(callback) {
            this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
          };
          {
            var deprecatedAPIs = {
              isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
              replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
            };
            var defineDeprecationWarning = function(methodName, info) {
              Object.defineProperty(Component3.prototype, methodName, {
                get: function() {
                  warn("%s(...) is deprecated in plain JavaScript React classes. %s", info[0], info[1]);
                  return void 0;
                }
              });
            };
            for (var fnName in deprecatedAPIs) {
              if (deprecatedAPIs.hasOwnProperty(fnName)) {
                defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
              }
            }
          }
          function ComponentDummy() {
          }
          ComponentDummy.prototype = Component3.prototype;
          function PureComponent(props, context3, updater) {
            this.props = props;
            this.context = context3;
            this.refs = emptyObject;
            this.updater = updater || ReactNoopUpdateQueue;
          }
          var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
          pureComponentPrototype.constructor = PureComponent;
          assign(pureComponentPrototype, Component3.prototype);
          pureComponentPrototype.isPureReactComponent = true;
          function createRef() {
            var refObject = {
              current: null
            };
            {
              Object.seal(refObject);
            }
            return refObject;
          }
          var isArrayImpl = Array.isArray;
          function isArray(a) {
            return isArrayImpl(a);
          }
          function typeName(value) {
            {
              var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
              var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
              return type;
            }
          }
          function willCoercionThrow(value) {
            {
              try {
                testStringCoercion(value);
                return false;
              } catch (e) {
                return true;
              }
            }
          }
          function testStringCoercion(value) {
            return "" + value;
          }
          function checkKeyStringCoercion(value) {
            {
              if (willCoercionThrow(value)) {
                error("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
                return testStringCoercion(value);
              }
            }
          }
          function getWrappedName(outerType, innerType, wrapperName) {
            var displayName = outerType.displayName;
            if (displayName) {
              return displayName;
            }
            var functionName = innerType.displayName || innerType.name || "";
            return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
          }
          function getContextName(type) {
            return type.displayName || "Context";
          }
          function getComponentNameFromType(type) {
            if (type == null) {
              return null;
            }
            {
              if (typeof type.tag === "number") {
                error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
              }
            }
            if (typeof type === "function") {
              return type.displayName || type.name || null;
            }
            if (typeof type === "string") {
              return type;
            }
            switch (type) {
              case REACT_FRAGMENT_TYPE:
                return "Fragment";
              case REACT_PORTAL_TYPE:
                return "Portal";
              case REACT_PROFILER_TYPE:
                return "Profiler";
              case REACT_STRICT_MODE_TYPE:
                return "StrictMode";
              case REACT_SUSPENSE_TYPE:
                return "Suspense";
              case REACT_SUSPENSE_LIST_TYPE:
                return "SuspenseList";
            }
            if (typeof type === "object") {
              switch (type.$$typeof) {
                case REACT_CONTEXT_TYPE:
                  var context3 = type;
                  return getContextName(context3) + ".Consumer";
                case REACT_PROVIDER_TYPE:
                  var provider = type;
                  return getContextName(provider._context) + ".Provider";
                case REACT_FORWARD_REF_TYPE:
                  return getWrappedName(type, type.render, "ForwardRef");
                case REACT_MEMO_TYPE:
                  var outerName = type.displayName || null;
                  if (outerName !== null) {
                    return outerName;
                  }
                  return getComponentNameFromType(type.type) || "Memo";
                case REACT_LAZY_TYPE: {
                  var lazyComponent = type;
                  var payload = lazyComponent._payload;
                  var init5 = lazyComponent._init;
                  try {
                    return getComponentNameFromType(init5(payload));
                  } catch (x) {
                    return null;
                  }
                }
              }
            }
            return null;
          }
          var hasOwnProperty = Object.prototype.hasOwnProperty;
          var RESERVED_PROPS = {
            key: true,
            ref: true,
            __self: true,
            __source: true
          };
          var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;
          {
            didWarnAboutStringRefs = {};
          }
          function hasValidRef(config3) {
            {
              if (hasOwnProperty.call(config3, "ref")) {
                var getter = Object.getOwnPropertyDescriptor(config3, "ref").get;
                if (getter && getter.isReactWarning) {
                  return false;
                }
              }
            }
            return config3.ref !== void 0;
          }
          function hasValidKey(config3) {
            {
              if (hasOwnProperty.call(config3, "key")) {
                var getter = Object.getOwnPropertyDescriptor(config3, "key").get;
                if (getter && getter.isReactWarning) {
                  return false;
                }
              }
            }
            return config3.key !== void 0;
          }
          function defineKeyPropWarningGetter(props, displayName) {
            var warnAboutAccessingKey = function() {
              {
                if (!specialPropKeyWarningShown) {
                  specialPropKeyWarningShown = true;
                  error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
                }
              }
            };
            warnAboutAccessingKey.isReactWarning = true;
            Object.defineProperty(props, "key", {
              get: warnAboutAccessingKey,
              configurable: true
            });
          }
          function defineRefPropWarningGetter(props, displayName) {
            var warnAboutAccessingRef = function() {
              {
                if (!specialPropRefWarningShown) {
                  specialPropRefWarningShown = true;
                  error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
                }
              }
            };
            warnAboutAccessingRef.isReactWarning = true;
            Object.defineProperty(props, "ref", {
              get: warnAboutAccessingRef,
              configurable: true
            });
          }
          function warnIfStringRefCannotBeAutoConverted(config3) {
            {
              if (typeof config3.ref === "string" && ReactCurrentOwner.current && config3.__self && ReactCurrentOwner.current.stateNode !== config3.__self) {
                var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
                if (!didWarnAboutStringRefs[componentName]) {
                  error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', componentName, config3.ref);
                  didWarnAboutStringRefs[componentName] = true;
                }
              }
            }
          }
          var ReactElement = function(type, key, ref2, self2, source, owner, props) {
            var element = {
              // This tag allows us to uniquely identify this as a React Element
              $$typeof: REACT_ELEMENT_TYPE,
              // Built-in properties that belong on the element
              type,
              key,
              ref: ref2,
              props,
              // Record the component responsible for creating this element.
              _owner: owner
            };
            {
              element._store = {};
              Object.defineProperty(element._store, "validated", {
                configurable: false,
                enumerable: false,
                writable: true,
                value: false
              });
              Object.defineProperty(element, "_self", {
                configurable: false,
                enumerable: false,
                writable: false,
                value: self2
              });
              Object.defineProperty(element, "_source", {
                configurable: false,
                enumerable: false,
                writable: false,
                value: source
              });
              if (Object.freeze) {
                Object.freeze(element.props);
                Object.freeze(element);
              }
            }
            return element;
          };
          function createElement4(type, config3, children) {
            var propName;
            var props = {};
            var key = null;
            var ref2 = null;
            var self2 = null;
            var source = null;
            if (config3 != null) {
              if (hasValidRef(config3)) {
                ref2 = config3.ref;
                {
                  warnIfStringRefCannotBeAutoConverted(config3);
                }
              }
              if (hasValidKey(config3)) {
                {
                  checkKeyStringCoercion(config3.key);
                }
                key = "" + config3.key;
              }
              self2 = config3.__self === void 0 ? null : config3.__self;
              source = config3.__source === void 0 ? null : config3.__source;
              for (propName in config3) {
                if (hasOwnProperty.call(config3, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                  props[propName] = config3[propName];
                }
              }
            }
            var childrenLength = arguments.length - 2;
            if (childrenLength === 1) {
              props.children = children;
            } else if (childrenLength > 1) {
              var childArray = Array(childrenLength);
              for (var i = 0; i < childrenLength; i++) {
                childArray[i] = arguments[i + 2];
              }
              {
                if (Object.freeze) {
                  Object.freeze(childArray);
                }
              }
              props.children = childArray;
            }
            if (type && type.defaultProps) {
              var defaultProps = type.defaultProps;
              for (propName in defaultProps) {
                if (props[propName] === void 0) {
                  props[propName] = defaultProps[propName];
                }
              }
            }
            {
              if (key || ref2) {
                var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
                if (key) {
                  defineKeyPropWarningGetter(props, displayName);
                }
                if (ref2) {
                  defineRefPropWarningGetter(props, displayName);
                }
              }
            }
            return ReactElement(type, key, ref2, self2, source, ReactCurrentOwner.current, props);
          }
          function cloneAndReplaceKey(oldElement, newKey) {
            var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
            return newElement;
          }
          function cloneElement(element, config3, children) {
            if (element === null || element === void 0) {
              throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + element + ".");
            }
            var propName;
            var props = assign({}, element.props);
            var key = element.key;
            var ref2 = element.ref;
            var self2 = element._self;
            var source = element._source;
            var owner = element._owner;
            if (config3 != null) {
              if (hasValidRef(config3)) {
                ref2 = config3.ref;
                owner = ReactCurrentOwner.current;
              }
              if (hasValidKey(config3)) {
                {
                  checkKeyStringCoercion(config3.key);
                }
                key = "" + config3.key;
              }
              var defaultProps;
              if (element.type && element.type.defaultProps) {
                defaultProps = element.type.defaultProps;
              }
              for (propName in config3) {
                if (hasOwnProperty.call(config3, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                  if (config3[propName] === void 0 && defaultProps !== void 0) {
                    props[propName] = defaultProps[propName];
                  } else {
                    props[propName] = config3[propName];
                  }
                }
              }
            }
            var childrenLength = arguments.length - 2;
            if (childrenLength === 1) {
              props.children = children;
            } else if (childrenLength > 1) {
              var childArray = Array(childrenLength);
              for (var i = 0; i < childrenLength; i++) {
                childArray[i] = arguments[i + 2];
              }
              props.children = childArray;
            }
            return ReactElement(element.type, key, ref2, self2, source, owner, props);
          }
          function isValidElement2(object) {
            return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
          }
          var SEPARATOR = ".";
          var SUBSEPARATOR = ":";
          function escape(key) {
            var escapeRegex = /[=:]/g;
            var escaperLookup = {
              "=": "=0",
              ":": "=2"
            };
            var escapedString = key.replace(escapeRegex, function(match) {
              return escaperLookup[match];
            });
            return "$" + escapedString;
          }
          var didWarnAboutMaps = false;
          var userProvidedKeyEscapeRegex = /\/+/g;
          function escapeUserProvidedKey(text) {
            return text.replace(userProvidedKeyEscapeRegex, "$&/");
          }
          function getElementKey(element, index) {
            if (typeof element === "object" && element !== null && element.key != null) {
              {
                checkKeyStringCoercion(element.key);
              }
              return escape("" + element.key);
            }
            return index.toString(36);
          }
          function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
            var type = typeof children;
            if (type === "undefined" || type === "boolean") {
              children = null;
            }
            var invokeCallback = false;
            if (children === null) {
              invokeCallback = true;
            } else {
              switch (type) {
                case "string":
                case "number":
                  invokeCallback = true;
                  break;
                case "object":
                  switch (children.$$typeof) {
                    case REACT_ELEMENT_TYPE:
                    case REACT_PORTAL_TYPE:
                      invokeCallback = true;
                  }
              }
            }
            if (invokeCallback) {
              var _child = children;
              var mappedChild = callback(_child);
              var childKey = nameSoFar === "" ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;
              if (isArray(mappedChild)) {
                var escapedChildKey = "";
                if (childKey != null) {
                  escapedChildKey = escapeUserProvidedKey(childKey) + "/";
                }
                mapIntoArray(mappedChild, array, escapedChildKey, "", function(c) {
                  return c;
                });
              } else if (mappedChild != null) {
                if (isValidElement2(mappedChild)) {
                  {
                    if (mappedChild.key && (!_child || _child.key !== mappedChild.key)) {
                      checkKeyStringCoercion(mappedChild.key);
                    }
                  }
                  mappedChild = cloneAndReplaceKey(
                    mappedChild,
                    // Keep both the (mapped) and old keys if they differ, just as
                    // traverseAllChildren used to do for objects as children
                    escapedPrefix + // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
                    (mappedChild.key && (!_child || _child.key !== mappedChild.key) ? (
                      // $FlowFixMe Flow incorrectly thinks existing element's key can be a number
                      // eslint-disable-next-line react-internal/safe-string-coercion
                      escapeUserProvidedKey("" + mappedChild.key) + "/"
                    ) : "") + childKey
                  );
                }
                array.push(mappedChild);
              }
              return 1;
            }
            var child;
            var nextName;
            var subtreeCount = 0;
            var nextNamePrefix = nameSoFar === "" ? SEPARATOR : nameSoFar + SUBSEPARATOR;
            if (isArray(children)) {
              for (var i = 0; i < children.length; i++) {
                child = children[i];
                nextName = nextNamePrefix + getElementKey(child, i);
                subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
              }
            } else {
              var iteratorFn = getIteratorFn(children);
              if (typeof iteratorFn === "function") {
                var iterableChildren = children;
                {
                  if (iteratorFn === iterableChildren.entries) {
                    if (!didWarnAboutMaps) {
                      warn("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
                    }
                    didWarnAboutMaps = true;
                  }
                }
                var iterator = iteratorFn.call(iterableChildren);
                var step;
                var ii = 0;
                while (!(step = iterator.next()).done) {
                  child = step.value;
                  nextName = nextNamePrefix + getElementKey(child, ii++);
                  subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
                }
              } else if (type === "object") {
                var childrenString = String(children);
                throw new Error("Objects are not valid as a React child (found: " + (childrenString === "[object Object]" ? "object with keys {" + Object.keys(children).join(", ") + "}" : childrenString) + "). If you meant to render a collection of children, use an array instead.");
              }
            }
            return subtreeCount;
          }
          function mapChildren(children, func, context3) {
            if (children == null) {
              return children;
            }
            var result = [];
            var count = 0;
            mapIntoArray(children, result, "", "", function(child) {
              return func.call(context3, child, count++);
            });
            return result;
          }
          function countChildren(children) {
            var n = 0;
            mapChildren(children, function() {
              n++;
            });
            return n;
          }
          function forEachChildren(children, forEachFunc, forEachContext) {
            mapChildren(children, function() {
              forEachFunc.apply(this, arguments);
            }, forEachContext);
          }
          function toArray3(children) {
            return mapChildren(children, function(child) {
              return child;
            }) || [];
          }
          function onlyChild(children) {
            if (!isValidElement2(children)) {
              throw new Error("React.Children.only expected to receive a single React element child.");
            }
            return children;
          }
          function createContext9(defaultValue) {
            var context3 = {
              $$typeof: REACT_CONTEXT_TYPE,
              // As a workaround to support multiple concurrent renderers, we categorize
              // some renderers as primary and others as secondary. We only expect
              // there to be two concurrent renderers at most: React Native (primary) and
              // Fabric (secondary); React DOM (primary) and React ART (secondary).
              // Secondary renderers store their context values on separate fields.
              _currentValue: defaultValue,
              _currentValue2: defaultValue,
              // Used to track how many concurrent renderers this context currently
              // supports within in a single renderer. Such as parallel server rendering.
              _threadCount: 0,
              // These are circular
              Provider: null,
              Consumer: null,
              // Add these to use same hidden class in VM as ServerContext
              _defaultValue: null,
              _globalName: null
            };
            context3.Provider = {
              $$typeof: REACT_PROVIDER_TYPE,
              _context: context3
            };
            var hasWarnedAboutUsingNestedContextConsumers = false;
            var hasWarnedAboutUsingConsumerProvider = false;
            var hasWarnedAboutDisplayNameOnConsumer = false;
            {
              var Consumer = {
                $$typeof: REACT_CONTEXT_TYPE,
                _context: context3
              };
              Object.defineProperties(Consumer, {
                Provider: {
                  get: function() {
                    if (!hasWarnedAboutUsingConsumerProvider) {
                      hasWarnedAboutUsingConsumerProvider = true;
                      error("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?");
                    }
                    return context3.Provider;
                  },
                  set: function(_Provider) {
                    context3.Provider = _Provider;
                  }
                },
                _currentValue: {
                  get: function() {
                    return context3._currentValue;
                  },
                  set: function(_currentValue) {
                    context3._currentValue = _currentValue;
                  }
                },
                _currentValue2: {
                  get: function() {
                    return context3._currentValue2;
                  },
                  set: function(_currentValue2) {
                    context3._currentValue2 = _currentValue2;
                  }
                },
                _threadCount: {
                  get: function() {
                    return context3._threadCount;
                  },
                  set: function(_threadCount) {
                    context3._threadCount = _threadCount;
                  }
                },
                Consumer: {
                  get: function() {
                    if (!hasWarnedAboutUsingNestedContextConsumers) {
                      hasWarnedAboutUsingNestedContextConsumers = true;
                      error("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                    }
                    return context3.Consumer;
                  }
                },
                displayName: {
                  get: function() {
                    return context3.displayName;
                  },
                  set: function(displayName) {
                    if (!hasWarnedAboutDisplayNameOnConsumer) {
                      warn("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", displayName);
                      hasWarnedAboutDisplayNameOnConsumer = true;
                    }
                  }
                }
              });
              context3.Consumer = Consumer;
            }
            {
              context3._currentRenderer = null;
              context3._currentRenderer2 = null;
            }
            return context3;
          }
          var Uninitialized = -1;
          var Pending = 0;
          var Resolved = 1;
          var Rejected = 2;
          function lazyInitializer(payload) {
            if (payload._status === Uninitialized) {
              var ctor = payload._result;
              var thenable = ctor();
              thenable.then(function(moduleObject2) {
                if (payload._status === Pending || payload._status === Uninitialized) {
                  var resolved = payload;
                  resolved._status = Resolved;
                  resolved._result = moduleObject2;
                }
              }, function(error2) {
                if (payload._status === Pending || payload._status === Uninitialized) {
                  var rejected = payload;
                  rejected._status = Rejected;
                  rejected._result = error2;
                }
              });
              if (payload._status === Uninitialized) {
                var pending = payload;
                pending._status = Pending;
                pending._result = thenable;
              }
            }
            if (payload._status === Resolved) {
              var moduleObject = payload._result;
              {
                if (moduleObject === void 0) {
                  error("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))\n\nDid you accidentally put curly braces around the import?", moduleObject);
                }
              }
              {
                if (!("default" in moduleObject)) {
                  error("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))", moduleObject);
                }
              }
              return moduleObject.default;
            } else {
              throw payload._result;
            }
          }
          function lazy(ctor) {
            var payload = {
              // We use these fields to store the result.
              _status: Uninitialized,
              _result: ctor
            };
            var lazyType = {
              $$typeof: REACT_LAZY_TYPE,
              _payload: payload,
              _init: lazyInitializer
            };
            {
              var defaultProps;
              var propTypes;
              Object.defineProperties(lazyType, {
                defaultProps: {
                  configurable: true,
                  get: function() {
                    return defaultProps;
                  },
                  set: function(newDefaultProps) {
                    error("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                    defaultProps = newDefaultProps;
                    Object.defineProperty(lazyType, "defaultProps", {
                      enumerable: true
                    });
                  }
                },
                propTypes: {
                  configurable: true,
                  get: function() {
                    return propTypes;
                  },
                  set: function(newPropTypes) {
                    error("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                    propTypes = newPropTypes;
                    Object.defineProperty(lazyType, "propTypes", {
                      enumerable: true
                    });
                  }
                }
              });
            }
            return lazyType;
          }
          function forwardRef3(render4) {
            {
              if (render4 != null && render4.$$typeof === REACT_MEMO_TYPE) {
                error("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).");
              } else if (typeof render4 !== "function") {
                error("forwardRef requires a render function but was given %s.", render4 === null ? "null" : typeof render4);
              } else {
                if (render4.length !== 0 && render4.length !== 2) {
                  error("forwardRef render functions accept exactly two parameters: props and ref. %s", render4.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined.");
                }
              }
              if (render4 != null) {
                if (render4.defaultProps != null || render4.propTypes != null) {
                  error("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
                }
              }
            }
            var elementType = {
              $$typeof: REACT_FORWARD_REF_TYPE,
              render: render4
            };
            {
              var ownName;
              Object.defineProperty(elementType, "displayName", {
                enumerable: false,
                configurable: true,
                get: function() {
                  return ownName;
                },
                set: function(name) {
                  ownName = name;
                  if (!render4.name && !render4.displayName) {
                    render4.displayName = name;
                  }
                }
              });
            }
            return elementType;
          }
          var REACT_MODULE_REFERENCE;
          {
            REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
          }
          function isValidElementType(type) {
            if (typeof type === "string" || typeof type === "function") {
              return true;
            }
            if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
              return true;
            }
            if (typeof type === "object" && type !== null) {
              if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
              // types supported by any Flight configuration anywhere since
              // we don't know which Flight build this will end up being used
              // with.
              type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {
                return true;
              }
            }
            return false;
          }
          function memo3(type, compare) {
            {
              if (!isValidElementType(type)) {
                error("memo: The first argument must be a component. Instead received: %s", type === null ? "null" : typeof type);
              }
            }
            var elementType = {
              $$typeof: REACT_MEMO_TYPE,
              type,
              compare: compare === void 0 ? null : compare
            };
            {
              var ownName;
              Object.defineProperty(elementType, "displayName", {
                enumerable: false,
                configurable: true,
                get: function() {
                  return ownName;
                },
                set: function(name) {
                  ownName = name;
                  if (!type.name && !type.displayName) {
                    type.displayName = name;
                  }
                }
              });
            }
            return elementType;
          }
          function resolveDispatcher() {
            var dispatcher = ReactCurrentDispatcher.current;
            {
              if (dispatcher === null) {
                error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
              }
            }
            return dispatcher;
          }
          function useContext12(Context2) {
            var dispatcher = resolveDispatcher();
            {
              if (Context2._context !== void 0) {
                var realContext = Context2._context;
                if (realContext.Consumer === Context2) {
                  error("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?");
                } else if (realContext.Provider === Context2) {
                  error("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
                }
              }
            }
            return dispatcher.useContext(Context2);
          }
          function useState8(initialState) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useState(initialState);
          }
          function useReducer(reducer, initialArg, init5) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useReducer(reducer, initialArg, init5);
          }
          function useRef14(initialValue) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useRef(initialValue);
          }
          function useEffect15(create, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useEffect(create, deps);
          }
          function useInsertionEffect4(create, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useInsertionEffect(create, deps);
          }
          function useLayoutEffect6(create, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useLayoutEffect(create, deps);
          }
          function useCallback7(callback, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useCallback(callback, deps);
          }
          function useMemo9(create, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useMemo(create, deps);
          }
          function useImperativeHandle(ref2, create, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useImperativeHandle(ref2, create, deps);
          }
          function useDebugValue(value, formatterFn) {
            {
              var dispatcher = resolveDispatcher();
              return dispatcher.useDebugValue(value, formatterFn);
            }
          }
          function useTransition() {
            var dispatcher = resolveDispatcher();
            return dispatcher.useTransition();
          }
          function useDeferredValue(value) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useDeferredValue(value);
          }
          function useId2() {
            var dispatcher = resolveDispatcher();
            return dispatcher.useId();
          }
          function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
          }
          var disabledDepth = 0;
          var prevLog;
          var prevInfo;
          var prevWarn;
          var prevError;
          var prevGroup;
          var prevGroupCollapsed;
          var prevGroupEnd;
          function disabledLog() {
          }
          disabledLog.__reactDisabledLog = true;
          function disableLogs() {
            {
              if (disabledDepth === 0) {
                prevLog = console.log;
                prevInfo = console.info;
                prevWarn = console.warn;
                prevError = console.error;
                prevGroup = console.group;
                prevGroupCollapsed = console.groupCollapsed;
                prevGroupEnd = console.groupEnd;
                var props = {
                  configurable: true,
                  enumerable: true,
                  value: disabledLog,
                  writable: true
                };
                Object.defineProperties(console, {
                  info: props,
                  log: props,
                  warn: props,
                  error: props,
                  group: props,
                  groupCollapsed: props,
                  groupEnd: props
                });
              }
              disabledDepth++;
            }
          }
          function reenableLogs() {
            {
              disabledDepth--;
              if (disabledDepth === 0) {
                var props = {
                  configurable: true,
                  enumerable: true,
                  writable: true
                };
                Object.defineProperties(console, {
                  log: assign({}, props, {
                    value: prevLog
                  }),
                  info: assign({}, props, {
                    value: prevInfo
                  }),
                  warn: assign({}, props, {
                    value: prevWarn
                  }),
                  error: assign({}, props, {
                    value: prevError
                  }),
                  group: assign({}, props, {
                    value: prevGroup
                  }),
                  groupCollapsed: assign({}, props, {
                    value: prevGroupCollapsed
                  }),
                  groupEnd: assign({}, props, {
                    value: prevGroupEnd
                  })
                });
              }
              if (disabledDepth < 0) {
                error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
              }
            }
          }
          var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
          var prefix;
          function describeBuiltInComponentFrame(name, source, ownerFn) {
            {
              if (prefix === void 0) {
                try {
                  throw Error();
                } catch (x) {
                  var match = x.stack.trim().match(/\n( *(at )?)/);
                  prefix = match && match[1] || "";
                }
              }
              return "\n" + prefix + name;
            }
          }
          var reentry = false;
          var componentFrameCache;
          {
            var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
            componentFrameCache = new PossiblyWeakMap();
          }
          function describeNativeComponentFrame(fn, construct) {
            if (!fn || reentry) {
              return "";
            }
            {
              var frame2 = componentFrameCache.get(fn);
              if (frame2 !== void 0) {
                return frame2;
              }
            }
            var control;
            reentry = true;
            var previousPrepareStackTrace = Error.prepareStackTrace;
            Error.prepareStackTrace = void 0;
            var previousDispatcher;
            {
              previousDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = null;
              disableLogs();
            }
            try {
              if (construct) {
                var Fake = function() {
                  throw Error();
                };
                Object.defineProperty(Fake.prototype, "props", {
                  set: function() {
                    throw Error();
                  }
                });
                if (typeof Reflect === "object" && Reflect.construct) {
                  try {
                    Reflect.construct(Fake, []);
                  } catch (x) {
                    control = x;
                  }
                  Reflect.construct(fn, [], Fake);
                } else {
                  try {
                    Fake.call();
                  } catch (x) {
                    control = x;
                  }
                  fn.call(Fake.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (x) {
                  control = x;
                }
                fn();
              }
            } catch (sample) {
              if (sample && control && typeof sample.stack === "string") {
                var sampleLines = sample.stack.split("\n");
                var controlLines = control.stack.split("\n");
                var s = sampleLines.length - 1;
                var c = controlLines.length - 1;
                while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
                  c--;
                }
                for (; s >= 1 && c >= 0; s--, c--) {
                  if (sampleLines[s] !== controlLines[c]) {
                    if (s !== 1 || c !== 1) {
                      do {
                        s--;
                        c--;
                        if (c < 0 || sampleLines[s] !== controlLines[c]) {
                          var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                          if (fn.displayName && _frame.includes("<anonymous>")) {
                            _frame = _frame.replace("<anonymous>", fn.displayName);
                          }
                          {
                            if (typeof fn === "function") {
                              componentFrameCache.set(fn, _frame);
                            }
                          }
                          return _frame;
                        }
                      } while (s >= 1 && c >= 0);
                    }
                    break;
                  }
                }
              }
            } finally {
              reentry = false;
              {
                ReactCurrentDispatcher$1.current = previousDispatcher;
                reenableLogs();
              }
              Error.prepareStackTrace = previousPrepareStackTrace;
            }
            var name = fn ? fn.displayName || fn.name : "";
            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
            {
              if (typeof fn === "function") {
                componentFrameCache.set(fn, syntheticFrame);
              }
            }
            return syntheticFrame;
          }
          function describeFunctionComponentFrame(fn, source, ownerFn) {
            {
              return describeNativeComponentFrame(fn, false);
            }
          }
          function shouldConstruct(Component4) {
            var prototype = Component4.prototype;
            return !!(prototype && prototype.isReactComponent);
          }
          function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
            if (type == null) {
              return "";
            }
            if (typeof type === "function") {
              {
                return describeNativeComponentFrame(type, shouldConstruct(type));
              }
            }
            if (typeof type === "string") {
              return describeBuiltInComponentFrame(type);
            }
            switch (type) {
              case REACT_SUSPENSE_TYPE:
                return describeBuiltInComponentFrame("Suspense");
              case REACT_SUSPENSE_LIST_TYPE:
                return describeBuiltInComponentFrame("SuspenseList");
            }
            if (typeof type === "object") {
              switch (type.$$typeof) {
                case REACT_FORWARD_REF_TYPE:
                  return describeFunctionComponentFrame(type.render);
                case REACT_MEMO_TYPE:
                  return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
                case REACT_LAZY_TYPE: {
                  var lazyComponent = type;
                  var payload = lazyComponent._payload;
                  var init5 = lazyComponent._init;
                  try {
                    return describeUnknownElementTypeFrameInDEV(init5(payload), source, ownerFn);
                  } catch (x) {
                  }
                }
              }
            }
            return "";
          }
          var loggedTypeFailures = {};
          var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
          function setCurrentlyValidatingElement(element) {
            {
              if (element) {
                var owner = element._owner;
                var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
              } else {
                ReactDebugCurrentFrame$1.setExtraStackFrame(null);
              }
            }
          }
          function checkPropTypes(typeSpecs, values, location2, componentName, element) {
            {
              var has = Function.call.bind(hasOwnProperty);
              for (var typeSpecName in typeSpecs) {
                if (has(typeSpecs, typeSpecName)) {
                  var error$1 = void 0;
                  try {
                    if (typeof typeSpecs[typeSpecName] !== "function") {
                      var err = Error((componentName || "React class") + ": " + location2 + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                      err.name = "Invariant Violation";
                      throw err;
                    }
                    error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location2, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                  } catch (ex) {
                    error$1 = ex;
                  }
                  if (error$1 && !(error$1 instanceof Error)) {
                    setCurrentlyValidatingElement(element);
                    error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location2, typeSpecName, typeof error$1);
                    setCurrentlyValidatingElement(null);
                  }
                  if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                    loggedTypeFailures[error$1.message] = true;
                    setCurrentlyValidatingElement(element);
                    error("Failed %s type: %s", location2, error$1.message);
                    setCurrentlyValidatingElement(null);
                  }
                }
              }
            }
          }
          function setCurrentlyValidatingElement$1(element) {
            {
              if (element) {
                var owner = element._owner;
                var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                setExtraStackFrame(stack);
              } else {
                setExtraStackFrame(null);
              }
            }
          }
          var propTypesMisspellWarningShown;
          {
            propTypesMisspellWarningShown = false;
          }
          function getDeclarationErrorAddendum() {
            if (ReactCurrentOwner.current) {
              var name = getComponentNameFromType(ReactCurrentOwner.current.type);
              if (name) {
                return "\n\nCheck the render method of `" + name + "`.";
              }
            }
            return "";
          }
          function getSourceInfoErrorAddendum(source) {
            if (source !== void 0) {
              var fileName = source.fileName.replace(/^.*[\\\/]/, "");
              var lineNumber = source.lineNumber;
              return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
            }
            return "";
          }
          function getSourceInfoErrorAddendumForProps(elementProps) {
            if (elementProps !== null && elementProps !== void 0) {
              return getSourceInfoErrorAddendum(elementProps.__source);
            }
            return "";
          }
          var ownerHasKeyUseWarning = {};
          function getCurrentComponentErrorInfo(parentType) {
            var info = getDeclarationErrorAddendum();
            if (!info) {
              var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
              if (parentName) {
                info = "\n\nCheck the top-level render call using <" + parentName + ">.";
              }
            }
            return info;
          }
          function validateExplicitKey(element, parentType) {
            if (!element._store || element._store.validated || element.key != null) {
              return;
            }
            element._store.validated = true;
            var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
            if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
              return;
            }
            ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
            var childOwner = "";
            if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
              childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
            }
            {
              setCurrentlyValidatingElement$1(element);
              error('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
              setCurrentlyValidatingElement$1(null);
            }
          }
          function validateChildKeys(node, parentType) {
            if (typeof node !== "object") {
              return;
            }
            if (isArray(node)) {
              for (var i = 0; i < node.length; i++) {
                var child = node[i];
                if (isValidElement2(child)) {
                  validateExplicitKey(child, parentType);
                }
              }
            } else if (isValidElement2(node)) {
              if (node._store) {
                node._store.validated = true;
              }
            } else if (node) {
              var iteratorFn = getIteratorFn(node);
              if (typeof iteratorFn === "function") {
                if (iteratorFn !== node.entries) {
                  var iterator = iteratorFn.call(node);
                  var step;
                  while (!(step = iterator.next()).done) {
                    if (isValidElement2(step.value)) {
                      validateExplicitKey(step.value, parentType);
                    }
                  }
                }
              }
            }
          }
          function validatePropTypes(element) {
            {
              var type = element.type;
              if (type === null || type === void 0 || typeof type === "string") {
                return;
              }
              var propTypes;
              if (typeof type === "function") {
                propTypes = type.propTypes;
              } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
              // Inner props are checked in the reconciler.
              type.$$typeof === REACT_MEMO_TYPE)) {
                propTypes = type.propTypes;
              } else {
                return;
              }
              if (propTypes) {
                var name = getComponentNameFromType(type);
                checkPropTypes(propTypes, element.props, "prop", name, element);
              } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
                propTypesMisspellWarningShown = true;
                var _name = getComponentNameFromType(type);
                error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
              }
              if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
                error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
              }
            }
          }
          function validateFragmentProps(fragment) {
            {
              var keys2 = Object.keys(fragment.props);
              for (var i = 0; i < keys2.length; i++) {
                var key = keys2[i];
                if (key !== "children" && key !== "key") {
                  setCurrentlyValidatingElement$1(fragment);
                  error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
                  setCurrentlyValidatingElement$1(null);
                  break;
                }
              }
              if (fragment.ref !== null) {
                setCurrentlyValidatingElement$1(fragment);
                error("Invalid attribute `ref` supplied to `React.Fragment`.");
                setCurrentlyValidatingElement$1(null);
              }
            }
          }
          function createElementWithValidation(type, props, children) {
            var validType = isValidElementType(type);
            if (!validType) {
              var info = "";
              if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
                info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
              }
              var sourceInfo = getSourceInfoErrorAddendumForProps(props);
              if (sourceInfo) {
                info += sourceInfo;
              } else {
                info += getDeclarationErrorAddendum();
              }
              var typeString;
              if (type === null) {
                typeString = "null";
              } else if (isArray(type)) {
                typeString = "array";
              } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {
                typeString = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />";
                info = " Did you accidentally export a JSX literal instead of a component?";
              } else {
                typeString = typeof type;
              }
              {
                error("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
              }
            }
            var element = createElement4.apply(this, arguments);
            if (element == null) {
              return element;
            }
            if (validType) {
              for (var i = 2; i < arguments.length; i++) {
                validateChildKeys(arguments[i], type);
              }
            }
            if (type === REACT_FRAGMENT_TYPE) {
              validateFragmentProps(element);
            } else {
              validatePropTypes(element);
            }
            return element;
          }
          var didWarnAboutDeprecatedCreateFactory = false;
          function createFactoryWithValidation(type) {
            var validatedFactory = createElementWithValidation.bind(null, type);
            validatedFactory.type = type;
            {
              if (!didWarnAboutDeprecatedCreateFactory) {
                didWarnAboutDeprecatedCreateFactory = true;
                warn("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.");
              }
              Object.defineProperty(validatedFactory, "type", {
                enumerable: false,
                get: function() {
                  warn("Factory.type is deprecated. Access the class directly before passing it to createFactory.");
                  Object.defineProperty(this, "type", {
                    value: type
                  });
                  return type;
                }
              });
            }
            return validatedFactory;
          }
          function cloneElementWithValidation(element, props, children) {
            var newElement = cloneElement.apply(this, arguments);
            for (var i = 2; i < arguments.length; i++) {
              validateChildKeys(arguments[i], newElement.type);
            }
            validatePropTypes(newElement);
            return newElement;
          }
          function startTransition(scope, options) {
            var prevTransition = ReactCurrentBatchConfig.transition;
            ReactCurrentBatchConfig.transition = {};
            var currentTransition = ReactCurrentBatchConfig.transition;
            {
              ReactCurrentBatchConfig.transition._updatedFibers = /* @__PURE__ */ new Set();
            }
            try {
              scope();
            } finally {
              ReactCurrentBatchConfig.transition = prevTransition;
              {
                if (prevTransition === null && currentTransition._updatedFibers) {
                  var updatedFibersCount = currentTransition._updatedFibers.size;
                  if (updatedFibersCount > 10) {
                    warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.");
                  }
                  currentTransition._updatedFibers.clear();
                }
              }
            }
          }
          var didWarnAboutMessageChannel = false;
          var enqueueTaskImpl = null;
          function enqueueTask(task) {
            if (enqueueTaskImpl === null) {
              try {
                var requireString = ("require" + Math.random()).slice(0, 7);
                var nodeRequire = module && module[requireString];
                enqueueTaskImpl = nodeRequire.call(module, "timers").setImmediate;
              } catch (_err) {
                enqueueTaskImpl = function(callback) {
                  {
                    if (didWarnAboutMessageChannel === false) {
                      didWarnAboutMessageChannel = true;
                      if (typeof MessageChannel === "undefined") {
                        error("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning.");
                      }
                    }
                  }
                  var channel = new MessageChannel();
                  channel.port1.onmessage = callback;
                  channel.port2.postMessage(void 0);
                };
              }
            }
            return enqueueTaskImpl(task);
          }
          var actScopeDepth = 0;
          var didWarnNoAwaitAct = false;
          function act(callback) {
            {
              var prevActScopeDepth = actScopeDepth;
              actScopeDepth++;
              if (ReactCurrentActQueue.current === null) {
                ReactCurrentActQueue.current = [];
              }
              var prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy;
              var result;
              try {
                ReactCurrentActQueue.isBatchingLegacy = true;
                result = callback();
                if (!prevIsBatchingLegacy && ReactCurrentActQueue.didScheduleLegacyUpdate) {
                  var queue = ReactCurrentActQueue.current;
                  if (queue !== null) {
                    ReactCurrentActQueue.didScheduleLegacyUpdate = false;
                    flushActQueue(queue);
                  }
                }
              } catch (error2) {
                popActScope(prevActScopeDepth);
                throw error2;
              } finally {
                ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;
              }
              if (result !== null && typeof result === "object" && typeof result.then === "function") {
                var thenableResult = result;
                var wasAwaited = false;
                var thenable = {
                  then: function(resolve, reject) {
                    wasAwaited = true;
                    thenableResult.then(function(returnValue2) {
                      popActScope(prevActScopeDepth);
                      if (actScopeDepth === 0) {
                        recursivelyFlushAsyncActWork(returnValue2, resolve, reject);
                      } else {
                        resolve(returnValue2);
                      }
                    }, function(error2) {
                      popActScope(prevActScopeDepth);
                      reject(error2);
                    });
                  }
                };
                {
                  if (!didWarnNoAwaitAct && typeof Promise !== "undefined") {
                    Promise.resolve().then(function() {
                    }).then(function() {
                      if (!wasAwaited) {
                        didWarnNoAwaitAct = true;
                        error("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);");
                      }
                    });
                  }
                }
                return thenable;
              } else {
                var returnValue = result;
                popActScope(prevActScopeDepth);
                if (actScopeDepth === 0) {
                  var _queue = ReactCurrentActQueue.current;
                  if (_queue !== null) {
                    flushActQueue(_queue);
                    ReactCurrentActQueue.current = null;
                  }
                  var _thenable = {
                    then: function(resolve, reject) {
                      if (ReactCurrentActQueue.current === null) {
                        ReactCurrentActQueue.current = [];
                        recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                      } else {
                        resolve(returnValue);
                      }
                    }
                  };
                  return _thenable;
                } else {
                  var _thenable2 = {
                    then: function(resolve, reject) {
                      resolve(returnValue);
                    }
                  };
                  return _thenable2;
                }
              }
            }
          }
          function popActScope(prevActScopeDepth) {
            {
              if (prevActScopeDepth !== actScopeDepth - 1) {
                error("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. ");
              }
              actScopeDepth = prevActScopeDepth;
            }
          }
          function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
            {
              var queue = ReactCurrentActQueue.current;
              if (queue !== null) {
                try {
                  flushActQueue(queue);
                  enqueueTask(function() {
                    if (queue.length === 0) {
                      ReactCurrentActQueue.current = null;
                      resolve(returnValue);
                    } else {
                      recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                    }
                  });
                } catch (error2) {
                  reject(error2);
                }
              } else {
                resolve(returnValue);
              }
            }
          }
          var isFlushing = false;
          function flushActQueue(queue) {
            {
              if (!isFlushing) {
                isFlushing = true;
                var i = 0;
                try {
                  for (; i < queue.length; i++) {
                    var callback = queue[i];
                    do {
                      callback = callback(true);
                    } while (callback !== null);
                  }
                  queue.length = 0;
                } catch (error2) {
                  queue = queue.slice(i + 1);
                  throw error2;
                } finally {
                  isFlushing = false;
                }
              }
            }
          }
          var createElement$1 = createElementWithValidation;
          var cloneElement$1 = cloneElementWithValidation;
          var createFactory = createFactoryWithValidation;
          var Children2 = {
            map: mapChildren,
            forEach: forEachChildren,
            count: countChildren,
            toArray: toArray3,
            only: onlyChild
          };
          exports.Children = Children2;
          exports.Component = Component3;
          exports.Fragment = REACT_FRAGMENT_TYPE;
          exports.Profiler = REACT_PROFILER_TYPE;
          exports.PureComponent = PureComponent;
          exports.StrictMode = REACT_STRICT_MODE_TYPE;
          exports.Suspense = REACT_SUSPENSE_TYPE;
          exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
          exports.act = act;
          exports.cloneElement = cloneElement$1;
          exports.createContext = createContext9;
          exports.createElement = createElement$1;
          exports.createFactory = createFactory;
          exports.createRef = createRef;
          exports.forwardRef = forwardRef3;
          exports.isValidElement = isValidElement2;
          exports.lazy = lazy;
          exports.memo = memo3;
          exports.startTransition = startTransition;
          exports.unstable_act = act;
          exports.useCallback = useCallback7;
          exports.useContext = useContext12;
          exports.useDebugValue = useDebugValue;
          exports.useDeferredValue = useDeferredValue;
          exports.useEffect = useEffect15;
          exports.useId = useId2;
          exports.useImperativeHandle = useImperativeHandle;
          exports.useInsertionEffect = useInsertionEffect4;
          exports.useLayoutEffect = useLayoutEffect6;
          exports.useMemo = useMemo9;
          exports.useReducer = useReducer;
          exports.useRef = useRef14;
          exports.useState = useState8;
          exports.useSyncExternalStore = useSyncExternalStore;
          exports.useTransition = useTransition;
          exports.version = ReactVersion;
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
          }
        })();
      }
    }
  });

  // node_modules/react/index.js
  var require_react = __commonJS({
    "node_modules/react/index.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_react_development();
      }
    }
  });

  // node_modules/scheduler/cjs/scheduler.development.js
  var require_scheduler_development = __commonJS({
    "node_modules/scheduler/cjs/scheduler.development.js"(exports) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
          }
          var enableSchedulerDebugging = false;
          var enableProfiling = false;
          var frameYieldMs = 5;
          function push2(heap, node) {
            var index = heap.length;
            heap.push(node);
            siftUp(heap, node, index);
          }
          function peek(heap) {
            return heap.length === 0 ? null : heap[0];
          }
          function pop(heap) {
            if (heap.length === 0) {
              return null;
            }
            var first = heap[0];
            var last = heap.pop();
            if (last !== first) {
              heap[0] = last;
              siftDown(heap, last, 0);
            }
            return first;
          }
          function siftUp(heap, node, i) {
            var index = i;
            while (index > 0) {
              var parentIndex = index - 1 >>> 1;
              var parent = heap[parentIndex];
              if (compare(parent, node) > 0) {
                heap[parentIndex] = node;
                heap[index] = parent;
                index = parentIndex;
              } else {
                return;
              }
            }
          }
          function siftDown(heap, node, i) {
            var index = i;
            var length = heap.length;
            var halfLength = length >>> 1;
            while (index < halfLength) {
              var leftIndex = (index + 1) * 2 - 1;
              var left = heap[leftIndex];
              var rightIndex = leftIndex + 1;
              var right = heap[rightIndex];
              if (compare(left, node) < 0) {
                if (rightIndex < length && compare(right, left) < 0) {
                  heap[index] = right;
                  heap[rightIndex] = node;
                  index = rightIndex;
                } else {
                  heap[index] = left;
                  heap[leftIndex] = node;
                  index = leftIndex;
                }
              } else if (rightIndex < length && compare(right, node) < 0) {
                heap[index] = right;
                heap[rightIndex] = node;
                index = rightIndex;
              } else {
                return;
              }
            }
          }
          function compare(a, b) {
            var diff = a.sortIndex - b.sortIndex;
            return diff !== 0 ? diff : a.id - b.id;
          }
          var ImmediatePriority = 1;
          var UserBlockingPriority = 2;
          var NormalPriority = 3;
          var LowPriority = 4;
          var IdlePriority = 5;
          function markTaskErrored(task, ms) {
          }
          var hasPerformanceNow = typeof performance === "object" && typeof performance.now === "function";
          if (hasPerformanceNow) {
            var localPerformance = performance;
            exports.unstable_now = function() {
              return localPerformance.now();
            };
          } else {
            var localDate = Date;
            var initialTime = localDate.now();
            exports.unstable_now = function() {
              return localDate.now() - initialTime;
            };
          }
          var maxSigned31BitInt = 1073741823;
          var IMMEDIATE_PRIORITY_TIMEOUT = -1;
          var USER_BLOCKING_PRIORITY_TIMEOUT = 250;
          var NORMAL_PRIORITY_TIMEOUT = 5e3;
          var LOW_PRIORITY_TIMEOUT = 1e4;
          var IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt;
          var taskQueue = [];
          var timerQueue = [];
          var taskIdCounter = 1;
          var currentTask = null;
          var currentPriorityLevel = NormalPriority;
          var isPerformingWork = false;
          var isHostCallbackScheduled = false;
          var isHostTimeoutScheduled = false;
          var localSetTimeout = typeof setTimeout === "function" ? setTimeout : null;
          var localClearTimeout = typeof clearTimeout === "function" ? clearTimeout : null;
          var localSetImmediate = typeof setImmediate !== "undefined" ? setImmediate : null;
          var isInputPending = typeof navigator !== "undefined" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 ? navigator.scheduling.isInputPending.bind(navigator.scheduling) : null;
          function advanceTimers(currentTime) {
            var timer = peek(timerQueue);
            while (timer !== null) {
              if (timer.callback === null) {
                pop(timerQueue);
              } else if (timer.startTime <= currentTime) {
                pop(timerQueue);
                timer.sortIndex = timer.expirationTime;
                push2(taskQueue, timer);
              } else {
                return;
              }
              timer = peek(timerQueue);
            }
          }
          function handleTimeout(currentTime) {
            isHostTimeoutScheduled = false;
            advanceTimers(currentTime);
            if (!isHostCallbackScheduled) {
              if (peek(taskQueue) !== null) {
                isHostCallbackScheduled = true;
                requestHostCallback(flushWork);
              } else {
                var firstTimer = peek(timerQueue);
                if (firstTimer !== null) {
                  requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
                }
              }
            }
          }
          function flushWork(hasTimeRemaining, initialTime2) {
            isHostCallbackScheduled = false;
            if (isHostTimeoutScheduled) {
              isHostTimeoutScheduled = false;
              cancelHostTimeout();
            }
            isPerformingWork = true;
            var previousPriorityLevel = currentPriorityLevel;
            try {
              if (enableProfiling) {
                try {
                  return workLoop(hasTimeRemaining, initialTime2);
                } catch (error) {
                  if (currentTask !== null) {
                    var currentTime = exports.unstable_now();
                    markTaskErrored(currentTask, currentTime);
                    currentTask.isQueued = false;
                  }
                  throw error;
                }
              } else {
                return workLoop(hasTimeRemaining, initialTime2);
              }
            } finally {
              currentTask = null;
              currentPriorityLevel = previousPriorityLevel;
              isPerformingWork = false;
            }
          }
          function workLoop(hasTimeRemaining, initialTime2) {
            var currentTime = initialTime2;
            advanceTimers(currentTime);
            currentTask = peek(taskQueue);
            while (currentTask !== null && !enableSchedulerDebugging) {
              if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {
                break;
              }
              var callback = currentTask.callback;
              if (typeof callback === "function") {
                currentTask.callback = null;
                currentPriorityLevel = currentTask.priorityLevel;
                var didUserCallbackTimeout = currentTask.expirationTime <= currentTime;
                var continuationCallback = callback(didUserCallbackTimeout);
                currentTime = exports.unstable_now();
                if (typeof continuationCallback === "function") {
                  currentTask.callback = continuationCallback;
                } else {
                  if (currentTask === peek(taskQueue)) {
                    pop(taskQueue);
                  }
                }
                advanceTimers(currentTime);
              } else {
                pop(taskQueue);
              }
              currentTask = peek(taskQueue);
            }
            if (currentTask !== null) {
              return true;
            } else {
              var firstTimer = peek(timerQueue);
              if (firstTimer !== null) {
                requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
              }
              return false;
            }
          }
          function unstable_runWithPriority(priorityLevel, eventHandler) {
            switch (priorityLevel) {
              case ImmediatePriority:
              case UserBlockingPriority:
              case NormalPriority:
              case LowPriority:
              case IdlePriority:
                break;
              default:
                priorityLevel = NormalPriority;
            }
            var previousPriorityLevel = currentPriorityLevel;
            currentPriorityLevel = priorityLevel;
            try {
              return eventHandler();
            } finally {
              currentPriorityLevel = previousPriorityLevel;
            }
          }
          function unstable_next(eventHandler) {
            var priorityLevel;
            switch (currentPriorityLevel) {
              case ImmediatePriority:
              case UserBlockingPriority:
              case NormalPriority:
                priorityLevel = NormalPriority;
                break;
              default:
                priorityLevel = currentPriorityLevel;
                break;
            }
            var previousPriorityLevel = currentPriorityLevel;
            currentPriorityLevel = priorityLevel;
            try {
              return eventHandler();
            } finally {
              currentPriorityLevel = previousPriorityLevel;
            }
          }
          function unstable_wrapCallback(callback) {
            var parentPriorityLevel = currentPriorityLevel;
            return function() {
              var previousPriorityLevel = currentPriorityLevel;
              currentPriorityLevel = parentPriorityLevel;
              try {
                return callback.apply(this, arguments);
              } finally {
                currentPriorityLevel = previousPriorityLevel;
              }
            };
          }
          function unstable_scheduleCallback(priorityLevel, callback, options) {
            var currentTime = exports.unstable_now();
            var startTime2;
            if (typeof options === "object" && options !== null) {
              var delay2 = options.delay;
              if (typeof delay2 === "number" && delay2 > 0) {
                startTime2 = currentTime + delay2;
              } else {
                startTime2 = currentTime;
              }
            } else {
              startTime2 = currentTime;
            }
            var timeout;
            switch (priorityLevel) {
              case ImmediatePriority:
                timeout = IMMEDIATE_PRIORITY_TIMEOUT;
                break;
              case UserBlockingPriority:
                timeout = USER_BLOCKING_PRIORITY_TIMEOUT;
                break;
              case IdlePriority:
                timeout = IDLE_PRIORITY_TIMEOUT;
                break;
              case LowPriority:
                timeout = LOW_PRIORITY_TIMEOUT;
                break;
              case NormalPriority:
              default:
                timeout = NORMAL_PRIORITY_TIMEOUT;
                break;
            }
            var expirationTime = startTime2 + timeout;
            var newTask = {
              id: taskIdCounter++,
              callback,
              priorityLevel,
              startTime: startTime2,
              expirationTime,
              sortIndex: -1
            };
            if (startTime2 > currentTime) {
              newTask.sortIndex = startTime2;
              push2(timerQueue, newTask);
              if (peek(taskQueue) === null && newTask === peek(timerQueue)) {
                if (isHostTimeoutScheduled) {
                  cancelHostTimeout();
                } else {
                  isHostTimeoutScheduled = true;
                }
                requestHostTimeout(handleTimeout, startTime2 - currentTime);
              }
            } else {
              newTask.sortIndex = expirationTime;
              push2(taskQueue, newTask);
              if (!isHostCallbackScheduled && !isPerformingWork) {
                isHostCallbackScheduled = true;
                requestHostCallback(flushWork);
              }
            }
            return newTask;
          }
          function unstable_pauseExecution() {
          }
          function unstable_continueExecution() {
            if (!isHostCallbackScheduled && !isPerformingWork) {
              isHostCallbackScheduled = true;
              requestHostCallback(flushWork);
            }
          }
          function unstable_getFirstCallbackNode() {
            return peek(taskQueue);
          }
          function unstable_cancelCallback(task) {
            task.callback = null;
          }
          function unstable_getCurrentPriorityLevel() {
            return currentPriorityLevel;
          }
          var isMessageLoopRunning = false;
          var scheduledHostCallback = null;
          var taskTimeoutID = -1;
          var frameInterval = frameYieldMs;
          var startTime = -1;
          function shouldYieldToHost() {
            var timeElapsed = exports.unstable_now() - startTime;
            if (timeElapsed < frameInterval) {
              return false;
            }
            return true;
          }
          function requestPaint() {
          }
          function forceFrameRate(fps) {
            if (fps < 0 || fps > 125) {
              console["error"]("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
              return;
            }
            if (fps > 0) {
              frameInterval = Math.floor(1e3 / fps);
            } else {
              frameInterval = frameYieldMs;
            }
          }
          var performWorkUntilDeadline = function() {
            if (scheduledHostCallback !== null) {
              var currentTime = exports.unstable_now();
              startTime = currentTime;
              var hasTimeRemaining = true;
              var hasMoreWork = true;
              try {
                hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);
              } finally {
                if (hasMoreWork) {
                  schedulePerformWorkUntilDeadline();
                } else {
                  isMessageLoopRunning = false;
                  scheduledHostCallback = null;
                }
              }
            } else {
              isMessageLoopRunning = false;
            }
          };
          var schedulePerformWorkUntilDeadline;
          if (typeof localSetImmediate === "function") {
            schedulePerformWorkUntilDeadline = function() {
              localSetImmediate(performWorkUntilDeadline);
            };
          } else if (typeof MessageChannel !== "undefined") {
            var channel = new MessageChannel();
            var port = channel.port2;
            channel.port1.onmessage = performWorkUntilDeadline;
            schedulePerformWorkUntilDeadline = function() {
              port.postMessage(null);
            };
          } else {
            schedulePerformWorkUntilDeadline = function() {
              localSetTimeout(performWorkUntilDeadline, 0);
            };
          }
          function requestHostCallback(callback) {
            scheduledHostCallback = callback;
            if (!isMessageLoopRunning) {
              isMessageLoopRunning = true;
              schedulePerformWorkUntilDeadline();
            }
          }
          function requestHostTimeout(callback, ms) {
            taskTimeoutID = localSetTimeout(function() {
              callback(exports.unstable_now());
            }, ms);
          }
          function cancelHostTimeout() {
            localClearTimeout(taskTimeoutID);
            taskTimeoutID = -1;
          }
          var unstable_requestPaint = requestPaint;
          var unstable_Profiling = null;
          exports.unstable_IdlePriority = IdlePriority;
          exports.unstable_ImmediatePriority = ImmediatePriority;
          exports.unstable_LowPriority = LowPriority;
          exports.unstable_NormalPriority = NormalPriority;
          exports.unstable_Profiling = unstable_Profiling;
          exports.unstable_UserBlockingPriority = UserBlockingPriority;
          exports.unstable_cancelCallback = unstable_cancelCallback;
          exports.unstable_continueExecution = unstable_continueExecution;
          exports.unstable_forceFrameRate = forceFrameRate;
          exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;
          exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;
          exports.unstable_next = unstable_next;
          exports.unstable_pauseExecution = unstable_pauseExecution;
          exports.unstable_requestPaint = unstable_requestPaint;
          exports.unstable_runWithPriority = unstable_runWithPriority;
          exports.unstable_scheduleCallback = unstable_scheduleCallback;
          exports.unstable_shouldYield = shouldYieldToHost;
          exports.unstable_wrapCallback = unstable_wrapCallback;
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
          }
        })();
      }
    }
  });

  // node_modules/scheduler/index.js
  var require_scheduler = __commonJS({
    "node_modules/scheduler/index.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_scheduler_development();
      }
    }
  });

  // node_modules/react-dom/cjs/react-dom.development.js
  var require_react_dom_development = __commonJS({
    "node_modules/react-dom/cjs/react-dom.development.js"(exports) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
          }
          var React5 = require_react();
          var Scheduler = require_scheduler();
          var ReactSharedInternals = React5.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
          var suppressWarning = false;
          function setSuppressWarning(newSuppressWarning) {
            {
              suppressWarning = newSuppressWarning;
            }
          }
          function warn(format2) {
            {
              if (!suppressWarning) {
                for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                  args[_key - 1] = arguments[_key];
                }
                printWarning("warn", format2, args);
              }
            }
          }
          function error(format2) {
            {
              if (!suppressWarning) {
                for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                  args[_key2 - 1] = arguments[_key2];
                }
                printWarning("error", format2, args);
              }
            }
          }
          function printWarning(level, format2, args) {
            {
              var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
              var stack = ReactDebugCurrentFrame2.getStackAddendum();
              if (stack !== "") {
                format2 += "%s";
                args = args.concat([stack]);
              }
              var argsWithFormat = args.map(function(item) {
                return String(item);
              });
              argsWithFormat.unshift("Warning: " + format2);
              Function.prototype.apply.call(console[level], console, argsWithFormat);
            }
          }
          var FunctionComponent = 0;
          var ClassComponent = 1;
          var IndeterminateComponent = 2;
          var HostRoot = 3;
          var HostPortal = 4;
          var HostComponent = 5;
          var HostText = 6;
          var Fragment7 = 7;
          var Mode = 8;
          var ContextConsumer = 9;
          var ContextProvider = 10;
          var ForwardRef = 11;
          var Profiler = 12;
          var SuspenseComponent = 13;
          var MemoComponent = 14;
          var SimpleMemoComponent = 15;
          var LazyComponent = 16;
          var IncompleteClassComponent = 17;
          var DehydratedFragment = 18;
          var SuspenseListComponent = 19;
          var ScopeComponent = 21;
          var OffscreenComponent = 22;
          var LegacyHiddenComponent = 23;
          var CacheComponent = 24;
          var TracingMarkerComponent = 25;
          var enableClientRenderFallbackOnTextMismatch = true;
          var enableNewReconciler = false;
          var enableLazyContextPropagation = false;
          var enableLegacyHidden = false;
          var enableSuspenseAvoidThisFallback = false;
          var disableCommentsAsDOMContainers = true;
          var enableCustomElementPropertySupport = false;
          var warnAboutStringRefs = true;
          var enableSchedulingProfiler = true;
          var enableProfilerTimer = true;
          var enableProfilerCommitHooks = true;
          var allNativeEvents = /* @__PURE__ */ new Set();
          var registrationNameDependencies = {};
          var possibleRegistrationNames = {};
          function registerTwoPhaseEvent(registrationName, dependencies) {
            registerDirectEvent(registrationName, dependencies);
            registerDirectEvent(registrationName + "Capture", dependencies);
          }
          function registerDirectEvent(registrationName, dependencies) {
            {
              if (registrationNameDependencies[registrationName]) {
                error("EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.", registrationName);
              }
            }
            registrationNameDependencies[registrationName] = dependencies;
            {
              var lowerCasedName = registrationName.toLowerCase();
              possibleRegistrationNames[lowerCasedName] = registrationName;
              if (registrationName === "onDoubleClick") {
                possibleRegistrationNames.ondblclick = registrationName;
              }
            }
            for (var i = 0; i < dependencies.length; i++) {
              allNativeEvents.add(dependencies[i]);
            }
          }
          var canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
          var hasOwnProperty = Object.prototype.hasOwnProperty;
          function typeName(value) {
            {
              var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
              var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
              return type;
            }
          }
          function willCoercionThrow(value) {
            {
              try {
                testStringCoercion(value);
                return false;
              } catch (e) {
                return true;
              }
            }
          }
          function testStringCoercion(value) {
            return "" + value;
          }
          function checkAttributeStringCoercion(value, attributeName) {
            {
              if (willCoercionThrow(value)) {
                error("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", attributeName, typeName(value));
                return testStringCoercion(value);
              }
            }
          }
          function checkKeyStringCoercion(value) {
            {
              if (willCoercionThrow(value)) {
                error("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
                return testStringCoercion(value);
              }
            }
          }
          function checkPropStringCoercion(value, propName) {
            {
              if (willCoercionThrow(value)) {
                error("The provided `%s` prop is an unsupported type %s. This value must be coerced to a string before before using it here.", propName, typeName(value));
                return testStringCoercion(value);
              }
            }
          }
          function checkCSSPropertyStringCoercion(value, propName) {
            {
              if (willCoercionThrow(value)) {
                error("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", propName, typeName(value));
                return testStringCoercion(value);
              }
            }
          }
          function checkHtmlStringCoercion(value) {
            {
              if (willCoercionThrow(value)) {
                error("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
                return testStringCoercion(value);
              }
            }
          }
          function checkFormFieldValueStringCoercion(value) {
            {
              if (willCoercionThrow(value)) {
                error("Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before before using it here.", typeName(value));
                return testStringCoercion(value);
              }
            }
          }
          var RESERVED = 0;
          var STRING2 = 1;
          var BOOLEANISH_STRING = 2;
          var BOOLEAN2 = 3;
          var OVERLOADED_BOOLEAN = 4;
          var NUMERIC = 5;
          var POSITIVE_NUMERIC = 6;
          var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
          var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
          var VALID_ATTRIBUTE_NAME_REGEX = new RegExp("^[" + ATTRIBUTE_NAME_START_CHAR + "][" + ATTRIBUTE_NAME_CHAR + "]*$");
          var illegalAttributeNameCache = {};
          var validatedAttributeNameCache = {};
          function isAttributeNameSafe(attributeName) {
            if (hasOwnProperty.call(validatedAttributeNameCache, attributeName)) {
              return true;
            }
            if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) {
              return false;
            }
            if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
              validatedAttributeNameCache[attributeName] = true;
              return true;
            }
            illegalAttributeNameCache[attributeName] = true;
            {
              error("Invalid attribute name: `%s`", attributeName);
            }
            return false;
          }
          function shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag) {
            if (propertyInfo !== null) {
              return propertyInfo.type === RESERVED;
            }
            if (isCustomComponentTag) {
              return false;
            }
            if (name.length > 2 && (name[0] === "o" || name[0] === "O") && (name[1] === "n" || name[1] === "N")) {
              return true;
            }
            return false;
          }
          function shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag) {
            if (propertyInfo !== null && propertyInfo.type === RESERVED) {
              return false;
            }
            switch (typeof value) {
              case "function":
              // $FlowIssue symbol is perfectly valid here
              case "symbol":
                return true;
              case "boolean": {
                if (isCustomComponentTag) {
                  return false;
                }
                if (propertyInfo !== null) {
                  return !propertyInfo.acceptsBooleans;
                } else {
                  var prefix2 = name.toLowerCase().slice(0, 5);
                  return prefix2 !== "data-" && prefix2 !== "aria-";
                }
              }
              default:
                return false;
            }
          }
          function shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag) {
            if (value === null || typeof value === "undefined") {
              return true;
            }
            if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag)) {
              return true;
            }
            if (isCustomComponentTag) {
              return false;
            }
            if (propertyInfo !== null) {
              switch (propertyInfo.type) {
                case BOOLEAN2:
                  return !value;
                case OVERLOADED_BOOLEAN:
                  return value === false;
                case NUMERIC:
                  return isNaN(value);
                case POSITIVE_NUMERIC:
                  return isNaN(value) || value < 1;
              }
            }
            return false;
          }
          function getPropertyInfo(name) {
            return properties.hasOwnProperty(name) ? properties[name] : null;
          }
          function PropertyInfoRecord(name, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL2, removeEmptyString) {
            this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN2 || type === OVERLOADED_BOOLEAN;
            this.attributeName = attributeName;
            this.attributeNamespace = attributeNamespace;
            this.mustUseProperty = mustUseProperty;
            this.propertyName = name;
            this.type = type;
            this.sanitizeURL = sanitizeURL2;
            this.removeEmptyString = removeEmptyString;
          }
          var properties = {};
          var reservedProps = [
            "children",
            "dangerouslySetInnerHTML",
            // TODO: This prevents the assignment of defaultValue to regular
            // elements (not just inputs). Now that ReactDOMInput assigns to the
            // defaultValue property -- do we need this?
            "defaultValue",
            "defaultChecked",
            "innerHTML",
            "suppressContentEditableWarning",
            "suppressHydrationWarning",
            "style"
          ];
          reservedProps.forEach(function(name) {
            properties[name] = new PropertyInfoRecord(
              name,
              RESERVED,
              false,
              // mustUseProperty
              name,
              // attributeName
              null,
              // attributeNamespace
              false,
              // sanitizeURL
              false
            );
          });
          [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(_ref) {
            var name = _ref[0], attributeName = _ref[1];
            properties[name] = new PropertyInfoRecord(
              name,
              STRING2,
              false,
              // mustUseProperty
              attributeName,
              // attributeName
              null,
              // attributeNamespace
              false,
              // sanitizeURL
              false
            );
          });
          ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(name) {
            properties[name] = new PropertyInfoRecord(
              name,
              BOOLEANISH_STRING,
              false,
              // mustUseProperty
              name.toLowerCase(),
              // attributeName
              null,
              // attributeNamespace
              false,
              // sanitizeURL
              false
            );
          });
          ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(name) {
            properties[name] = new PropertyInfoRecord(
              name,
              BOOLEANISH_STRING,
              false,
              // mustUseProperty
              name,
              // attributeName
              null,
              // attributeNamespace
              false,
              // sanitizeURL
              false
            );
          });
          [
            "allowFullScreen",
            "async",
            // Note: there is a special case that prevents it from being written to the DOM
            // on the client side because the browsers are inconsistent. Instead we call focus().
            "autoFocus",
            "autoPlay",
            "controls",
            "default",
            "defer",
            "disabled",
            "disablePictureInPicture",
            "disableRemotePlayback",
            "formNoValidate",
            "hidden",
            "loop",
            "noModule",
            "noValidate",
            "open",
            "playsInline",
            "readOnly",
            "required",
            "reversed",
            "scoped",
            "seamless",
            // Microdata
            "itemScope"
          ].forEach(function(name) {
            properties[name] = new PropertyInfoRecord(
              name,
              BOOLEAN2,
              false,
              // mustUseProperty
              name.toLowerCase(),
              // attributeName
              null,
              // attributeNamespace
              false,
              // sanitizeURL
              false
            );
          });
          [
            "checked",
            // Note: `option.selected` is not updated if `select.multiple` is
            // disabled with `removeAttribute`. We have special logic for handling this.
            "multiple",
            "muted",
            "selected"
            // NOTE: if you add a camelCased prop to this list,
            // you'll need to set attributeName to name.toLowerCase()
            // instead in the assignment below.
          ].forEach(function(name) {
            properties[name] = new PropertyInfoRecord(
              name,
              BOOLEAN2,
              true,
              // mustUseProperty
              name,
              // attributeName
              null,
              // attributeNamespace
              false,
              // sanitizeURL
              false
            );
          });
          [
            "capture",
            "download"
            // NOTE: if you add a camelCased prop to this list,
            // you'll need to set attributeName to name.toLowerCase()
            // instead in the assignment below.
          ].forEach(function(name) {
            properties[name] = new PropertyInfoRecord(
              name,
              OVERLOADED_BOOLEAN,
              false,
              // mustUseProperty
              name,
              // attributeName
              null,
              // attributeNamespace
              false,
              // sanitizeURL
              false
            );
          });
          [
            "cols",
            "rows",
            "size",
            "span"
            // NOTE: if you add a camelCased prop to this list,
            // you'll need to set attributeName to name.toLowerCase()
            // instead in the assignment below.
          ].forEach(function(name) {
            properties[name] = new PropertyInfoRecord(
              name,
              POSITIVE_NUMERIC,
              false,
              // mustUseProperty
              name,
              // attributeName
              null,
              // attributeNamespace
              false,
              // sanitizeURL
              false
            );
          });
          ["rowSpan", "start"].forEach(function(name) {
            properties[name] = new PropertyInfoRecord(
              name,
              NUMERIC,
              false,
              // mustUseProperty
              name.toLowerCase(),
              // attributeName
              null,
              // attributeNamespace
              false,
              // sanitizeURL
              false
            );
          });
          var CAMELIZE = /[\-\:]([a-z])/g;
          var capitalize = function(token) {
            return token[1].toUpperCase();
          };
          [
            "accent-height",
            "alignment-baseline",
            "arabic-form",
            "baseline-shift",
            "cap-height",
            "clip-path",
            "clip-rule",
            "color-interpolation",
            "color-interpolation-filters",
            "color-profile",
            "color-rendering",
            "dominant-baseline",
            "enable-background",
            "fill-opacity",
            "fill-rule",
            "flood-color",
            "flood-opacity",
            "font-family",
            "font-size",
            "font-size-adjust",
            "font-stretch",
            "font-style",
            "font-variant",
            "font-weight",
            "glyph-name",
            "glyph-orientation-horizontal",
            "glyph-orientation-vertical",
            "horiz-adv-x",
            "horiz-origin-x",
            "image-rendering",
            "letter-spacing",
            "lighting-color",
            "marker-end",
            "marker-mid",
            "marker-start",
            "overline-position",
            "overline-thickness",
            "paint-order",
            "panose-1",
            "pointer-events",
            "rendering-intent",
            "shape-rendering",
            "stop-color",
            "stop-opacity",
            "strikethrough-position",
            "strikethrough-thickness",
            "stroke-dasharray",
            "stroke-dashoffset",
            "stroke-linecap",
            "stroke-linejoin",
            "stroke-miterlimit",
            "stroke-opacity",
            "stroke-width",
            "text-anchor",
            "text-decoration",
            "text-rendering",
            "underline-position",
            "underline-thickness",
            "unicode-bidi",
            "unicode-range",
            "units-per-em",
            "v-alphabetic",
            "v-hanging",
            "v-ideographic",
            "v-mathematical",
            "vector-effect",
            "vert-adv-y",
            "vert-origin-x",
            "vert-origin-y",
            "word-spacing",
            "writing-mode",
            "xmlns:xlink",
            "x-height"
            // NOTE: if you add a camelCased prop to this list,
            // you'll need to set attributeName to name.toLowerCase()
            // instead in the assignment below.
          ].forEach(function(attributeName) {
            var name = attributeName.replace(CAMELIZE, capitalize);
            properties[name] = new PropertyInfoRecord(
              name,
              STRING2,
              false,
              // mustUseProperty
              attributeName,
              null,
              // attributeNamespace
              false,
              // sanitizeURL
              false
            );
          });
          [
            "xlink:actuate",
            "xlink:arcrole",
            "xlink:role",
            "xlink:show",
            "xlink:title",
            "xlink:type"
            // NOTE: if you add a camelCased prop to this list,
            // you'll need to set attributeName to name.toLowerCase()
            // instead in the assignment below.
          ].forEach(function(attributeName) {
            var name = attributeName.replace(CAMELIZE, capitalize);
            properties[name] = new PropertyInfoRecord(
              name,
              STRING2,
              false,
              // mustUseProperty
              attributeName,
              "http://www.w3.org/1999/xlink",
              false,
              // sanitizeURL
              false
            );
          });
          [
            "xml:base",
            "xml:lang",
            "xml:space"
            // NOTE: if you add a camelCased prop to this list,
            // you'll need to set attributeName to name.toLowerCase()
            // instead in the assignment below.
          ].forEach(function(attributeName) {
            var name = attributeName.replace(CAMELIZE, capitalize);
            properties[name] = new PropertyInfoRecord(
              name,
              STRING2,
              false,
              // mustUseProperty
              attributeName,
              "http://www.w3.org/XML/1998/namespace",
              false,
              // sanitizeURL
              false
            );
          });
          ["tabIndex", "crossOrigin"].forEach(function(attributeName) {
            properties[attributeName] = new PropertyInfoRecord(
              attributeName,
              STRING2,
              false,
              // mustUseProperty
              attributeName.toLowerCase(),
              // attributeName
              null,
              // attributeNamespace
              false,
              // sanitizeURL
              false
            );
          });
          var xlinkHref = "xlinkHref";
          properties[xlinkHref] = new PropertyInfoRecord(
            "xlinkHref",
            STRING2,
            false,
            // mustUseProperty
            "xlink:href",
            "http://www.w3.org/1999/xlink",
            true,
            // sanitizeURL
            false
          );
          ["src", "href", "action", "formAction"].forEach(function(attributeName) {
            properties[attributeName] = new PropertyInfoRecord(
              attributeName,
              STRING2,
              false,
              // mustUseProperty
              attributeName.toLowerCase(),
              // attributeName
              null,
              // attributeNamespace
              true,
              // sanitizeURL
              true
            );
          });
          var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i;
          var didWarn = false;
          function sanitizeURL(url) {
            {
              if (!didWarn && isJavaScriptProtocol.test(url)) {
                didWarn = true;
                error("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(url));
              }
            }
          }
          function getValueForProperty(node, name, expected, propertyInfo) {
            {
              if (propertyInfo.mustUseProperty) {
                var propertyName = propertyInfo.propertyName;
                return node[propertyName];
              } else {
                {
                  checkAttributeStringCoercion(expected, name);
                }
                if (propertyInfo.sanitizeURL) {
                  sanitizeURL("" + expected);
                }
                var attributeName = propertyInfo.attributeName;
                var stringValue = null;
                if (propertyInfo.type === OVERLOADED_BOOLEAN) {
                  if (node.hasAttribute(attributeName)) {
                    var value = node.getAttribute(attributeName);
                    if (value === "") {
                      return true;
                    }
                    if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {
                      return value;
                    }
                    if (value === "" + expected) {
                      return expected;
                    }
                    return value;
                  }
                } else if (node.hasAttribute(attributeName)) {
                  if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {
                    return node.getAttribute(attributeName);
                  }
                  if (propertyInfo.type === BOOLEAN2) {
                    return expected;
                  }
                  stringValue = node.getAttribute(attributeName);
                }
                if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {
                  return stringValue === null ? expected : stringValue;
                } else if (stringValue === "" + expected) {
                  return expected;
                } else {
                  return stringValue;
                }
              }
            }
          }
          function getValueForAttribute(node, name, expected, isCustomComponentTag) {
            {
              if (!isAttributeNameSafe(name)) {
                return;
              }
              if (!node.hasAttribute(name)) {
                return expected === void 0 ? void 0 : null;
              }
              var value = node.getAttribute(name);
              {
                checkAttributeStringCoercion(expected, name);
              }
              if (value === "" + expected) {
                return expected;
              }
              return value;
            }
          }
          function setValueForProperty(node, name, value, isCustomComponentTag) {
            var propertyInfo = getPropertyInfo(name);
            if (shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag)) {
              return;
            }
            if (shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag)) {
              value = null;
            }
            if (isCustomComponentTag || propertyInfo === null) {
              if (isAttributeNameSafe(name)) {
                var _attributeName = name;
                if (value === null) {
                  node.removeAttribute(_attributeName);
                } else {
                  {
                    checkAttributeStringCoercion(value, name);
                  }
                  node.setAttribute(_attributeName, "" + value);
                }
              }
              return;
            }
            var mustUseProperty = propertyInfo.mustUseProperty;
            if (mustUseProperty) {
              var propertyName = propertyInfo.propertyName;
              if (value === null) {
                var type = propertyInfo.type;
                node[propertyName] = type === BOOLEAN2 ? false : "";
              } else {
                node[propertyName] = value;
              }
              return;
            }
            var attributeName = propertyInfo.attributeName, attributeNamespace = propertyInfo.attributeNamespace;
            if (value === null) {
              node.removeAttribute(attributeName);
            } else {
              var _type = propertyInfo.type;
              var attributeValue;
              if (_type === BOOLEAN2 || _type === OVERLOADED_BOOLEAN && value === true) {
                attributeValue = "";
              } else {
                {
                  {
                    checkAttributeStringCoercion(value, attributeName);
                  }
                  attributeValue = "" + value;
                }
                if (propertyInfo.sanitizeURL) {
                  sanitizeURL(attributeValue.toString());
                }
              }
              if (attributeNamespace) {
                node.setAttributeNS(attributeNamespace, attributeName, attributeValue);
              } else {
                node.setAttribute(attributeName, attributeValue);
              }
            }
          }
          var REACT_ELEMENT_TYPE = Symbol.for("react.element");
          var REACT_PORTAL_TYPE = Symbol.for("react.portal");
          var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
          var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
          var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
          var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
          var REACT_CONTEXT_TYPE = Symbol.for("react.context");
          var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
          var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
          var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
          var REACT_MEMO_TYPE = Symbol.for("react.memo");
          var REACT_LAZY_TYPE = Symbol.for("react.lazy");
          var REACT_SCOPE_TYPE = Symbol.for("react.scope");
          var REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for("react.debug_trace_mode");
          var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
          var REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden");
          var REACT_CACHE_TYPE = Symbol.for("react.cache");
          var REACT_TRACING_MARKER_TYPE = Symbol.for("react.tracing_marker");
          var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
          var FAUX_ITERATOR_SYMBOL = "@@iterator";
          function getIteratorFn(maybeIterable) {
            if (maybeIterable === null || typeof maybeIterable !== "object") {
              return null;
            }
            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
            if (typeof maybeIterator === "function") {
              return maybeIterator;
            }
            return null;
          }
          var assign = Object.assign;
          var disabledDepth = 0;
          var prevLog;
          var prevInfo;
          var prevWarn;
          var prevError;
          var prevGroup;
          var prevGroupCollapsed;
          var prevGroupEnd;
          function disabledLog() {
          }
          disabledLog.__reactDisabledLog = true;
          function disableLogs() {
            {
              if (disabledDepth === 0) {
                prevLog = console.log;
                prevInfo = console.info;
                prevWarn = console.warn;
                prevError = console.error;
                prevGroup = console.group;
                prevGroupCollapsed = console.groupCollapsed;
                prevGroupEnd = console.groupEnd;
                var props = {
                  configurable: true,
                  enumerable: true,
                  value: disabledLog,
                  writable: true
                };
                Object.defineProperties(console, {
                  info: props,
                  log: props,
                  warn: props,
                  error: props,
                  group: props,
                  groupCollapsed: props,
                  groupEnd: props
                });
              }
              disabledDepth++;
            }
          }
          function reenableLogs() {
            {
              disabledDepth--;
              if (disabledDepth === 0) {
                var props = {
                  configurable: true,
                  enumerable: true,
                  writable: true
                };
                Object.defineProperties(console, {
                  log: assign({}, props, {
                    value: prevLog
                  }),
                  info: assign({}, props, {
                    value: prevInfo
                  }),
                  warn: assign({}, props, {
                    value: prevWarn
                  }),
                  error: assign({}, props, {
                    value: prevError
                  }),
                  group: assign({}, props, {
                    value: prevGroup
                  }),
                  groupCollapsed: assign({}, props, {
                    value: prevGroupCollapsed
                  }),
                  groupEnd: assign({}, props, {
                    value: prevGroupEnd
                  })
                });
              }
              if (disabledDepth < 0) {
                error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
              }
            }
          }
          var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
          var prefix;
          function describeBuiltInComponentFrame(name, source, ownerFn) {
            {
              if (prefix === void 0) {
                try {
                  throw Error();
                } catch (x) {
                  var match = x.stack.trim().match(/\n( *(at )?)/);
                  prefix = match && match[1] || "";
                }
              }
              return "\n" + prefix + name;
            }
          }
          var reentry = false;
          var componentFrameCache;
          {
            var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
            componentFrameCache = new PossiblyWeakMap();
          }
          function describeNativeComponentFrame(fn, construct) {
            if (!fn || reentry) {
              return "";
            }
            {
              var frame2 = componentFrameCache.get(fn);
              if (frame2 !== void 0) {
                return frame2;
              }
            }
            var control;
            reentry = true;
            var previousPrepareStackTrace = Error.prepareStackTrace;
            Error.prepareStackTrace = void 0;
            var previousDispatcher;
            {
              previousDispatcher = ReactCurrentDispatcher.current;
              ReactCurrentDispatcher.current = null;
              disableLogs();
            }
            try {
              if (construct) {
                var Fake = function() {
                  throw Error();
                };
                Object.defineProperty(Fake.prototype, "props", {
                  set: function() {
                    throw Error();
                  }
                });
                if (typeof Reflect === "object" && Reflect.construct) {
                  try {
                    Reflect.construct(Fake, []);
                  } catch (x) {
                    control = x;
                  }
                  Reflect.construct(fn, [], Fake);
                } else {
                  try {
                    Fake.call();
                  } catch (x) {
                    control = x;
                  }
                  fn.call(Fake.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (x) {
                  control = x;
                }
                fn();
              }
            } catch (sample) {
              if (sample && control && typeof sample.stack === "string") {
                var sampleLines = sample.stack.split("\n");
                var controlLines = control.stack.split("\n");
                var s = sampleLines.length - 1;
                var c = controlLines.length - 1;
                while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
                  c--;
                }
                for (; s >= 1 && c >= 0; s--, c--) {
                  if (sampleLines[s] !== controlLines[c]) {
                    if (s !== 1 || c !== 1) {
                      do {
                        s--;
                        c--;
                        if (c < 0 || sampleLines[s] !== controlLines[c]) {
                          var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                          if (fn.displayName && _frame.includes("<anonymous>")) {
                            _frame = _frame.replace("<anonymous>", fn.displayName);
                          }
                          {
                            if (typeof fn === "function") {
                              componentFrameCache.set(fn, _frame);
                            }
                          }
                          return _frame;
                        }
                      } while (s >= 1 && c >= 0);
                    }
                    break;
                  }
                }
              }
            } finally {
              reentry = false;
              {
                ReactCurrentDispatcher.current = previousDispatcher;
                reenableLogs();
              }
              Error.prepareStackTrace = previousPrepareStackTrace;
            }
            var name = fn ? fn.displayName || fn.name : "";
            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
            {
              if (typeof fn === "function") {
                componentFrameCache.set(fn, syntheticFrame);
              }
            }
            return syntheticFrame;
          }
          function describeClassComponentFrame(ctor, source, ownerFn) {
            {
              return describeNativeComponentFrame(ctor, true);
            }
          }
          function describeFunctionComponentFrame(fn, source, ownerFn) {
            {
              return describeNativeComponentFrame(fn, false);
            }
          }
          function shouldConstruct(Component3) {
            var prototype = Component3.prototype;
            return !!(prototype && prototype.isReactComponent);
          }
          function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
            if (type == null) {
              return "";
            }
            if (typeof type === "function") {
              {
                return describeNativeComponentFrame(type, shouldConstruct(type));
              }
            }
            if (typeof type === "string") {
              return describeBuiltInComponentFrame(type);
            }
            switch (type) {
              case REACT_SUSPENSE_TYPE:
                return describeBuiltInComponentFrame("Suspense");
              case REACT_SUSPENSE_LIST_TYPE:
                return describeBuiltInComponentFrame("SuspenseList");
            }
            if (typeof type === "object") {
              switch (type.$$typeof) {
                case REACT_FORWARD_REF_TYPE:
                  return describeFunctionComponentFrame(type.render);
                case REACT_MEMO_TYPE:
                  return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
                case REACT_LAZY_TYPE: {
                  var lazyComponent = type;
                  var payload = lazyComponent._payload;
                  var init5 = lazyComponent._init;
                  try {
                    return describeUnknownElementTypeFrameInDEV(init5(payload), source, ownerFn);
                  } catch (x) {
                  }
                }
              }
            }
            return "";
          }
          function describeFiber(fiber) {
            var owner = fiber._debugOwner ? fiber._debugOwner.type : null;
            var source = fiber._debugSource;
            switch (fiber.tag) {
              case HostComponent:
                return describeBuiltInComponentFrame(fiber.type);
              case LazyComponent:
                return describeBuiltInComponentFrame("Lazy");
              case SuspenseComponent:
                return describeBuiltInComponentFrame("Suspense");
              case SuspenseListComponent:
                return describeBuiltInComponentFrame("SuspenseList");
              case FunctionComponent:
              case IndeterminateComponent:
              case SimpleMemoComponent:
                return describeFunctionComponentFrame(fiber.type);
              case ForwardRef:
                return describeFunctionComponentFrame(fiber.type.render);
              case ClassComponent:
                return describeClassComponentFrame(fiber.type);
              default:
                return "";
            }
          }
          function getStackByFiberInDevAndProd(workInProgress2) {
            try {
              var info = "";
              var node = workInProgress2;
              do {
                info += describeFiber(node);
                node = node.return;
              } while (node);
              return info;
            } catch (x) {
              return "\nError generating stack: " + x.message + "\n" + x.stack;
            }
          }
          function getWrappedName(outerType, innerType, wrapperName) {
            var displayName = outerType.displayName;
            if (displayName) {
              return displayName;
            }
            var functionName = innerType.displayName || innerType.name || "";
            return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
          }
          function getContextName(type) {
            return type.displayName || "Context";
          }
          function getComponentNameFromType(type) {
            if (type == null) {
              return null;
            }
            {
              if (typeof type.tag === "number") {
                error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
              }
            }
            if (typeof type === "function") {
              return type.displayName || type.name || null;
            }
            if (typeof type === "string") {
              return type;
            }
            switch (type) {
              case REACT_FRAGMENT_TYPE:
                return "Fragment";
              case REACT_PORTAL_TYPE:
                return "Portal";
              case REACT_PROFILER_TYPE:
                return "Profiler";
              case REACT_STRICT_MODE_TYPE:
                return "StrictMode";
              case REACT_SUSPENSE_TYPE:
                return "Suspense";
              case REACT_SUSPENSE_LIST_TYPE:
                return "SuspenseList";
            }
            if (typeof type === "object") {
              switch (type.$$typeof) {
                case REACT_CONTEXT_TYPE:
                  var context3 = type;
                  return getContextName(context3) + ".Consumer";
                case REACT_PROVIDER_TYPE:
                  var provider = type;
                  return getContextName(provider._context) + ".Provider";
                case REACT_FORWARD_REF_TYPE:
                  return getWrappedName(type, type.render, "ForwardRef");
                case REACT_MEMO_TYPE:
                  var outerName = type.displayName || null;
                  if (outerName !== null) {
                    return outerName;
                  }
                  return getComponentNameFromType(type.type) || "Memo";
                case REACT_LAZY_TYPE: {
                  var lazyComponent = type;
                  var payload = lazyComponent._payload;
                  var init5 = lazyComponent._init;
                  try {
                    return getComponentNameFromType(init5(payload));
                  } catch (x) {
                    return null;
                  }
                }
              }
            }
            return null;
          }
          function getWrappedName$1(outerType, innerType, wrapperName) {
            var functionName = innerType.displayName || innerType.name || "";
            return outerType.displayName || (functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName);
          }
          function getContextName$1(type) {
            return type.displayName || "Context";
          }
          function getComponentNameFromFiber(fiber) {
            var tag = fiber.tag, type = fiber.type;
            switch (tag) {
              case CacheComponent:
                return "Cache";
              case ContextConsumer:
                var context3 = type;
                return getContextName$1(context3) + ".Consumer";
              case ContextProvider:
                var provider = type;
                return getContextName$1(provider._context) + ".Provider";
              case DehydratedFragment:
                return "DehydratedFragment";
              case ForwardRef:
                return getWrappedName$1(type, type.render, "ForwardRef");
              case Fragment7:
                return "Fragment";
              case HostComponent:
                return type;
              case HostPortal:
                return "Portal";
              case HostRoot:
                return "Root";
              case HostText:
                return "Text";
              case LazyComponent:
                return getComponentNameFromType(type);
              case Mode:
                if (type === REACT_STRICT_MODE_TYPE) {
                  return "StrictMode";
                }
                return "Mode";
              case OffscreenComponent:
                return "Offscreen";
              case Profiler:
                return "Profiler";
              case ScopeComponent:
                return "Scope";
              case SuspenseComponent:
                return "Suspense";
              case SuspenseListComponent:
                return "SuspenseList";
              case TracingMarkerComponent:
                return "TracingMarker";
              // The display name for this tags come from the user-provided type:
              case ClassComponent:
              case FunctionComponent:
              case IncompleteClassComponent:
              case IndeterminateComponent:
              case MemoComponent:
              case SimpleMemoComponent:
                if (typeof type === "function") {
                  return type.displayName || type.name || null;
                }
                if (typeof type === "string") {
                  return type;
                }
                break;
            }
            return null;
          }
          var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
          var current = null;
          var isRendering = false;
          function getCurrentFiberOwnerNameInDevOrNull() {
            {
              if (current === null) {
                return null;
              }
              var owner = current._debugOwner;
              if (owner !== null && typeof owner !== "undefined") {
                return getComponentNameFromFiber(owner);
              }
            }
            return null;
          }
          function getCurrentFiberStackInDev() {
            {
              if (current === null) {
                return "";
              }
              return getStackByFiberInDevAndProd(current);
            }
          }
          function resetCurrentFiber() {
            {
              ReactDebugCurrentFrame.getCurrentStack = null;
              current = null;
              isRendering = false;
            }
          }
          function setCurrentFiber(fiber) {
            {
              ReactDebugCurrentFrame.getCurrentStack = fiber === null ? null : getCurrentFiberStackInDev;
              current = fiber;
              isRendering = false;
            }
          }
          function getCurrentFiber() {
            {
              return current;
            }
          }
          function setIsRendering(rendering) {
            {
              isRendering = rendering;
            }
          }
          function toString(value) {
            return "" + value;
          }
          function getToStringValue(value) {
            switch (typeof value) {
              case "boolean":
              case "number":
              case "string":
              case "undefined":
                return value;
              case "object":
                {
                  checkFormFieldValueStringCoercion(value);
                }
                return value;
              default:
                return "";
            }
          }
          var hasReadOnlyValue = {
            button: true,
            checkbox: true,
            image: true,
            hidden: true,
            radio: true,
            reset: true,
            submit: true
          };
          function checkControlledValueProps(tagName, props) {
            {
              if (!(hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null)) {
                error("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.");
              }
              if (!(props.onChange || props.readOnly || props.disabled || props.checked == null)) {
                error("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
              }
            }
          }
          function isCheckable(elem) {
            var type = elem.type;
            var nodeName = elem.nodeName;
            return nodeName && nodeName.toLowerCase() === "input" && (type === "checkbox" || type === "radio");
          }
          function getTracker(node) {
            return node._valueTracker;
          }
          function detachTracker(node) {
            node._valueTracker = null;
          }
          function getValueFromNode(node) {
            var value = "";
            if (!node) {
              return value;
            }
            if (isCheckable(node)) {
              value = node.checked ? "true" : "false";
            } else {
              value = node.value;
            }
            return value;
          }
          function trackValueOnNode(node) {
            var valueField = isCheckable(node) ? "checked" : "value";
            var descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField);
            {
              checkFormFieldValueStringCoercion(node[valueField]);
            }
            var currentValue = "" + node[valueField];
            if (node.hasOwnProperty(valueField) || typeof descriptor === "undefined" || typeof descriptor.get !== "function" || typeof descriptor.set !== "function") {
              return;
            }
            var get2 = descriptor.get, set2 = descriptor.set;
            Object.defineProperty(node, valueField, {
              configurable: true,
              get: function() {
                return get2.call(this);
              },
              set: function(value) {
                {
                  checkFormFieldValueStringCoercion(value);
                }
                currentValue = "" + value;
                set2.call(this, value);
              }
            });
            Object.defineProperty(node, valueField, {
              enumerable: descriptor.enumerable
            });
            var tracker = {
              getValue: function() {
                return currentValue;
              },
              setValue: function(value) {
                {
                  checkFormFieldValueStringCoercion(value);
                }
                currentValue = "" + value;
              },
              stopTracking: function() {
                detachTracker(node);
                delete node[valueField];
              }
            };
            return tracker;
          }
          function track(node) {
            if (getTracker(node)) {
              return;
            }
            node._valueTracker = trackValueOnNode(node);
          }
          function updateValueIfChanged(node) {
            if (!node) {
              return false;
            }
            var tracker = getTracker(node);
            if (!tracker) {
              return true;
            }
            var lastValue = tracker.getValue();
            var nextValue = getValueFromNode(node);
            if (nextValue !== lastValue) {
              tracker.setValue(nextValue);
              return true;
            }
            return false;
          }
          function getActiveElement(doc) {
            doc = doc || (typeof document !== "undefined" ? document : void 0);
            if (typeof doc === "undefined") {
              return null;
            }
            try {
              return doc.activeElement || doc.body;
            } catch (e) {
              return doc.body;
            }
          }
          var didWarnValueDefaultValue = false;
          var didWarnCheckedDefaultChecked = false;
          var didWarnControlledToUncontrolled = false;
          var didWarnUncontrolledToControlled = false;
          function isControlled(props) {
            var usesChecked = props.type === "checkbox" || props.type === "radio";
            return usesChecked ? props.checked != null : props.value != null;
          }
          function getHostProps(element, props) {
            var node = element;
            var checked = props.checked;
            var hostProps = assign({}, props, {
              defaultChecked: void 0,
              defaultValue: void 0,
              value: void 0,
              checked: checked != null ? checked : node._wrapperState.initialChecked
            });
            return hostProps;
          }
          function initWrapperState(element, props) {
            {
              checkControlledValueProps("input", props);
              if (props.checked !== void 0 && props.defaultChecked !== void 0 && !didWarnCheckedDefaultChecked) {
                error("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component", props.type);
                didWarnCheckedDefaultChecked = true;
              }
              if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValueDefaultValue) {
                error("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component", props.type);
                didWarnValueDefaultValue = true;
              }
            }
            var node = element;
            var defaultValue = props.defaultValue == null ? "" : props.defaultValue;
            node._wrapperState = {
              initialChecked: props.checked != null ? props.checked : props.defaultChecked,
              initialValue: getToStringValue(props.value != null ? props.value : defaultValue),
              controlled: isControlled(props)
            };
          }
          function updateChecked(element, props) {
            var node = element;
            var checked = props.checked;
            if (checked != null) {
              setValueForProperty(node, "checked", checked, false);
            }
          }
          function updateWrapper(element, props) {
            var node = element;
            {
              var controlled = isControlled(props);
              if (!node._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {
                error("A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components");
                didWarnUncontrolledToControlled = true;
              }
              if (node._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {
                error("A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components");
                didWarnControlledToUncontrolled = true;
              }
            }
            updateChecked(element, props);
            var value = getToStringValue(props.value);
            var type = props.type;
            if (value != null) {
              if (type === "number") {
                if (value === 0 && node.value === "" || // We explicitly want to coerce to number here if possible.
                // eslint-disable-next-line
                node.value != value) {
                  node.value = toString(value);
                }
              } else if (node.value !== toString(value)) {
                node.value = toString(value);
              }
            } else if (type === "submit" || type === "reset") {
              node.removeAttribute("value");
              return;
            }
            {
              if (props.hasOwnProperty("value")) {
                setDefaultValue(node, props.type, value);
              } else if (props.hasOwnProperty("defaultValue")) {
                setDefaultValue(node, props.type, getToStringValue(props.defaultValue));
              }
            }
            {
              if (props.checked == null && props.defaultChecked != null) {
                node.defaultChecked = !!props.defaultChecked;
              }
            }
          }
          function postMountWrapper(element, props, isHydrating2) {
            var node = element;
            if (props.hasOwnProperty("value") || props.hasOwnProperty("defaultValue")) {
              var type = props.type;
              var isButton = type === "submit" || type === "reset";
              if (isButton && (props.value === void 0 || props.value === null)) {
                return;
              }
              var initialValue = toString(node._wrapperState.initialValue);
              if (!isHydrating2) {
                {
                  if (initialValue !== node.value) {
                    node.value = initialValue;
                  }
                }
              }
              {
                node.defaultValue = initialValue;
              }
            }
            var name = node.name;
            if (name !== "") {
              node.name = "";
            }
            {
              node.defaultChecked = !node.defaultChecked;
              node.defaultChecked = !!node._wrapperState.initialChecked;
            }
            if (name !== "") {
              node.name = name;
            }
          }
          function restoreControlledState(element, props) {
            var node = element;
            updateWrapper(node, props);
            updateNamedCousins(node, props);
          }
          function updateNamedCousins(rootNode, props) {
            var name = props.name;
            if (props.type === "radio" && name != null) {
              var queryRoot = rootNode;
              while (queryRoot.parentNode) {
                queryRoot = queryRoot.parentNode;
              }
              {
                checkAttributeStringCoercion(name, "name");
              }
              var group = queryRoot.querySelectorAll("input[name=" + JSON.stringify("" + name) + '][type="radio"]');
              for (var i = 0; i < group.length; i++) {
                var otherNode = group[i];
                if (otherNode === rootNode || otherNode.form !== rootNode.form) {
                  continue;
                }
                var otherProps = getFiberCurrentPropsFromNode(otherNode);
                if (!otherProps) {
                  throw new Error("ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.");
                }
                updateValueIfChanged(otherNode);
                updateWrapper(otherNode, otherProps);
              }
            }
          }
          function setDefaultValue(node, type, value) {
            if (
              // Focused number inputs synchronize on blur. See ChangeEventPlugin.js
              type !== "number" || getActiveElement(node.ownerDocument) !== node
            ) {
              if (value == null) {
                node.defaultValue = toString(node._wrapperState.initialValue);
              } else if (node.defaultValue !== toString(value)) {
                node.defaultValue = toString(value);
              }
            }
          }
          var didWarnSelectedSetOnOption = false;
          var didWarnInvalidChild = false;
          var didWarnInvalidInnerHTML = false;
          function validateProps(element, props) {
            {
              if (props.value == null) {
                if (typeof props.children === "object" && props.children !== null) {
                  React5.Children.forEach(props.children, function(child) {
                    if (child == null) {
                      return;
                    }
                    if (typeof child === "string" || typeof child === "number") {
                      return;
                    }
                    if (!didWarnInvalidChild) {
                      didWarnInvalidChild = true;
                      error("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.");
                    }
                  });
                } else if (props.dangerouslySetInnerHTML != null) {
                  if (!didWarnInvalidInnerHTML) {
                    didWarnInvalidInnerHTML = true;
                    error("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.");
                  }
                }
              }
              if (props.selected != null && !didWarnSelectedSetOnOption) {
                error("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>.");
                didWarnSelectedSetOnOption = true;
              }
            }
          }
          function postMountWrapper$1(element, props) {
            if (props.value != null) {
              element.setAttribute("value", toString(getToStringValue(props.value)));
            }
          }
          var isArrayImpl = Array.isArray;
          function isArray(a) {
            return isArrayImpl(a);
          }
          var didWarnValueDefaultValue$1;
          {
            didWarnValueDefaultValue$1 = false;
          }
          function getDeclarationErrorAddendum() {
            var ownerName = getCurrentFiberOwnerNameInDevOrNull();
            if (ownerName) {
              return "\n\nCheck the render method of `" + ownerName + "`.";
            }
            return "";
          }
          var valuePropNames = ["value", "defaultValue"];
          function checkSelectPropTypes(props) {
            {
              checkControlledValueProps("select", props);
              for (var i = 0; i < valuePropNames.length; i++) {
                var propName = valuePropNames[i];
                if (props[propName] == null) {
                  continue;
                }
                var propNameIsArray = isArray(props[propName]);
                if (props.multiple && !propNameIsArray) {
                  error("The `%s` prop supplied to <select> must be an array if `multiple` is true.%s", propName, getDeclarationErrorAddendum());
                } else if (!props.multiple && propNameIsArray) {
                  error("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s", propName, getDeclarationErrorAddendum());
                }
              }
            }
          }
          function updateOptions(node, multiple, propValue, setDefaultSelected) {
            var options2 = node.options;
            if (multiple) {
              var selectedValues = propValue;
              var selectedValue = {};
              for (var i = 0; i < selectedValues.length; i++) {
                selectedValue["$" + selectedValues[i]] = true;
              }
              for (var _i2 = 0; _i2 < options2.length; _i2++) {
                var selected = selectedValue.hasOwnProperty("$" + options2[_i2].value);
                if (options2[_i2].selected !== selected) {
                  options2[_i2].selected = selected;
                }
                if (selected && setDefaultSelected) {
                  options2[_i2].defaultSelected = true;
                }
              }
            } else {
              var _selectedValue = toString(getToStringValue(propValue));
              var defaultSelected = null;
              for (var _i22 = 0; _i22 < options2.length; _i22++) {
                if (options2[_i22].value === _selectedValue) {
                  options2[_i22].selected = true;
                  if (setDefaultSelected) {
                    options2[_i22].defaultSelected = true;
                  }
                  return;
                }
                if (defaultSelected === null && !options2[_i22].disabled) {
                  defaultSelected = options2[_i22];
                }
              }
              if (defaultSelected !== null) {
                defaultSelected.selected = true;
              }
            }
          }
          function getHostProps$1(element, props) {
            return assign({}, props, {
              value: void 0
            });
          }
          function initWrapperState$1(element, props) {
            var node = element;
            {
              checkSelectPropTypes(props);
            }
            node._wrapperState = {
              wasMultiple: !!props.multiple
            };
            {
              if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValueDefaultValue$1) {
                error("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components");
                didWarnValueDefaultValue$1 = true;
              }
            }
          }
          function postMountWrapper$2(element, props) {
            var node = element;
            node.multiple = !!props.multiple;
            var value = props.value;
            if (value != null) {
              updateOptions(node, !!props.multiple, value, false);
            } else if (props.defaultValue != null) {
              updateOptions(node, !!props.multiple, props.defaultValue, true);
            }
          }
          function postUpdateWrapper(element, props) {
            var node = element;
            var wasMultiple = node._wrapperState.wasMultiple;
            node._wrapperState.wasMultiple = !!props.multiple;
            var value = props.value;
            if (value != null) {
              updateOptions(node, !!props.multiple, value, false);
            } else if (wasMultiple !== !!props.multiple) {
              if (props.defaultValue != null) {
                updateOptions(node, !!props.multiple, props.defaultValue, true);
              } else {
                updateOptions(node, !!props.multiple, props.multiple ? [] : "", false);
              }
            }
          }
          function restoreControlledState$1(element, props) {
            var node = element;
            var value = props.value;
            if (value != null) {
              updateOptions(node, !!props.multiple, value, false);
            }
          }
          var didWarnValDefaultVal = false;
          function getHostProps$2(element, props) {
            var node = element;
            if (props.dangerouslySetInnerHTML != null) {
              throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
            }
            var hostProps = assign({}, props, {
              value: void 0,
              defaultValue: void 0,
              children: toString(node._wrapperState.initialValue)
            });
            return hostProps;
          }
          function initWrapperState$2(element, props) {
            var node = element;
            {
              checkControlledValueProps("textarea", props);
              if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValDefaultVal) {
                error("%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component");
                didWarnValDefaultVal = true;
              }
            }
            var initialValue = props.value;
            if (initialValue == null) {
              var children = props.children, defaultValue = props.defaultValue;
              if (children != null) {
                {
                  error("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
                }
                {
                  if (defaultValue != null) {
                    throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
                  }
                  if (isArray(children)) {
                    if (children.length > 1) {
                      throw new Error("<textarea> can only have at most one child.");
                    }
                    children = children[0];
                  }
                  defaultValue = children;
                }
              }
              if (defaultValue == null) {
                defaultValue = "";
              }
              initialValue = defaultValue;
            }
            node._wrapperState = {
              initialValue: getToStringValue(initialValue)
            };
          }
          function updateWrapper$1(element, props) {
            var node = element;
            var value = getToStringValue(props.value);
            var defaultValue = getToStringValue(props.defaultValue);
            if (value != null) {
              var newValue = toString(value);
              if (newValue !== node.value) {
                node.value = newValue;
              }
              if (props.defaultValue == null && node.defaultValue !== newValue) {
                node.defaultValue = newValue;
              }
            }
            if (defaultValue != null) {
              node.defaultValue = toString(defaultValue);
            }
          }
          function postMountWrapper$3(element, props) {
            var node = element;
            var textContent = node.textContent;
            if (textContent === node._wrapperState.initialValue) {
              if (textContent !== "" && textContent !== null) {
                node.value = textContent;
              }
            }
          }
          function restoreControlledState$2(element, props) {
            updateWrapper$1(element, props);
          }
          var HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
          var MATH_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
          var SVG_NAMESPACE = "http://www.w3.org/2000/svg";
          function getIntrinsicNamespace(type) {
            switch (type) {
              case "svg":
                return SVG_NAMESPACE;
              case "math":
                return MATH_NAMESPACE;
              default:
                return HTML_NAMESPACE;
            }
          }
          function getChildNamespace(parentNamespace, type) {
            if (parentNamespace == null || parentNamespace === HTML_NAMESPACE) {
              return getIntrinsicNamespace(type);
            }
            if (parentNamespace === SVG_NAMESPACE && type === "foreignObject") {
              return HTML_NAMESPACE;
            }
            return parentNamespace;
          }
          var createMicrosoftUnsafeLocalFunction = function(func) {
            if (typeof MSApp !== "undefined" && MSApp.execUnsafeLocalFunction) {
              return function(arg0, arg1, arg2, arg3) {
                MSApp.execUnsafeLocalFunction(function() {
                  return func(arg0, arg1, arg2, arg3);
                });
              };
            } else {
              return func;
            }
          };
          var reusableSVGContainer;
          var setInnerHTML = createMicrosoftUnsafeLocalFunction(function(node, html) {
            if (node.namespaceURI === SVG_NAMESPACE) {
              if (!("innerHTML" in node)) {
                reusableSVGContainer = reusableSVGContainer || document.createElement("div");
                reusableSVGContainer.innerHTML = "<svg>" + html.valueOf().toString() + "</svg>";
                var svgNode = reusableSVGContainer.firstChild;
                while (node.firstChild) {
                  node.removeChild(node.firstChild);
                }
                while (svgNode.firstChild) {
                  node.appendChild(svgNode.firstChild);
                }
                return;
              }
            }
            node.innerHTML = html;
          });
          var ELEMENT_NODE = 1;
          var TEXT_NODE = 3;
          var COMMENT_NODE = 8;
          var DOCUMENT_NODE = 9;
          var DOCUMENT_FRAGMENT_NODE = 11;
          var setTextContent = function(node, text) {
            if (text) {
              var firstChild = node.firstChild;
              if (firstChild && firstChild === node.lastChild && firstChild.nodeType === TEXT_NODE) {
                firstChild.nodeValue = text;
                return;
              }
            }
            node.textContent = text;
          };
          var shorthandToLonghand = {
            animation: ["animationDelay", "animationDirection", "animationDuration", "animationFillMode", "animationIterationCount", "animationName", "animationPlayState", "animationTimingFunction"],
            background: ["backgroundAttachment", "backgroundClip", "backgroundColor", "backgroundImage", "backgroundOrigin", "backgroundPositionX", "backgroundPositionY", "backgroundRepeat", "backgroundSize"],
            backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
            border: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth", "borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth", "borderLeftColor", "borderLeftStyle", "borderLeftWidth", "borderRightColor", "borderRightStyle", "borderRightWidth", "borderTopColor", "borderTopStyle", "borderTopWidth"],
            borderBlockEnd: ["borderBlockEndColor", "borderBlockEndStyle", "borderBlockEndWidth"],
            borderBlockStart: ["borderBlockStartColor", "borderBlockStartStyle", "borderBlockStartWidth"],
            borderBottom: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth"],
            borderColor: ["borderBottomColor", "borderLeftColor", "borderRightColor", "borderTopColor"],
            borderImage: ["borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth"],
            borderInlineEnd: ["borderInlineEndColor", "borderInlineEndStyle", "borderInlineEndWidth"],
            borderInlineStart: ["borderInlineStartColor", "borderInlineStartStyle", "borderInlineStartWidth"],
            borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
            borderRadius: ["borderBottomLeftRadius", "borderBottomRightRadius", "borderTopLeftRadius", "borderTopRightRadius"],
            borderRight: ["borderRightColor", "borderRightStyle", "borderRightWidth"],
            borderStyle: ["borderBottomStyle", "borderLeftStyle", "borderRightStyle", "borderTopStyle"],
            borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
            borderWidth: ["borderBottomWidth", "borderLeftWidth", "borderRightWidth", "borderTopWidth"],
            columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
            columns: ["columnCount", "columnWidth"],
            flex: ["flexBasis", "flexGrow", "flexShrink"],
            flexFlow: ["flexDirection", "flexWrap"],
            font: ["fontFamily", "fontFeatureSettings", "fontKerning", "fontLanguageOverride", "fontSize", "fontSizeAdjust", "fontStretch", "fontStyle", "fontVariant", "fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition", "fontWeight", "lineHeight"],
            fontVariant: ["fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition"],
            gap: ["columnGap", "rowGap"],
            grid: ["gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
            gridArea: ["gridColumnEnd", "gridColumnStart", "gridRowEnd", "gridRowStart"],
            gridColumn: ["gridColumnEnd", "gridColumnStart"],
            gridColumnGap: ["columnGap"],
            gridGap: ["columnGap", "rowGap"],
            gridRow: ["gridRowEnd", "gridRowStart"],
            gridRowGap: ["rowGap"],
            gridTemplate: ["gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
            listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
            margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
            marker: ["markerEnd", "markerMid", "markerStart"],
            mask: ["maskClip", "maskComposite", "maskImage", "maskMode", "maskOrigin", "maskPositionX", "maskPositionY", "maskRepeat", "maskSize"],
            maskPosition: ["maskPositionX", "maskPositionY"],
            outline: ["outlineColor", "outlineStyle", "outlineWidth"],
            overflow: ["overflowX", "overflowY"],
            padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
            placeContent: ["alignContent", "justifyContent"],
            placeItems: ["alignItems", "justifyItems"],
            placeSelf: ["alignSelf", "justifySelf"],
            textDecoration: ["textDecorationColor", "textDecorationLine", "textDecorationStyle"],
            textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
            transition: ["transitionDelay", "transitionDuration", "transitionProperty", "transitionTimingFunction"],
            wordWrap: ["overflowWrap"]
          };
          var isUnitlessNumber = {
            animationIterationCount: true,
            aspectRatio: true,
            borderImageOutset: true,
            borderImageSlice: true,
            borderImageWidth: true,
            boxFlex: true,
            boxFlexGroup: true,
            boxOrdinalGroup: true,
            columnCount: true,
            columns: true,
            flex: true,
            flexGrow: true,
            flexPositive: true,
            flexShrink: true,
            flexNegative: true,
            flexOrder: true,
            gridArea: true,
            gridRow: true,
            gridRowEnd: true,
            gridRowSpan: true,
            gridRowStart: true,
            gridColumn: true,
            gridColumnEnd: true,
            gridColumnSpan: true,
            gridColumnStart: true,
            fontWeight: true,
            lineClamp: true,
            lineHeight: true,
            opacity: true,
            order: true,
            orphans: true,
            tabSize: true,
            widows: true,
            zIndex: true,
            zoom: true,
            // SVG-related properties
            fillOpacity: true,
            floodOpacity: true,
            stopOpacity: true,
            strokeDasharray: true,
            strokeDashoffset: true,
            strokeMiterlimit: true,
            strokeOpacity: true,
            strokeWidth: true
          };
          function prefixKey(prefix2, key) {
            return prefix2 + key.charAt(0).toUpperCase() + key.substring(1);
          }
          var prefixes = ["Webkit", "ms", "Moz", "O"];
          Object.keys(isUnitlessNumber).forEach(function(prop) {
            prefixes.forEach(function(prefix2) {
              isUnitlessNumber[prefixKey(prefix2, prop)] = isUnitlessNumber[prop];
            });
          });
          function dangerousStyleValue(name, value, isCustomProperty) {
            var isEmpty = value == null || typeof value === "boolean" || value === "";
            if (isEmpty) {
              return "";
            }
            if (!isCustomProperty && typeof value === "number" && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name])) {
              return value + "px";
            }
            {
              checkCSSPropertyStringCoercion(value, name);
            }
            return ("" + value).trim();
          }
          var uppercasePattern = /([A-Z])/g;
          var msPattern = /^ms-/;
          function hyphenateStyleName(name) {
            return name.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern, "-ms-");
          }
          var warnValidStyle = function() {
          };
          {
            var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
            var msPattern$1 = /^-ms-/;
            var hyphenPattern = /-(.)/g;
            var badStyleValueWithSemicolonPattern = /;\s*$/;
            var warnedStyleNames = {};
            var warnedStyleValues = {};
            var warnedForNaNValue = false;
            var warnedForInfinityValue = false;
            var camelize = function(string) {
              return string.replace(hyphenPattern, function(_, character) {
                return character.toUpperCase();
              });
            };
            var warnHyphenatedStyleName = function(name) {
              if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
                return;
              }
              warnedStyleNames[name] = true;
              error(
                "Unsupported style property %s. Did you mean %s?",
                name,
                // As Andi Smith suggests
                // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
                // is converted to lowercase `ms`.
                camelize(name.replace(msPattern$1, "ms-"))
              );
            };
            var warnBadVendoredStyleName = function(name) {
              if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
                return;
              }
              warnedStyleNames[name] = true;
              error("Unsupported vendor-prefixed style property %s. Did you mean %s?", name, name.charAt(0).toUpperCase() + name.slice(1));
            };
            var warnStyleValueWithSemicolon = function(name, value) {
              if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
                return;
              }
              warnedStyleValues[value] = true;
              error(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, name, value.replace(badStyleValueWithSemicolonPattern, ""));
            };
            var warnStyleValueIsNaN = function(name, value) {
              if (warnedForNaNValue) {
                return;
              }
              warnedForNaNValue = true;
              error("`NaN` is an invalid value for the `%s` css style property.", name);
            };
            var warnStyleValueIsInfinity = function(name, value) {
              if (warnedForInfinityValue) {
                return;
              }
              warnedForInfinityValue = true;
              error("`Infinity` is an invalid value for the `%s` css style property.", name);
            };
            warnValidStyle = function(name, value) {
              if (name.indexOf("-") > -1) {
                warnHyphenatedStyleName(name);
              } else if (badVendoredStyleNamePattern.test(name)) {
                warnBadVendoredStyleName(name);
              } else if (badStyleValueWithSemicolonPattern.test(value)) {
                warnStyleValueWithSemicolon(name, value);
              }
              if (typeof value === "number") {
                if (isNaN(value)) {
                  warnStyleValueIsNaN(name, value);
                } else if (!isFinite(value)) {
                  warnStyleValueIsInfinity(name, value);
                }
              }
            };
          }
          var warnValidStyle$1 = warnValidStyle;
          function createDangerousStringForStyles(styles) {
            {
              var serialized = "";
              var delimiter = "";
              for (var styleName in styles) {
                if (!styles.hasOwnProperty(styleName)) {
                  continue;
                }
                var styleValue = styles[styleName];
                if (styleValue != null) {
                  var isCustomProperty = styleName.indexOf("--") === 0;
                  serialized += delimiter + (isCustomProperty ? styleName : hyphenateStyleName(styleName)) + ":";
                  serialized += dangerousStyleValue(styleName, styleValue, isCustomProperty);
                  delimiter = ";";
                }
              }
              return serialized || null;
            }
          }
          function setValueForStyles(node, styles) {
            var style2 = node.style;
            for (var styleName in styles) {
              if (!styles.hasOwnProperty(styleName)) {
                continue;
              }
              var isCustomProperty = styleName.indexOf("--") === 0;
              {
                if (!isCustomProperty) {
                  warnValidStyle$1(styleName, styles[styleName]);
                }
              }
              var styleValue = dangerousStyleValue(styleName, styles[styleName], isCustomProperty);
              if (styleName === "float") {
                styleName = "cssFloat";
              }
              if (isCustomProperty) {
                style2.setProperty(styleName, styleValue);
              } else {
                style2[styleName] = styleValue;
              }
            }
          }
          function isValueEmpty(value) {
            return value == null || typeof value === "boolean" || value === "";
          }
          function expandShorthandMap(styles) {
            var expanded = {};
            for (var key in styles) {
              var longhands = shorthandToLonghand[key] || [key];
              for (var i = 0; i < longhands.length; i++) {
                expanded[longhands[i]] = key;
              }
            }
            return expanded;
          }
          function validateShorthandPropertyCollisionInDev(styleUpdates, nextStyles) {
            {
              if (!nextStyles) {
                return;
              }
              var expandedUpdates = expandShorthandMap(styleUpdates);
              var expandedStyles = expandShorthandMap(nextStyles);
              var warnedAbout = {};
              for (var key in expandedUpdates) {
                var originalKey = expandedUpdates[key];
                var correctOriginalKey = expandedStyles[key];
                if (correctOriginalKey && originalKey !== correctOriginalKey) {
                  var warningKey = originalKey + "," + correctOriginalKey;
                  if (warnedAbout[warningKey]) {
                    continue;
                  }
                  warnedAbout[warningKey] = true;
                  error("%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.", isValueEmpty(styleUpdates[originalKey]) ? "Removing" : "Updating", originalKey, correctOriginalKey);
                }
              }
            }
          }
          var omittedCloseTags = {
            area: true,
            base: true,
            br: true,
            col: true,
            embed: true,
            hr: true,
            img: true,
            input: true,
            keygen: true,
            link: true,
            meta: true,
            param: true,
            source: true,
            track: true,
            wbr: true
            // NOTE: menuitem's close tag should be omitted, but that causes problems.
          };
          var voidElementTags = assign({
            menuitem: true
          }, omittedCloseTags);
          var HTML = "__html";
          function assertValidProps(tag, props) {
            if (!props) {
              return;
            }
            if (voidElementTags[tag]) {
              if (props.children != null || props.dangerouslySetInnerHTML != null) {
                throw new Error(tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
              }
            }
            if (props.dangerouslySetInnerHTML != null) {
              if (props.children != null) {
                throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
              }
              if (typeof props.dangerouslySetInnerHTML !== "object" || !(HTML in props.dangerouslySetInnerHTML)) {
                throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
              }
            }
            {
              if (!props.suppressContentEditableWarning && props.contentEditable && props.children != null) {
                error("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.");
              }
            }
            if (props.style != null && typeof props.style !== "object") {
              throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
            }
          }
          function isCustomComponent(tagName, props) {
            if (tagName.indexOf("-") === -1) {
              return typeof props.is === "string";
            }
            switch (tagName) {
              // These are reserved SVG and MathML elements.
              // We don't mind this list too much because we expect it to never grow.
              // The alternative is to track the namespace in a few places which is convoluted.
              // https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts
              case "annotation-xml":
              case "color-profile":
              case "font-face":
              case "font-face-src":
              case "font-face-uri":
              case "font-face-format":
              case "font-face-name":
              case "missing-glyph":
                return false;
              default:
                return true;
            }
          }
          var possibleStandardNames = {
            // HTML
            accept: "accept",
            acceptcharset: "acceptCharset",
            "accept-charset": "acceptCharset",
            accesskey: "accessKey",
            action: "action",
            allowfullscreen: "allowFullScreen",
            alt: "alt",
            as: "as",
            async: "async",
            autocapitalize: "autoCapitalize",
            autocomplete: "autoComplete",
            autocorrect: "autoCorrect",
            autofocus: "autoFocus",
            autoplay: "autoPlay",
            autosave: "autoSave",
            capture: "capture",
            cellpadding: "cellPadding",
            cellspacing: "cellSpacing",
            challenge: "challenge",
            charset: "charSet",
            checked: "checked",
            children: "children",
            cite: "cite",
            class: "className",
            classid: "classID",
            classname: "className",
            cols: "cols",
            colspan: "colSpan",
            content: "content",
            contenteditable: "contentEditable",
            contextmenu: "contextMenu",
            controls: "controls",
            controlslist: "controlsList",
            coords: "coords",
            crossorigin: "crossOrigin",
            dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
            data: "data",
            datetime: "dateTime",
            default: "default",
            defaultchecked: "defaultChecked",
            defaultvalue: "defaultValue",
            defer: "defer",
            dir: "dir",
            disabled: "disabled",
            disablepictureinpicture: "disablePictureInPicture",
            disableremoteplayback: "disableRemotePlayback",
            download: "download",
            draggable: "draggable",
            enctype: "encType",
            enterkeyhint: "enterKeyHint",
            for: "htmlFor",
            form: "form",
            formmethod: "formMethod",
            formaction: "formAction",
            formenctype: "formEncType",
            formnovalidate: "formNoValidate",
            formtarget: "formTarget",
            frameborder: "frameBorder",
            headers: "headers",
            height: "height",
            hidden: "hidden",
            high: "high",
            href: "href",
            hreflang: "hrefLang",
            htmlfor: "htmlFor",
            httpequiv: "httpEquiv",
            "http-equiv": "httpEquiv",
            icon: "icon",
            id: "id",
            imagesizes: "imageSizes",
            imagesrcset: "imageSrcSet",
            innerhtml: "innerHTML",
            inputmode: "inputMode",
            integrity: "integrity",
            is: "is",
            itemid: "itemID",
            itemprop: "itemProp",
            itemref: "itemRef",
            itemscope: "itemScope",
            itemtype: "itemType",
            keyparams: "keyParams",
            keytype: "keyType",
            kind: "kind",
            label: "label",
            lang: "lang",
            list: "list",
            loop: "loop",
            low: "low",
            manifest: "manifest",
            marginwidth: "marginWidth",
            marginheight: "marginHeight",
            max: "max",
            maxlength: "maxLength",
            media: "media",
            mediagroup: "mediaGroup",
            method: "method",
            min: "min",
            minlength: "minLength",
            multiple: "multiple",
            muted: "muted",
            name: "name",
            nomodule: "noModule",
            nonce: "nonce",
            novalidate: "noValidate",
            open: "open",
            optimum: "optimum",
            pattern: "pattern",
            placeholder: "placeholder",
            playsinline: "playsInline",
            poster: "poster",
            preload: "preload",
            profile: "profile",
            radiogroup: "radioGroup",
            readonly: "readOnly",
            referrerpolicy: "referrerPolicy",
            rel: "rel",
            required: "required",
            reversed: "reversed",
            role: "role",
            rows: "rows",
            rowspan: "rowSpan",
            sandbox: "sandbox",
            scope: "scope",
            scoped: "scoped",
            scrolling: "scrolling",
            seamless: "seamless",
            selected: "selected",
            shape: "shape",
            size: "size",
            sizes: "sizes",
            span: "span",
            spellcheck: "spellCheck",
            src: "src",
            srcdoc: "srcDoc",
            srclang: "srcLang",
            srcset: "srcSet",
            start: "start",
            step: "step",
            style: "style",
            summary: "summary",
            tabindex: "tabIndex",
            target: "target",
            title: "title",
            type: "type",
            usemap: "useMap",
            value: "value",
            width: "width",
            wmode: "wmode",
            wrap: "wrap",
            // SVG
            about: "about",
            accentheight: "accentHeight",
            "accent-height": "accentHeight",
            accumulate: "accumulate",
            additive: "additive",
            alignmentbaseline: "alignmentBaseline",
            "alignment-baseline": "alignmentBaseline",
            allowreorder: "allowReorder",
            alphabetic: "alphabetic",
            amplitude: "amplitude",
            arabicform: "arabicForm",
            "arabic-form": "arabicForm",
            ascent: "ascent",
            attributename: "attributeName",
            attributetype: "attributeType",
            autoreverse: "autoReverse",
            azimuth: "azimuth",
            basefrequency: "baseFrequency",
            baselineshift: "baselineShift",
            "baseline-shift": "baselineShift",
            baseprofile: "baseProfile",
            bbox: "bbox",
            begin: "begin",
            bias: "bias",
            by: "by",
            calcmode: "calcMode",
            capheight: "capHeight",
            "cap-height": "capHeight",
            clip: "clip",
            clippath: "clipPath",
            "clip-path": "clipPath",
            clippathunits: "clipPathUnits",
            cliprule: "clipRule",
            "clip-rule": "clipRule",
            color: "color",
            colorinterpolation: "colorInterpolation",
            "color-interpolation": "colorInterpolation",
            colorinterpolationfilters: "colorInterpolationFilters",
            "color-interpolation-filters": "colorInterpolationFilters",
            colorprofile: "colorProfile",
            "color-profile": "colorProfile",
            colorrendering: "colorRendering",
            "color-rendering": "colorRendering",
            contentscripttype: "contentScriptType",
            contentstyletype: "contentStyleType",
            cursor: "cursor",
            cx: "cx",
            cy: "cy",
            d: "d",
            datatype: "datatype",
            decelerate: "decelerate",
            descent: "descent",
            diffuseconstant: "diffuseConstant",
            direction: "direction",
            display: "display",
            divisor: "divisor",
            dominantbaseline: "dominantBaseline",
            "dominant-baseline": "dominantBaseline",
            dur: "dur",
            dx: "dx",
            dy: "dy",
            edgemode: "edgeMode",
            elevation: "elevation",
            enablebackground: "enableBackground",
            "enable-background": "enableBackground",
            end: "end",
            exponent: "exponent",
            externalresourcesrequired: "externalResourcesRequired",
            fill: "fill",
            fillopacity: "fillOpacity",
            "fill-opacity": "fillOpacity",
            fillrule: "fillRule",
            "fill-rule": "fillRule",
            filter: "filter",
            filterres: "filterRes",
            filterunits: "filterUnits",
            floodopacity: "floodOpacity",
            "flood-opacity": "floodOpacity",
            floodcolor: "floodColor",
            "flood-color": "floodColor",
            focusable: "focusable",
            fontfamily: "fontFamily",
            "font-family": "fontFamily",
            fontsize: "fontSize",
            "font-size": "fontSize",
            fontsizeadjust: "fontSizeAdjust",
            "font-size-adjust": "fontSizeAdjust",
            fontstretch: "fontStretch",
            "font-stretch": "fontStretch",
            fontstyle: "fontStyle",
            "font-style": "fontStyle",
            fontvariant: "fontVariant",
            "font-variant": "fontVariant",
            fontweight: "fontWeight",
            "font-weight": "fontWeight",
            format: "format",
            from: "from",
            fx: "fx",
            fy: "fy",
            g1: "g1",
            g2: "g2",
            glyphname: "glyphName",
            "glyph-name": "glyphName",
            glyphorientationhorizontal: "glyphOrientationHorizontal",
            "glyph-orientation-horizontal": "glyphOrientationHorizontal",
            glyphorientationvertical: "glyphOrientationVertical",
            "glyph-orientation-vertical": "glyphOrientationVertical",
            glyphref: "glyphRef",
            gradienttransform: "gradientTransform",
            gradientunits: "gradientUnits",
            hanging: "hanging",
            horizadvx: "horizAdvX",
            "horiz-adv-x": "horizAdvX",
            horizoriginx: "horizOriginX",
            "horiz-origin-x": "horizOriginX",
            ideographic: "ideographic",
            imagerendering: "imageRendering",
            "image-rendering": "imageRendering",
            in2: "in2",
            in: "in",
            inlist: "inlist",
            intercept: "intercept",
            k1: "k1",
            k2: "k2",
            k3: "k3",
            k4: "k4",
            k: "k",
            kernelmatrix: "kernelMatrix",
            kernelunitlength: "kernelUnitLength",
            kerning: "kerning",
            keypoints: "keyPoints",
            keysplines: "keySplines",
            keytimes: "keyTimes",
            lengthadjust: "lengthAdjust",
            letterspacing: "letterSpacing",
            "letter-spacing": "letterSpacing",
            lightingcolor: "lightingColor",
            "lighting-color": "lightingColor",
            limitingconeangle: "limitingConeAngle",
            local: "local",
            markerend: "markerEnd",
            "marker-end": "markerEnd",
            markerheight: "markerHeight",
            markermid: "markerMid",
            "marker-mid": "markerMid",
            markerstart: "markerStart",
            "marker-start": "markerStart",
            markerunits: "markerUnits",
            markerwidth: "markerWidth",
            mask: "mask",
            maskcontentunits: "maskContentUnits",
            maskunits: "maskUnits",
            mathematical: "mathematical",
            mode: "mode",
            numoctaves: "numOctaves",
            offset: "offset",
            opacity: "opacity",
            operator: "operator",
            order: "order",
            orient: "orient",
            orientation: "orientation",
            origin: "origin",
            overflow: "overflow",
            overlineposition: "overlinePosition",
            "overline-position": "overlinePosition",
            overlinethickness: "overlineThickness",
            "overline-thickness": "overlineThickness",
            paintorder: "paintOrder",
            "paint-order": "paintOrder",
            panose1: "panose1",
            "panose-1": "panose1",
            pathlength: "pathLength",
            patterncontentunits: "patternContentUnits",
            patterntransform: "patternTransform",
            patternunits: "patternUnits",
            pointerevents: "pointerEvents",
            "pointer-events": "pointerEvents",
            points: "points",
            pointsatx: "pointsAtX",
            pointsaty: "pointsAtY",
            pointsatz: "pointsAtZ",
            prefix: "prefix",
            preservealpha: "preserveAlpha",
            preserveaspectratio: "preserveAspectRatio",
            primitiveunits: "primitiveUnits",
            property: "property",
            r: "r",
            radius: "radius",
            refx: "refX",
            refy: "refY",
            renderingintent: "renderingIntent",
            "rendering-intent": "renderingIntent",
            repeatcount: "repeatCount",
            repeatdur: "repeatDur",
            requiredextensions: "requiredExtensions",
            requiredfeatures: "requiredFeatures",
            resource: "resource",
            restart: "restart",
            result: "result",
            results: "results",
            rotate: "rotate",
            rx: "rx",
            ry: "ry",
            scale: "scale",
            security: "security",
            seed: "seed",
            shaperendering: "shapeRendering",
            "shape-rendering": "shapeRendering",
            slope: "slope",
            spacing: "spacing",
            specularconstant: "specularConstant",
            specularexponent: "specularExponent",
            speed: "speed",
            spreadmethod: "spreadMethod",
            startoffset: "startOffset",
            stddeviation: "stdDeviation",
            stemh: "stemh",
            stemv: "stemv",
            stitchtiles: "stitchTiles",
            stopcolor: "stopColor",
            "stop-color": "stopColor",
            stopopacity: "stopOpacity",
            "stop-opacity": "stopOpacity",
            strikethroughposition: "strikethroughPosition",
            "strikethrough-position": "strikethroughPosition",
            strikethroughthickness: "strikethroughThickness",
            "strikethrough-thickness": "strikethroughThickness",
            string: "string",
            stroke: "stroke",
            strokedasharray: "strokeDasharray",
            "stroke-dasharray": "strokeDasharray",
            strokedashoffset: "strokeDashoffset",
            "stroke-dashoffset": "strokeDashoffset",
            strokelinecap: "strokeLinecap",
            "stroke-linecap": "strokeLinecap",
            strokelinejoin: "strokeLinejoin",
            "stroke-linejoin": "strokeLinejoin",
            strokemiterlimit: "strokeMiterlimit",
            "stroke-miterlimit": "strokeMiterlimit",
            strokewidth: "strokeWidth",
            "stroke-width": "strokeWidth",
            strokeopacity: "strokeOpacity",
            "stroke-opacity": "strokeOpacity",
            suppresscontenteditablewarning: "suppressContentEditableWarning",
            suppresshydrationwarning: "suppressHydrationWarning",
            surfacescale: "surfaceScale",
            systemlanguage: "systemLanguage",
            tablevalues: "tableValues",
            targetx: "targetX",
            targety: "targetY",
            textanchor: "textAnchor",
            "text-anchor": "textAnchor",
            textdecoration: "textDecoration",
            "text-decoration": "textDecoration",
            textlength: "textLength",
            textrendering: "textRendering",
            "text-rendering": "textRendering",
            to: "to",
            transform: "transform",
            typeof: "typeof",
            u1: "u1",
            u2: "u2",
            underlineposition: "underlinePosition",
            "underline-position": "underlinePosition",
            underlinethickness: "underlineThickness",
            "underline-thickness": "underlineThickness",
            unicode: "unicode",
            unicodebidi: "unicodeBidi",
            "unicode-bidi": "unicodeBidi",
            unicoderange: "unicodeRange",
            "unicode-range": "unicodeRange",
            unitsperem: "unitsPerEm",
            "units-per-em": "unitsPerEm",
            unselectable: "unselectable",
            valphabetic: "vAlphabetic",
            "v-alphabetic": "vAlphabetic",
            values: "values",
            vectoreffect: "vectorEffect",
            "vector-effect": "vectorEffect",
            version: "version",
            vertadvy: "vertAdvY",
            "vert-adv-y": "vertAdvY",
            vertoriginx: "vertOriginX",
            "vert-origin-x": "vertOriginX",
            vertoriginy: "vertOriginY",
            "vert-origin-y": "vertOriginY",
            vhanging: "vHanging",
            "v-hanging": "vHanging",
            videographic: "vIdeographic",
            "v-ideographic": "vIdeographic",
            viewbox: "viewBox",
            viewtarget: "viewTarget",
            visibility: "visibility",
            vmathematical: "vMathematical",
            "v-mathematical": "vMathematical",
            vocab: "vocab",
            widths: "widths",
            wordspacing: "wordSpacing",
            "word-spacing": "wordSpacing",
            writingmode: "writingMode",
            "writing-mode": "writingMode",
            x1: "x1",
            x2: "x2",
            x: "x",
            xchannelselector: "xChannelSelector",
            xheight: "xHeight",
            "x-height": "xHeight",
            xlinkactuate: "xlinkActuate",
            "xlink:actuate": "xlinkActuate",
            xlinkarcrole: "xlinkArcrole",
            "xlink:arcrole": "xlinkArcrole",
            xlinkhref: "xlinkHref",
            "xlink:href": "xlinkHref",
            xlinkrole: "xlinkRole",
            "xlink:role": "xlinkRole",
            xlinkshow: "xlinkShow",
            "xlink:show": "xlinkShow",
            xlinktitle: "xlinkTitle",
            "xlink:title": "xlinkTitle",
            xlinktype: "xlinkType",
            "xlink:type": "xlinkType",
            xmlbase: "xmlBase",
            "xml:base": "xmlBase",
            xmllang: "xmlLang",
            "xml:lang": "xmlLang",
            xmlns: "xmlns",
            "xml:space": "xmlSpace",
            xmlnsxlink: "xmlnsXlink",
            "xmlns:xlink": "xmlnsXlink",
            xmlspace: "xmlSpace",
            y1: "y1",
            y2: "y2",
            y: "y",
            ychannelselector: "yChannelSelector",
            z: "z",
            zoomandpan: "zoomAndPan"
          };
          var ariaProperties = {
            "aria-current": 0,
            // state
            "aria-description": 0,
            "aria-details": 0,
            "aria-disabled": 0,
            // state
            "aria-hidden": 0,
            // state
            "aria-invalid": 0,
            // state
            "aria-keyshortcuts": 0,
            "aria-label": 0,
            "aria-roledescription": 0,
            // Widget Attributes
            "aria-autocomplete": 0,
            "aria-checked": 0,
            "aria-expanded": 0,
            "aria-haspopup": 0,
            "aria-level": 0,
            "aria-modal": 0,
            "aria-multiline": 0,
            "aria-multiselectable": 0,
            "aria-orientation": 0,
            "aria-placeholder": 0,
            "aria-pressed": 0,
            "aria-readonly": 0,
            "aria-required": 0,
            "aria-selected": 0,
            "aria-sort": 0,
            "aria-valuemax": 0,
            "aria-valuemin": 0,
            "aria-valuenow": 0,
            "aria-valuetext": 0,
            // Live Region Attributes
            "aria-atomic": 0,
            "aria-busy": 0,
            "aria-live": 0,
            "aria-relevant": 0,
            // Drag-and-Drop Attributes
            "aria-dropeffect": 0,
            "aria-grabbed": 0,
            // Relationship Attributes
            "aria-activedescendant": 0,
            "aria-colcount": 0,
            "aria-colindex": 0,
            "aria-colspan": 0,
            "aria-controls": 0,
            "aria-describedby": 0,
            "aria-errormessage": 0,
            "aria-flowto": 0,
            "aria-labelledby": 0,
            "aria-owns": 0,
            "aria-posinset": 0,
            "aria-rowcount": 0,
            "aria-rowindex": 0,
            "aria-rowspan": 0,
            "aria-setsize": 0
          };
          var warnedProperties = {};
          var rARIA = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
          var rARIACamel = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
          function validateProperty(tagName, name) {
            {
              if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name]) {
                return true;
              }
              if (rARIACamel.test(name)) {
                var ariaName = "aria-" + name.slice(4).toLowerCase();
                var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;
                if (correctName == null) {
                  error("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", name);
                  warnedProperties[name] = true;
                  return true;
                }
                if (name !== correctName) {
                  error("Invalid ARIA attribute `%s`. Did you mean `%s`?", name, correctName);
                  warnedProperties[name] = true;
                  return true;
                }
              }
              if (rARIA.test(name)) {
                var lowerCasedName = name.toLowerCase();
                var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;
                if (standardName == null) {
                  warnedProperties[name] = true;
                  return false;
                }
                if (name !== standardName) {
                  error("Unknown ARIA attribute `%s`. Did you mean `%s`?", name, standardName);
                  warnedProperties[name] = true;
                  return true;
                }
              }
            }
            return true;
          }
          function warnInvalidARIAProps(type, props) {
            {
              var invalidProps = [];
              for (var key in props) {
                var isValid2 = validateProperty(type, key);
                if (!isValid2) {
                  invalidProps.push(key);
                }
              }
              var unknownPropString = invalidProps.map(function(prop) {
                return "`" + prop + "`";
              }).join(", ");
              if (invalidProps.length === 1) {
                error("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
              } else if (invalidProps.length > 1) {
                error("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
              }
            }
          }
          function validateProperties(type, props) {
            if (isCustomComponent(type, props)) {
              return;
            }
            warnInvalidARIAProps(type, props);
          }
          var didWarnValueNull = false;
          function validateProperties$1(type, props) {
            {
              if (type !== "input" && type !== "textarea" && type !== "select") {
                return;
              }
              if (props != null && props.value === null && !didWarnValueNull) {
                didWarnValueNull = true;
                if (type === "select" && props.multiple) {
                  error("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", type);
                } else {
                  error("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", type);
                }
              }
            }
          }
          var validateProperty$1 = function() {
          };
          {
            var warnedProperties$1 = {};
            var EVENT_NAME_REGEX = /^on./;
            var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
            var rARIA$1 = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
            var rARIACamel$1 = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
            validateProperty$1 = function(tagName, name, value, eventRegistry) {
              if (hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name]) {
                return true;
              }
              var lowerCasedName = name.toLowerCase();
              if (lowerCasedName === "onfocusin" || lowerCasedName === "onfocusout") {
                error("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React.");
                warnedProperties$1[name] = true;
                return true;
              }
              if (eventRegistry != null) {
                var registrationNameDependencies2 = eventRegistry.registrationNameDependencies, possibleRegistrationNames2 = eventRegistry.possibleRegistrationNames;
                if (registrationNameDependencies2.hasOwnProperty(name)) {
                  return true;
                }
                var registrationName = possibleRegistrationNames2.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames2[lowerCasedName] : null;
                if (registrationName != null) {
                  error("Invalid event handler property `%s`. Did you mean `%s`?", name, registrationName);
                  warnedProperties$1[name] = true;
                  return true;
                }
                if (EVENT_NAME_REGEX.test(name)) {
                  error("Unknown event handler property `%s`. It will be ignored.", name);
                  warnedProperties$1[name] = true;
                  return true;
                }
              } else if (EVENT_NAME_REGEX.test(name)) {
                if (INVALID_EVENT_NAME_REGEX.test(name)) {
                  error("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", name);
                }
                warnedProperties$1[name] = true;
                return true;
              }
              if (rARIA$1.test(name) || rARIACamel$1.test(name)) {
                return true;
              }
              if (lowerCasedName === "innerhtml") {
                error("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`.");
                warnedProperties$1[name] = true;
                return true;
              }
              if (lowerCasedName === "aria") {
                error("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead.");
                warnedProperties$1[name] = true;
                return true;
              }
              if (lowerCasedName === "is" && value !== null && value !== void 0 && typeof value !== "string") {
                error("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof value);
                warnedProperties$1[name] = true;
                return true;
              }
              if (typeof value === "number" && isNaN(value)) {
                error("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", name);
                warnedProperties$1[name] = true;
                return true;
              }
              var propertyInfo = getPropertyInfo(name);
              var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED;
              if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
                var standardName = possibleStandardNames[lowerCasedName];
                if (standardName !== name) {
                  error("Invalid DOM property `%s`. Did you mean `%s`?", name, standardName);
                  warnedProperties$1[name] = true;
                  return true;
                }
              } else if (!isReserved && name !== lowerCasedName) {
                error("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", name, lowerCasedName);
                warnedProperties$1[name] = true;
                return true;
              }
              if (typeof value === "boolean" && shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
                if (value) {
                  error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', value, name, name, value, name);
                } else {
                  error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', value, name, name, value, name, name, name);
                }
                warnedProperties$1[name] = true;
                return true;
              }
              if (isReserved) {
                return true;
              }
              if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
                warnedProperties$1[name] = true;
                return false;
              }
              if ((value === "false" || value === "true") && propertyInfo !== null && propertyInfo.type === BOOLEAN2) {
                error("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", value, name, value === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', name, value);
                warnedProperties$1[name] = true;
                return true;
              }
              return true;
            };
          }
          var warnUnknownProperties = function(type, props, eventRegistry) {
            {
              var unknownProps = [];
              for (var key in props) {
                var isValid2 = validateProperty$1(type, key, props[key], eventRegistry);
                if (!isValid2) {
                  unknownProps.push(key);
                }
              }
              var unknownPropString = unknownProps.map(function(prop) {
                return "`" + prop + "`";
              }).join(", ");
              if (unknownProps.length === 1) {
                error("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
              } else if (unknownProps.length > 1) {
                error("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
              }
            }
          };
          function validateProperties$2(type, props, eventRegistry) {
            if (isCustomComponent(type, props)) {
              return;
            }
            warnUnknownProperties(type, props, eventRegistry);
          }
          var IS_EVENT_HANDLE_NON_MANAGED_NODE = 1;
          var IS_NON_DELEGATED = 1 << 1;
          var IS_CAPTURE_PHASE = 1 << 2;
          var SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS = IS_EVENT_HANDLE_NON_MANAGED_NODE | IS_NON_DELEGATED | IS_CAPTURE_PHASE;
          var currentReplayingEvent = null;
          function setReplayingEvent(event) {
            {
              if (currentReplayingEvent !== null) {
                error("Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
            currentReplayingEvent = event;
          }
          function resetReplayingEvent() {
            {
              if (currentReplayingEvent === null) {
                error("Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
            currentReplayingEvent = null;
          }
          function isReplayingEvent(event) {
            return event === currentReplayingEvent;
          }
          function getEventTarget2(nativeEvent) {
            var target = nativeEvent.target || nativeEvent.srcElement || window;
            if (target.correspondingUseElement) {
              target = target.correspondingUseElement;
            }
            return target.nodeType === TEXT_NODE ? target.parentNode : target;
          }
          var restoreImpl = null;
          var restoreTarget = null;
          var restoreQueue = null;
          function restoreStateOfTarget(target) {
            var internalInstance = getInstanceFromNode(target);
            if (!internalInstance) {
              return;
            }
            if (typeof restoreImpl !== "function") {
              throw new Error("setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.");
            }
            var stateNode = internalInstance.stateNode;
            if (stateNode) {
              var _props = getFiberCurrentPropsFromNode(stateNode);
              restoreImpl(internalInstance.stateNode, internalInstance.type, _props);
            }
          }
          function setRestoreImplementation(impl) {
            restoreImpl = impl;
          }
          function enqueueStateRestore(target) {
            if (restoreTarget) {
              if (restoreQueue) {
                restoreQueue.push(target);
              } else {
                restoreQueue = [target];
              }
            } else {
              restoreTarget = target;
            }
          }
          function needsStateRestore() {
            return restoreTarget !== null || restoreQueue !== null;
          }
          function restoreStateIfNeeded() {
            if (!restoreTarget) {
              return;
            }
            var target = restoreTarget;
            var queuedTargets = restoreQueue;
            restoreTarget = null;
            restoreQueue = null;
            restoreStateOfTarget(target);
            if (queuedTargets) {
              for (var i = 0; i < queuedTargets.length; i++) {
                restoreStateOfTarget(queuedTargets[i]);
              }
            }
          }
          var batchedUpdatesImpl = function(fn, bookkeeping) {
            return fn(bookkeeping);
          };
          var flushSyncImpl2 = function() {
          };
          var isInsideEventHandler = false;
          function finishEventHandler() {
            var controlledComponentsHavePendingUpdates = needsStateRestore();
            if (controlledComponentsHavePendingUpdates) {
              flushSyncImpl2();
              restoreStateIfNeeded();
            }
          }
          function batchedUpdates(fn, a, b) {
            if (isInsideEventHandler) {
              return fn(a, b);
            }
            isInsideEventHandler = true;
            try {
              return batchedUpdatesImpl(fn, a, b);
            } finally {
              isInsideEventHandler = false;
              finishEventHandler();
            }
          }
          function setBatchingImplementation(_batchedUpdatesImpl, _discreteUpdatesImpl, _flushSyncImpl) {
            batchedUpdatesImpl = _batchedUpdatesImpl;
            flushSyncImpl2 = _flushSyncImpl;
          }
          function isInteractive(tag) {
            return tag === "button" || tag === "input" || tag === "select" || tag === "textarea";
          }
          function shouldPreventMouseEvent(name, type, props) {
            switch (name) {
              case "onClick":
              case "onClickCapture":
              case "onDoubleClick":
              case "onDoubleClickCapture":
              case "onMouseDown":
              case "onMouseDownCapture":
              case "onMouseMove":
              case "onMouseMoveCapture":
              case "onMouseUp":
              case "onMouseUpCapture":
              case "onMouseEnter":
                return !!(props.disabled && isInteractive(type));
              default:
                return false;
            }
          }
          function getListener(inst, registrationName) {
            var stateNode = inst.stateNode;
            if (stateNode === null) {
              return null;
            }
            var props = getFiberCurrentPropsFromNode(stateNode);
            if (props === null) {
              return null;
            }
            var listener = props[registrationName];
            if (shouldPreventMouseEvent(registrationName, inst.type, props)) {
              return null;
            }
            if (listener && typeof listener !== "function") {
              throw new Error("Expected `" + registrationName + "` listener to be a function, instead got a value of `" + typeof listener + "` type.");
            }
            return listener;
          }
          var passiveBrowserEventsSupported = false;
          if (canUseDOM) {
            try {
              var options = {};
              Object.defineProperty(options, "passive", {
                get: function() {
                  passiveBrowserEventsSupported = true;
                }
              });
              window.addEventListener("test", options, options);
              window.removeEventListener("test", options, options);
            } catch (e) {
              passiveBrowserEventsSupported = false;
            }
          }
          function invokeGuardedCallbackProd(name, func, context3, a, b, c, d, e, f) {
            var funcArgs = Array.prototype.slice.call(arguments, 3);
            try {
              func.apply(context3, funcArgs);
            } catch (error2) {
              this.onError(error2);
            }
          }
          var invokeGuardedCallbackImpl = invokeGuardedCallbackProd;
          {
            if (typeof window !== "undefined" && typeof window.dispatchEvent === "function" && typeof document !== "undefined" && typeof document.createEvent === "function") {
              var fakeNode = document.createElement("react");
              invokeGuardedCallbackImpl = function invokeGuardedCallbackDev(name, func, context3, a, b, c, d, e, f) {
                if (typeof document === "undefined" || document === null) {
                  throw new Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");
                }
                var evt = document.createEvent("Event");
                var didCall = false;
                var didError = true;
                var windowEvent = window.event;
                var windowEventDescriptor = Object.getOwnPropertyDescriptor(window, "event");
                function restoreAfterDispatch() {
                  fakeNode.removeEventListener(evtType, callCallback2, false);
                  if (typeof window.event !== "undefined" && window.hasOwnProperty("event")) {
                    window.event = windowEvent;
                  }
                }
                var funcArgs = Array.prototype.slice.call(arguments, 3);
                function callCallback2() {
                  didCall = true;
                  restoreAfterDispatch();
                  func.apply(context3, funcArgs);
                  didError = false;
                }
                var error2;
                var didSetError = false;
                var isCrossOriginError = false;
                function handleWindowError(event) {
                  error2 = event.error;
                  didSetError = true;
                  if (error2 === null && event.colno === 0 && event.lineno === 0) {
                    isCrossOriginError = true;
                  }
                  if (event.defaultPrevented) {
                    if (error2 != null && typeof error2 === "object") {
                      try {
                        error2._suppressLogging = true;
                      } catch (inner) {
                      }
                    }
                  }
                }
                var evtType = "react-" + (name ? name : "invokeguardedcallback");
                window.addEventListener("error", handleWindowError);
                fakeNode.addEventListener(evtType, callCallback2, false);
                evt.initEvent(evtType, false, false);
                fakeNode.dispatchEvent(evt);
                if (windowEventDescriptor) {
                  Object.defineProperty(window, "event", windowEventDescriptor);
                }
                if (didCall && didError) {
                  if (!didSetError) {
                    error2 = new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`);
                  } else if (isCrossOriginError) {
                    error2 = new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.");
                  }
                  this.onError(error2);
                }
                window.removeEventListener("error", handleWindowError);
                if (!didCall) {
                  restoreAfterDispatch();
                  return invokeGuardedCallbackProd.apply(this, arguments);
                }
              };
            }
          }
          var invokeGuardedCallbackImpl$1 = invokeGuardedCallbackImpl;
          var hasError = false;
          var caughtError = null;
          var hasRethrowError = false;
          var rethrowError = null;
          var reporter = {
            onError: function(error2) {
              hasError = true;
              caughtError = error2;
            }
          };
          function invokeGuardedCallback(name, func, context3, a, b, c, d, e, f) {
            hasError = false;
            caughtError = null;
            invokeGuardedCallbackImpl$1.apply(reporter, arguments);
          }
          function invokeGuardedCallbackAndCatchFirstError(name, func, context3, a, b, c, d, e, f) {
            invokeGuardedCallback.apply(this, arguments);
            if (hasError) {
              var error2 = clearCaughtError();
              if (!hasRethrowError) {
                hasRethrowError = true;
                rethrowError = error2;
              }
            }
          }
          function rethrowCaughtError() {
            if (hasRethrowError) {
              var error2 = rethrowError;
              hasRethrowError = false;
              rethrowError = null;
              throw error2;
            }
          }
          function hasCaughtError() {
            return hasError;
          }
          function clearCaughtError() {
            if (hasError) {
              var error2 = caughtError;
              hasError = false;
              caughtError = null;
              return error2;
            } else {
              throw new Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");
            }
          }
          function get(key) {
            return key._reactInternals;
          }
          function has(key) {
            return key._reactInternals !== void 0;
          }
          function set(key, value) {
            key._reactInternals = value;
          }
          var NoFlags = (
            /*                      */
            0
          );
          var PerformedWork = (
            /*                */
            1
          );
          var Placement = (
            /*                    */
            2
          );
          var Update = (
            /*                       */
            4
          );
          var ChildDeletion = (
            /*                */
            16
          );
          var ContentReset = (
            /*                 */
            32
          );
          var Callback = (
            /*                     */
            64
          );
          var DidCapture = (
            /*                   */
            128
          );
          var ForceClientRender = (
            /*            */
            256
          );
          var Ref = (
            /*                          */
            512
          );
          var Snapshot = (
            /*                     */
            1024
          );
          var Passive = (
            /*                      */
            2048
          );
          var Hydrating = (
            /*                    */
            4096
          );
          var Visibility = (
            /*                   */
            8192
          );
          var StoreConsistency = (
            /*             */
            16384
          );
          var LifecycleEffectMask = Passive | Update | Callback | Ref | Snapshot | StoreConsistency;
          var HostEffectMask = (
            /*               */
            32767
          );
          var Incomplete = (
            /*                   */
            32768
          );
          var ShouldCapture = (
            /*                */
            65536
          );
          var ForceUpdateForLegacySuspense = (
            /* */
            131072
          );
          var Forked = (
            /*                       */
            1048576
          );
          var RefStatic = (
            /*                    */
            2097152
          );
          var LayoutStatic = (
            /*                 */
            4194304
          );
          var PassiveStatic = (
            /*                */
            8388608
          );
          var MountLayoutDev = (
            /*               */
            16777216
          );
          var MountPassiveDev = (
            /*              */
            33554432
          );
          var BeforeMutationMask = (
            // TODO: Remove Update flag from before mutation phase by re-landing Visibility
            // flag logic (see #20043)
            Update | Snapshot | 0
          );
          var MutationMask = Placement | Update | ChildDeletion | ContentReset | Ref | Hydrating | Visibility;
          var LayoutMask = Update | Callback | Ref | Visibility;
          var PassiveMask = Passive | ChildDeletion;
          var StaticMask = LayoutStatic | PassiveStatic | RefStatic;
          var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
          function getNearestMountedFiber(fiber) {
            var node = fiber;
            var nearestMounted = fiber;
            if (!fiber.alternate) {
              var nextNode = node;
              do {
                node = nextNode;
                if ((node.flags & (Placement | Hydrating)) !== NoFlags) {
                  nearestMounted = node.return;
                }
                nextNode = node.return;
              } while (nextNode);
            } else {
              while (node.return) {
                node = node.return;
              }
            }
            if (node.tag === HostRoot) {
              return nearestMounted;
            }
            return null;
          }
          function getSuspenseInstanceFromFiber(fiber) {
            if (fiber.tag === SuspenseComponent) {
              var suspenseState = fiber.memoizedState;
              if (suspenseState === null) {
                var current2 = fiber.alternate;
                if (current2 !== null) {
                  suspenseState = current2.memoizedState;
                }
              }
              if (suspenseState !== null) {
                return suspenseState.dehydrated;
              }
            }
            return null;
          }
          function getContainerFromFiber(fiber) {
            return fiber.tag === HostRoot ? fiber.stateNode.containerInfo : null;
          }
          function isFiberMounted(fiber) {
            return getNearestMountedFiber(fiber) === fiber;
          }
          function isMounted(component) {
            {
              var owner = ReactCurrentOwner.current;
              if (owner !== null && owner.tag === ClassComponent) {
                var ownerFiber = owner;
                var instance = ownerFiber.stateNode;
                if (!instance._warnedAboutRefsInRender) {
                  error("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", getComponentNameFromFiber(ownerFiber) || "A component");
                }
                instance._warnedAboutRefsInRender = true;
              }
            }
            var fiber = get(component);
            if (!fiber) {
              return false;
            }
            return getNearestMountedFiber(fiber) === fiber;
          }
          function assertIsMounted(fiber) {
            if (getNearestMountedFiber(fiber) !== fiber) {
              throw new Error("Unable to find node on an unmounted component.");
            }
          }
          function findCurrentFiberUsingSlowPath(fiber) {
            var alternate = fiber.alternate;
            if (!alternate) {
              var nearestMounted = getNearestMountedFiber(fiber);
              if (nearestMounted === null) {
                throw new Error("Unable to find node on an unmounted component.");
              }
              if (nearestMounted !== fiber) {
                return null;
              }
              return fiber;
            }
            var a = fiber;
            var b = alternate;
            while (true) {
              var parentA = a.return;
              if (parentA === null) {
                break;
              }
              var parentB = parentA.alternate;
              if (parentB === null) {
                var nextParent = parentA.return;
                if (nextParent !== null) {
                  a = b = nextParent;
                  continue;
                }
                break;
              }
              if (parentA.child === parentB.child) {
                var child = parentA.child;
                while (child) {
                  if (child === a) {
                    assertIsMounted(parentA);
                    return fiber;
                  }
                  if (child === b) {
                    assertIsMounted(parentA);
                    return alternate;
                  }
                  child = child.sibling;
                }
                throw new Error("Unable to find node on an unmounted component.");
              }
              if (a.return !== b.return) {
                a = parentA;
                b = parentB;
              } else {
                var didFindChild = false;
                var _child = parentA.child;
                while (_child) {
                  if (_child === a) {
                    didFindChild = true;
                    a = parentA;
                    b = parentB;
                    break;
                  }
                  if (_child === b) {
                    didFindChild = true;
                    b = parentA;
                    a = parentB;
                    break;
                  }
                  _child = _child.sibling;
                }
                if (!didFindChild) {
                  _child = parentB.child;
                  while (_child) {
                    if (_child === a) {
                      didFindChild = true;
                      a = parentB;
                      b = parentA;
                      break;
                    }
                    if (_child === b) {
                      didFindChild = true;
                      b = parentB;
                      a = parentA;
                      break;
                    }
                    _child = _child.sibling;
                  }
                  if (!didFindChild) {
                    throw new Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
                  }
                }
              }
              if (a.alternate !== b) {
                throw new Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
            if (a.tag !== HostRoot) {
              throw new Error("Unable to find node on an unmounted component.");
            }
            if (a.stateNode.current === a) {
              return fiber;
            }
            return alternate;
          }
          function findCurrentHostFiber(parent) {
            var currentParent = findCurrentFiberUsingSlowPath(parent);
            return currentParent !== null ? findCurrentHostFiberImpl(currentParent) : null;
          }
          function findCurrentHostFiberImpl(node) {
            if (node.tag === HostComponent || node.tag === HostText) {
              return node;
            }
            var child = node.child;
            while (child !== null) {
              var match = findCurrentHostFiberImpl(child);
              if (match !== null) {
                return match;
              }
              child = child.sibling;
            }
            return null;
          }
          function findCurrentHostFiberWithNoPortals(parent) {
            var currentParent = findCurrentFiberUsingSlowPath(parent);
            return currentParent !== null ? findCurrentHostFiberWithNoPortalsImpl(currentParent) : null;
          }
          function findCurrentHostFiberWithNoPortalsImpl(node) {
            if (node.tag === HostComponent || node.tag === HostText) {
              return node;
            }
            var child = node.child;
            while (child !== null) {
              if (child.tag !== HostPortal) {
                var match = findCurrentHostFiberWithNoPortalsImpl(child);
                if (match !== null) {
                  return match;
                }
              }
              child = child.sibling;
            }
            return null;
          }
          var scheduleCallback = Scheduler.unstable_scheduleCallback;
          var cancelCallback = Scheduler.unstable_cancelCallback;
          var shouldYield = Scheduler.unstable_shouldYield;
          var requestPaint = Scheduler.unstable_requestPaint;
          var now3 = Scheduler.unstable_now;
          var getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel;
          var ImmediatePriority = Scheduler.unstable_ImmediatePriority;
          var UserBlockingPriority = Scheduler.unstable_UserBlockingPriority;
          var NormalPriority = Scheduler.unstable_NormalPriority;
          var LowPriority = Scheduler.unstable_LowPriority;
          var IdlePriority = Scheduler.unstable_IdlePriority;
          var unstable_yieldValue = Scheduler.unstable_yieldValue;
          var unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue;
          var rendererID = null;
          var injectedHook = null;
          var injectedProfilingHooks = null;
          var hasLoggedError = false;
          var isDevToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined";
          function injectInternals(internals) {
            if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined") {
              return false;
            }
            var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
            if (hook.isDisabled) {
              return true;
            }
            if (!hook.supportsFiber) {
              {
                error("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools");
              }
              return true;
            }
            try {
              if (enableSchedulingProfiler) {
                internals = assign({}, internals, {
                  getLaneLabelMap,
                  injectProfilingHooks
                });
              }
              rendererID = hook.inject(internals);
              injectedHook = hook;
            } catch (err) {
              {
                error("React instrumentation encountered an error: %s.", err);
              }
            }
            if (hook.checkDCE) {
              return true;
            } else {
              return false;
            }
          }
          function onScheduleRoot(root3, children) {
            {
              if (injectedHook && typeof injectedHook.onScheduleFiberRoot === "function") {
                try {
                  injectedHook.onScheduleFiberRoot(rendererID, root3, children);
                } catch (err) {
                  if (!hasLoggedError) {
                    hasLoggedError = true;
                    error("React instrumentation encountered an error: %s", err);
                  }
                }
              }
            }
          }
          function onCommitRoot(root3, eventPriority) {
            if (injectedHook && typeof injectedHook.onCommitFiberRoot === "function") {
              try {
                var didError = (root3.current.flags & DidCapture) === DidCapture;
                if (enableProfilerTimer) {
                  var schedulerPriority;
                  switch (eventPriority) {
                    case DiscreteEventPriority:
                      schedulerPriority = ImmediatePriority;
                      break;
                    case ContinuousEventPriority:
                      schedulerPriority = UserBlockingPriority;
                      break;
                    case DefaultEventPriority:
                      schedulerPriority = NormalPriority;
                      break;
                    case IdleEventPriority:
                      schedulerPriority = IdlePriority;
                      break;
                    default:
                      schedulerPriority = NormalPriority;
                      break;
                  }
                  injectedHook.onCommitFiberRoot(rendererID, root3, schedulerPriority, didError);
                } else {
                  injectedHook.onCommitFiberRoot(rendererID, root3, void 0, didError);
                }
              } catch (err) {
                {
                  if (!hasLoggedError) {
                    hasLoggedError = true;
                    error("React instrumentation encountered an error: %s", err);
                  }
                }
              }
            }
          }
          function onPostCommitRoot(root3) {
            if (injectedHook && typeof injectedHook.onPostCommitFiberRoot === "function") {
              try {
                injectedHook.onPostCommitFiberRoot(rendererID, root3);
              } catch (err) {
                {
                  if (!hasLoggedError) {
                    hasLoggedError = true;
                    error("React instrumentation encountered an error: %s", err);
                  }
                }
              }
            }
          }
          function onCommitUnmount(fiber) {
            if (injectedHook && typeof injectedHook.onCommitFiberUnmount === "function") {
              try {
                injectedHook.onCommitFiberUnmount(rendererID, fiber);
              } catch (err) {
                {
                  if (!hasLoggedError) {
                    hasLoggedError = true;
                    error("React instrumentation encountered an error: %s", err);
                  }
                }
              }
            }
          }
          function setIsStrictModeForDevtools(newIsStrictMode) {
            {
              if (typeof unstable_yieldValue === "function") {
                unstable_setDisableYieldValue(newIsStrictMode);
                setSuppressWarning(newIsStrictMode);
              }
              if (injectedHook && typeof injectedHook.setStrictMode === "function") {
                try {
                  injectedHook.setStrictMode(rendererID, newIsStrictMode);
                } catch (err) {
                  {
                    if (!hasLoggedError) {
                      hasLoggedError = true;
                      error("React instrumentation encountered an error: %s", err);
                    }
                  }
                }
              }
            }
          }
          function injectProfilingHooks(profilingHooks) {
            injectedProfilingHooks = profilingHooks;
          }
          function getLaneLabelMap() {
            {
              var map = /* @__PURE__ */ new Map();
              var lane = 1;
              for (var index2 = 0; index2 < TotalLanes; index2++) {
                var label = getLabelForLane(lane);
                map.set(lane, label);
                lane *= 2;
              }
              return map;
            }
          }
          function markCommitStarted(lanes) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStarted === "function") {
                injectedProfilingHooks.markCommitStarted(lanes);
              }
            }
          }
          function markCommitStopped() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStopped === "function") {
                injectedProfilingHooks.markCommitStopped();
              }
            }
          }
          function markComponentRenderStarted(fiber) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStarted === "function") {
                injectedProfilingHooks.markComponentRenderStarted(fiber);
              }
            }
          }
          function markComponentRenderStopped() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStopped === "function") {
                injectedProfilingHooks.markComponentRenderStopped();
              }
            }
          }
          function markComponentPassiveEffectMountStarted(fiber) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted === "function") {
                injectedProfilingHooks.markComponentPassiveEffectMountStarted(fiber);
              }
            }
          }
          function markComponentPassiveEffectMountStopped() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped === "function") {
                injectedProfilingHooks.markComponentPassiveEffectMountStopped();
              }
            }
          }
          function markComponentPassiveEffectUnmountStarted(fiber) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted === "function") {
                injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(fiber);
              }
            }
          }
          function markComponentPassiveEffectUnmountStopped() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped === "function") {
                injectedProfilingHooks.markComponentPassiveEffectUnmountStopped();
              }
            }
          }
          function markComponentLayoutEffectMountStarted(fiber) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted === "function") {
                injectedProfilingHooks.markComponentLayoutEffectMountStarted(fiber);
              }
            }
          }
          function markComponentLayoutEffectMountStopped() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped === "function") {
                injectedProfilingHooks.markComponentLayoutEffectMountStopped();
              }
            }
          }
          function markComponentLayoutEffectUnmountStarted(fiber) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted === "function") {
                injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(fiber);
              }
            }
          }
          function markComponentLayoutEffectUnmountStopped() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped === "function") {
                injectedProfilingHooks.markComponentLayoutEffectUnmountStopped();
              }
            }
          }
          function markComponentErrored(fiber, thrownValue, lanes) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentErrored === "function") {
                injectedProfilingHooks.markComponentErrored(fiber, thrownValue, lanes);
              }
            }
          }
          function markComponentSuspended(fiber, wakeable, lanes) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentSuspended === "function") {
                injectedProfilingHooks.markComponentSuspended(fiber, wakeable, lanes);
              }
            }
          }
          function markLayoutEffectsStarted(lanes) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStarted === "function") {
                injectedProfilingHooks.markLayoutEffectsStarted(lanes);
              }
            }
          }
          function markLayoutEffectsStopped() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStopped === "function") {
                injectedProfilingHooks.markLayoutEffectsStopped();
              }
            }
          }
          function markPassiveEffectsStarted(lanes) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStarted === "function") {
                injectedProfilingHooks.markPassiveEffectsStarted(lanes);
              }
            }
          }
          function markPassiveEffectsStopped() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStopped === "function") {
                injectedProfilingHooks.markPassiveEffectsStopped();
              }
            }
          }
          function markRenderStarted(lanes) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStarted === "function") {
                injectedProfilingHooks.markRenderStarted(lanes);
              }
            }
          }
          function markRenderYielded() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderYielded === "function") {
                injectedProfilingHooks.markRenderYielded();
              }
            }
          }
          function markRenderStopped() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStopped === "function") {
                injectedProfilingHooks.markRenderStopped();
              }
            }
          }
          function markRenderScheduled(lane) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderScheduled === "function") {
                injectedProfilingHooks.markRenderScheduled(lane);
              }
            }
          }
          function markForceUpdateScheduled(fiber, lane) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markForceUpdateScheduled === "function") {
                injectedProfilingHooks.markForceUpdateScheduled(fiber, lane);
              }
            }
          }
          function markStateUpdateScheduled(fiber, lane) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markStateUpdateScheduled === "function") {
                injectedProfilingHooks.markStateUpdateScheduled(fiber, lane);
              }
            }
          }
          var NoMode = (
            /*                         */
            0
          );
          var ConcurrentMode = (
            /*                 */
            1
          );
          var ProfileMode = (
            /*                    */
            2
          );
          var StrictLegacyMode = (
            /*               */
            8
          );
          var StrictEffectsMode = (
            /*              */
            16
          );
          var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback;
          var log = Math.log;
          var LN2 = Math.LN2;
          function clz32Fallback(x) {
            var asUint = x >>> 0;
            if (asUint === 0) {
              return 32;
            }
            return 31 - (log(asUint) / LN2 | 0) | 0;
          }
          var TotalLanes = 31;
          var NoLanes = (
            /*                        */
            0
          );
          var NoLane = (
            /*                          */
            0
          );
          var SyncLane = (
            /*                        */
            1
          );
          var InputContinuousHydrationLane = (
            /*    */
            2
          );
          var InputContinuousLane = (
            /*             */
            4
          );
          var DefaultHydrationLane = (
            /*            */
            8
          );
          var DefaultLane = (
            /*                     */
            16
          );
          var TransitionHydrationLane = (
            /*                */
            32
          );
          var TransitionLanes = (
            /*                       */
            4194240
          );
          var TransitionLane1 = (
            /*                        */
            64
          );
          var TransitionLane2 = (
            /*                        */
            128
          );
          var TransitionLane3 = (
            /*                        */
            256
          );
          var TransitionLane4 = (
            /*                        */
            512
          );
          var TransitionLane5 = (
            /*                        */
            1024
          );
          var TransitionLane6 = (
            /*                        */
            2048
          );
          var TransitionLane7 = (
            /*                        */
            4096
          );
          var TransitionLane8 = (
            /*                        */
            8192
          );
          var TransitionLane9 = (
            /*                        */
            16384
          );
          var TransitionLane10 = (
            /*                       */
            32768
          );
          var TransitionLane11 = (
            /*                       */
            65536
          );
          var TransitionLane12 = (
            /*                       */
            131072
          );
          var TransitionLane13 = (
            /*                       */
            262144
          );
          var TransitionLane14 = (
            /*                       */
            524288
          );
          var TransitionLane15 = (
            /*                       */
            1048576
          );
          var TransitionLane16 = (
            /*                       */
            2097152
          );
          var RetryLanes = (
            /*                            */
            130023424
          );
          var RetryLane1 = (
            /*                             */
            4194304
          );
          var RetryLane2 = (
            /*                             */
            8388608
          );
          var RetryLane3 = (
            /*                             */
            16777216
          );
          var RetryLane4 = (
            /*                             */
            33554432
          );
          var RetryLane5 = (
            /*                             */
            67108864
          );
          var SomeRetryLane = RetryLane1;
          var SelectiveHydrationLane = (
            /*          */
            134217728
          );
          var NonIdleLanes = (
            /*                          */
            268435455
          );
          var IdleHydrationLane = (
            /*               */
            268435456
          );
          var IdleLane = (
            /*                        */
            536870912
          );
          var OffscreenLane = (
            /*                   */
            1073741824
          );
          function getLabelForLane(lane) {
            {
              if (lane & SyncLane) {
                return "Sync";
              }
              if (lane & InputContinuousHydrationLane) {
                return "InputContinuousHydration";
              }
              if (lane & InputContinuousLane) {
                return "InputContinuous";
              }
              if (lane & DefaultHydrationLane) {
                return "DefaultHydration";
              }
              if (lane & DefaultLane) {
                return "Default";
              }
              if (lane & TransitionHydrationLane) {
                return "TransitionHydration";
              }
              if (lane & TransitionLanes) {
                return "Transition";
              }
              if (lane & RetryLanes) {
                return "Retry";
              }
              if (lane & SelectiveHydrationLane) {
                return "SelectiveHydration";
              }
              if (lane & IdleHydrationLane) {
                return "IdleHydration";
              }
              if (lane & IdleLane) {
                return "Idle";
              }
              if (lane & OffscreenLane) {
                return "Offscreen";
              }
            }
          }
          var NoTimestamp = -1;
          var nextTransitionLane = TransitionLane1;
          var nextRetryLane = RetryLane1;
          function getHighestPriorityLanes(lanes) {
            switch (getHighestPriorityLane(lanes)) {
              case SyncLane:
                return SyncLane;
              case InputContinuousHydrationLane:
                return InputContinuousHydrationLane;
              case InputContinuousLane:
                return InputContinuousLane;
              case DefaultHydrationLane:
                return DefaultHydrationLane;
              case DefaultLane:
                return DefaultLane;
              case TransitionHydrationLane:
                return TransitionHydrationLane;
              case TransitionLane1:
              case TransitionLane2:
              case TransitionLane3:
              case TransitionLane4:
              case TransitionLane5:
              case TransitionLane6:
              case TransitionLane7:
              case TransitionLane8:
              case TransitionLane9:
              case TransitionLane10:
              case TransitionLane11:
              case TransitionLane12:
              case TransitionLane13:
              case TransitionLane14:
              case TransitionLane15:
              case TransitionLane16:
                return lanes & TransitionLanes;
              case RetryLane1:
              case RetryLane2:
              case RetryLane3:
              case RetryLane4:
              case RetryLane5:
                return lanes & RetryLanes;
              case SelectiveHydrationLane:
                return SelectiveHydrationLane;
              case IdleHydrationLane:
                return IdleHydrationLane;
              case IdleLane:
                return IdleLane;
              case OffscreenLane:
                return OffscreenLane;
              default:
                {
                  error("Should have found matching lanes. This is a bug in React.");
                }
                return lanes;
            }
          }
          function getNextLanes(root3, wipLanes) {
            var pendingLanes = root3.pendingLanes;
            if (pendingLanes === NoLanes) {
              return NoLanes;
            }
            var nextLanes = NoLanes;
            var suspendedLanes = root3.suspendedLanes;
            var pingedLanes = root3.pingedLanes;
            var nonIdlePendingLanes = pendingLanes & NonIdleLanes;
            if (nonIdlePendingLanes !== NoLanes) {
              var nonIdleUnblockedLanes = nonIdlePendingLanes & ~suspendedLanes;
              if (nonIdleUnblockedLanes !== NoLanes) {
                nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes);
              } else {
                var nonIdlePingedLanes = nonIdlePendingLanes & pingedLanes;
                if (nonIdlePingedLanes !== NoLanes) {
                  nextLanes = getHighestPriorityLanes(nonIdlePingedLanes);
                }
              }
            } else {
              var unblockedLanes = pendingLanes & ~suspendedLanes;
              if (unblockedLanes !== NoLanes) {
                nextLanes = getHighestPriorityLanes(unblockedLanes);
              } else {
                if (pingedLanes !== NoLanes) {
                  nextLanes = getHighestPriorityLanes(pingedLanes);
                }
              }
            }
            if (nextLanes === NoLanes) {
              return NoLanes;
            }
            if (wipLanes !== NoLanes && wipLanes !== nextLanes && // If we already suspended with a delay, then interrupting is fine. Don't
            // bother waiting until the root is complete.
            (wipLanes & suspendedLanes) === NoLanes) {
              var nextLane = getHighestPriorityLane(nextLanes);
              var wipLane = getHighestPriorityLane(wipLanes);
              if (
                // Tests whether the next lane is equal or lower priority than the wip
                // one. This works because the bits decrease in priority as you go left.
                nextLane >= wipLane || // Default priority updates should not interrupt transition updates. The
                // only difference between default updates and transition updates is that
                // default updates do not support refresh transitions.
                nextLane === DefaultLane && (wipLane & TransitionLanes) !== NoLanes
              ) {
                return wipLanes;
              }
            }
            if ((nextLanes & InputContinuousLane) !== NoLanes) {
              nextLanes |= pendingLanes & DefaultLane;
            }
            var entangledLanes = root3.entangledLanes;
            if (entangledLanes !== NoLanes) {
              var entanglements = root3.entanglements;
              var lanes = nextLanes & entangledLanes;
              while (lanes > 0) {
                var index2 = pickArbitraryLaneIndex(lanes);
                var lane = 1 << index2;
                nextLanes |= entanglements[index2];
                lanes &= ~lane;
              }
            }
            return nextLanes;
          }
          function getMostRecentEventTime(root3, lanes) {
            var eventTimes = root3.eventTimes;
            var mostRecentEventTime = NoTimestamp;
            while (lanes > 0) {
              var index2 = pickArbitraryLaneIndex(lanes);
              var lane = 1 << index2;
              var eventTime = eventTimes[index2];
              if (eventTime > mostRecentEventTime) {
                mostRecentEventTime = eventTime;
              }
              lanes &= ~lane;
            }
            return mostRecentEventTime;
          }
          function computeExpirationTime(lane, currentTime) {
            switch (lane) {
              case SyncLane:
              case InputContinuousHydrationLane:
              case InputContinuousLane:
                return currentTime + 250;
              case DefaultHydrationLane:
              case DefaultLane:
              case TransitionHydrationLane:
              case TransitionLane1:
              case TransitionLane2:
              case TransitionLane3:
              case TransitionLane4:
              case TransitionLane5:
              case TransitionLane6:
              case TransitionLane7:
              case TransitionLane8:
              case TransitionLane9:
              case TransitionLane10:
              case TransitionLane11:
              case TransitionLane12:
              case TransitionLane13:
              case TransitionLane14:
              case TransitionLane15:
              case TransitionLane16:
                return currentTime + 5e3;
              case RetryLane1:
              case RetryLane2:
              case RetryLane3:
              case RetryLane4:
              case RetryLane5:
                return NoTimestamp;
              case SelectiveHydrationLane:
              case IdleHydrationLane:
              case IdleLane:
              case OffscreenLane:
                return NoTimestamp;
              default:
                {
                  error("Should have found matching lanes. This is a bug in React.");
                }
                return NoTimestamp;
            }
          }
          function markStarvedLanesAsExpired(root3, currentTime) {
            var pendingLanes = root3.pendingLanes;
            var suspendedLanes = root3.suspendedLanes;
            var pingedLanes = root3.pingedLanes;
            var expirationTimes = root3.expirationTimes;
            var lanes = pendingLanes;
            while (lanes > 0) {
              var index2 = pickArbitraryLaneIndex(lanes);
              var lane = 1 << index2;
              var expirationTime = expirationTimes[index2];
              if (expirationTime === NoTimestamp) {
                if ((lane & suspendedLanes) === NoLanes || (lane & pingedLanes) !== NoLanes) {
                  expirationTimes[index2] = computeExpirationTime(lane, currentTime);
                }
              } else if (expirationTime <= currentTime) {
                root3.expiredLanes |= lane;
              }
              lanes &= ~lane;
            }
          }
          function getHighestPriorityPendingLanes(root3) {
            return getHighestPriorityLanes(root3.pendingLanes);
          }
          function getLanesToRetrySynchronouslyOnError(root3) {
            var everythingButOffscreen = root3.pendingLanes & ~OffscreenLane;
            if (everythingButOffscreen !== NoLanes) {
              return everythingButOffscreen;
            }
            if (everythingButOffscreen & OffscreenLane) {
              return OffscreenLane;
            }
            return NoLanes;
          }
          function includesSyncLane(lanes) {
            return (lanes & SyncLane) !== NoLanes;
          }
          function includesNonIdleWork(lanes) {
            return (lanes & NonIdleLanes) !== NoLanes;
          }
          function includesOnlyRetries(lanes) {
            return (lanes & RetryLanes) === lanes;
          }
          function includesOnlyNonUrgentLanes(lanes) {
            var UrgentLanes = SyncLane | InputContinuousLane | DefaultLane;
            return (lanes & UrgentLanes) === NoLanes;
          }
          function includesOnlyTransitions(lanes) {
            return (lanes & TransitionLanes) === lanes;
          }
          function includesBlockingLane(root3, lanes) {
            var SyncDefaultLanes = InputContinuousHydrationLane | InputContinuousLane | DefaultHydrationLane | DefaultLane;
            return (lanes & SyncDefaultLanes) !== NoLanes;
          }
          function includesExpiredLane(root3, lanes) {
            return (lanes & root3.expiredLanes) !== NoLanes;
          }
          function isTransitionLane(lane) {
            return (lane & TransitionLanes) !== NoLanes;
          }
          function claimNextTransitionLane() {
            var lane = nextTransitionLane;
            nextTransitionLane <<= 1;
            if ((nextTransitionLane & TransitionLanes) === NoLanes) {
              nextTransitionLane = TransitionLane1;
            }
            return lane;
          }
          function claimNextRetryLane() {
            var lane = nextRetryLane;
            nextRetryLane <<= 1;
            if ((nextRetryLane & RetryLanes) === NoLanes) {
              nextRetryLane = RetryLane1;
            }
            return lane;
          }
          function getHighestPriorityLane(lanes) {
            return lanes & -lanes;
          }
          function pickArbitraryLane(lanes) {
            return getHighestPriorityLane(lanes);
          }
          function pickArbitraryLaneIndex(lanes) {
            return 31 - clz32(lanes);
          }
          function laneToIndex(lane) {
            return pickArbitraryLaneIndex(lane);
          }
          function includesSomeLane(a, b) {
            return (a & b) !== NoLanes;
          }
          function isSubsetOfLanes(set2, subset) {
            return (set2 & subset) === subset;
          }
          function mergeLanes(a, b) {
            return a | b;
          }
          function removeLanes(set2, subset) {
            return set2 & ~subset;
          }
          function intersectLanes(a, b) {
            return a & b;
          }
          function laneToLanes(lane) {
            return lane;
          }
          function higherPriorityLane(a, b) {
            return a !== NoLane && a < b ? a : b;
          }
          function createLaneMap(initial) {
            var laneMap = [];
            for (var i = 0; i < TotalLanes; i++) {
              laneMap.push(initial);
            }
            return laneMap;
          }
          function markRootUpdated(root3, updateLane, eventTime) {
            root3.pendingLanes |= updateLane;
            if (updateLane !== IdleLane) {
              root3.suspendedLanes = NoLanes;
              root3.pingedLanes = NoLanes;
            }
            var eventTimes = root3.eventTimes;
            var index2 = laneToIndex(updateLane);
            eventTimes[index2] = eventTime;
          }
          function markRootSuspended(root3, suspendedLanes) {
            root3.suspendedLanes |= suspendedLanes;
            root3.pingedLanes &= ~suspendedLanes;
            var expirationTimes = root3.expirationTimes;
            var lanes = suspendedLanes;
            while (lanes > 0) {
              var index2 = pickArbitraryLaneIndex(lanes);
              var lane = 1 << index2;
              expirationTimes[index2] = NoTimestamp;
              lanes &= ~lane;
            }
          }
          function markRootPinged(root3, pingedLanes, eventTime) {
            root3.pingedLanes |= root3.suspendedLanes & pingedLanes;
          }
          function markRootFinished(root3, remainingLanes) {
            var noLongerPendingLanes = root3.pendingLanes & ~remainingLanes;
            root3.pendingLanes = remainingLanes;
            root3.suspendedLanes = NoLanes;
            root3.pingedLanes = NoLanes;
            root3.expiredLanes &= remainingLanes;
            root3.mutableReadLanes &= remainingLanes;
            root3.entangledLanes &= remainingLanes;
            var entanglements = root3.entanglements;
            var eventTimes = root3.eventTimes;
            var expirationTimes = root3.expirationTimes;
            var lanes = noLongerPendingLanes;
            while (lanes > 0) {
              var index2 = pickArbitraryLaneIndex(lanes);
              var lane = 1 << index2;
              entanglements[index2] = NoLanes;
              eventTimes[index2] = NoTimestamp;
              expirationTimes[index2] = NoTimestamp;
              lanes &= ~lane;
            }
          }
          function markRootEntangled(root3, entangledLanes) {
            var rootEntangledLanes = root3.entangledLanes |= entangledLanes;
            var entanglements = root3.entanglements;
            var lanes = rootEntangledLanes;
            while (lanes) {
              var index2 = pickArbitraryLaneIndex(lanes);
              var lane = 1 << index2;
              if (
                // Is this one of the newly entangled lanes?
                lane & entangledLanes | // Is this lane transitively entangled with the newly entangled lanes?
                entanglements[index2] & entangledLanes
              ) {
                entanglements[index2] |= entangledLanes;
              }
              lanes &= ~lane;
            }
          }
          function getBumpedLaneForHydration(root3, renderLanes2) {
            var renderLane = getHighestPriorityLane(renderLanes2);
            var lane;
            switch (renderLane) {
              case InputContinuousLane:
                lane = InputContinuousHydrationLane;
                break;
              case DefaultLane:
                lane = DefaultHydrationLane;
                break;
              case TransitionLane1:
              case TransitionLane2:
              case TransitionLane3:
              case TransitionLane4:
              case TransitionLane5:
              case TransitionLane6:
              case TransitionLane7:
              case TransitionLane8:
              case TransitionLane9:
              case TransitionLane10:
              case TransitionLane11:
              case TransitionLane12:
              case TransitionLane13:
              case TransitionLane14:
              case TransitionLane15:
              case TransitionLane16:
              case RetryLane1:
              case RetryLane2:
              case RetryLane3:
              case RetryLane4:
              case RetryLane5:
                lane = TransitionHydrationLane;
                break;
              case IdleLane:
                lane = IdleHydrationLane;
                break;
              default:
                lane = NoLane;
                break;
            }
            if ((lane & (root3.suspendedLanes | renderLanes2)) !== NoLane) {
              return NoLane;
            }
            return lane;
          }
          function addFiberToLanesMap(root3, fiber, lanes) {
            if (!isDevToolsPresent) {
              return;
            }
            var pendingUpdatersLaneMap = root3.pendingUpdatersLaneMap;
            while (lanes > 0) {
              var index2 = laneToIndex(lanes);
              var lane = 1 << index2;
              var updaters = pendingUpdatersLaneMap[index2];
              updaters.add(fiber);
              lanes &= ~lane;
            }
          }
          function movePendingFibersToMemoized(root3, lanes) {
            if (!isDevToolsPresent) {
              return;
            }
            var pendingUpdatersLaneMap = root3.pendingUpdatersLaneMap;
            var memoizedUpdaters = root3.memoizedUpdaters;
            while (lanes > 0) {
              var index2 = laneToIndex(lanes);
              var lane = 1 << index2;
              var updaters = pendingUpdatersLaneMap[index2];
              if (updaters.size > 0) {
                updaters.forEach(function(fiber) {
                  var alternate = fiber.alternate;
                  if (alternate === null || !memoizedUpdaters.has(alternate)) {
                    memoizedUpdaters.add(fiber);
                  }
                });
                updaters.clear();
              }
              lanes &= ~lane;
            }
          }
          function getTransitionsForLanes(root3, lanes) {
            {
              return null;
            }
          }
          var DiscreteEventPriority = SyncLane;
          var ContinuousEventPriority = InputContinuousLane;
          var DefaultEventPriority = DefaultLane;
          var IdleEventPriority = IdleLane;
          var currentUpdatePriority = NoLane;
          function getCurrentUpdatePriority() {
            return currentUpdatePriority;
          }
          function setCurrentUpdatePriority(newPriority) {
            currentUpdatePriority = newPriority;
          }
          function runWithPriority(priority, fn) {
            var previousPriority = currentUpdatePriority;
            try {
              currentUpdatePriority = priority;
              return fn();
            } finally {
              currentUpdatePriority = previousPriority;
            }
          }
          function higherEventPriority(a, b) {
            return a !== 0 && a < b ? a : b;
          }
          function lowerEventPriority(a, b) {
            return a === 0 || a > b ? a : b;
          }
          function isHigherEventPriority(a, b) {
            return a !== 0 && a < b;
          }
          function lanesToEventPriority(lanes) {
            var lane = getHighestPriorityLane(lanes);
            if (!isHigherEventPriority(DiscreteEventPriority, lane)) {
              return DiscreteEventPriority;
            }
            if (!isHigherEventPriority(ContinuousEventPriority, lane)) {
              return ContinuousEventPriority;
            }
            if (includesNonIdleWork(lane)) {
              return DefaultEventPriority;
            }
            return IdleEventPriority;
          }
          function isRootDehydrated(root3) {
            var currentState = root3.current.memoizedState;
            return currentState.isDehydrated;
          }
          var _attemptSynchronousHydration;
          function setAttemptSynchronousHydration(fn) {
            _attemptSynchronousHydration = fn;
          }
          function attemptSynchronousHydration(fiber) {
            _attemptSynchronousHydration(fiber);
          }
          var attemptContinuousHydration;
          function setAttemptContinuousHydration(fn) {
            attemptContinuousHydration = fn;
          }
          var attemptHydrationAtCurrentPriority;
          function setAttemptHydrationAtCurrentPriority(fn) {
            attemptHydrationAtCurrentPriority = fn;
          }
          var getCurrentUpdatePriority$1;
          function setGetCurrentUpdatePriority(fn) {
            getCurrentUpdatePriority$1 = fn;
          }
          var attemptHydrationAtPriority;
          function setAttemptHydrationAtPriority(fn) {
            attemptHydrationAtPriority = fn;
          }
          var hasScheduledReplayAttempt = false;
          var queuedDiscreteEvents = [];
          var queuedFocus = null;
          var queuedDrag = null;
          var queuedMouse = null;
          var queuedPointers = /* @__PURE__ */ new Map();
          var queuedPointerCaptures = /* @__PURE__ */ new Map();
          var queuedExplicitHydrationTargets = [];
          var discreteReplayableEvents = [
            "mousedown",
            "mouseup",
            "touchcancel",
            "touchend",
            "touchstart",
            "auxclick",
            "dblclick",
            "pointercancel",
            "pointerdown",
            "pointerup",
            "dragend",
            "dragstart",
            "drop",
            "compositionend",
            "compositionstart",
            "keydown",
            "keypress",
            "keyup",
            "input",
            "textInput",
            // Intentionally camelCase
            "copy",
            "cut",
            "paste",
            "click",
            "change",
            "contextmenu",
            "reset",
            "submit"
          ];
          function isDiscreteEventThatRequiresHydration(eventType) {
            return discreteReplayableEvents.indexOf(eventType) > -1;
          }
          function createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
            return {
              blockedOn,
              domEventName,
              eventSystemFlags,
              nativeEvent,
              targetContainers: [targetContainer]
            };
          }
          function clearIfContinuousEvent(domEventName, nativeEvent) {
            switch (domEventName) {
              case "focusin":
              case "focusout":
                queuedFocus = null;
                break;
              case "dragenter":
              case "dragleave":
                queuedDrag = null;
                break;
              case "mouseover":
              case "mouseout":
                queuedMouse = null;
                break;
              case "pointerover":
              case "pointerout": {
                var pointerId = nativeEvent.pointerId;
                queuedPointers.delete(pointerId);
                break;
              }
              case "gotpointercapture":
              case "lostpointercapture": {
                var _pointerId = nativeEvent.pointerId;
                queuedPointerCaptures.delete(_pointerId);
                break;
              }
            }
          }
          function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
            if (existingQueuedEvent === null || existingQueuedEvent.nativeEvent !== nativeEvent) {
              var queuedEvent = createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent);
              if (blockedOn !== null) {
                var _fiber2 = getInstanceFromNode(blockedOn);
                if (_fiber2 !== null) {
                  attemptContinuousHydration(_fiber2);
                }
              }
              return queuedEvent;
            }
            existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
            var targetContainers = existingQueuedEvent.targetContainers;
            if (targetContainer !== null && targetContainers.indexOf(targetContainer) === -1) {
              targetContainers.push(targetContainer);
            }
            return existingQueuedEvent;
          }
          function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
            switch (domEventName) {
              case "focusin": {
                var focusEvent = nativeEvent;
                queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(queuedFocus, blockedOn, domEventName, eventSystemFlags, targetContainer, focusEvent);
                return true;
              }
              case "dragenter": {
                var dragEvent = nativeEvent;
                queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(queuedDrag, blockedOn, domEventName, eventSystemFlags, targetContainer, dragEvent);
                return true;
              }
              case "mouseover": {
                var mouseEvent = nativeEvent;
                queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(queuedMouse, blockedOn, domEventName, eventSystemFlags, targetContainer, mouseEvent);
                return true;
              }
              case "pointerover": {
                var pointerEvent = nativeEvent;
                var pointerId = pointerEvent.pointerId;
                queuedPointers.set(pointerId, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointers.get(pointerId) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, pointerEvent));
                return true;
              }
              case "gotpointercapture": {
                var _pointerEvent = nativeEvent;
                var _pointerId2 = _pointerEvent.pointerId;
                queuedPointerCaptures.set(_pointerId2, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointerCaptures.get(_pointerId2) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, _pointerEvent));
                return true;
              }
            }
            return false;
          }
          function attemptExplicitHydrationTarget(queuedTarget) {
            var targetInst = getClosestInstanceFromNode(queuedTarget.target);
            if (targetInst !== null) {
              var nearestMounted = getNearestMountedFiber(targetInst);
              if (nearestMounted !== null) {
                var tag = nearestMounted.tag;
                if (tag === SuspenseComponent) {
                  var instance = getSuspenseInstanceFromFiber(nearestMounted);
                  if (instance !== null) {
                    queuedTarget.blockedOn = instance;
                    attemptHydrationAtPriority(queuedTarget.priority, function() {
                      attemptHydrationAtCurrentPriority(nearestMounted);
                    });
                    return;
                  }
                } else if (tag === HostRoot) {
                  var root3 = nearestMounted.stateNode;
                  if (isRootDehydrated(root3)) {
                    queuedTarget.blockedOn = getContainerFromFiber(nearestMounted);
                    return;
                  }
                }
              }
            }
            queuedTarget.blockedOn = null;
          }
          function queueExplicitHydrationTarget(target) {
            var updatePriority = getCurrentUpdatePriority$1();
            var queuedTarget = {
              blockedOn: null,
              target,
              priority: updatePriority
            };
            var i = 0;
            for (; i < queuedExplicitHydrationTargets.length; i++) {
              if (!isHigherEventPriority(updatePriority, queuedExplicitHydrationTargets[i].priority)) {
                break;
              }
            }
            queuedExplicitHydrationTargets.splice(i, 0, queuedTarget);
            if (i === 0) {
              attemptExplicitHydrationTarget(queuedTarget);
            }
          }
          function attemptReplayContinuousQueuedEvent(queuedEvent) {
            if (queuedEvent.blockedOn !== null) {
              return false;
            }
            var targetContainers = queuedEvent.targetContainers;
            while (targetContainers.length > 0) {
              var targetContainer = targetContainers[0];
              var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.domEventName, queuedEvent.eventSystemFlags, targetContainer, queuedEvent.nativeEvent);
              if (nextBlockedOn === null) {
                {
                  var nativeEvent = queuedEvent.nativeEvent;
                  var nativeEventClone = new nativeEvent.constructor(nativeEvent.type, nativeEvent);
                  setReplayingEvent(nativeEventClone);
                  nativeEvent.target.dispatchEvent(nativeEventClone);
                  resetReplayingEvent();
                }
              } else {
                var _fiber3 = getInstanceFromNode(nextBlockedOn);
                if (_fiber3 !== null) {
                  attemptContinuousHydration(_fiber3);
                }
                queuedEvent.blockedOn = nextBlockedOn;
                return false;
              }
              targetContainers.shift();
            }
            return true;
          }
          function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {
            if (attemptReplayContinuousQueuedEvent(queuedEvent)) {
              map.delete(key);
            }
          }
          function replayUnblockedEvents() {
            hasScheduledReplayAttempt = false;
            if (queuedFocus !== null && attemptReplayContinuousQueuedEvent(queuedFocus)) {
              queuedFocus = null;
            }
            if (queuedDrag !== null && attemptReplayContinuousQueuedEvent(queuedDrag)) {
              queuedDrag = null;
            }
            if (queuedMouse !== null && attemptReplayContinuousQueuedEvent(queuedMouse)) {
              queuedMouse = null;
            }
            queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
            queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
          }
          function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
            if (queuedEvent.blockedOn === unblocked) {
              queuedEvent.blockedOn = null;
              if (!hasScheduledReplayAttempt) {
                hasScheduledReplayAttempt = true;
                Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority, replayUnblockedEvents);
              }
            }
          }
          function retryIfBlockedOn(unblocked) {
            if (queuedDiscreteEvents.length > 0) {
              scheduleCallbackIfUnblocked(queuedDiscreteEvents[0], unblocked);
              for (var i = 1; i < queuedDiscreteEvents.length; i++) {
                var queuedEvent = queuedDiscreteEvents[i];
                if (queuedEvent.blockedOn === unblocked) {
                  queuedEvent.blockedOn = null;
                }
              }
            }
            if (queuedFocus !== null) {
              scheduleCallbackIfUnblocked(queuedFocus, unblocked);
            }
            if (queuedDrag !== null) {
              scheduleCallbackIfUnblocked(queuedDrag, unblocked);
            }
            if (queuedMouse !== null) {
              scheduleCallbackIfUnblocked(queuedMouse, unblocked);
            }
            var unblock = function(queuedEvent2) {
              return scheduleCallbackIfUnblocked(queuedEvent2, unblocked);
            };
            queuedPointers.forEach(unblock);
            queuedPointerCaptures.forEach(unblock);
            for (var _i2 = 0; _i2 < queuedExplicitHydrationTargets.length; _i2++) {
              var queuedTarget = queuedExplicitHydrationTargets[_i2];
              if (queuedTarget.blockedOn === unblocked) {
                queuedTarget.blockedOn = null;
              }
            }
            while (queuedExplicitHydrationTargets.length > 0) {
              var nextExplicitTarget = queuedExplicitHydrationTargets[0];
              if (nextExplicitTarget.blockedOn !== null) {
                break;
              } else {
                attemptExplicitHydrationTarget(nextExplicitTarget);
                if (nextExplicitTarget.blockedOn === null) {
                  queuedExplicitHydrationTargets.shift();
                }
              }
            }
          }
          var ReactCurrentBatchConfig = ReactSharedInternals.ReactCurrentBatchConfig;
          var _enabled2 = true;
          function setEnabled(enabled) {
            _enabled2 = !!enabled;
          }
          function isEnabled() {
            return _enabled2;
          }
          function createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags) {
            var eventPriority = getEventPriority(domEventName);
            var listenerWrapper;
            switch (eventPriority) {
              case DiscreteEventPriority:
                listenerWrapper = dispatchDiscreteEvent;
                break;
              case ContinuousEventPriority:
                listenerWrapper = dispatchContinuousEvent;
                break;
              case DefaultEventPriority:
              default:
                listenerWrapper = dispatchEvent;
                break;
            }
            return listenerWrapper.bind(null, domEventName, eventSystemFlags, targetContainer);
          }
          function dispatchDiscreteEvent(domEventName, eventSystemFlags, container2, nativeEvent) {
            var previousPriority = getCurrentUpdatePriority();
            var prevTransition = ReactCurrentBatchConfig.transition;
            ReactCurrentBatchConfig.transition = null;
            try {
              setCurrentUpdatePriority(DiscreteEventPriority);
              dispatchEvent(domEventName, eventSystemFlags, container2, nativeEvent);
            } finally {
              setCurrentUpdatePriority(previousPriority);
              ReactCurrentBatchConfig.transition = prevTransition;
            }
          }
          function dispatchContinuousEvent(domEventName, eventSystemFlags, container2, nativeEvent) {
            var previousPriority = getCurrentUpdatePriority();
            var prevTransition = ReactCurrentBatchConfig.transition;
            ReactCurrentBatchConfig.transition = null;
            try {
              setCurrentUpdatePriority(ContinuousEventPriority);
              dispatchEvent(domEventName, eventSystemFlags, container2, nativeEvent);
            } finally {
              setCurrentUpdatePriority(previousPriority);
              ReactCurrentBatchConfig.transition = prevTransition;
            }
          }
          function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
            if (!_enabled2) {
              return;
            }
            {
              dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(domEventName, eventSystemFlags, targetContainer, nativeEvent);
            }
          }
          function dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
            var blockedOn = findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent);
            if (blockedOn === null) {
              dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer);
              clearIfContinuousEvent(domEventName, nativeEvent);
              return;
            }
            if (queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent)) {
              nativeEvent.stopPropagation();
              return;
            }
            clearIfContinuousEvent(domEventName, nativeEvent);
            if (eventSystemFlags & IS_CAPTURE_PHASE && isDiscreteEventThatRequiresHydration(domEventName)) {
              while (blockedOn !== null) {
                var fiber = getInstanceFromNode(blockedOn);
                if (fiber !== null) {
                  attemptSynchronousHydration(fiber);
                }
                var nextBlockedOn = findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent);
                if (nextBlockedOn === null) {
                  dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer);
                }
                if (nextBlockedOn === blockedOn) {
                  break;
                }
                blockedOn = nextBlockedOn;
              }
              if (blockedOn !== null) {
                nativeEvent.stopPropagation();
              }
              return;
            }
            dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, null, targetContainer);
          }
          var return_targetInst = null;
          function findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
            return_targetInst = null;
            var nativeEventTarget = getEventTarget2(nativeEvent);
            var targetInst = getClosestInstanceFromNode(nativeEventTarget);
            if (targetInst !== null) {
              var nearestMounted = getNearestMountedFiber(targetInst);
              if (nearestMounted === null) {
                targetInst = null;
              } else {
                var tag = nearestMounted.tag;
                if (tag === SuspenseComponent) {
                  var instance = getSuspenseInstanceFromFiber(nearestMounted);
                  if (instance !== null) {
                    return instance;
                  }
                  targetInst = null;
                } else if (tag === HostRoot) {
                  var root3 = nearestMounted.stateNode;
                  if (isRootDehydrated(root3)) {
                    return getContainerFromFiber(nearestMounted);
                  }
                  targetInst = null;
                } else if (nearestMounted !== targetInst) {
                  targetInst = null;
                }
              }
            }
            return_targetInst = targetInst;
            return null;
          }
          function getEventPriority(domEventName) {
            switch (domEventName) {
              // Used by SimpleEventPlugin:
              case "cancel":
              case "click":
              case "close":
              case "contextmenu":
              case "copy":
              case "cut":
              case "auxclick":
              case "dblclick":
              case "dragend":
              case "dragstart":
              case "drop":
              case "focusin":
              case "focusout":
              case "input":
              case "invalid":
              case "keydown":
              case "keypress":
              case "keyup":
              case "mousedown":
              case "mouseup":
              case "paste":
              case "pause":
              case "play":
              case "pointercancel":
              case "pointerdown":
              case "pointerup":
              case "ratechange":
              case "reset":
              case "resize":
              case "seeked":
              case "submit":
              case "touchcancel":
              case "touchend":
              case "touchstart":
              case "volumechange":
              // Used by polyfills:
              // eslint-disable-next-line no-fallthrough
              case "change":
              case "selectionchange":
              case "textInput":
              case "compositionstart":
              case "compositionend":
              case "compositionupdate":
              // Only enableCreateEventHandleAPI:
              // eslint-disable-next-line no-fallthrough
              case "beforeblur":
              case "afterblur":
              // Not used by React but could be by user code:
              // eslint-disable-next-line no-fallthrough
              case "beforeinput":
              case "blur":
              case "fullscreenchange":
              case "focus":
              case "hashchange":
              case "popstate":
              case "select":
              case "selectstart":
                return DiscreteEventPriority;
              case "drag":
              case "dragenter":
              case "dragexit":
              case "dragleave":
              case "dragover":
              case "mousemove":
              case "mouseout":
              case "mouseover":
              case "pointermove":
              case "pointerout":
              case "pointerover":
              case "scroll":
              case "toggle":
              case "touchmove":
              case "wheel":
              // Not used by React but could be by user code:
              // eslint-disable-next-line no-fallthrough
              case "mouseenter":
              case "mouseleave":
              case "pointerenter":
              case "pointerleave":
                return ContinuousEventPriority;
              case "message": {
                var schedulerPriority = getCurrentPriorityLevel();
                switch (schedulerPriority) {
                  case ImmediatePriority:
                    return DiscreteEventPriority;
                  case UserBlockingPriority:
                    return ContinuousEventPriority;
                  case NormalPriority:
                  case LowPriority:
                    return DefaultEventPriority;
                  case IdlePriority:
                    return IdleEventPriority;
                  default:
                    return DefaultEventPriority;
                }
              }
              default:
                return DefaultEventPriority;
            }
          }
          function addEventBubbleListener(target, eventType, listener) {
            target.addEventListener(eventType, listener, false);
            return listener;
          }
          function addEventCaptureListener(target, eventType, listener) {
            target.addEventListener(eventType, listener, true);
            return listener;
          }
          function addEventCaptureListenerWithPassiveFlag(target, eventType, listener, passive) {
            target.addEventListener(eventType, listener, {
              capture: true,
              passive
            });
            return listener;
          }
          function addEventBubbleListenerWithPassiveFlag(target, eventType, listener, passive) {
            target.addEventListener(eventType, listener, {
              passive
            });
            return listener;
          }
          var root2 = null;
          var startText = null;
          var fallbackText = null;
          function initialize(nativeEventTarget) {
            root2 = nativeEventTarget;
            startText = getText2();
            return true;
          }
          function reset() {
            root2 = null;
            startText = null;
            fallbackText = null;
          }
          function getData() {
            if (fallbackText) {
              return fallbackText;
            }
            var start;
            var startValue = startText;
            var startLength = startValue.length;
            var end;
            var endValue = getText2();
            var endLength = endValue.length;
            for (start = 0; start < startLength; start++) {
              if (startValue[start] !== endValue[start]) {
                break;
              }
            }
            var minEnd = startLength - start;
            for (end = 1; end <= minEnd; end++) {
              if (startValue[startLength - end] !== endValue[endLength - end]) {
                break;
              }
            }
            var sliceTail = end > 1 ? 1 - end : void 0;
            fallbackText = endValue.slice(start, sliceTail);
            return fallbackText;
          }
          function getText2() {
            if ("value" in root2) {
              return root2.value;
            }
            return root2.textContent;
          }
          function getEventCharCode(nativeEvent) {
            var charCode;
            var keyCode = nativeEvent.keyCode;
            if ("charCode" in nativeEvent) {
              charCode = nativeEvent.charCode;
              if (charCode === 0 && keyCode === 13) {
                charCode = 13;
              }
            } else {
              charCode = keyCode;
            }
            if (charCode === 10) {
              charCode = 13;
            }
            if (charCode >= 32 || charCode === 13) {
              return charCode;
            }
            return 0;
          }
          function functionThatReturnsTrue() {
            return true;
          }
          function functionThatReturnsFalse() {
            return false;
          }
          function createSyntheticEvent(Interface) {
            function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
              this._reactName = reactName;
              this._targetInst = targetInst;
              this.type = reactEventType;
              this.nativeEvent = nativeEvent;
              this.target = nativeEventTarget;
              this.currentTarget = null;
              for (var _propName in Interface) {
                if (!Interface.hasOwnProperty(_propName)) {
                  continue;
                }
                var normalize3 = Interface[_propName];
                if (normalize3) {
                  this[_propName] = normalize3(nativeEvent);
                } else {
                  this[_propName] = nativeEvent[_propName];
                }
              }
              var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
              if (defaultPrevented) {
                this.isDefaultPrevented = functionThatReturnsTrue;
              } else {
                this.isDefaultPrevented = functionThatReturnsFalse;
              }
              this.isPropagationStopped = functionThatReturnsFalse;
              return this;
            }
            assign(SyntheticBaseEvent.prototype, {
              preventDefault: function() {
                this.defaultPrevented = true;
                var event = this.nativeEvent;
                if (!event) {
                  return;
                }
                if (event.preventDefault) {
                  event.preventDefault();
                } else if (typeof event.returnValue !== "unknown") {
                  event.returnValue = false;
                }
                this.isDefaultPrevented = functionThatReturnsTrue;
              },
              stopPropagation: function() {
                var event = this.nativeEvent;
                if (!event) {
                  return;
                }
                if (event.stopPropagation) {
                  event.stopPropagation();
                } else if (typeof event.cancelBubble !== "unknown") {
                  event.cancelBubble = true;
                }
                this.isPropagationStopped = functionThatReturnsTrue;
              },
              /**
               * We release all dispatched `SyntheticEvent`s after each event loop, adding
               * them back into the pool. This allows a way to hold onto a reference that
               * won't be added back into the pool.
               */
              persist: function() {
              },
              /**
               * Checks if this event should be released back into the pool.
               *
               * @return {boolean} True if this should not be released, false otherwise.
               */
              isPersistent: functionThatReturnsTrue
            });
            return SyntheticBaseEvent;
          }
          var EventInterface = {
            eventPhase: 0,
            bubbles: 0,
            cancelable: 0,
            timeStamp: function(event) {
              return event.timeStamp || Date.now();
            },
            defaultPrevented: 0,
            isTrusted: 0
          };
          var SyntheticEvent = createSyntheticEvent(EventInterface);
          var UIEventInterface = assign({}, EventInterface, {
            view: 0,
            detail: 0
          });
          var SyntheticUIEvent = createSyntheticEvent(UIEventInterface);
          var lastMovementX;
          var lastMovementY;
          var lastMouseEvent;
          function updateMouseMovementPolyfillState(event) {
            if (event !== lastMouseEvent) {
              if (lastMouseEvent && event.type === "mousemove") {
                lastMovementX = event.screenX - lastMouseEvent.screenX;
                lastMovementY = event.screenY - lastMouseEvent.screenY;
              } else {
                lastMovementX = 0;
                lastMovementY = 0;
              }
              lastMouseEvent = event;
            }
          }
          var MouseEventInterface = assign({}, UIEventInterface, {
            screenX: 0,
            screenY: 0,
            clientX: 0,
            clientY: 0,
            pageX: 0,
            pageY: 0,
            ctrlKey: 0,
            shiftKey: 0,
            altKey: 0,
            metaKey: 0,
            getModifierState: getEventModifierState,
            button: 0,
            buttons: 0,
            relatedTarget: function(event) {
              if (event.relatedTarget === void 0) return event.fromElement === event.srcElement ? event.toElement : event.fromElement;
              return event.relatedTarget;
            },
            movementX: function(event) {
              if ("movementX" in event) {
                return event.movementX;
              }
              updateMouseMovementPolyfillState(event);
              return lastMovementX;
            },
            movementY: function(event) {
              if ("movementY" in event) {
                return event.movementY;
              }
              return lastMovementY;
            }
          });
          var SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface);
          var DragEventInterface = assign({}, MouseEventInterface, {
            dataTransfer: 0
          });
          var SyntheticDragEvent = createSyntheticEvent(DragEventInterface);
          var FocusEventInterface = assign({}, UIEventInterface, {
            relatedTarget: 0
          });
          var SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface);
          var AnimationEventInterface = assign({}, EventInterface, {
            animationName: 0,
            elapsedTime: 0,
            pseudoElement: 0
          });
          var SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface);
          var ClipboardEventInterface = assign({}, EventInterface, {
            clipboardData: function(event) {
              return "clipboardData" in event ? event.clipboardData : window.clipboardData;
            }
          });
          var SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface);
          var CompositionEventInterface = assign({}, EventInterface, {
            data: 0
          });
          var SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface);
          var SyntheticInputEvent = SyntheticCompositionEvent;
          var normalizeKey = {
            Esc: "Escape",
            Spacebar: " ",
            Left: "ArrowLeft",
            Up: "ArrowUp",
            Right: "ArrowRight",
            Down: "ArrowDown",
            Del: "Delete",
            Win: "OS",
            Menu: "ContextMenu",
            Apps: "ContextMenu",
            Scroll: "ScrollLock",
            MozPrintableKey: "Unidentified"
          };
          var translateToKey = {
            "8": "Backspace",
            "9": "Tab",
            "12": "Clear",
            "13": "Enter",
            "16": "Shift",
            "17": "Control",
            "18": "Alt",
            "19": "Pause",
            "20": "CapsLock",
            "27": "Escape",
            "32": " ",
            "33": "PageUp",
            "34": "PageDown",
            "35": "End",
            "36": "Home",
            "37": "ArrowLeft",
            "38": "ArrowUp",
            "39": "ArrowRight",
            "40": "ArrowDown",
            "45": "Insert",
            "46": "Delete",
            "112": "F1",
            "113": "F2",
            "114": "F3",
            "115": "F4",
            "116": "F5",
            "117": "F6",
            "118": "F7",
            "119": "F8",
            "120": "F9",
            "121": "F10",
            "122": "F11",
            "123": "F12",
            "144": "NumLock",
            "145": "ScrollLock",
            "224": "Meta"
          };
          function getEventKey(nativeEvent) {
            if (nativeEvent.key) {
              var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
              if (key !== "Unidentified") {
                return key;
              }
            }
            if (nativeEvent.type === "keypress") {
              var charCode = getEventCharCode(nativeEvent);
              return charCode === 13 ? "Enter" : String.fromCharCode(charCode);
            }
            if (nativeEvent.type === "keydown" || nativeEvent.type === "keyup") {
              return translateToKey[nativeEvent.keyCode] || "Unidentified";
            }
            return "";
          }
          var modifierKeyToProp = {
            Alt: "altKey",
            Control: "ctrlKey",
            Meta: "metaKey",
            Shift: "shiftKey"
          };
          function modifierStateGetter(keyArg) {
            var syntheticEvent = this;
            var nativeEvent = syntheticEvent.nativeEvent;
            if (nativeEvent.getModifierState) {
              return nativeEvent.getModifierState(keyArg);
            }
            var keyProp = modifierKeyToProp[keyArg];
            return keyProp ? !!nativeEvent[keyProp] : false;
          }
          function getEventModifierState(nativeEvent) {
            return modifierStateGetter;
          }
          var KeyboardEventInterface = assign({}, UIEventInterface, {
            key: getEventKey,
            code: 0,
            location: 0,
            ctrlKey: 0,
            shiftKey: 0,
            altKey: 0,
            metaKey: 0,
            repeat: 0,
            locale: 0,
            getModifierState: getEventModifierState,
            // Legacy Interface
            charCode: function(event) {
              if (event.type === "keypress") {
                return getEventCharCode(event);
              }
              return 0;
            },
            keyCode: function(event) {
              if (event.type === "keydown" || event.type === "keyup") {
                return event.keyCode;
              }
              return 0;
            },
            which: function(event) {
              if (event.type === "keypress") {
                return getEventCharCode(event);
              }
              if (event.type === "keydown" || event.type === "keyup") {
                return event.keyCode;
              }
              return 0;
            }
          });
          var SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface);
          var PointerEventInterface = assign({}, MouseEventInterface, {
            pointerId: 0,
            width: 0,
            height: 0,
            pressure: 0,
            tangentialPressure: 0,
            tiltX: 0,
            tiltY: 0,
            twist: 0,
            pointerType: 0,
            isPrimary: 0
          });
          var SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface);
          var TouchEventInterface = assign({}, UIEventInterface, {
            touches: 0,
            targetTouches: 0,
            changedTouches: 0,
            altKey: 0,
            metaKey: 0,
            ctrlKey: 0,
            shiftKey: 0,
            getModifierState: getEventModifierState
          });
          var SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface);
          var TransitionEventInterface = assign({}, EventInterface, {
            propertyName: 0,
            elapsedTime: 0,
            pseudoElement: 0
          });
          var SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface);
          var WheelEventInterface = assign({}, MouseEventInterface, {
            deltaX: function(event) {
              return "deltaX" in event ? event.deltaX : (
                // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
                "wheelDeltaX" in event ? -event.wheelDeltaX : 0
              );
            },
            deltaY: function(event) {
              return "deltaY" in event ? event.deltaY : (
                // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
                "wheelDeltaY" in event ? -event.wheelDeltaY : (
                  // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
                  "wheelDelta" in event ? -event.wheelDelta : 0
                )
              );
            },
            deltaZ: 0,
            // Browsers without "deltaMode" is reporting in raw wheel delta where one
            // notch on the scroll is always +/- 120, roughly equivalent to pixels.
            // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
            // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
            deltaMode: 0
          });
          var SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface);
          var END_KEYCODES = [9, 13, 27, 32];
          var START_KEYCODE = 229;
          var canUseCompositionEvent = canUseDOM && "CompositionEvent" in window;
          var documentMode = null;
          if (canUseDOM && "documentMode" in document) {
            documentMode = document.documentMode;
          }
          var canUseTextInputEvent = canUseDOM && "TextEvent" in window && !documentMode;
          var useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);
          var SPACEBAR_CODE = 32;
          var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);
          function registerEvents() {
            registerTwoPhaseEvent("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
            registerTwoPhaseEvent("onCompositionEnd", ["compositionend", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
            registerTwoPhaseEvent("onCompositionStart", ["compositionstart", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
            registerTwoPhaseEvent("onCompositionUpdate", ["compositionupdate", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
          }
          var hasSpaceKeypress = false;
          function isKeypressCommand(nativeEvent) {
            return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) && // ctrlKey && altKey is equivalent to AltGr, and is not a command.
            !(nativeEvent.ctrlKey && nativeEvent.altKey);
          }
          function getCompositionEventType(domEventName) {
            switch (domEventName) {
              case "compositionstart":
                return "onCompositionStart";
              case "compositionend":
                return "onCompositionEnd";
              case "compositionupdate":
                return "onCompositionUpdate";
            }
          }
          function isFallbackCompositionStart(domEventName, nativeEvent) {
            return domEventName === "keydown" && nativeEvent.keyCode === START_KEYCODE;
          }
          function isFallbackCompositionEnd(domEventName, nativeEvent) {
            switch (domEventName) {
              case "keyup":
                return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
              case "keydown":
                return nativeEvent.keyCode !== START_KEYCODE;
              case "keypress":
              case "mousedown":
              case "focusout":
                return true;
              default:
                return false;
            }
          }
          function getDataFromCustomEvent(nativeEvent) {
            var detail = nativeEvent.detail;
            if (typeof detail === "object" && "data" in detail) {
              return detail.data;
            }
            return null;
          }
          function isUsingKoreanIME(nativeEvent) {
            return nativeEvent.locale === "ko";
          }
          var isComposing = false;
          function extractCompositionEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {
            var eventType;
            var fallbackData;
            if (canUseCompositionEvent) {
              eventType = getCompositionEventType(domEventName);
            } else if (!isComposing) {
              if (isFallbackCompositionStart(domEventName, nativeEvent)) {
                eventType = "onCompositionStart";
              }
            } else if (isFallbackCompositionEnd(domEventName, nativeEvent)) {
              eventType = "onCompositionEnd";
            }
            if (!eventType) {
              return null;
            }
            if (useFallbackCompositionData && !isUsingKoreanIME(nativeEvent)) {
              if (!isComposing && eventType === "onCompositionStart") {
                isComposing = initialize(nativeEventTarget);
              } else if (eventType === "onCompositionEnd") {
                if (isComposing) {
                  fallbackData = getData();
                }
              }
            }
            var listeners = accumulateTwoPhaseListeners(targetInst, eventType);
            if (listeners.length > 0) {
              var event = new SyntheticCompositionEvent(eventType, domEventName, null, nativeEvent, nativeEventTarget);
              dispatchQueue.push({
                event,
                listeners
              });
              if (fallbackData) {
                event.data = fallbackData;
              } else {
                var customData = getDataFromCustomEvent(nativeEvent);
                if (customData !== null) {
                  event.data = customData;
                }
              }
            }
          }
          function getNativeBeforeInputChars(domEventName, nativeEvent) {
            switch (domEventName) {
              case "compositionend":
                return getDataFromCustomEvent(nativeEvent);
              case "keypress":
                var which = nativeEvent.which;
                if (which !== SPACEBAR_CODE) {
                  return null;
                }
                hasSpaceKeypress = true;
                return SPACEBAR_CHAR;
              case "textInput":
                var chars = nativeEvent.data;
                if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
                  return null;
                }
                return chars;
              default:
                return null;
            }
          }
          function getFallbackBeforeInputChars(domEventName, nativeEvent) {
            if (isComposing) {
              if (domEventName === "compositionend" || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent)) {
                var chars = getData();
                reset();
                isComposing = false;
                return chars;
              }
              return null;
            }
            switch (domEventName) {
              case "paste":
                return null;
              case "keypress":
                if (!isKeypressCommand(nativeEvent)) {
                  if (nativeEvent.char && nativeEvent.char.length > 1) {
                    return nativeEvent.char;
                  } else if (nativeEvent.which) {
                    return String.fromCharCode(nativeEvent.which);
                  }
                }
                return null;
              case "compositionend":
                return useFallbackCompositionData && !isUsingKoreanIME(nativeEvent) ? null : nativeEvent.data;
              default:
                return null;
            }
          }
          function extractBeforeInputEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {
            var chars;
            if (canUseTextInputEvent) {
              chars = getNativeBeforeInputChars(domEventName, nativeEvent);
            } else {
              chars = getFallbackBeforeInputChars(domEventName, nativeEvent);
            }
            if (!chars) {
              return null;
            }
            var listeners = accumulateTwoPhaseListeners(targetInst, "onBeforeInput");
            if (listeners.length > 0) {
              var event = new SyntheticInputEvent("onBeforeInput", "beforeinput", null, nativeEvent, nativeEventTarget);
              dispatchQueue.push({
                event,
                listeners
              });
              event.data = chars;
            }
          }
          function extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
            extractCompositionEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
            extractBeforeInputEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
          }
          var supportedInputTypes = {
            color: true,
            date: true,
            datetime: true,
            "datetime-local": true,
            email: true,
            month: true,
            number: true,
            password: true,
            range: true,
            search: true,
            tel: true,
            text: true,
            time: true,
            url: true,
            week: true
          };
          function isTextInputElement(elem) {
            var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
            if (nodeName === "input") {
              return !!supportedInputTypes[elem.type];
            }
            if (nodeName === "textarea") {
              return true;
            }
            return false;
          }
          function isEventSupported(eventNameSuffix) {
            if (!canUseDOM) {
              return false;
            }
            var eventName = "on" + eventNameSuffix;
            var isSupported2 = eventName in document;
            if (!isSupported2) {
              var element = document.createElement("div");
              element.setAttribute(eventName, "return;");
              isSupported2 = typeof element[eventName] === "function";
            }
            return isSupported2;
          }
          function registerEvents$1() {
            registerTwoPhaseEvent("onChange", ["change", "click", "focusin", "focusout", "input", "keydown", "keyup", "selectionchange"]);
          }
          function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
            enqueueStateRestore(target);
            var listeners = accumulateTwoPhaseListeners(inst, "onChange");
            if (listeners.length > 0) {
              var event = new SyntheticEvent("onChange", "change", null, nativeEvent, target);
              dispatchQueue.push({
                event,
                listeners
              });
            }
          }
          var activeElement = null;
          var activeElementInst = null;
          function shouldUseChangeEvent(elem) {
            var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
            return nodeName === "select" || nodeName === "input" && elem.type === "file";
          }
          function manualDispatchChangeEvent(nativeEvent) {
            var dispatchQueue = [];
            createAndAccumulateChangeEvent(dispatchQueue, activeElementInst, nativeEvent, getEventTarget2(nativeEvent));
            batchedUpdates(runEventInBatch, dispatchQueue);
          }
          function runEventInBatch(dispatchQueue) {
            processDispatchQueue(dispatchQueue, 0);
          }
          function getInstIfValueChanged(targetInst) {
            var targetNode = getNodeFromInstance(targetInst);
            if (updateValueIfChanged(targetNode)) {
              return targetInst;
            }
          }
          function getTargetInstForChangeEvent(domEventName, targetInst) {
            if (domEventName === "change") {
              return targetInst;
            }
          }
          var isInputEventSupported = false;
          if (canUseDOM) {
            isInputEventSupported = isEventSupported("input") && (!document.documentMode || document.documentMode > 9);
          }
          function startWatchingForValueChange(target, targetInst) {
            activeElement = target;
            activeElementInst = targetInst;
            activeElement.attachEvent("onpropertychange", handlePropertyChange);
          }
          function stopWatchingForValueChange() {
            if (!activeElement) {
              return;
            }
            activeElement.detachEvent("onpropertychange", handlePropertyChange);
            activeElement = null;
            activeElementInst = null;
          }
          function handlePropertyChange(nativeEvent) {
            if (nativeEvent.propertyName !== "value") {
              return;
            }
            if (getInstIfValueChanged(activeElementInst)) {
              manualDispatchChangeEvent(nativeEvent);
            }
          }
          function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
            if (domEventName === "focusin") {
              stopWatchingForValueChange();
              startWatchingForValueChange(target, targetInst);
            } else if (domEventName === "focusout") {
              stopWatchingForValueChange();
            }
          }
          function getTargetInstForInputEventPolyfill(domEventName, targetInst) {
            if (domEventName === "selectionchange" || domEventName === "keyup" || domEventName === "keydown") {
              return getInstIfValueChanged(activeElementInst);
            }
          }
          function shouldUseClickEvent(elem) {
            var nodeName = elem.nodeName;
            return nodeName && nodeName.toLowerCase() === "input" && (elem.type === "checkbox" || elem.type === "radio");
          }
          function getTargetInstForClickEvent(domEventName, targetInst) {
            if (domEventName === "click") {
              return getInstIfValueChanged(targetInst);
            }
          }
          function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
            if (domEventName === "input" || domEventName === "change") {
              return getInstIfValueChanged(targetInst);
            }
          }
          function handleControlledInputBlur(node) {
            var state = node._wrapperState;
            if (!state || !state.controlled || node.type !== "number") {
              return;
            }
            {
              setDefaultValue(node, "number", node.value);
            }
          }
          function extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
            var targetNode = targetInst ? getNodeFromInstance(targetInst) : window;
            var getTargetInstFunc, handleEventFunc;
            if (shouldUseChangeEvent(targetNode)) {
              getTargetInstFunc = getTargetInstForChangeEvent;
            } else if (isTextInputElement(targetNode)) {
              if (isInputEventSupported) {
                getTargetInstFunc = getTargetInstForInputOrChangeEvent;
              } else {
                getTargetInstFunc = getTargetInstForInputEventPolyfill;
                handleEventFunc = handleEventsForInputEventPolyfill;
              }
            } else if (shouldUseClickEvent(targetNode)) {
              getTargetInstFunc = getTargetInstForClickEvent;
            }
            if (getTargetInstFunc) {
              var inst = getTargetInstFunc(domEventName, targetInst);
              if (inst) {
                createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, nativeEventTarget);
                return;
              }
            }
            if (handleEventFunc) {
              handleEventFunc(domEventName, targetNode, targetInst);
            }
            if (domEventName === "focusout") {
              handleControlledInputBlur(targetNode);
            }
          }
          function registerEvents$2() {
            registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
            registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
            registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
            registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
          }
          function extractEvents$2(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
            var isOverEvent = domEventName === "mouseover" || domEventName === "pointerover";
            var isOutEvent = domEventName === "mouseout" || domEventName === "pointerout";
            if (isOverEvent && !isReplayingEvent(nativeEvent)) {
              var related = nativeEvent.relatedTarget || nativeEvent.fromElement;
              if (related) {
                if (getClosestInstanceFromNode(related) || isContainerMarkedAsRoot(related)) {
                  return;
                }
              }
            }
            if (!isOutEvent && !isOverEvent) {
              return;
            }
            var win;
            if (nativeEventTarget.window === nativeEventTarget) {
              win = nativeEventTarget;
            } else {
              var doc = nativeEventTarget.ownerDocument;
              if (doc) {
                win = doc.defaultView || doc.parentWindow;
              } else {
                win = window;
              }
            }
            var from;
            var to;
            if (isOutEvent) {
              var _related = nativeEvent.relatedTarget || nativeEvent.toElement;
              from = targetInst;
              to = _related ? getClosestInstanceFromNode(_related) : null;
              if (to !== null) {
                var nearestMounted = getNearestMountedFiber(to);
                if (to !== nearestMounted || to.tag !== HostComponent && to.tag !== HostText) {
                  to = null;
                }
              }
            } else {
              from = null;
              to = targetInst;
            }
            if (from === to) {
              return;
            }
            var SyntheticEventCtor = SyntheticMouseEvent;
            var leaveEventType = "onMouseLeave";
            var enterEventType = "onMouseEnter";
            var eventTypePrefix = "mouse";
            if (domEventName === "pointerout" || domEventName === "pointerover") {
              SyntheticEventCtor = SyntheticPointerEvent;
              leaveEventType = "onPointerLeave";
              enterEventType = "onPointerEnter";
              eventTypePrefix = "pointer";
            }
            var fromNode = from == null ? win : getNodeFromInstance(from);
            var toNode = to == null ? win : getNodeFromInstance(to);
            var leave = new SyntheticEventCtor(leaveEventType, eventTypePrefix + "leave", from, nativeEvent, nativeEventTarget);
            leave.target = fromNode;
            leave.relatedTarget = toNode;
            var enter = null;
            var nativeTargetInst = getClosestInstanceFromNode(nativeEventTarget);
            if (nativeTargetInst === targetInst) {
              var enterEvent = new SyntheticEventCtor(enterEventType, eventTypePrefix + "enter", to, nativeEvent, nativeEventTarget);
              enterEvent.target = toNode;
              enterEvent.relatedTarget = fromNode;
              enter = enterEvent;
            }
            accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leave, enter, from, to);
          }
          function is(x, y) {
            return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
          }
          var objectIs = typeof Object.is === "function" ? Object.is : is;
          function shallowEqual(objA, objB) {
            if (objectIs(objA, objB)) {
              return true;
            }
            if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
              return false;
            }
            var keysA = Object.keys(objA);
            var keysB = Object.keys(objB);
            if (keysA.length !== keysB.length) {
              return false;
            }
            for (var i = 0; i < keysA.length; i++) {
              var currentKey = keysA[i];
              if (!hasOwnProperty.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey])) {
                return false;
              }
            }
            return true;
          }
          function getLeafNode(node) {
            while (node && node.firstChild) {
              node = node.firstChild;
            }
            return node;
          }
          function getSiblingNode(node) {
            while (node) {
              if (node.nextSibling) {
                return node.nextSibling;
              }
              node = node.parentNode;
            }
          }
          function getNodeForCharacterOffset(root3, offset) {
            var node = getLeafNode(root3);
            var nodeStart = 0;
            var nodeEnd = 0;
            while (node) {
              if (node.nodeType === TEXT_NODE) {
                nodeEnd = nodeStart + node.textContent.length;
                if (nodeStart <= offset && nodeEnd >= offset) {
                  return {
                    node,
                    offset: offset - nodeStart
                  };
                }
                nodeStart = nodeEnd;
              }
              node = getLeafNode(getSiblingNode(node));
            }
          }
          function getOffsets(outerNode) {
            var ownerDocument = outerNode.ownerDocument;
            var win = ownerDocument && ownerDocument.defaultView || window;
            var selection = win.getSelection && win.getSelection();
            if (!selection || selection.rangeCount === 0) {
              return null;
            }
            var anchorNode = selection.anchorNode, anchorOffset = selection.anchorOffset, focusNode = selection.focusNode, focusOffset = selection.focusOffset;
            try {
              anchorNode.nodeType;
              focusNode.nodeType;
            } catch (e) {
              return null;
            }
            return getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset);
          }
          function getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset) {
            var length = 0;
            var start = -1;
            var end = -1;
            var indexWithinAnchor = 0;
            var indexWithinFocus = 0;
            var node = outerNode;
            var parentNode = null;
            outer: while (true) {
              var next = null;
              while (true) {
                if (node === anchorNode && (anchorOffset === 0 || node.nodeType === TEXT_NODE)) {
                  start = length + anchorOffset;
                }
                if (node === focusNode && (focusOffset === 0 || node.nodeType === TEXT_NODE)) {
                  end = length + focusOffset;
                }
                if (node.nodeType === TEXT_NODE) {
                  length += node.nodeValue.length;
                }
                if ((next = node.firstChild) === null) {
                  break;
                }
                parentNode = node;
                node = next;
              }
              while (true) {
                if (node === outerNode) {
                  break outer;
                }
                if (parentNode === anchorNode && ++indexWithinAnchor === anchorOffset) {
                  start = length;
                }
                if (parentNode === focusNode && ++indexWithinFocus === focusOffset) {
                  end = length;
                }
                if ((next = node.nextSibling) !== null) {
                  break;
                }
                node = parentNode;
                parentNode = node.parentNode;
              }
              node = next;
            }
            if (start === -1 || end === -1) {
              return null;
            }
            return {
              start,
              end
            };
          }
          function setOffsets(node, offsets) {
            var doc = node.ownerDocument || document;
            var win = doc && doc.defaultView || window;
            if (!win.getSelection) {
              return;
            }
            var selection = win.getSelection();
            var length = node.textContent.length;
            var start = Math.min(offsets.start, length);
            var end = offsets.end === void 0 ? start : Math.min(offsets.end, length);
            if (!selection.extend && start > end) {
              var temp = end;
              end = start;
              start = temp;
            }
            var startMarker = getNodeForCharacterOffset(node, start);
            var endMarker = getNodeForCharacterOffset(node, end);
            if (startMarker && endMarker) {
              if (selection.rangeCount === 1 && selection.anchorNode === startMarker.node && selection.anchorOffset === startMarker.offset && selection.focusNode === endMarker.node && selection.focusOffset === endMarker.offset) {
                return;
              }
              var range = doc.createRange();
              range.setStart(startMarker.node, startMarker.offset);
              selection.removeAllRanges();
              if (start > end) {
                selection.addRange(range);
                selection.extend(endMarker.node, endMarker.offset);
              } else {
                range.setEnd(endMarker.node, endMarker.offset);
                selection.addRange(range);
              }
            }
          }
          function isTextNode(node) {
            return node && node.nodeType === TEXT_NODE;
          }
          function containsNode(outerNode, innerNode) {
            if (!outerNode || !innerNode) {
              return false;
            } else if (outerNode === innerNode) {
              return true;
            } else if (isTextNode(outerNode)) {
              return false;
            } else if (isTextNode(innerNode)) {
              return containsNode(outerNode, innerNode.parentNode);
            } else if ("contains" in outerNode) {
              return outerNode.contains(innerNode);
            } else if (outerNode.compareDocumentPosition) {
              return !!(outerNode.compareDocumentPosition(innerNode) & 16);
            } else {
              return false;
            }
          }
          function isInDocument(node) {
            return node && node.ownerDocument && containsNode(node.ownerDocument.documentElement, node);
          }
          function isSameOriginFrame(iframe) {
            try {
              return typeof iframe.contentWindow.location.href === "string";
            } catch (err) {
              return false;
            }
          }
          function getActiveElementDeep() {
            var win = window;
            var element = getActiveElement();
            while (element instanceof win.HTMLIFrameElement) {
              if (isSameOriginFrame(element)) {
                win = element.contentWindow;
              } else {
                return element;
              }
              element = getActiveElement(win.document);
            }
            return element;
          }
          function hasSelectionCapabilities(elem) {
            var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
            return nodeName && (nodeName === "input" && (elem.type === "text" || elem.type === "search" || elem.type === "tel" || elem.type === "url" || elem.type === "password") || nodeName === "textarea" || elem.contentEditable === "true");
          }
          function getSelectionInformation() {
            var focusedElem = getActiveElementDeep();
            return {
              focusedElem,
              selectionRange: hasSelectionCapabilities(focusedElem) ? getSelection(focusedElem) : null
            };
          }
          function restoreSelection(priorSelectionInformation) {
            var curFocusedElem = getActiveElementDeep();
            var priorFocusedElem = priorSelectionInformation.focusedElem;
            var priorSelectionRange = priorSelectionInformation.selectionRange;
            if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
              if (priorSelectionRange !== null && hasSelectionCapabilities(priorFocusedElem)) {
                setSelection(priorFocusedElem, priorSelectionRange);
              }
              var ancestors = [];
              var ancestor = priorFocusedElem;
              while (ancestor = ancestor.parentNode) {
                if (ancestor.nodeType === ELEMENT_NODE) {
                  ancestors.push({
                    element: ancestor,
                    left: ancestor.scrollLeft,
                    top: ancestor.scrollTop
                  });
                }
              }
              if (typeof priorFocusedElem.focus === "function") {
                priorFocusedElem.focus();
              }
              for (var i = 0; i < ancestors.length; i++) {
                var info = ancestors[i];
                info.element.scrollLeft = info.left;
                info.element.scrollTop = info.top;
              }
            }
          }
          function getSelection(input) {
            var selection;
            if ("selectionStart" in input) {
              selection = {
                start: input.selectionStart,
                end: input.selectionEnd
              };
            } else {
              selection = getOffsets(input);
            }
            return selection || {
              start: 0,
              end: 0
            };
          }
          function setSelection(input, offsets) {
            var start = offsets.start;
            var end = offsets.end;
            if (end === void 0) {
              end = start;
            }
            if ("selectionStart" in input) {
              input.selectionStart = start;
              input.selectionEnd = Math.min(end, input.value.length);
            } else {
              setOffsets(input, offsets);
            }
          }
          var skipSelectionChangeEvent = canUseDOM && "documentMode" in document && document.documentMode <= 11;
          function registerEvents$3() {
            registerTwoPhaseEvent("onSelect", ["focusout", "contextmenu", "dragend", "focusin", "keydown", "keyup", "mousedown", "mouseup", "selectionchange"]);
          }
          var activeElement$1 = null;
          var activeElementInst$1 = null;
          var lastSelection = null;
          var mouseDown = false;
          function getSelection$1(node) {
            if ("selectionStart" in node && hasSelectionCapabilities(node)) {
              return {
                start: node.selectionStart,
                end: node.selectionEnd
              };
            } else {
              var win = node.ownerDocument && node.ownerDocument.defaultView || window;
              var selection = win.getSelection();
              return {
                anchorNode: selection.anchorNode,
                anchorOffset: selection.anchorOffset,
                focusNode: selection.focusNode,
                focusOffset: selection.focusOffset
              };
            }
          }
          function getEventTargetDocument(eventTarget) {
            return eventTarget.window === eventTarget ? eventTarget.document : eventTarget.nodeType === DOCUMENT_NODE ? eventTarget : eventTarget.ownerDocument;
          }
          function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
            var doc = getEventTargetDocument(nativeEventTarget);
            if (mouseDown || activeElement$1 == null || activeElement$1 !== getActiveElement(doc)) {
              return;
            }
            var currentSelection = getSelection$1(activeElement$1);
            if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
              lastSelection = currentSelection;
              var listeners = accumulateTwoPhaseListeners(activeElementInst$1, "onSelect");
              if (listeners.length > 0) {
                var event = new SyntheticEvent("onSelect", "select", null, nativeEvent, nativeEventTarget);
                dispatchQueue.push({
                  event,
                  listeners
                });
                event.target = activeElement$1;
              }
            }
          }
          function extractEvents$3(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
            var targetNode = targetInst ? getNodeFromInstance(targetInst) : window;
            switch (domEventName) {
              // Track the input node that has focus.
              case "focusin":
                if (isTextInputElement(targetNode) || targetNode.contentEditable === "true") {
                  activeElement$1 = targetNode;
                  activeElementInst$1 = targetInst;
                  lastSelection = null;
                }
                break;
              case "focusout":
                activeElement$1 = null;
                activeElementInst$1 = null;
                lastSelection = null;
                break;
              // Don't fire the event while the user is dragging. This matches the
              // semantics of the native select event.
              case "mousedown":
                mouseDown = true;
                break;
              case "contextmenu":
              case "mouseup":
              case "dragend":
                mouseDown = false;
                constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
                break;
              // Chrome and IE fire non-standard event when selection is changed (and
              // sometimes when it hasn't). IE's event fires out of order with respect
              // to key and input events on deletion, so we discard it.
              //
              // Firefox doesn't support selectionchange, so check selection status
              // after each key entry. The selection changes after keydown and before
              // keyup, but we check on keydown as well in the case of holding down a
              // key, when multiple keydown events are fired but only one keyup is.
              // This is also our approach for IE handling, for the reason above.
              case "selectionchange":
                if (skipSelectionChangeEvent) {
                  break;
                }
              // falls through
              case "keydown":
              case "keyup":
                constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
            }
          }
          function makePrefixMap(styleProp, eventName) {
            var prefixes2 = {};
            prefixes2[styleProp.toLowerCase()] = eventName.toLowerCase();
            prefixes2["Webkit" + styleProp] = "webkit" + eventName;
            prefixes2["Moz" + styleProp] = "moz" + eventName;
            return prefixes2;
          }
          var vendorPrefixes = {
            animationend: makePrefixMap("Animation", "AnimationEnd"),
            animationiteration: makePrefixMap("Animation", "AnimationIteration"),
            animationstart: makePrefixMap("Animation", "AnimationStart"),
            transitionend: makePrefixMap("Transition", "TransitionEnd")
          };
          var prefixedEventNames = {};
          var style = {};
          if (canUseDOM) {
            style = document.createElement("div").style;
            if (!("AnimationEvent" in window)) {
              delete vendorPrefixes.animationend.animation;
              delete vendorPrefixes.animationiteration.animation;
              delete vendorPrefixes.animationstart.animation;
            }
            if (!("TransitionEvent" in window)) {
              delete vendorPrefixes.transitionend.transition;
            }
          }
          function getVendorPrefixedEventName(eventName) {
            if (prefixedEventNames[eventName]) {
              return prefixedEventNames[eventName];
            } else if (!vendorPrefixes[eventName]) {
              return eventName;
            }
            var prefixMap = vendorPrefixes[eventName];
            for (var styleProp in prefixMap) {
              if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {
                return prefixedEventNames[eventName] = prefixMap[styleProp];
              }
            }
            return eventName;
          }
          var ANIMATION_END = getVendorPrefixedEventName("animationend");
          var ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration");
          var ANIMATION_START = getVendorPrefixedEventName("animationstart");
          var TRANSITION_END = getVendorPrefixedEventName("transitionend");
          var topLevelEventsToReactNames = /* @__PURE__ */ new Map();
          var simpleEventPluginEvents = ["abort", "auxClick", "cancel", "canPlay", "canPlayThrough", "click", "close", "contextMenu", "copy", "cut", "drag", "dragEnd", "dragEnter", "dragExit", "dragLeave", "dragOver", "dragStart", "drop", "durationChange", "emptied", "encrypted", "ended", "error", "gotPointerCapture", "input", "invalid", "keyDown", "keyPress", "keyUp", "load", "loadedData", "loadedMetadata", "loadStart", "lostPointerCapture", "mouseDown", "mouseMove", "mouseOut", "mouseOver", "mouseUp", "paste", "pause", "play", "playing", "pointerCancel", "pointerDown", "pointerMove", "pointerOut", "pointerOver", "pointerUp", "progress", "rateChange", "reset", "resize", "seeked", "seeking", "stalled", "submit", "suspend", "timeUpdate", "touchCancel", "touchEnd", "touchStart", "volumeChange", "scroll", "toggle", "touchMove", "waiting", "wheel"];
          function registerSimpleEvent(domEventName, reactName) {
            topLevelEventsToReactNames.set(domEventName, reactName);
            registerTwoPhaseEvent(reactName, [domEventName]);
          }
          function registerSimpleEvents() {
            for (var i = 0; i < simpleEventPluginEvents.length; i++) {
              var eventName = simpleEventPluginEvents[i];
              var domEventName = eventName.toLowerCase();
              var capitalizedEvent = eventName[0].toUpperCase() + eventName.slice(1);
              registerSimpleEvent(domEventName, "on" + capitalizedEvent);
            }
            registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
            registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
            registerSimpleEvent(ANIMATION_START, "onAnimationStart");
            registerSimpleEvent("dblclick", "onDoubleClick");
            registerSimpleEvent("focusin", "onFocus");
            registerSimpleEvent("focusout", "onBlur");
            registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
          }
          function extractEvents$4(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
            var reactName = topLevelEventsToReactNames.get(domEventName);
            if (reactName === void 0) {
              return;
            }
            var SyntheticEventCtor = SyntheticEvent;
            var reactEventType = domEventName;
            switch (domEventName) {
              case "keypress":
                if (getEventCharCode(nativeEvent) === 0) {
                  return;
                }
              /* falls through */
              case "keydown":
              case "keyup":
                SyntheticEventCtor = SyntheticKeyboardEvent;
                break;
              case "focusin":
                reactEventType = "focus";
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
              case "focusout":
                reactEventType = "blur";
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
              case "beforeblur":
              case "afterblur":
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
              case "click":
                if (nativeEvent.button === 2) {
                  return;
                }
              /* falls through */
              case "auxclick":
              case "dblclick":
              case "mousedown":
              case "mousemove":
              case "mouseup":
              // TODO: Disabled elements should not respond to mouse events
              /* falls through */
              case "mouseout":
              case "mouseover":
              case "contextmenu":
                SyntheticEventCtor = SyntheticMouseEvent;
                break;
              case "drag":
              case "dragend":
              case "dragenter":
              case "dragexit":
              case "dragleave":
              case "dragover":
              case "dragstart":
              case "drop":
                SyntheticEventCtor = SyntheticDragEvent;
                break;
              case "touchcancel":
              case "touchend":
              case "touchmove":
              case "touchstart":
                SyntheticEventCtor = SyntheticTouchEvent;
                break;
              case ANIMATION_END:
              case ANIMATION_ITERATION:
              case ANIMATION_START:
                SyntheticEventCtor = SyntheticAnimationEvent;
                break;
              case TRANSITION_END:
                SyntheticEventCtor = SyntheticTransitionEvent;
                break;
              case "scroll":
                SyntheticEventCtor = SyntheticUIEvent;
                break;
              case "wheel":
                SyntheticEventCtor = SyntheticWheelEvent;
                break;
              case "copy":
              case "cut":
              case "paste":
                SyntheticEventCtor = SyntheticClipboardEvent;
                break;
              case "gotpointercapture":
              case "lostpointercapture":
              case "pointercancel":
              case "pointerdown":
              case "pointermove":
              case "pointerout":
              case "pointerover":
              case "pointerup":
                SyntheticEventCtor = SyntheticPointerEvent;
                break;
            }
            var inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;
            {
              var accumulateTargetOnly = !inCapturePhase && // TODO: ideally, we'd eventually add all events from
              // nonDelegatedEvents list in DOMPluginEventSystem.
              // Then we can remove this special list.
              // This is a breaking change that can wait until React 18.
              domEventName === "scroll";
              var _listeners3 = accumulateSinglePhaseListeners(targetInst, reactName, nativeEvent.type, inCapturePhase, accumulateTargetOnly);
              if (_listeners3.length > 0) {
                var _event = new SyntheticEventCtor(reactName, reactEventType, null, nativeEvent, nativeEventTarget);
                dispatchQueue.push({
                  event: _event,
                  listeners: _listeners3
                });
              }
            }
          }
          registerSimpleEvents();
          registerEvents$2();
          registerEvents$1();
          registerEvents$3();
          registerEvents();
          function extractEvents$5(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
            extractEvents$4(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);
            var shouldProcessPolyfillPlugins = (eventSystemFlags & SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS) === 0;
            if (shouldProcessPolyfillPlugins) {
              extractEvents$2(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
              extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
              extractEvents$3(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
              extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
            }
          }
          var mediaEventTypes = ["abort", "canplay", "canplaythrough", "durationchange", "emptied", "encrypted", "ended", "error", "loadeddata", "loadedmetadata", "loadstart", "pause", "play", "playing", "progress", "ratechange", "resize", "seeked", "seeking", "stalled", "suspend", "timeupdate", "volumechange", "waiting"];
          var nonDelegatedEvents = new Set(["cancel", "close", "invalid", "load", "scroll", "toggle"].concat(mediaEventTypes));
          function executeDispatch(event, listener, currentTarget) {
            var type = event.type || "unknown-event";
            event.currentTarget = currentTarget;
            invokeGuardedCallbackAndCatchFirstError(type, listener, void 0, event);
            event.currentTarget = null;
          }
          function processDispatchQueueItemsInOrder(event, dispatchListeners, inCapturePhase) {
            var previousInstance;
            if (inCapturePhase) {
              for (var i = dispatchListeners.length - 1; i >= 0; i--) {
                var _dispatchListeners$i = dispatchListeners[i], instance = _dispatchListeners$i.instance, currentTarget = _dispatchListeners$i.currentTarget, listener = _dispatchListeners$i.listener;
                if (instance !== previousInstance && event.isPropagationStopped()) {
                  return;
                }
                executeDispatch(event, listener, currentTarget);
                previousInstance = instance;
              }
            } else {
              for (var _i2 = 0; _i2 < dispatchListeners.length; _i2++) {
                var _dispatchListeners$_i = dispatchListeners[_i2], _instance = _dispatchListeners$_i.instance, _currentTarget = _dispatchListeners$_i.currentTarget, _listener = _dispatchListeners$_i.listener;
                if (_instance !== previousInstance && event.isPropagationStopped()) {
                  return;
                }
                executeDispatch(event, _listener, _currentTarget);
                previousInstance = _instance;
              }
            }
          }
          function processDispatchQueue(dispatchQueue, eventSystemFlags) {
            var inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;
            for (var i = 0; i < dispatchQueue.length; i++) {
              var _dispatchQueue$i = dispatchQueue[i], event = _dispatchQueue$i.event, listeners = _dispatchQueue$i.listeners;
              processDispatchQueueItemsInOrder(event, listeners, inCapturePhase);
            }
            rethrowCaughtError();
          }
          function dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {
            var nativeEventTarget = getEventTarget2(nativeEvent);
            var dispatchQueue = [];
            extractEvents$5(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);
            processDispatchQueue(dispatchQueue, eventSystemFlags);
          }
          function listenToNonDelegatedEvent(domEventName, targetElement) {
            {
              if (!nonDelegatedEvents.has(domEventName)) {
                error('Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.', domEventName);
              }
            }
            var isCapturePhaseListener = false;
            var listenerSet = getEventListenerSet(targetElement);
            var listenerSetKey = getListenerSetKey(domEventName, isCapturePhaseListener);
            if (!listenerSet.has(listenerSetKey)) {
              addTrappedEventListener(targetElement, domEventName, IS_NON_DELEGATED, isCapturePhaseListener);
              listenerSet.add(listenerSetKey);
            }
          }
          function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
            {
              if (nonDelegatedEvents.has(domEventName) && !isCapturePhaseListener) {
                error('Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.', domEventName);
              }
            }
            var eventSystemFlags = 0;
            if (isCapturePhaseListener) {
              eventSystemFlags |= IS_CAPTURE_PHASE;
            }
            addTrappedEventListener(target, domEventName, eventSystemFlags, isCapturePhaseListener);
          }
          var listeningMarker = "_reactListening" + Math.random().toString(36).slice(2);
          function listenToAllSupportedEvents(rootContainerElement) {
            if (!rootContainerElement[listeningMarker]) {
              rootContainerElement[listeningMarker] = true;
              allNativeEvents.forEach(function(domEventName) {
                if (domEventName !== "selectionchange") {
                  if (!nonDelegatedEvents.has(domEventName)) {
                    listenToNativeEvent(domEventName, false, rootContainerElement);
                  }
                  listenToNativeEvent(domEventName, true, rootContainerElement);
                }
              });
              var ownerDocument = rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;
              if (ownerDocument !== null) {
                if (!ownerDocument[listeningMarker]) {
                  ownerDocument[listeningMarker] = true;
                  listenToNativeEvent("selectionchange", false, ownerDocument);
                }
              }
            }
          }
          function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener, isDeferredListenerForLegacyFBSupport) {
            var listener = createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags);
            var isPassiveListener = void 0;
            if (passiveBrowserEventsSupported) {
              if (domEventName === "touchstart" || domEventName === "touchmove" || domEventName === "wheel") {
                isPassiveListener = true;
              }
            }
            targetContainer = targetContainer;
            var unsubscribeListener;
            if (isCapturePhaseListener) {
              if (isPassiveListener !== void 0) {
                unsubscribeListener = addEventCaptureListenerWithPassiveFlag(targetContainer, domEventName, listener, isPassiveListener);
              } else {
                unsubscribeListener = addEventCaptureListener(targetContainer, domEventName, listener);
              }
            } else {
              if (isPassiveListener !== void 0) {
                unsubscribeListener = addEventBubbleListenerWithPassiveFlag(targetContainer, domEventName, listener, isPassiveListener);
              } else {
                unsubscribeListener = addEventBubbleListener(targetContainer, domEventName, listener);
              }
            }
          }
          function isMatchingRootContainer(grandContainer, targetContainer) {
            return grandContainer === targetContainer || grandContainer.nodeType === COMMENT_NODE && grandContainer.parentNode === targetContainer;
          }
          function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {
            var ancestorInst = targetInst;
            if ((eventSystemFlags & IS_EVENT_HANDLE_NON_MANAGED_NODE) === 0 && (eventSystemFlags & IS_NON_DELEGATED) === 0) {
              var targetContainerNode = targetContainer;
              if (targetInst !== null) {
                var node = targetInst;
                mainLoop: while (true) {
                  if (node === null) {
                    return;
                  }
                  var nodeTag = node.tag;
                  if (nodeTag === HostRoot || nodeTag === HostPortal) {
                    var container2 = node.stateNode.containerInfo;
                    if (isMatchingRootContainer(container2, targetContainerNode)) {
                      break;
                    }
                    if (nodeTag === HostPortal) {
                      var grandNode = node.return;
                      while (grandNode !== null) {
                        var grandTag = grandNode.tag;
                        if (grandTag === HostRoot || grandTag === HostPortal) {
                          var grandContainer = grandNode.stateNode.containerInfo;
                          if (isMatchingRootContainer(grandContainer, targetContainerNode)) {
                            return;
                          }
                        }
                        grandNode = grandNode.return;
                      }
                    }
                    while (container2 !== null) {
                      var parentNode = getClosestInstanceFromNode(container2);
                      if (parentNode === null) {
                        return;
                      }
                      var parentTag = parentNode.tag;
                      if (parentTag === HostComponent || parentTag === HostText) {
                        node = ancestorInst = parentNode;
                        continue mainLoop;
                      }
                      container2 = container2.parentNode;
                    }
                  }
                  node = node.return;
                }
              }
            }
            batchedUpdates(function() {
              return dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, ancestorInst);
            });
          }
          function createDispatchListener(instance, listener, currentTarget) {
            return {
              instance,
              listener,
              currentTarget
            };
          }
          function accumulateSinglePhaseListeners(targetFiber, reactName, nativeEventType, inCapturePhase, accumulateTargetOnly, nativeEvent) {
            var captureName = reactName !== null ? reactName + "Capture" : null;
            var reactEventName = inCapturePhase ? captureName : reactName;
            var listeners = [];
            var instance = targetFiber;
            var lastHostComponent = null;
            while (instance !== null) {
              var _instance2 = instance, stateNode = _instance2.stateNode, tag = _instance2.tag;
              if (tag === HostComponent && stateNode !== null) {
                lastHostComponent = stateNode;
                if (reactEventName !== null) {
                  var listener = getListener(instance, reactEventName);
                  if (listener != null) {
                    listeners.push(createDispatchListener(instance, listener, lastHostComponent));
                  }
                }
              }
              if (accumulateTargetOnly) {
                break;
              }
              instance = instance.return;
            }
            return listeners;
          }
          function accumulateTwoPhaseListeners(targetFiber, reactName) {
            var captureName = reactName + "Capture";
            var listeners = [];
            var instance = targetFiber;
            while (instance !== null) {
              var _instance3 = instance, stateNode = _instance3.stateNode, tag = _instance3.tag;
              if (tag === HostComponent && stateNode !== null) {
                var currentTarget = stateNode;
                var captureListener = getListener(instance, captureName);
                if (captureListener != null) {
                  listeners.unshift(createDispatchListener(instance, captureListener, currentTarget));
                }
                var bubbleListener = getListener(instance, reactName);
                if (bubbleListener != null) {
                  listeners.push(createDispatchListener(instance, bubbleListener, currentTarget));
                }
              }
              instance = instance.return;
            }
            return listeners;
          }
          function getParent(inst) {
            if (inst === null) {
              return null;
            }
            do {
              inst = inst.return;
            } while (inst && inst.tag !== HostComponent);
            if (inst) {
              return inst;
            }
            return null;
          }
          function getLowestCommonAncestor(instA, instB) {
            var nodeA = instA;
            var nodeB = instB;
            var depthA = 0;
            for (var tempA = nodeA; tempA; tempA = getParent(tempA)) {
              depthA++;
            }
            var depthB = 0;
            for (var tempB = nodeB; tempB; tempB = getParent(tempB)) {
              depthB++;
            }
            while (depthA - depthB > 0) {
              nodeA = getParent(nodeA);
              depthA--;
            }
            while (depthB - depthA > 0) {
              nodeB = getParent(nodeB);
              depthB--;
            }
            var depth = depthA;
            while (depth--) {
              if (nodeA === nodeB || nodeB !== null && nodeA === nodeB.alternate) {
                return nodeA;
              }
              nodeA = getParent(nodeA);
              nodeB = getParent(nodeB);
            }
            return null;
          }
          function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common, inCapturePhase) {
            var registrationName = event._reactName;
            var listeners = [];
            var instance = target;
            while (instance !== null) {
              if (instance === common) {
                break;
              }
              var _instance4 = instance, alternate = _instance4.alternate, stateNode = _instance4.stateNode, tag = _instance4.tag;
              if (alternate !== null && alternate === common) {
                break;
              }
              if (tag === HostComponent && stateNode !== null) {
                var currentTarget = stateNode;
                if (inCapturePhase) {
                  var captureListener = getListener(instance, registrationName);
                  if (captureListener != null) {
                    listeners.unshift(createDispatchListener(instance, captureListener, currentTarget));
                  }
                } else if (!inCapturePhase) {
                  var bubbleListener = getListener(instance, registrationName);
                  if (bubbleListener != null) {
                    listeners.push(createDispatchListener(instance, bubbleListener, currentTarget));
                  }
                }
              }
              instance = instance.return;
            }
            if (listeners.length !== 0) {
              dispatchQueue.push({
                event,
                listeners
              });
            }
          }
          function accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leaveEvent, enterEvent, from, to) {
            var common = from && to ? getLowestCommonAncestor(from, to) : null;
            if (from !== null) {
              accumulateEnterLeaveListenersForEvent(dispatchQueue, leaveEvent, from, common, false);
            }
            if (to !== null && enterEvent !== null) {
              accumulateEnterLeaveListenersForEvent(dispatchQueue, enterEvent, to, common, true);
            }
          }
          function getListenerSetKey(domEventName, capture) {
            return domEventName + "__" + (capture ? "capture" : "bubble");
          }
          var didWarnInvalidHydration = false;
          var DANGEROUSLY_SET_INNER_HTML = "dangerouslySetInnerHTML";
          var SUPPRESS_CONTENT_EDITABLE_WARNING = "suppressContentEditableWarning";
          var SUPPRESS_HYDRATION_WARNING = "suppressHydrationWarning";
          var AUTOFOCUS = "autoFocus";
          var CHILDREN = "children";
          var STYLE = "style";
          var HTML$1 = "__html";
          var warnedUnknownTags;
          var validatePropertiesInDevelopment;
          var warnForPropDifference;
          var warnForExtraAttributes;
          var warnForInvalidEventListener;
          var canDiffStyleForHydrationWarning;
          var normalizeHTML;
          {
            warnedUnknownTags = {
              // There are working polyfills for <dialog>. Let people use it.
              dialog: true,
              // Electron ships a custom <webview> tag to display external web content in
              // an isolated frame and process.
              // This tag is not present in non Electron environments such as JSDom which
              // is often used for testing purposes.
              // @see https://electronjs.org/docs/api/webview-tag
              webview: true
            };
            validatePropertiesInDevelopment = function(type, props) {
              validateProperties(type, props);
              validateProperties$1(type, props);
              validateProperties$2(type, props, {
                registrationNameDependencies,
                possibleRegistrationNames
              });
            };
            canDiffStyleForHydrationWarning = canUseDOM && !document.documentMode;
            warnForPropDifference = function(propName, serverValue, clientValue) {
              if (didWarnInvalidHydration) {
                return;
              }
              var normalizedClientValue = normalizeMarkupForTextOrAttribute(clientValue);
              var normalizedServerValue = normalizeMarkupForTextOrAttribute(serverValue);
              if (normalizedServerValue === normalizedClientValue) {
                return;
              }
              didWarnInvalidHydration = true;
              error("Prop `%s` did not match. Server: %s Client: %s", propName, JSON.stringify(normalizedServerValue), JSON.stringify(normalizedClientValue));
            };
            warnForExtraAttributes = function(attributeNames) {
              if (didWarnInvalidHydration) {
                return;
              }
              didWarnInvalidHydration = true;
              var names = [];
              attributeNames.forEach(function(name) {
                names.push(name);
              });
              error("Extra attributes from the server: %s", names);
            };
            warnForInvalidEventListener = function(registrationName, listener) {
              if (listener === false) {
                error("Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.", registrationName, registrationName, registrationName);
              } else {
                error("Expected `%s` listener to be a function, instead got a value of `%s` type.", registrationName, typeof listener);
              }
            };
            normalizeHTML = function(parent, html) {
              var testElement = parent.namespaceURI === HTML_NAMESPACE ? parent.ownerDocument.createElement(parent.tagName) : parent.ownerDocument.createElementNS(parent.namespaceURI, parent.tagName);
              testElement.innerHTML = html;
              return testElement.innerHTML;
            };
          }
          var NORMALIZE_NEWLINES_REGEX = /\r\n?/g;
          var NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;
          function normalizeMarkupForTextOrAttribute(markup) {
            {
              checkHtmlStringCoercion(markup);
            }
            var markupString = typeof markup === "string" ? markup : "" + markup;
            return markupString.replace(NORMALIZE_NEWLINES_REGEX, "\n").replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
          }
          function checkForUnmatchedText(serverText, clientText, isConcurrentMode, shouldWarnDev) {
            var normalizedClientText = normalizeMarkupForTextOrAttribute(clientText);
            var normalizedServerText = normalizeMarkupForTextOrAttribute(serverText);
            if (normalizedServerText === normalizedClientText) {
              return;
            }
            if (shouldWarnDev) {
              {
                if (!didWarnInvalidHydration) {
                  didWarnInvalidHydration = true;
                  error('Text content did not match. Server: "%s" Client: "%s"', normalizedServerText, normalizedClientText);
                }
              }
            }
            if (isConcurrentMode && enableClientRenderFallbackOnTextMismatch) {
              throw new Error("Text content does not match server-rendered HTML.");
            }
          }
          function getOwnerDocumentFromRootContainer(rootContainerElement) {
            return rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;
          }
          function noop4() {
          }
          function trapClickOnNonInteractiveElement(node) {
            node.onclick = noop4;
          }
          function setInitialDOMProperties(tag, domElement, rootContainerElement, nextProps, isCustomComponentTag) {
            for (var propKey in nextProps) {
              if (!nextProps.hasOwnProperty(propKey)) {
                continue;
              }
              var nextProp = nextProps[propKey];
              if (propKey === STYLE) {
                {
                  if (nextProp) {
                    Object.freeze(nextProp);
                  }
                }
                setValueForStyles(domElement, nextProp);
              } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
                var nextHtml = nextProp ? nextProp[HTML$1] : void 0;
                if (nextHtml != null) {
                  setInnerHTML(domElement, nextHtml);
                }
              } else if (propKey === CHILDREN) {
                if (typeof nextProp === "string") {
                  var canSetTextContent = tag !== "textarea" || nextProp !== "";
                  if (canSetTextContent) {
                    setTextContent(domElement, nextProp);
                  }
                } else if (typeof nextProp === "number") {
                  setTextContent(domElement, "" + nextProp);
                }
              } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING) ;
              else if (propKey === AUTOFOCUS) ;
              else if (registrationNameDependencies.hasOwnProperty(propKey)) {
                if (nextProp != null) {
                  if (typeof nextProp !== "function") {
                    warnForInvalidEventListener(propKey, nextProp);
                  }
                  if (propKey === "onScroll") {
                    listenToNonDelegatedEvent("scroll", domElement);
                  }
                }
              } else if (nextProp != null) {
                setValueForProperty(domElement, propKey, nextProp, isCustomComponentTag);
              }
            }
          }
          function updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag) {
            for (var i = 0; i < updatePayload.length; i += 2) {
              var propKey = updatePayload[i];
              var propValue = updatePayload[i + 1];
              if (propKey === STYLE) {
                setValueForStyles(domElement, propValue);
              } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
                setInnerHTML(domElement, propValue);
              } else if (propKey === CHILDREN) {
                setTextContent(domElement, propValue);
              } else {
                setValueForProperty(domElement, propKey, propValue, isCustomComponentTag);
              }
            }
          }
          function createElement4(type, props, rootContainerElement, parentNamespace) {
            var isCustomComponentTag;
            var ownerDocument = getOwnerDocumentFromRootContainer(rootContainerElement);
            var domElement;
            var namespaceURI = parentNamespace;
            if (namespaceURI === HTML_NAMESPACE) {
              namespaceURI = getIntrinsicNamespace(type);
            }
            if (namespaceURI === HTML_NAMESPACE) {
              {
                isCustomComponentTag = isCustomComponent(type, props);
                if (!isCustomComponentTag && type !== type.toLowerCase()) {
                  error("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", type);
                }
              }
              if (type === "script") {
                var div = ownerDocument.createElement("div");
                div.innerHTML = "<script><\/script>";
                var firstChild = div.firstChild;
                domElement = div.removeChild(firstChild);
              } else if (typeof props.is === "string") {
                domElement = ownerDocument.createElement(type, {
                  is: props.is
                });
              } else {
                domElement = ownerDocument.createElement(type);
                if (type === "select") {
                  var node = domElement;
                  if (props.multiple) {
                    node.multiple = true;
                  } else if (props.size) {
                    node.size = props.size;
                  }
                }
              }
            } else {
              domElement = ownerDocument.createElementNS(namespaceURI, type);
            }
            {
              if (namespaceURI === HTML_NAMESPACE) {
                if (!isCustomComponentTag && Object.prototype.toString.call(domElement) === "[object HTMLUnknownElement]" && !hasOwnProperty.call(warnedUnknownTags, type)) {
                  warnedUnknownTags[type] = true;
                  error("The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.", type);
                }
              }
            }
            return domElement;
          }
          function createTextNode(text, rootContainerElement) {
            return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);
          }
          function setInitialProperties(domElement, tag, rawProps, rootContainerElement) {
            var isCustomComponentTag = isCustomComponent(tag, rawProps);
            {
              validatePropertiesInDevelopment(tag, rawProps);
            }
            var props;
            switch (tag) {
              case "dialog":
                listenToNonDelegatedEvent("cancel", domElement);
                listenToNonDelegatedEvent("close", domElement);
                props = rawProps;
                break;
              case "iframe":
              case "object":
              case "embed":
                listenToNonDelegatedEvent("load", domElement);
                props = rawProps;
                break;
              case "video":
              case "audio":
                for (var i = 0; i < mediaEventTypes.length; i++) {
                  listenToNonDelegatedEvent(mediaEventTypes[i], domElement);
                }
                props = rawProps;
                break;
              case "source":
                listenToNonDelegatedEvent("error", domElement);
                props = rawProps;
                break;
              case "img":
              case "image":
              case "link":
                listenToNonDelegatedEvent("error", domElement);
                listenToNonDelegatedEvent("load", domElement);
                props = rawProps;
                break;
              case "details":
                listenToNonDelegatedEvent("toggle", domElement);
                props = rawProps;
                break;
              case "input":
                initWrapperState(domElement, rawProps);
                props = getHostProps(domElement, rawProps);
                listenToNonDelegatedEvent("invalid", domElement);
                break;
              case "option":
                validateProps(domElement, rawProps);
                props = rawProps;
                break;
              case "select":
                initWrapperState$1(domElement, rawProps);
                props = getHostProps$1(domElement, rawProps);
                listenToNonDelegatedEvent("invalid", domElement);
                break;
              case "textarea":
                initWrapperState$2(domElement, rawProps);
                props = getHostProps$2(domElement, rawProps);
                listenToNonDelegatedEvent("invalid", domElement);
                break;
              default:
                props = rawProps;
            }
            assertValidProps(tag, props);
            setInitialDOMProperties(tag, domElement, rootContainerElement, props, isCustomComponentTag);
            switch (tag) {
              case "input":
                track(domElement);
                postMountWrapper(domElement, rawProps, false);
                break;
              case "textarea":
                track(domElement);
                postMountWrapper$3(domElement);
                break;
              case "option":
                postMountWrapper$1(domElement, rawProps);
                break;
              case "select":
                postMountWrapper$2(domElement, rawProps);
                break;
              default:
                if (typeof props.onClick === "function") {
                  trapClickOnNonInteractiveElement(domElement);
                }
                break;
            }
          }
          function diffProperties(domElement, tag, lastRawProps, nextRawProps, rootContainerElement) {
            {
              validatePropertiesInDevelopment(tag, nextRawProps);
            }
            var updatePayload = null;
            var lastProps;
            var nextProps;
            switch (tag) {
              case "input":
                lastProps = getHostProps(domElement, lastRawProps);
                nextProps = getHostProps(domElement, nextRawProps);
                updatePayload = [];
                break;
              case "select":
                lastProps = getHostProps$1(domElement, lastRawProps);
                nextProps = getHostProps$1(domElement, nextRawProps);
                updatePayload = [];
                break;
              case "textarea":
                lastProps = getHostProps$2(domElement, lastRawProps);
                nextProps = getHostProps$2(domElement, nextRawProps);
                updatePayload = [];
                break;
              default:
                lastProps = lastRawProps;
                nextProps = nextRawProps;
                if (typeof lastProps.onClick !== "function" && typeof nextProps.onClick === "function") {
                  trapClickOnNonInteractiveElement(domElement);
                }
                break;
            }
            assertValidProps(tag, nextProps);
            var propKey;
            var styleName;
            var styleUpdates = null;
            for (propKey in lastProps) {
              if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {
                continue;
              }
              if (propKey === STYLE) {
                var lastStyle = lastProps[propKey];
                for (styleName in lastStyle) {
                  if (lastStyle.hasOwnProperty(styleName)) {
                    if (!styleUpdates) {
                      styleUpdates = {};
                    }
                    styleUpdates[styleName] = "";
                  }
                }
              } else if (propKey === DANGEROUSLY_SET_INNER_HTML || propKey === CHILDREN) ;
              else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING) ;
              else if (propKey === AUTOFOCUS) ;
              else if (registrationNameDependencies.hasOwnProperty(propKey)) {
                if (!updatePayload) {
                  updatePayload = [];
                }
              } else {
                (updatePayload = updatePayload || []).push(propKey, null);
              }
            }
            for (propKey in nextProps) {
              var nextProp = nextProps[propKey];
              var lastProp = lastProps != null ? lastProps[propKey] : void 0;
              if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {
                continue;
              }
              if (propKey === STYLE) {
                {
                  if (nextProp) {
                    Object.freeze(nextProp);
                  }
                }
                if (lastProp) {
                  for (styleName in lastProp) {
                    if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
                      if (!styleUpdates) {
                        styleUpdates = {};
                      }
                      styleUpdates[styleName] = "";
                    }
                  }
                  for (styleName in nextProp) {
                    if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
                      if (!styleUpdates) {
                        styleUpdates = {};
                      }
                      styleUpdates[styleName] = nextProp[styleName];
                    }
                  }
                } else {
                  if (!styleUpdates) {
                    if (!updatePayload) {
                      updatePayload = [];
                    }
                    updatePayload.push(propKey, styleUpdates);
                  }
                  styleUpdates = nextProp;
                }
              } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
                var nextHtml = nextProp ? nextProp[HTML$1] : void 0;
                var lastHtml = lastProp ? lastProp[HTML$1] : void 0;
                if (nextHtml != null) {
                  if (lastHtml !== nextHtml) {
                    (updatePayload = updatePayload || []).push(propKey, nextHtml);
                  }
                }
              } else if (propKey === CHILDREN) {
                if (typeof nextProp === "string" || typeof nextProp === "number") {
                  (updatePayload = updatePayload || []).push(propKey, "" + nextProp);
                }
              } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING) ;
              else if (registrationNameDependencies.hasOwnProperty(propKey)) {
                if (nextProp != null) {
                  if (typeof nextProp !== "function") {
                    warnForInvalidEventListener(propKey, nextProp);
                  }
                  if (propKey === "onScroll") {
                    listenToNonDelegatedEvent("scroll", domElement);
                  }
                }
                if (!updatePayload && lastProp !== nextProp) {
                  updatePayload = [];
                }
              } else {
                (updatePayload = updatePayload || []).push(propKey, nextProp);
              }
            }
            if (styleUpdates) {
              {
                validateShorthandPropertyCollisionInDev(styleUpdates, nextProps[STYLE]);
              }
              (updatePayload = updatePayload || []).push(STYLE, styleUpdates);
            }
            return updatePayload;
          }
          function updateProperties(domElement, updatePayload, tag, lastRawProps, nextRawProps) {
            if (tag === "input" && nextRawProps.type === "radio" && nextRawProps.name != null) {
              updateChecked(domElement, nextRawProps);
            }
            var wasCustomComponentTag = isCustomComponent(tag, lastRawProps);
            var isCustomComponentTag = isCustomComponent(tag, nextRawProps);
            updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag);
            switch (tag) {
              case "input":
                updateWrapper(domElement, nextRawProps);
                break;
              case "textarea":
                updateWrapper$1(domElement, nextRawProps);
                break;
              case "select":
                postUpdateWrapper(domElement, nextRawProps);
                break;
            }
          }
          function getPossibleStandardName(propName) {
            {
              var lowerCasedName = propName.toLowerCase();
              if (!possibleStandardNames.hasOwnProperty(lowerCasedName)) {
                return null;
              }
              return possibleStandardNames[lowerCasedName] || null;
            }
          }
          function diffHydratedProperties(domElement, tag, rawProps, parentNamespace, rootContainerElement, isConcurrentMode, shouldWarnDev) {
            var isCustomComponentTag;
            var extraAttributeNames;
            {
              isCustomComponentTag = isCustomComponent(tag, rawProps);
              validatePropertiesInDevelopment(tag, rawProps);
            }
            switch (tag) {
              case "dialog":
                listenToNonDelegatedEvent("cancel", domElement);
                listenToNonDelegatedEvent("close", domElement);
                break;
              case "iframe":
              case "object":
              case "embed":
                listenToNonDelegatedEvent("load", domElement);
                break;
              case "video":
              case "audio":
                for (var i = 0; i < mediaEventTypes.length; i++) {
                  listenToNonDelegatedEvent(mediaEventTypes[i], domElement);
                }
                break;
              case "source":
                listenToNonDelegatedEvent("error", domElement);
                break;
              case "img":
              case "image":
              case "link":
                listenToNonDelegatedEvent("error", domElement);
                listenToNonDelegatedEvent("load", domElement);
                break;
              case "details":
                listenToNonDelegatedEvent("toggle", domElement);
                break;
              case "input":
                initWrapperState(domElement, rawProps);
                listenToNonDelegatedEvent("invalid", domElement);
                break;
              case "option":
                validateProps(domElement, rawProps);
                break;
              case "select":
                initWrapperState$1(domElement, rawProps);
                listenToNonDelegatedEvent("invalid", domElement);
                break;
              case "textarea":
                initWrapperState$2(domElement, rawProps);
                listenToNonDelegatedEvent("invalid", domElement);
                break;
            }
            assertValidProps(tag, rawProps);
            {
              extraAttributeNames = /* @__PURE__ */ new Set();
              var attributes = domElement.attributes;
              for (var _i2 = 0; _i2 < attributes.length; _i2++) {
                var name = attributes[_i2].name.toLowerCase();
                switch (name) {
                  // Controlled attributes are not validated
                  // TODO: Only ignore them on controlled tags.
                  case "value":
                    break;
                  case "checked":
                    break;
                  case "selected":
                    break;
                  default:
                    extraAttributeNames.add(attributes[_i2].name);
                }
              }
            }
            var updatePayload = null;
            for (var propKey in rawProps) {
              if (!rawProps.hasOwnProperty(propKey)) {
                continue;
              }
              var nextProp = rawProps[propKey];
              if (propKey === CHILDREN) {
                if (typeof nextProp === "string") {
                  if (domElement.textContent !== nextProp) {
                    if (rawProps[SUPPRESS_HYDRATION_WARNING] !== true) {
                      checkForUnmatchedText(domElement.textContent, nextProp, isConcurrentMode, shouldWarnDev);
                    }
                    updatePayload = [CHILDREN, nextProp];
                  }
                } else if (typeof nextProp === "number") {
                  if (domElement.textContent !== "" + nextProp) {
                    if (rawProps[SUPPRESS_HYDRATION_WARNING] !== true) {
                      checkForUnmatchedText(domElement.textContent, nextProp, isConcurrentMode, shouldWarnDev);
                    }
                    updatePayload = [CHILDREN, "" + nextProp];
                  }
                }
              } else if (registrationNameDependencies.hasOwnProperty(propKey)) {
                if (nextProp != null) {
                  if (typeof nextProp !== "function") {
                    warnForInvalidEventListener(propKey, nextProp);
                  }
                  if (propKey === "onScroll") {
                    listenToNonDelegatedEvent("scroll", domElement);
                  }
                }
              } else if (shouldWarnDev && true && // Convince Flow we've calculated it (it's DEV-only in this method.)
              typeof isCustomComponentTag === "boolean") {
                var serverValue = void 0;
                var propertyInfo = isCustomComponentTag && enableCustomElementPropertySupport ? null : getPropertyInfo(propKey);
                if (rawProps[SUPPRESS_HYDRATION_WARNING] === true) ;
                else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING || // Controlled attributes are not validated
                // TODO: Only ignore them on controlled tags.
                propKey === "value" || propKey === "checked" || propKey === "selected") ;
                else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
                  var serverHTML = domElement.innerHTML;
                  var nextHtml = nextProp ? nextProp[HTML$1] : void 0;
                  if (nextHtml != null) {
                    var expectedHTML = normalizeHTML(domElement, nextHtml);
                    if (expectedHTML !== serverHTML) {
                      warnForPropDifference(propKey, serverHTML, expectedHTML);
                    }
                  }
                } else if (propKey === STYLE) {
                  extraAttributeNames.delete(propKey);
                  if (canDiffStyleForHydrationWarning) {
                    var expectedStyle = createDangerousStringForStyles(nextProp);
                    serverValue = domElement.getAttribute("style");
                    if (expectedStyle !== serverValue) {
                      warnForPropDifference(propKey, serverValue, expectedStyle);
                    }
                  }
                } else if (isCustomComponentTag && !enableCustomElementPropertySupport) {
                  extraAttributeNames.delete(propKey.toLowerCase());
                  serverValue = getValueForAttribute(domElement, propKey, nextProp);
                  if (nextProp !== serverValue) {
                    warnForPropDifference(propKey, serverValue, nextProp);
                  }
                } else if (!shouldIgnoreAttribute(propKey, propertyInfo, isCustomComponentTag) && !shouldRemoveAttribute(propKey, nextProp, propertyInfo, isCustomComponentTag)) {
                  var isMismatchDueToBadCasing = false;
                  if (propertyInfo !== null) {
                    extraAttributeNames.delete(propertyInfo.attributeName);
                    serverValue = getValueForProperty(domElement, propKey, nextProp, propertyInfo);
                  } else {
                    var ownNamespace = parentNamespace;
                    if (ownNamespace === HTML_NAMESPACE) {
                      ownNamespace = getIntrinsicNamespace(tag);
                    }
                    if (ownNamespace === HTML_NAMESPACE) {
                      extraAttributeNames.delete(propKey.toLowerCase());
                    } else {
                      var standardName = getPossibleStandardName(propKey);
                      if (standardName !== null && standardName !== propKey) {
                        isMismatchDueToBadCasing = true;
                        extraAttributeNames.delete(standardName);
                      }
                      extraAttributeNames.delete(propKey);
                    }
                    serverValue = getValueForAttribute(domElement, propKey, nextProp);
                  }
                  var dontWarnCustomElement = enableCustomElementPropertySupport;
                  if (!dontWarnCustomElement && nextProp !== serverValue && !isMismatchDueToBadCasing) {
                    warnForPropDifference(propKey, serverValue, nextProp);
                  }
                }
              }
            }
            {
              if (shouldWarnDev) {
                if (
                  // $FlowFixMe - Should be inferred as not undefined.
                  extraAttributeNames.size > 0 && rawProps[SUPPRESS_HYDRATION_WARNING] !== true
                ) {
                  warnForExtraAttributes(extraAttributeNames);
                }
              }
            }
            switch (tag) {
              case "input":
                track(domElement);
                postMountWrapper(domElement, rawProps, true);
                break;
              case "textarea":
                track(domElement);
                postMountWrapper$3(domElement);
                break;
              case "select":
              case "option":
                break;
              default:
                if (typeof rawProps.onClick === "function") {
                  trapClickOnNonInteractiveElement(domElement);
                }
                break;
            }
            return updatePayload;
          }
          function diffHydratedText(textNode, text, isConcurrentMode) {
            var isDifferent = textNode.nodeValue !== text;
            return isDifferent;
          }
          function warnForDeletedHydratableElement(parentNode, child) {
            {
              if (didWarnInvalidHydration) {
                return;
              }
              didWarnInvalidHydration = true;
              error("Did not expect server HTML to contain a <%s> in <%s>.", child.nodeName.toLowerCase(), parentNode.nodeName.toLowerCase());
            }
          }
          function warnForDeletedHydratableText(parentNode, child) {
            {
              if (didWarnInvalidHydration) {
                return;
              }
              didWarnInvalidHydration = true;
              error('Did not expect server HTML to contain the text node "%s" in <%s>.', child.nodeValue, parentNode.nodeName.toLowerCase());
            }
          }
          function warnForInsertedHydratedElement(parentNode, tag, props) {
            {
              if (didWarnInvalidHydration) {
                return;
              }
              didWarnInvalidHydration = true;
              error("Expected server HTML to contain a matching <%s> in <%s>.", tag, parentNode.nodeName.toLowerCase());
            }
          }
          function warnForInsertedHydratedText(parentNode, text) {
            {
              if (text === "") {
                return;
              }
              if (didWarnInvalidHydration) {
                return;
              }
              didWarnInvalidHydration = true;
              error('Expected server HTML to contain a matching text node for "%s" in <%s>.', text, parentNode.nodeName.toLowerCase());
            }
          }
          function restoreControlledState$3(domElement, tag, props) {
            switch (tag) {
              case "input":
                restoreControlledState(domElement, props);
                return;
              case "textarea":
                restoreControlledState$2(domElement, props);
                return;
              case "select":
                restoreControlledState$1(domElement, props);
                return;
            }
          }
          var validateDOMNesting = function() {
          };
          var updatedAncestorInfo = function() {
          };
          {
            var specialTags = ["address", "applet", "area", "article", "aside", "base", "basefont", "bgsound", "blockquote", "body", "br", "button", "caption", "center", "col", "colgroup", "dd", "details", "dir", "div", "dl", "dt", "embed", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "iframe", "img", "input", "isindex", "li", "link", "listing", "main", "marquee", "menu", "menuitem", "meta", "nav", "noembed", "noframes", "noscript", "object", "ol", "p", "param", "plaintext", "pre", "script", "section", "select", "source", "style", "summary", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "title", "tr", "track", "ul", "wbr", "xmp"];
            var inScopeTags = [
              "applet",
              "caption",
              "html",
              "table",
              "td",
              "th",
              "marquee",
              "object",
              "template",
              // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
              // TODO: Distinguish by namespace here -- for <title>, including it here
              // errs on the side of fewer warnings
              "foreignObject",
              "desc",
              "title"
            ];
            var buttonScopeTags = inScopeTags.concat(["button"]);
            var impliedEndTags = ["dd", "dt", "li", "option", "optgroup", "p", "rp", "rt"];
            var emptyAncestorInfo = {
              current: null,
              formTag: null,
              aTagInScope: null,
              buttonTagInScope: null,
              nobrTagInScope: null,
              pTagInButtonScope: null,
              listItemTagAutoclosing: null,
              dlItemTagAutoclosing: null
            };
            updatedAncestorInfo = function(oldInfo, tag) {
              var ancestorInfo = assign({}, oldInfo || emptyAncestorInfo);
              var info = {
                tag
              };
              if (inScopeTags.indexOf(tag) !== -1) {
                ancestorInfo.aTagInScope = null;
                ancestorInfo.buttonTagInScope = null;
                ancestorInfo.nobrTagInScope = null;
              }
              if (buttonScopeTags.indexOf(tag) !== -1) {
                ancestorInfo.pTagInButtonScope = null;
              }
              if (specialTags.indexOf(tag) !== -1 && tag !== "address" && tag !== "div" && tag !== "p") {
                ancestorInfo.listItemTagAutoclosing = null;
                ancestorInfo.dlItemTagAutoclosing = null;
              }
              ancestorInfo.current = info;
              if (tag === "form") {
                ancestorInfo.formTag = info;
              }
              if (tag === "a") {
                ancestorInfo.aTagInScope = info;
              }
              if (tag === "button") {
                ancestorInfo.buttonTagInScope = info;
              }
              if (tag === "nobr") {
                ancestorInfo.nobrTagInScope = info;
              }
              if (tag === "p") {
                ancestorInfo.pTagInButtonScope = info;
              }
              if (tag === "li") {
                ancestorInfo.listItemTagAutoclosing = info;
              }
              if (tag === "dd" || tag === "dt") {
                ancestorInfo.dlItemTagAutoclosing = info;
              }
              return ancestorInfo;
            };
            var isTagValidWithParent = function(tag, parentTag) {
              switch (parentTag) {
                // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
                case "select":
                  return tag === "option" || tag === "optgroup" || tag === "#text";
                case "optgroup":
                  return tag === "option" || tag === "#text";
                // Strictly speaking, seeing an <option> doesn't mean we're in a <select>
                // but
                case "option":
                  return tag === "#text";
                // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
                // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
                // No special behavior since these rules fall back to "in body" mode for
                // all except special table nodes which cause bad parsing behavior anyway.
                // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
                case "tr":
                  return tag === "th" || tag === "td" || tag === "style" || tag === "script" || tag === "template";
                // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
                case "tbody":
                case "thead":
                case "tfoot":
                  return tag === "tr" || tag === "style" || tag === "script" || tag === "template";
                // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
                case "colgroup":
                  return tag === "col" || tag === "template";
                // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
                case "table":
                  return tag === "caption" || tag === "colgroup" || tag === "tbody" || tag === "tfoot" || tag === "thead" || tag === "style" || tag === "script" || tag === "template";
                // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
                case "head":
                  return tag === "base" || tag === "basefont" || tag === "bgsound" || tag === "link" || tag === "meta" || tag === "title" || tag === "noscript" || tag === "noframes" || tag === "style" || tag === "script" || tag === "template";
                // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
                case "html":
                  return tag === "head" || tag === "body" || tag === "frameset";
                case "frameset":
                  return tag === "frame";
                case "#document":
                  return tag === "html";
              }
              switch (tag) {
                case "h1":
                case "h2":
                case "h3":
                case "h4":
                case "h5":
                case "h6":
                  return parentTag !== "h1" && parentTag !== "h2" && parentTag !== "h3" && parentTag !== "h4" && parentTag !== "h5" && parentTag !== "h6";
                case "rp":
                case "rt":
                  return impliedEndTags.indexOf(parentTag) === -1;
                case "body":
                case "caption":
                case "col":
                case "colgroup":
                case "frameset":
                case "frame":
                case "head":
                case "html":
                case "tbody":
                case "td":
                case "tfoot":
                case "th":
                case "thead":
                case "tr":
                  return parentTag == null;
              }
              return true;
            };
            var findInvalidAncestorForTag = function(tag, ancestorInfo) {
              switch (tag) {
                case "address":
                case "article":
                case "aside":
                case "blockquote":
                case "center":
                case "details":
                case "dialog":
                case "dir":
                case "div":
                case "dl":
                case "fieldset":
                case "figcaption":
                case "figure":
                case "footer":
                case "header":
                case "hgroup":
                case "main":
                case "menu":
                case "nav":
                case "ol":
                case "p":
                case "section":
                case "summary":
                case "ul":
                case "pre":
                case "listing":
                case "table":
                case "hr":
                case "xmp":
                case "h1":
                case "h2":
                case "h3":
                case "h4":
                case "h5":
                case "h6":
                  return ancestorInfo.pTagInButtonScope;
                case "form":
                  return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
                case "li":
                  return ancestorInfo.listItemTagAutoclosing;
                case "dd":
                case "dt":
                  return ancestorInfo.dlItemTagAutoclosing;
                case "button":
                  return ancestorInfo.buttonTagInScope;
                case "a":
                  return ancestorInfo.aTagInScope;
                case "nobr":
                  return ancestorInfo.nobrTagInScope;
              }
              return null;
            };
            var didWarn$1 = {};
            validateDOMNesting = function(childTag, childText, ancestorInfo) {
              ancestorInfo = ancestorInfo || emptyAncestorInfo;
              var parentInfo = ancestorInfo.current;
              var parentTag = parentInfo && parentInfo.tag;
              if (childText != null) {
                if (childTag != null) {
                  error("validateDOMNesting: when childText is passed, childTag should be null");
                }
                childTag = "#text";
              }
              var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
              var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
              var invalidParentOrAncestor = invalidParent || invalidAncestor;
              if (!invalidParentOrAncestor) {
                return;
              }
              var ancestorTag = invalidParentOrAncestor.tag;
              var warnKey = !!invalidParent + "|" + childTag + "|" + ancestorTag;
              if (didWarn$1[warnKey]) {
                return;
              }
              didWarn$1[warnKey] = true;
              var tagDisplayName = childTag;
              var whitespaceInfo = "";
              if (childTag === "#text") {
                if (/\S/.test(childText)) {
                  tagDisplayName = "Text nodes";
                } else {
                  tagDisplayName = "Whitespace text nodes";
                  whitespaceInfo = " Make sure you don't have any extra whitespace between tags on each line of your source code.";
                }
              } else {
                tagDisplayName = "<" + childTag + ">";
              }
              if (invalidParent) {
                var info = "";
                if (ancestorTag === "table" && childTag === "tr") {
                  info += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser.";
                }
                error("validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s", tagDisplayName, ancestorTag, whitespaceInfo, info);
              } else {
                error("validateDOMNesting(...): %s cannot appear as a descendant of <%s>.", tagDisplayName, ancestorTag);
              }
            };
          }
          var SUPPRESS_HYDRATION_WARNING$1 = "suppressHydrationWarning";
          var SUSPENSE_START_DATA = "$";
          var SUSPENSE_END_DATA = "/$";
          var SUSPENSE_PENDING_START_DATA = "$?";
          var SUSPENSE_FALLBACK_START_DATA = "$!";
          var STYLE$1 = "style";
          var eventsEnabled = null;
          var selectionInformation = null;
          function getRootHostContext(rootContainerInstance) {
            var type;
            var namespace;
            var nodeType = rootContainerInstance.nodeType;
            switch (nodeType) {
              case DOCUMENT_NODE:
              case DOCUMENT_FRAGMENT_NODE: {
                type = nodeType === DOCUMENT_NODE ? "#document" : "#fragment";
                var root3 = rootContainerInstance.documentElement;
                namespace = root3 ? root3.namespaceURI : getChildNamespace(null, "");
                break;
              }
              default: {
                var container2 = nodeType === COMMENT_NODE ? rootContainerInstance.parentNode : rootContainerInstance;
                var ownNamespace = container2.namespaceURI || null;
                type = container2.tagName;
                namespace = getChildNamespace(ownNamespace, type);
                break;
              }
            }
            {
              var validatedTag = type.toLowerCase();
              var ancestorInfo = updatedAncestorInfo(null, validatedTag);
              return {
                namespace,
                ancestorInfo
              };
            }
          }
          function getChildHostContext(parentHostContext, type, rootContainerInstance) {
            {
              var parentHostContextDev = parentHostContext;
              var namespace = getChildNamespace(parentHostContextDev.namespace, type);
              var ancestorInfo = updatedAncestorInfo(parentHostContextDev.ancestorInfo, type);
              return {
                namespace,
                ancestorInfo
              };
            }
          }
          function getPublicInstance(instance) {
            return instance;
          }
          function prepareForCommit(containerInfo) {
            eventsEnabled = isEnabled();
            selectionInformation = getSelectionInformation();
            var activeInstance = null;
            setEnabled(false);
            return activeInstance;
          }
          function resetAfterCommit(containerInfo) {
            restoreSelection(selectionInformation);
            setEnabled(eventsEnabled);
            eventsEnabled = null;
            selectionInformation = null;
          }
          function createInstance(type, props, rootContainerInstance, hostContext, internalInstanceHandle) {
            var parentNamespace;
            {
              var hostContextDev = hostContext;
              validateDOMNesting(type, null, hostContextDev.ancestorInfo);
              if (typeof props.children === "string" || typeof props.children === "number") {
                var string = "" + props.children;
                var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);
                validateDOMNesting(null, string, ownAncestorInfo);
              }
              parentNamespace = hostContextDev.namespace;
            }
            var domElement = createElement4(type, props, rootContainerInstance, parentNamespace);
            precacheFiberNode(internalInstanceHandle, domElement);
            updateFiberProps(domElement, props);
            return domElement;
          }
          function appendInitialChild(parentInstance, child) {
            parentInstance.appendChild(child);
          }
          function finalizeInitialChildren(domElement, type, props, rootContainerInstance, hostContext) {
            setInitialProperties(domElement, type, props, rootContainerInstance);
            switch (type) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                return !!props.autoFocus;
              case "img":
                return true;
              default:
                return false;
            }
          }
          function prepareUpdate(domElement, type, oldProps, newProps, rootContainerInstance, hostContext) {
            {
              var hostContextDev = hostContext;
              if (typeof newProps.children !== typeof oldProps.children && (typeof newProps.children === "string" || typeof newProps.children === "number")) {
                var string = "" + newProps.children;
                var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);
                validateDOMNesting(null, string, ownAncestorInfo);
              }
            }
            return diffProperties(domElement, type, oldProps, newProps);
          }
          function shouldSetTextContent(type, props) {
            return type === "textarea" || type === "noscript" || typeof props.children === "string" || typeof props.children === "number" || typeof props.dangerouslySetInnerHTML === "object" && props.dangerouslySetInnerHTML !== null && props.dangerouslySetInnerHTML.__html != null;
          }
          function createTextInstance(text, rootContainerInstance, hostContext, internalInstanceHandle) {
            {
              var hostContextDev = hostContext;
              validateDOMNesting(null, text, hostContextDev.ancestorInfo);
            }
            var textNode = createTextNode(text, rootContainerInstance);
            precacheFiberNode(internalInstanceHandle, textNode);
            return textNode;
          }
          function getCurrentEventPriority() {
            var currentEvent = window.event;
            if (currentEvent === void 0) {
              return DefaultEventPriority;
            }
            return getEventPriority(currentEvent.type);
          }
          var scheduleTimeout = typeof setTimeout === "function" ? setTimeout : void 0;
          var cancelTimeout = typeof clearTimeout === "function" ? clearTimeout : void 0;
          var noTimeout = -1;
          var localPromise = typeof Promise === "function" ? Promise : void 0;
          var scheduleMicrotask = typeof queueMicrotask === "function" ? queueMicrotask : typeof localPromise !== "undefined" ? function(callback) {
            return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick);
          } : scheduleTimeout;
          function handleErrorInNextTick(error2) {
            setTimeout(function() {
              throw error2;
            });
          }
          function commitMount(domElement, type, newProps, internalInstanceHandle) {
            switch (type) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                if (newProps.autoFocus) {
                  domElement.focus();
                }
                return;
              case "img": {
                if (newProps.src) {
                  domElement.src = newProps.src;
                }
                return;
              }
            }
          }
          function commitUpdate(domElement, updatePayload, type, oldProps, newProps, internalInstanceHandle) {
            updateProperties(domElement, updatePayload, type, oldProps, newProps);
            updateFiberProps(domElement, newProps);
          }
          function resetTextContent(domElement) {
            setTextContent(domElement, "");
          }
          function commitTextUpdate(textInstance, oldText, newText) {
            textInstance.nodeValue = newText;
          }
          function appendChild(parentInstance, child) {
            parentInstance.appendChild(child);
          }
          function appendChildToContainer(container2, child) {
            var parentNode;
            if (container2.nodeType === COMMENT_NODE) {
              parentNode = container2.parentNode;
              parentNode.insertBefore(child, container2);
            } else {
              parentNode = container2;
              parentNode.appendChild(child);
            }
            var reactRootContainer = container2._reactRootContainer;
            if ((reactRootContainer === null || reactRootContainer === void 0) && parentNode.onclick === null) {
              trapClickOnNonInteractiveElement(parentNode);
            }
          }
          function insertBefore(parentInstance, child, beforeChild) {
            parentInstance.insertBefore(child, beforeChild);
          }
          function insertInContainerBefore(container2, child, beforeChild) {
            if (container2.nodeType === COMMENT_NODE) {
              container2.parentNode.insertBefore(child, beforeChild);
            } else {
              container2.insertBefore(child, beforeChild);
            }
          }
          function removeChild(parentInstance, child) {
            parentInstance.removeChild(child);
          }
          function removeChildFromContainer(container2, child) {
            if (container2.nodeType === COMMENT_NODE) {
              container2.parentNode.removeChild(child);
            } else {
              container2.removeChild(child);
            }
          }
          function clearSuspenseBoundary(parentInstance, suspenseInstance) {
            var node = suspenseInstance;
            var depth = 0;
            do {
              var nextNode = node.nextSibling;
              parentInstance.removeChild(node);
              if (nextNode && nextNode.nodeType === COMMENT_NODE) {
                var data = nextNode.data;
                if (data === SUSPENSE_END_DATA) {
                  if (depth === 0) {
                    parentInstance.removeChild(nextNode);
                    retryIfBlockedOn(suspenseInstance);
                    return;
                  } else {
                    depth--;
                  }
                } else if (data === SUSPENSE_START_DATA || data === SUSPENSE_PENDING_START_DATA || data === SUSPENSE_FALLBACK_START_DATA) {
                  depth++;
                }
              }
              node = nextNode;
            } while (node);
            retryIfBlockedOn(suspenseInstance);
          }
          function clearSuspenseBoundaryFromContainer(container2, suspenseInstance) {
            if (container2.nodeType === COMMENT_NODE) {
              clearSuspenseBoundary(container2.parentNode, suspenseInstance);
            } else if (container2.nodeType === ELEMENT_NODE) {
              clearSuspenseBoundary(container2, suspenseInstance);
            }
            retryIfBlockedOn(container2);
          }
          function hideInstance(instance) {
            instance = instance;
            var style2 = instance.style;
            if (typeof style2.setProperty === "function") {
              style2.setProperty("display", "none", "important");
            } else {
              style2.display = "none";
            }
          }
          function hideTextInstance(textInstance) {
            textInstance.nodeValue = "";
          }
          function unhideInstance(instance, props) {
            instance = instance;
            var styleProp = props[STYLE$1];
            var display = styleProp !== void 0 && styleProp !== null && styleProp.hasOwnProperty("display") ? styleProp.display : null;
            instance.style.display = dangerousStyleValue("display", display);
          }
          function unhideTextInstance(textInstance, text) {
            textInstance.nodeValue = text;
          }
          function clearContainer(container2) {
            if (container2.nodeType === ELEMENT_NODE) {
              container2.textContent = "";
            } else if (container2.nodeType === DOCUMENT_NODE) {
              if (container2.documentElement) {
                container2.removeChild(container2.documentElement);
              }
            }
          }
          function canHydrateInstance(instance, type, props) {
            if (instance.nodeType !== ELEMENT_NODE || type.toLowerCase() !== instance.nodeName.toLowerCase()) {
              return null;
            }
            return instance;
          }
          function canHydrateTextInstance(instance, text) {
            if (text === "" || instance.nodeType !== TEXT_NODE) {
              return null;
            }
            return instance;
          }
          function canHydrateSuspenseInstance(instance) {
            if (instance.nodeType !== COMMENT_NODE) {
              return null;
            }
            return instance;
          }
          function isSuspenseInstancePending(instance) {
            return instance.data === SUSPENSE_PENDING_START_DATA;
          }
          function isSuspenseInstanceFallback(instance) {
            return instance.data === SUSPENSE_FALLBACK_START_DATA;
          }
          function getSuspenseInstanceFallbackErrorDetails(instance) {
            var dataset = instance.nextSibling && instance.nextSibling.dataset;
            var digest, message, stack;
            if (dataset) {
              digest = dataset.dgst;
              {
                message = dataset.msg;
                stack = dataset.stck;
              }
            }
            {
              return {
                message,
                digest,
                stack
              };
            }
          }
          function registerSuspenseInstanceRetry(instance, callback) {
            instance._reactRetry = callback;
          }
          function getNextHydratable(node) {
            for (; node != null; node = node.nextSibling) {
              var nodeType = node.nodeType;
              if (nodeType === ELEMENT_NODE || nodeType === TEXT_NODE) {
                break;
              }
              if (nodeType === COMMENT_NODE) {
                var nodeData = node.data;
                if (nodeData === SUSPENSE_START_DATA || nodeData === SUSPENSE_FALLBACK_START_DATA || nodeData === SUSPENSE_PENDING_START_DATA) {
                  break;
                }
                if (nodeData === SUSPENSE_END_DATA) {
                  return null;
                }
              }
            }
            return node;
          }
          function getNextHydratableSibling(instance) {
            return getNextHydratable(instance.nextSibling);
          }
          function getFirstHydratableChild(parentInstance) {
            return getNextHydratable(parentInstance.firstChild);
          }
          function getFirstHydratableChildWithinContainer(parentContainer) {
            return getNextHydratable(parentContainer.firstChild);
          }
          function getFirstHydratableChildWithinSuspenseInstance(parentInstance) {
            return getNextHydratable(parentInstance.nextSibling);
          }
          function hydrateInstance(instance, type, props, rootContainerInstance, hostContext, internalInstanceHandle, shouldWarnDev) {
            precacheFiberNode(internalInstanceHandle, instance);
            updateFiberProps(instance, props);
            var parentNamespace;
            {
              var hostContextDev = hostContext;
              parentNamespace = hostContextDev.namespace;
            }
            var isConcurrentMode = (internalInstanceHandle.mode & ConcurrentMode) !== NoMode;
            return diffHydratedProperties(instance, type, props, parentNamespace, rootContainerInstance, isConcurrentMode, shouldWarnDev);
          }
          function hydrateTextInstance(textInstance, text, internalInstanceHandle, shouldWarnDev) {
            precacheFiberNode(internalInstanceHandle, textInstance);
            var isConcurrentMode = (internalInstanceHandle.mode & ConcurrentMode) !== NoMode;
            return diffHydratedText(textInstance, text);
          }
          function hydrateSuspenseInstance(suspenseInstance, internalInstanceHandle) {
            precacheFiberNode(internalInstanceHandle, suspenseInstance);
          }
          function getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance) {
            var node = suspenseInstance.nextSibling;
            var depth = 0;
            while (node) {
              if (node.nodeType === COMMENT_NODE) {
                var data = node.data;
                if (data === SUSPENSE_END_DATA) {
                  if (depth === 0) {
                    return getNextHydratableSibling(node);
                  } else {
                    depth--;
                  }
                } else if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {
                  depth++;
                }
              }
              node = node.nextSibling;
            }
            return null;
          }
          function getParentSuspenseInstance(targetInstance) {
            var node = targetInstance.previousSibling;
            var depth = 0;
            while (node) {
              if (node.nodeType === COMMENT_NODE) {
                var data = node.data;
                if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {
                  if (depth === 0) {
                    return node;
                  } else {
                    depth--;
                  }
                } else if (data === SUSPENSE_END_DATA) {
                  depth++;
                }
              }
              node = node.previousSibling;
            }
            return null;
          }
          function commitHydratedContainer(container2) {
            retryIfBlockedOn(container2);
          }
          function commitHydratedSuspenseInstance(suspenseInstance) {
            retryIfBlockedOn(suspenseInstance);
          }
          function shouldDeleteUnhydratedTailInstances(parentType) {
            return parentType !== "head" && parentType !== "body";
          }
          function didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, text, isConcurrentMode) {
            var shouldWarnDev = true;
            checkForUnmatchedText(textInstance.nodeValue, text, isConcurrentMode, shouldWarnDev);
          }
          function didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, text, isConcurrentMode) {
            if (parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
              var shouldWarnDev = true;
              checkForUnmatchedText(textInstance.nodeValue, text, isConcurrentMode, shouldWarnDev);
            }
          }
          function didNotHydrateInstanceWithinContainer(parentContainer, instance) {
            {
              if (instance.nodeType === ELEMENT_NODE) {
                warnForDeletedHydratableElement(parentContainer, instance);
              } else if (instance.nodeType === COMMENT_NODE) ;
              else {
                warnForDeletedHydratableText(parentContainer, instance);
              }
            }
          }
          function didNotHydrateInstanceWithinSuspenseInstance(parentInstance, instance) {
            {
              var parentNode = parentInstance.parentNode;
              if (parentNode !== null) {
                if (instance.nodeType === ELEMENT_NODE) {
                  warnForDeletedHydratableElement(parentNode, instance);
                } else if (instance.nodeType === COMMENT_NODE) ;
                else {
                  warnForDeletedHydratableText(parentNode, instance);
                }
              }
            }
          }
          function didNotHydrateInstance(parentType, parentProps, parentInstance, instance, isConcurrentMode) {
            {
              if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
                if (instance.nodeType === ELEMENT_NODE) {
                  warnForDeletedHydratableElement(parentInstance, instance);
                } else if (instance.nodeType === COMMENT_NODE) ;
                else {
                  warnForDeletedHydratableText(parentInstance, instance);
                }
              }
            }
          }
          function didNotFindHydratableInstanceWithinContainer(parentContainer, type, props) {
            {
              warnForInsertedHydratedElement(parentContainer, type);
            }
          }
          function didNotFindHydratableTextInstanceWithinContainer(parentContainer, text) {
            {
              warnForInsertedHydratedText(parentContainer, text);
            }
          }
          function didNotFindHydratableInstanceWithinSuspenseInstance(parentInstance, type, props) {
            {
              var parentNode = parentInstance.parentNode;
              if (parentNode !== null) warnForInsertedHydratedElement(parentNode, type);
            }
          }
          function didNotFindHydratableTextInstanceWithinSuspenseInstance(parentInstance, text) {
            {
              var parentNode = parentInstance.parentNode;
              if (parentNode !== null) warnForInsertedHydratedText(parentNode, text);
            }
          }
          function didNotFindHydratableInstance(parentType, parentProps, parentInstance, type, props, isConcurrentMode) {
            {
              if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
                warnForInsertedHydratedElement(parentInstance, type);
              }
            }
          }
          function didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, text, isConcurrentMode) {
            {
              if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
                warnForInsertedHydratedText(parentInstance, text);
              }
            }
          }
          function errorHydratingContainer(parentContainer) {
            {
              error("An error occurred during hydration. The server HTML was replaced with client content in <%s>.", parentContainer.nodeName.toLowerCase());
            }
          }
          function preparePortalMount(portalInstance) {
            listenToAllSupportedEvents(portalInstance);
          }
          var randomKey = Math.random().toString(36).slice(2);
          var internalInstanceKey = "__reactFiber$" + randomKey;
          var internalPropsKey = "__reactProps$" + randomKey;
          var internalContainerInstanceKey = "__reactContainer$" + randomKey;
          var internalEventHandlersKey = "__reactEvents$" + randomKey;
          var internalEventHandlerListenersKey = "__reactListeners$" + randomKey;
          var internalEventHandlesSetKey = "__reactHandles$" + randomKey;
          function detachDeletedInstance(node) {
            delete node[internalInstanceKey];
            delete node[internalPropsKey];
            delete node[internalEventHandlersKey];
            delete node[internalEventHandlerListenersKey];
            delete node[internalEventHandlesSetKey];
          }
          function precacheFiberNode(hostInst, node) {
            node[internalInstanceKey] = hostInst;
          }
          function markContainerAsRoot(hostRoot, node) {
            node[internalContainerInstanceKey] = hostRoot;
          }
          function unmarkContainerAsRoot(node) {
            node[internalContainerInstanceKey] = null;
          }
          function isContainerMarkedAsRoot(node) {
            return !!node[internalContainerInstanceKey];
          }
          function getClosestInstanceFromNode(targetNode) {
            var targetInst = targetNode[internalInstanceKey];
            if (targetInst) {
              return targetInst;
            }
            var parentNode = targetNode.parentNode;
            while (parentNode) {
              targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey];
              if (targetInst) {
                var alternate = targetInst.alternate;
                if (targetInst.child !== null || alternate !== null && alternate.child !== null) {
                  var suspenseInstance = getParentSuspenseInstance(targetNode);
                  while (suspenseInstance !== null) {
                    var targetSuspenseInst = suspenseInstance[internalInstanceKey];
                    if (targetSuspenseInst) {
                      return targetSuspenseInst;
                    }
                    suspenseInstance = getParentSuspenseInstance(suspenseInstance);
                  }
                }
                return targetInst;
              }
              targetNode = parentNode;
              parentNode = targetNode.parentNode;
            }
            return null;
          }
          function getInstanceFromNode(node) {
            var inst = node[internalInstanceKey] || node[internalContainerInstanceKey];
            if (inst) {
              if (inst.tag === HostComponent || inst.tag === HostText || inst.tag === SuspenseComponent || inst.tag === HostRoot) {
                return inst;
              } else {
                return null;
              }
            }
            return null;
          }
          function getNodeFromInstance(inst) {
            if (inst.tag === HostComponent || inst.tag === HostText) {
              return inst.stateNode;
            }
            throw new Error("getNodeFromInstance: Invalid argument.");
          }
          function getFiberCurrentPropsFromNode(node) {
            return node[internalPropsKey] || null;
          }
          function updateFiberProps(node, props) {
            node[internalPropsKey] = props;
          }
          function getEventListenerSet(node) {
            var elementListenerSet = node[internalEventHandlersKey];
            if (elementListenerSet === void 0) {
              elementListenerSet = node[internalEventHandlersKey] = /* @__PURE__ */ new Set();
            }
            return elementListenerSet;
          }
          var loggedTypeFailures = {};
          var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
          function setCurrentlyValidatingElement(element) {
            {
              if (element) {
                var owner = element._owner;
                var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
              } else {
                ReactDebugCurrentFrame$1.setExtraStackFrame(null);
              }
            }
          }
          function checkPropTypes(typeSpecs, values, location2, componentName, element) {
            {
              var has2 = Function.call.bind(hasOwnProperty);
              for (var typeSpecName in typeSpecs) {
                if (has2(typeSpecs, typeSpecName)) {
                  var error$1 = void 0;
                  try {
                    if (typeof typeSpecs[typeSpecName] !== "function") {
                      var err = Error((componentName || "React class") + ": " + location2 + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                      err.name = "Invariant Violation";
                      throw err;
                    }
                    error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location2, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                  } catch (ex) {
                    error$1 = ex;
                  }
                  if (error$1 && !(error$1 instanceof Error)) {
                    setCurrentlyValidatingElement(element);
                    error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location2, typeSpecName, typeof error$1);
                    setCurrentlyValidatingElement(null);
                  }
                  if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                    loggedTypeFailures[error$1.message] = true;
                    setCurrentlyValidatingElement(element);
                    error("Failed %s type: %s", location2, error$1.message);
                    setCurrentlyValidatingElement(null);
                  }
                }
              }
            }
          }
          var valueStack = [];
          var fiberStack;
          {
            fiberStack = [];
          }
          var index = -1;
          function createCursor(defaultValue) {
            return {
              current: defaultValue
            };
          }
          function pop(cursor, fiber) {
            if (index < 0) {
              {
                error("Unexpected pop.");
              }
              return;
            }
            {
              if (fiber !== fiberStack[index]) {
                error("Unexpected Fiber popped.");
              }
            }
            cursor.current = valueStack[index];
            valueStack[index] = null;
            {
              fiberStack[index] = null;
            }
            index--;
          }
          function push2(cursor, value, fiber) {
            index++;
            valueStack[index] = cursor.current;
            {
              fiberStack[index] = fiber;
            }
            cursor.current = value;
          }
          var warnedAboutMissingGetChildContext;
          {
            warnedAboutMissingGetChildContext = {};
          }
          var emptyContextObject = {};
          {
            Object.freeze(emptyContextObject);
          }
          var contextStackCursor = createCursor(emptyContextObject);
          var didPerformWorkStackCursor = createCursor(false);
          var previousContext = emptyContextObject;
          function getUnmaskedContext(workInProgress2, Component3, didPushOwnContextIfProvider) {
            {
              if (didPushOwnContextIfProvider && isContextProvider(Component3)) {
                return previousContext;
              }
              return contextStackCursor.current;
            }
          }
          function cacheContext(workInProgress2, unmaskedContext, maskedContext) {
            {
              var instance = workInProgress2.stateNode;
              instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;
              instance.__reactInternalMemoizedMaskedChildContext = maskedContext;
            }
          }
          function getMaskedContext(workInProgress2, unmaskedContext) {
            {
              var type = workInProgress2.type;
              var contextTypes = type.contextTypes;
              if (!contextTypes) {
                return emptyContextObject;
              }
              var instance = workInProgress2.stateNode;
              if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {
                return instance.__reactInternalMemoizedMaskedChildContext;
              }
              var context3 = {};
              for (var key in contextTypes) {
                context3[key] = unmaskedContext[key];
              }
              {
                var name = getComponentNameFromFiber(workInProgress2) || "Unknown";
                checkPropTypes(contextTypes, context3, "context", name);
              }
              if (instance) {
                cacheContext(workInProgress2, unmaskedContext, context3);
              }
              return context3;
            }
          }
          function hasContextChanged() {
            {
              return didPerformWorkStackCursor.current;
            }
          }
          function isContextProvider(type) {
            {
              var childContextTypes = type.childContextTypes;
              return childContextTypes !== null && childContextTypes !== void 0;
            }
          }
          function popContext(fiber) {
            {
              pop(didPerformWorkStackCursor, fiber);
              pop(contextStackCursor, fiber);
            }
          }
          function popTopLevelContextObject(fiber) {
            {
              pop(didPerformWorkStackCursor, fiber);
              pop(contextStackCursor, fiber);
            }
          }
          function pushTopLevelContextObject(fiber, context3, didChange) {
            {
              if (contextStackCursor.current !== emptyContextObject) {
                throw new Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
              }
              push2(contextStackCursor, context3, fiber);
              push2(didPerformWorkStackCursor, didChange, fiber);
            }
          }
          function processChildContext(fiber, type, parentContext) {
            {
              var instance = fiber.stateNode;
              var childContextTypes = type.childContextTypes;
              if (typeof instance.getChildContext !== "function") {
                {
                  var componentName = getComponentNameFromFiber(fiber) || "Unknown";
                  if (!warnedAboutMissingGetChildContext[componentName]) {
                    warnedAboutMissingGetChildContext[componentName] = true;
                    error("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", componentName, componentName);
                  }
                }
                return parentContext;
              }
              var childContext = instance.getChildContext();
              for (var contextKey in childContext) {
                if (!(contextKey in childContextTypes)) {
                  throw new Error((getComponentNameFromFiber(fiber) || "Unknown") + '.getChildContext(): key "' + contextKey + '" is not defined in childContextTypes.');
                }
              }
              {
                var name = getComponentNameFromFiber(fiber) || "Unknown";
                checkPropTypes(childContextTypes, childContext, "child context", name);
              }
              return assign({}, parentContext, childContext);
            }
          }
          function pushContextProvider(workInProgress2) {
            {
              var instance = workInProgress2.stateNode;
              var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyContextObject;
              previousContext = contextStackCursor.current;
              push2(contextStackCursor, memoizedMergedChildContext, workInProgress2);
              push2(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress2);
              return true;
            }
          }
          function invalidateContextProvider(workInProgress2, type, didChange) {
            {
              var instance = workInProgress2.stateNode;
              if (!instance) {
                throw new Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
              }
              if (didChange) {
                var mergedContext = processChildContext(workInProgress2, type, previousContext);
                instance.__reactInternalMemoizedMergedChildContext = mergedContext;
                pop(didPerformWorkStackCursor, workInProgress2);
                pop(contextStackCursor, workInProgress2);
                push2(contextStackCursor, mergedContext, workInProgress2);
                push2(didPerformWorkStackCursor, didChange, workInProgress2);
              } else {
                pop(didPerformWorkStackCursor, workInProgress2);
                push2(didPerformWorkStackCursor, didChange, workInProgress2);
              }
            }
          }
          function findCurrentUnmaskedContext(fiber) {
            {
              if (!isFiberMounted(fiber) || fiber.tag !== ClassComponent) {
                throw new Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
              }
              var node = fiber;
              do {
                switch (node.tag) {
                  case HostRoot:
                    return node.stateNode.context;
                  case ClassComponent: {
                    var Component3 = node.type;
                    if (isContextProvider(Component3)) {
                      return node.stateNode.__reactInternalMemoizedMergedChildContext;
                    }
                    break;
                  }
                }
                node = node.return;
              } while (node !== null);
              throw new Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
            }
          }
          var LegacyRoot = 0;
          var ConcurrentRoot = 1;
          var syncQueue = null;
          var includesLegacySyncCallbacks = false;
          var isFlushingSyncQueue = false;
          function scheduleSyncCallback(callback) {
            if (syncQueue === null) {
              syncQueue = [callback];
            } else {
              syncQueue.push(callback);
            }
          }
          function scheduleLegacySyncCallback(callback) {
            includesLegacySyncCallbacks = true;
            scheduleSyncCallback(callback);
          }
          function flushSyncCallbacksOnlyInLegacyMode() {
            if (includesLegacySyncCallbacks) {
              flushSyncCallbacks();
            }
          }
          function flushSyncCallbacks() {
            if (!isFlushingSyncQueue && syncQueue !== null) {
              isFlushingSyncQueue = true;
              var i = 0;
              var previousUpdatePriority = getCurrentUpdatePriority();
              try {
                var isSync = true;
                var queue = syncQueue;
                setCurrentUpdatePriority(DiscreteEventPriority);
                for (; i < queue.length; i++) {
                  var callback = queue[i];
                  do {
                    callback = callback(isSync);
                  } while (callback !== null);
                }
                syncQueue = null;
                includesLegacySyncCallbacks = false;
              } catch (error2) {
                if (syncQueue !== null) {
                  syncQueue = syncQueue.slice(i + 1);
                }
                scheduleCallback(ImmediatePriority, flushSyncCallbacks);
                throw error2;
              } finally {
                setCurrentUpdatePriority(previousUpdatePriority);
                isFlushingSyncQueue = false;
              }
            }
            return null;
          }
          var forkStack = [];
          var forkStackIndex = 0;
          var treeForkProvider = null;
          var treeForkCount = 0;
          var idStack = [];
          var idStackIndex = 0;
          var treeContextProvider = null;
          var treeContextId = 1;
          var treeContextOverflow = "";
          function isForkedChild(workInProgress2) {
            warnIfNotHydrating();
            return (workInProgress2.flags & Forked) !== NoFlags;
          }
          function getForksAtLevel(workInProgress2) {
            warnIfNotHydrating();
            return treeForkCount;
          }
          function getTreeId() {
            var overflow = treeContextOverflow;
            var idWithLeadingBit = treeContextId;
            var id3 = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);
            return id3.toString(32) + overflow;
          }
          function pushTreeFork(workInProgress2, totalChildren) {
            warnIfNotHydrating();
            forkStack[forkStackIndex++] = treeForkCount;
            forkStack[forkStackIndex++] = treeForkProvider;
            treeForkProvider = workInProgress2;
            treeForkCount = totalChildren;
          }
          function pushTreeId(workInProgress2, totalChildren, index2) {
            warnIfNotHydrating();
            idStack[idStackIndex++] = treeContextId;
            idStack[idStackIndex++] = treeContextOverflow;
            idStack[idStackIndex++] = treeContextProvider;
            treeContextProvider = workInProgress2;
            var baseIdWithLeadingBit = treeContextId;
            var baseOverflow = treeContextOverflow;
            var baseLength = getBitLength(baseIdWithLeadingBit) - 1;
            var baseId = baseIdWithLeadingBit & ~(1 << baseLength);
            var slot = index2 + 1;
            var length = getBitLength(totalChildren) + baseLength;
            if (length > 30) {
              var numberOfOverflowBits = baseLength - baseLength % 5;
              var newOverflowBits = (1 << numberOfOverflowBits) - 1;
              var newOverflow = (baseId & newOverflowBits).toString(32);
              var restOfBaseId = baseId >> numberOfOverflowBits;
              var restOfBaseLength = baseLength - numberOfOverflowBits;
              var restOfLength = getBitLength(totalChildren) + restOfBaseLength;
              var restOfNewBits = slot << restOfBaseLength;
              var id3 = restOfNewBits | restOfBaseId;
              var overflow = newOverflow + baseOverflow;
              treeContextId = 1 << restOfLength | id3;
              treeContextOverflow = overflow;
            } else {
              var newBits = slot << baseLength;
              var _id = newBits | baseId;
              var _overflow2 = baseOverflow;
              treeContextId = 1 << length | _id;
              treeContextOverflow = _overflow2;
            }
          }
          function pushMaterializedTreeId(workInProgress2) {
            warnIfNotHydrating();
            var returnFiber = workInProgress2.return;
            if (returnFiber !== null) {
              var numberOfForks = 1;
              var slotIndex = 0;
              pushTreeFork(workInProgress2, numberOfForks);
              pushTreeId(workInProgress2, numberOfForks, slotIndex);
            }
          }
          function getBitLength(number2) {
            return 32 - clz32(number2);
          }
          function getLeadingBit(id3) {
            return 1 << getBitLength(id3) - 1;
          }
          function popTreeContext(workInProgress2) {
            while (workInProgress2 === treeForkProvider) {
              treeForkProvider = forkStack[--forkStackIndex];
              forkStack[forkStackIndex] = null;
              treeForkCount = forkStack[--forkStackIndex];
              forkStack[forkStackIndex] = null;
            }
            while (workInProgress2 === treeContextProvider) {
              treeContextProvider = idStack[--idStackIndex];
              idStack[idStackIndex] = null;
              treeContextOverflow = idStack[--idStackIndex];
              idStack[idStackIndex] = null;
              treeContextId = idStack[--idStackIndex];
              idStack[idStackIndex] = null;
            }
          }
          function getSuspendedTreeContext() {
            warnIfNotHydrating();
            if (treeContextProvider !== null) {
              return {
                id: treeContextId,
                overflow: treeContextOverflow
              };
            } else {
              return null;
            }
          }
          function restoreSuspendedTreeContext(workInProgress2, suspendedContext) {
            warnIfNotHydrating();
            idStack[idStackIndex++] = treeContextId;
            idStack[idStackIndex++] = treeContextOverflow;
            idStack[idStackIndex++] = treeContextProvider;
            treeContextId = suspendedContext.id;
            treeContextOverflow = suspendedContext.overflow;
            treeContextProvider = workInProgress2;
          }
          function warnIfNotHydrating() {
            {
              if (!getIsHydrating()) {
                error("Expected to be hydrating. This is a bug in React. Please file an issue.");
              }
            }
          }
          var hydrationParentFiber = null;
          var nextHydratableInstance = null;
          var isHydrating = false;
          var didSuspendOrErrorDEV = false;
          var hydrationErrors = null;
          function warnIfHydrating() {
            {
              if (isHydrating) {
                error("We should not be hydrating here. This is a bug in React. Please file a bug.");
              }
            }
          }
          function markDidThrowWhileHydratingDEV() {
            {
              didSuspendOrErrorDEV = true;
            }
          }
          function didSuspendOrErrorWhileHydratingDEV() {
            {
              return didSuspendOrErrorDEV;
            }
          }
          function enterHydrationState(fiber) {
            var parentInstance = fiber.stateNode.containerInfo;
            nextHydratableInstance = getFirstHydratableChildWithinContainer(parentInstance);
            hydrationParentFiber = fiber;
            isHydrating = true;
            hydrationErrors = null;
            didSuspendOrErrorDEV = false;
            return true;
          }
          function reenterHydrationStateFromDehydratedSuspenseInstance(fiber, suspenseInstance, treeContext) {
            nextHydratableInstance = getFirstHydratableChildWithinSuspenseInstance(suspenseInstance);
            hydrationParentFiber = fiber;
            isHydrating = true;
            hydrationErrors = null;
            didSuspendOrErrorDEV = false;
            if (treeContext !== null) {
              restoreSuspendedTreeContext(fiber, treeContext);
            }
            return true;
          }
          function warnUnhydratedInstance(returnFiber, instance) {
            {
              switch (returnFiber.tag) {
                case HostRoot: {
                  didNotHydrateInstanceWithinContainer(returnFiber.stateNode.containerInfo, instance);
                  break;
                }
                case HostComponent: {
                  var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                  didNotHydrateInstance(
                    returnFiber.type,
                    returnFiber.memoizedProps,
                    returnFiber.stateNode,
                    instance,
                    // TODO: Delete this argument when we remove the legacy root API.
                    isConcurrentMode
                  );
                  break;
                }
                case SuspenseComponent: {
                  var suspenseState = returnFiber.memoizedState;
                  if (suspenseState.dehydrated !== null) didNotHydrateInstanceWithinSuspenseInstance(suspenseState.dehydrated, instance);
                  break;
                }
              }
            }
          }
          function deleteHydratableInstance(returnFiber, instance) {
            warnUnhydratedInstance(returnFiber, instance);
            var childToDelete = createFiberFromHostInstanceForDeletion();
            childToDelete.stateNode = instance;
            childToDelete.return = returnFiber;
            var deletions = returnFiber.deletions;
            if (deletions === null) {
              returnFiber.deletions = [childToDelete];
              returnFiber.flags |= ChildDeletion;
            } else {
              deletions.push(childToDelete);
            }
          }
          function warnNonhydratedInstance(returnFiber, fiber) {
            {
              if (didSuspendOrErrorDEV) {
                return;
              }
              switch (returnFiber.tag) {
                case HostRoot: {
                  var parentContainer = returnFiber.stateNode.containerInfo;
                  switch (fiber.tag) {
                    case HostComponent:
                      var type = fiber.type;
                      var props = fiber.pendingProps;
                      didNotFindHydratableInstanceWithinContainer(parentContainer, type);
                      break;
                    case HostText:
                      var text = fiber.pendingProps;
                      didNotFindHydratableTextInstanceWithinContainer(parentContainer, text);
                      break;
                  }
                  break;
                }
                case HostComponent: {
                  var parentType = returnFiber.type;
                  var parentProps = returnFiber.memoizedProps;
                  var parentInstance = returnFiber.stateNode;
                  switch (fiber.tag) {
                    case HostComponent: {
                      var _type = fiber.type;
                      var _props = fiber.pendingProps;
                      var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                      didNotFindHydratableInstance(
                        parentType,
                        parentProps,
                        parentInstance,
                        _type,
                        _props,
                        // TODO: Delete this argument when we remove the legacy root API.
                        isConcurrentMode
                      );
                      break;
                    }
                    case HostText: {
                      var _text = fiber.pendingProps;
                      var _isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                      didNotFindHydratableTextInstance(
                        parentType,
                        parentProps,
                        parentInstance,
                        _text,
                        // TODO: Delete this argument when we remove the legacy root API.
                        _isConcurrentMode
                      );
                      break;
                    }
                  }
                  break;
                }
                case SuspenseComponent: {
                  var suspenseState = returnFiber.memoizedState;
                  var _parentInstance = suspenseState.dehydrated;
                  if (_parentInstance !== null) switch (fiber.tag) {
                    case HostComponent:
                      var _type2 = fiber.type;
                      var _props2 = fiber.pendingProps;
                      didNotFindHydratableInstanceWithinSuspenseInstance(_parentInstance, _type2);
                      break;
                    case HostText:
                      var _text2 = fiber.pendingProps;
                      didNotFindHydratableTextInstanceWithinSuspenseInstance(_parentInstance, _text2);
                      break;
                  }
                  break;
                }
                default:
                  return;
              }
            }
          }
          function insertNonHydratedInstance(returnFiber, fiber) {
            fiber.flags = fiber.flags & ~Hydrating | Placement;
            warnNonhydratedInstance(returnFiber, fiber);
          }
          function tryHydrate(fiber, nextInstance) {
            switch (fiber.tag) {
              case HostComponent: {
                var type = fiber.type;
                var props = fiber.pendingProps;
                var instance = canHydrateInstance(nextInstance, type);
                if (instance !== null) {
                  fiber.stateNode = instance;
                  hydrationParentFiber = fiber;
                  nextHydratableInstance = getFirstHydratableChild(instance);
                  return true;
                }
                return false;
              }
              case HostText: {
                var text = fiber.pendingProps;
                var textInstance = canHydrateTextInstance(nextInstance, text);
                if (textInstance !== null) {
                  fiber.stateNode = textInstance;
                  hydrationParentFiber = fiber;
                  nextHydratableInstance = null;
                  return true;
                }
                return false;
              }
              case SuspenseComponent: {
                var suspenseInstance = canHydrateSuspenseInstance(nextInstance);
                if (suspenseInstance !== null) {
                  var suspenseState = {
                    dehydrated: suspenseInstance,
                    treeContext: getSuspendedTreeContext(),
                    retryLane: OffscreenLane
                  };
                  fiber.memoizedState = suspenseState;
                  var dehydratedFragment = createFiberFromDehydratedFragment(suspenseInstance);
                  dehydratedFragment.return = fiber;
                  fiber.child = dehydratedFragment;
                  hydrationParentFiber = fiber;
                  nextHydratableInstance = null;
                  return true;
                }
                return false;
              }
              default:
                return false;
            }
          }
          function shouldClientRenderOnMismatch(fiber) {
            return (fiber.mode & ConcurrentMode) !== NoMode && (fiber.flags & DidCapture) === NoFlags;
          }
          function throwOnHydrationMismatch(fiber) {
            throw new Error("Hydration failed because the initial UI does not match what was rendered on the server.");
          }
          function tryToClaimNextHydratableInstance(fiber) {
            if (!isHydrating) {
              return;
            }
            var nextInstance = nextHydratableInstance;
            if (!nextInstance) {
              if (shouldClientRenderOnMismatch(fiber)) {
                warnNonhydratedInstance(hydrationParentFiber, fiber);
                throwOnHydrationMismatch();
              }
              insertNonHydratedInstance(hydrationParentFiber, fiber);
              isHydrating = false;
              hydrationParentFiber = fiber;
              return;
            }
            var firstAttemptedInstance = nextInstance;
            if (!tryHydrate(fiber, nextInstance)) {
              if (shouldClientRenderOnMismatch(fiber)) {
                warnNonhydratedInstance(hydrationParentFiber, fiber);
                throwOnHydrationMismatch();
              }
              nextInstance = getNextHydratableSibling(firstAttemptedInstance);
              var prevHydrationParentFiber = hydrationParentFiber;
              if (!nextInstance || !tryHydrate(fiber, nextInstance)) {
                insertNonHydratedInstance(hydrationParentFiber, fiber);
                isHydrating = false;
                hydrationParentFiber = fiber;
                return;
              }
              deleteHydratableInstance(prevHydrationParentFiber, firstAttemptedInstance);
            }
          }
          function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {
            var instance = fiber.stateNode;
            var shouldWarnIfMismatchDev = !didSuspendOrErrorDEV;
            var updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber, shouldWarnIfMismatchDev);
            fiber.updateQueue = updatePayload;
            if (updatePayload !== null) {
              return true;
            }
            return false;
          }
          function prepareToHydrateHostTextInstance(fiber) {
            var textInstance = fiber.stateNode;
            var textContent = fiber.memoizedProps;
            var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);
            if (shouldUpdate) {
              var returnFiber = hydrationParentFiber;
              if (returnFiber !== null) {
                switch (returnFiber.tag) {
                  case HostRoot: {
                    var parentContainer = returnFiber.stateNode.containerInfo;
                    var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                    didNotMatchHydratedContainerTextInstance(
                      parentContainer,
                      textInstance,
                      textContent,
                      // TODO: Delete this argument when we remove the legacy root API.
                      isConcurrentMode
                    );
                    break;
                  }
                  case HostComponent: {
                    var parentType = returnFiber.type;
                    var parentProps = returnFiber.memoizedProps;
                    var parentInstance = returnFiber.stateNode;
                    var _isConcurrentMode2 = (returnFiber.mode & ConcurrentMode) !== NoMode;
                    didNotMatchHydratedTextInstance(
                      parentType,
                      parentProps,
                      parentInstance,
                      textInstance,
                      textContent,
                      // TODO: Delete this argument when we remove the legacy root API.
                      _isConcurrentMode2
                    );
                    break;
                  }
                }
              }
            }
            return shouldUpdate;
          }
          function prepareToHydrateHostSuspenseInstance(fiber) {
            var suspenseState = fiber.memoizedState;
            var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;
            if (!suspenseInstance) {
              throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
            }
            hydrateSuspenseInstance(suspenseInstance, fiber);
          }
          function skipPastDehydratedSuspenseInstance(fiber) {
            var suspenseState = fiber.memoizedState;
            var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;
            if (!suspenseInstance) {
              throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
            }
            return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);
          }
          function popToNextHostParent(fiber) {
            var parent = fiber.return;
            while (parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot && parent.tag !== SuspenseComponent) {
              parent = parent.return;
            }
            hydrationParentFiber = parent;
          }
          function popHydrationState(fiber) {
            if (fiber !== hydrationParentFiber) {
              return false;
            }
            if (!isHydrating) {
              popToNextHostParent(fiber);
              isHydrating = true;
              return false;
            }
            if (fiber.tag !== HostRoot && (fiber.tag !== HostComponent || shouldDeleteUnhydratedTailInstances(fiber.type) && !shouldSetTextContent(fiber.type, fiber.memoizedProps))) {
              var nextInstance = nextHydratableInstance;
              if (nextInstance) {
                if (shouldClientRenderOnMismatch(fiber)) {
                  warnIfUnhydratedTailNodes(fiber);
                  throwOnHydrationMismatch();
                } else {
                  while (nextInstance) {
                    deleteHydratableInstance(fiber, nextInstance);
                    nextInstance = getNextHydratableSibling(nextInstance);
                  }
                }
              }
            }
            popToNextHostParent(fiber);
            if (fiber.tag === SuspenseComponent) {
              nextHydratableInstance = skipPastDehydratedSuspenseInstance(fiber);
            } else {
              nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;
            }
            return true;
          }
          function hasUnhydratedTailNodes() {
            return isHydrating && nextHydratableInstance !== null;
          }
          function warnIfUnhydratedTailNodes(fiber) {
            var nextInstance = nextHydratableInstance;
            while (nextInstance) {
              warnUnhydratedInstance(fiber, nextInstance);
              nextInstance = getNextHydratableSibling(nextInstance);
            }
          }
          function resetHydrationState() {
            hydrationParentFiber = null;
            nextHydratableInstance = null;
            isHydrating = false;
            didSuspendOrErrorDEV = false;
          }
          function upgradeHydrationErrorsToRecoverable() {
            if (hydrationErrors !== null) {
              queueRecoverableErrors(hydrationErrors);
              hydrationErrors = null;
            }
          }
          function getIsHydrating() {
            return isHydrating;
          }
          function queueHydrationError(error2) {
            if (hydrationErrors === null) {
              hydrationErrors = [error2];
            } else {
              hydrationErrors.push(error2);
            }
          }
          var ReactCurrentBatchConfig$1 = ReactSharedInternals.ReactCurrentBatchConfig;
          var NoTransition = null;
          function requestCurrentTransition() {
            return ReactCurrentBatchConfig$1.transition;
          }
          var ReactStrictModeWarnings = {
            recordUnsafeLifecycleWarnings: function(fiber, instance) {
            },
            flushPendingUnsafeLifecycleWarnings: function() {
            },
            recordLegacyContextWarning: function(fiber, instance) {
            },
            flushLegacyContextWarning: function() {
            },
            discardPendingWarnings: function() {
            }
          };
          {
            var findStrictRoot = function(fiber) {
              var maybeStrictRoot = null;
              var node = fiber;
              while (node !== null) {
                if (node.mode & StrictLegacyMode) {
                  maybeStrictRoot = node;
                }
                node = node.return;
              }
              return maybeStrictRoot;
            };
            var setToSortedString = function(set2) {
              var array = [];
              set2.forEach(function(value) {
                array.push(value);
              });
              return array.sort().join(", ");
            };
            var pendingComponentWillMountWarnings = [];
            var pendingUNSAFE_ComponentWillMountWarnings = [];
            var pendingComponentWillReceivePropsWarnings = [];
            var pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
            var pendingComponentWillUpdateWarnings = [];
            var pendingUNSAFE_ComponentWillUpdateWarnings = [];
            var didWarnAboutUnsafeLifecycles = /* @__PURE__ */ new Set();
            ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(fiber, instance) {
              if (didWarnAboutUnsafeLifecycles.has(fiber.type)) {
                return;
              }
              if (typeof instance.componentWillMount === "function" && // Don't warn about react-lifecycles-compat polyfilled components.
              instance.componentWillMount.__suppressDeprecationWarning !== true) {
                pendingComponentWillMountWarnings.push(fiber);
              }
              if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillMount === "function") {
                pendingUNSAFE_ComponentWillMountWarnings.push(fiber);
              }
              if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
                pendingComponentWillReceivePropsWarnings.push(fiber);
              }
              if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillReceiveProps === "function") {
                pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber);
              }
              if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
                pendingComponentWillUpdateWarnings.push(fiber);
              }
              if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillUpdate === "function") {
                pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber);
              }
            };
            ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function() {
              var componentWillMountUniqueNames = /* @__PURE__ */ new Set();
              if (pendingComponentWillMountWarnings.length > 0) {
                pendingComponentWillMountWarnings.forEach(function(fiber) {
                  componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
                });
                pendingComponentWillMountWarnings = [];
              }
              var UNSAFE_componentWillMountUniqueNames = /* @__PURE__ */ new Set();
              if (pendingUNSAFE_ComponentWillMountWarnings.length > 0) {
                pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber) {
                  UNSAFE_componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
                });
                pendingUNSAFE_ComponentWillMountWarnings = [];
              }
              var componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
              if (pendingComponentWillReceivePropsWarnings.length > 0) {
                pendingComponentWillReceivePropsWarnings.forEach(function(fiber) {
                  componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
                });
                pendingComponentWillReceivePropsWarnings = [];
              }
              var UNSAFE_componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
              if (pendingUNSAFE_ComponentWillReceivePropsWarnings.length > 0) {
                pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function(fiber) {
                  UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
                });
                pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
              }
              var componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
              if (pendingComponentWillUpdateWarnings.length > 0) {
                pendingComponentWillUpdateWarnings.forEach(function(fiber) {
                  componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
                });
                pendingComponentWillUpdateWarnings = [];
              }
              var UNSAFE_componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
              if (pendingUNSAFE_ComponentWillUpdateWarnings.length > 0) {
                pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber) {
                  UNSAFE_componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
                });
                pendingUNSAFE_ComponentWillUpdateWarnings = [];
              }
              if (UNSAFE_componentWillMountUniqueNames.size > 0) {
                var sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames);
                error("Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n\nPlease update the following components: %s", sortedNames);
              }
              if (UNSAFE_componentWillReceivePropsUniqueNames.size > 0) {
                var _sortedNames = setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames);
                error("Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n\nPlease update the following components: %s", _sortedNames);
              }
              if (UNSAFE_componentWillUpdateUniqueNames.size > 0) {
                var _sortedNames2 = setToSortedString(UNSAFE_componentWillUpdateUniqueNames);
                error("Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n\nPlease update the following components: %s", _sortedNames2);
              }
              if (componentWillMountUniqueNames.size > 0) {
                var _sortedNames3 = setToSortedString(componentWillMountUniqueNames);
                warn("componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames3);
              }
              if (componentWillReceivePropsUniqueNames.size > 0) {
                var _sortedNames4 = setToSortedString(componentWillReceivePropsUniqueNames);
                warn("componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames4);
              }
              if (componentWillUpdateUniqueNames.size > 0) {
                var _sortedNames5 = setToSortedString(componentWillUpdateUniqueNames);
                warn("componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames5);
              }
            };
            var pendingLegacyContextWarning = /* @__PURE__ */ new Map();
            var didWarnAboutLegacyContext = /* @__PURE__ */ new Set();
            ReactStrictModeWarnings.recordLegacyContextWarning = function(fiber, instance) {
              var strictRoot = findStrictRoot(fiber);
              if (strictRoot === null) {
                error("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");
                return;
              }
              if (didWarnAboutLegacyContext.has(fiber.type)) {
                return;
              }
              var warningsForRoot = pendingLegacyContextWarning.get(strictRoot);
              if (fiber.type.contextTypes != null || fiber.type.childContextTypes != null || instance !== null && typeof instance.getChildContext === "function") {
                if (warningsForRoot === void 0) {
                  warningsForRoot = [];
                  pendingLegacyContextWarning.set(strictRoot, warningsForRoot);
                }
                warningsForRoot.push(fiber);
              }
            };
            ReactStrictModeWarnings.flushLegacyContextWarning = function() {
              pendingLegacyContextWarning.forEach(function(fiberArray, strictRoot) {
                if (fiberArray.length === 0) {
                  return;
                }
                var firstFiber = fiberArray[0];
                var uniqueNames = /* @__PURE__ */ new Set();
                fiberArray.forEach(function(fiber) {
                  uniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                  didWarnAboutLegacyContext.add(fiber.type);
                });
                var sortedNames = setToSortedString(uniqueNames);
                try {
                  setCurrentFiber(firstFiber);
                  error("Legacy context API has been detected within a strict-mode tree.\n\nThe old API will be supported in all 16.x releases, but applications using it should migrate to the new version.\n\nPlease update the following components: %s\n\nLearn more about this warning here: https://reactjs.org/link/legacy-context", sortedNames);
                } finally {
                  resetCurrentFiber();
                }
              });
            };
            ReactStrictModeWarnings.discardPendingWarnings = function() {
              pendingComponentWillMountWarnings = [];
              pendingUNSAFE_ComponentWillMountWarnings = [];
              pendingComponentWillReceivePropsWarnings = [];
              pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
              pendingComponentWillUpdateWarnings = [];
              pendingUNSAFE_ComponentWillUpdateWarnings = [];
              pendingLegacyContextWarning = /* @__PURE__ */ new Map();
            };
          }
          var didWarnAboutMaps;
          var didWarnAboutGenerators;
          var didWarnAboutStringRefs;
          var ownerHasKeyUseWarning;
          var ownerHasFunctionTypeWarning;
          var warnForMissingKey = function(child, returnFiber) {
          };
          {
            didWarnAboutMaps = false;
            didWarnAboutGenerators = false;
            didWarnAboutStringRefs = {};
            ownerHasKeyUseWarning = {};
            ownerHasFunctionTypeWarning = {};
            warnForMissingKey = function(child, returnFiber) {
              if (child === null || typeof child !== "object") {
                return;
              }
              if (!child._store || child._store.validated || child.key != null) {
                return;
              }
              if (typeof child._store !== "object") {
                throw new Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
              }
              child._store.validated = true;
              var componentName = getComponentNameFromFiber(returnFiber) || "Component";
              if (ownerHasKeyUseWarning[componentName]) {
                return;
              }
              ownerHasKeyUseWarning[componentName] = true;
              error('Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.');
            };
          }
          function isReactClass(type) {
            return type.prototype && type.prototype.isReactComponent;
          }
          function coerceRef(returnFiber, current2, element) {
            var mixedRef = element.ref;
            if (mixedRef !== null && typeof mixedRef !== "function" && typeof mixedRef !== "object") {
              {
                if ((returnFiber.mode & StrictLegacyMode || warnAboutStringRefs) && // We warn in ReactElement.js if owner and self are equal for string refs
                // because these cannot be automatically converted to an arrow function
                // using a codemod. Therefore, we don't have to warn about string refs again.
                !(element._owner && element._self && element._owner.stateNode !== element._self) && // Will already throw with "Function components cannot have string refs"
                !(element._owner && element._owner.tag !== ClassComponent) && // Will already warn with "Function components cannot be given refs"
                !(typeof element.type === "function" && !isReactClass(element.type)) && // Will already throw with "Element ref was specified as a string (someStringRef) but no owner was set"
                element._owner) {
                  var componentName = getComponentNameFromFiber(returnFiber) || "Component";
                  if (!didWarnAboutStringRefs[componentName]) {
                    {
                      error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', componentName, mixedRef);
                    }
                    didWarnAboutStringRefs[componentName] = true;
                  }
                }
              }
              if (element._owner) {
                var owner = element._owner;
                var inst;
                if (owner) {
                  var ownerFiber = owner;
                  if (ownerFiber.tag !== ClassComponent) {
                    throw new Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");
                  }
                  inst = ownerFiber.stateNode;
                }
                if (!inst) {
                  throw new Error("Missing owner for string ref " + mixedRef + ". This error is likely caused by a bug in React. Please file an issue.");
                }
                var resolvedInst = inst;
                {
                  checkPropStringCoercion(mixedRef, "ref");
                }
                var stringRef = "" + mixedRef;
                if (current2 !== null && current2.ref !== null && typeof current2.ref === "function" && current2.ref._stringRef === stringRef) {
                  return current2.ref;
                }
                var ref2 = function(value) {
                  var refs = resolvedInst.refs;
                  if (value === null) {
                    delete refs[stringRef];
                  } else {
                    refs[stringRef] = value;
                  }
                };
                ref2._stringRef = stringRef;
                return ref2;
              } else {
                if (typeof mixedRef !== "string") {
                  throw new Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
                }
                if (!element._owner) {
                  throw new Error("Element ref was specified as a string (" + mixedRef + ") but no owner was set. This could happen for one of the following reasons:\n1. You may be adding a ref to a function component\n2. You may be adding a ref to a component that was not created inside a component's render method\n3. You have multiple copies of React loaded\nSee https://reactjs.org/link/refs-must-have-owner for more information.");
                }
              }
            }
            return mixedRef;
          }
          function throwOnInvalidObjectType(returnFiber, newChild) {
            var childString = Object.prototype.toString.call(newChild);
            throw new Error("Objects are not valid as a React child (found: " + (childString === "[object Object]" ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : childString) + "). If you meant to render a collection of children, use an array instead.");
          }
          function warnOnFunctionType(returnFiber) {
            {
              var componentName = getComponentNameFromFiber(returnFiber) || "Component";
              if (ownerHasFunctionTypeWarning[componentName]) {
                return;
              }
              ownerHasFunctionTypeWarning[componentName] = true;
              error("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
            }
          }
          function resolveLazy(lazyType) {
            var payload = lazyType._payload;
            var init5 = lazyType._init;
            return init5(payload);
          }
          function ChildReconciler(shouldTrackSideEffects) {
            function deleteChild(returnFiber, childToDelete) {
              if (!shouldTrackSideEffects) {
                return;
              }
              var deletions = returnFiber.deletions;
              if (deletions === null) {
                returnFiber.deletions = [childToDelete];
                returnFiber.flags |= ChildDeletion;
              } else {
                deletions.push(childToDelete);
              }
            }
            function deleteRemainingChildren(returnFiber, currentFirstChild) {
              if (!shouldTrackSideEffects) {
                return null;
              }
              var childToDelete = currentFirstChild;
              while (childToDelete !== null) {
                deleteChild(returnFiber, childToDelete);
                childToDelete = childToDelete.sibling;
              }
              return null;
            }
            function mapRemainingChildren(returnFiber, currentFirstChild) {
              var existingChildren = /* @__PURE__ */ new Map();
              var existingChild = currentFirstChild;
              while (existingChild !== null) {
                if (existingChild.key !== null) {
                  existingChildren.set(existingChild.key, existingChild);
                } else {
                  existingChildren.set(existingChild.index, existingChild);
                }
                existingChild = existingChild.sibling;
              }
              return existingChildren;
            }
            function useFiber(fiber, pendingProps) {
              var clone = createWorkInProgress(fiber, pendingProps);
              clone.index = 0;
              clone.sibling = null;
              return clone;
            }
            function placeChild(newFiber, lastPlacedIndex, newIndex) {
              newFiber.index = newIndex;
              if (!shouldTrackSideEffects) {
                newFiber.flags |= Forked;
                return lastPlacedIndex;
              }
              var current2 = newFiber.alternate;
              if (current2 !== null) {
                var oldIndex = current2.index;
                if (oldIndex < lastPlacedIndex) {
                  newFiber.flags |= Placement;
                  return lastPlacedIndex;
                } else {
                  return oldIndex;
                }
              } else {
                newFiber.flags |= Placement;
                return lastPlacedIndex;
              }
            }
            function placeSingleChild(newFiber) {
              if (shouldTrackSideEffects && newFiber.alternate === null) {
                newFiber.flags |= Placement;
              }
              return newFiber;
            }
            function updateTextNode(returnFiber, current2, textContent, lanes) {
              if (current2 === null || current2.tag !== HostText) {
                var created = createFiberFromText(textContent, returnFiber.mode, lanes);
                created.return = returnFiber;
                return created;
              } else {
                var existing = useFiber(current2, textContent);
                existing.return = returnFiber;
                return existing;
              }
            }
            function updateElement(returnFiber, current2, element, lanes) {
              var elementType = element.type;
              if (elementType === REACT_FRAGMENT_TYPE) {
                return updateFragment2(returnFiber, current2, element.props.children, lanes, element.key);
              }
              if (current2 !== null) {
                if (current2.elementType === elementType || // Keep this check inline so it only runs on the false path:
                isCompatibleFamilyForHotReloading(current2, element) || // Lazy types should reconcile their resolved type.
                // We need to do this after the Hot Reloading check above,
                // because hot reloading has different semantics than prod because
                // it doesn't resuspend. So we can't let the call below suspend.
                typeof elementType === "object" && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current2.type) {
                  var existing = useFiber(current2, element.props);
                  existing.ref = coerceRef(returnFiber, current2, element);
                  existing.return = returnFiber;
                  {
                    existing._debugSource = element._source;
                    existing._debugOwner = element._owner;
                  }
                  return existing;
                }
              }
              var created = createFiberFromElement(element, returnFiber.mode, lanes);
              created.ref = coerceRef(returnFiber, current2, element);
              created.return = returnFiber;
              return created;
            }
            function updatePortal(returnFiber, current2, portal, lanes) {
              if (current2 === null || current2.tag !== HostPortal || current2.stateNode.containerInfo !== portal.containerInfo || current2.stateNode.implementation !== portal.implementation) {
                var created = createFiberFromPortal(portal, returnFiber.mode, lanes);
                created.return = returnFiber;
                return created;
              } else {
                var existing = useFiber(current2, portal.children || []);
                existing.return = returnFiber;
                return existing;
              }
            }
            function updateFragment2(returnFiber, current2, fragment, lanes, key) {
              if (current2 === null || current2.tag !== Fragment7) {
                var created = createFiberFromFragment(fragment, returnFiber.mode, lanes, key);
                created.return = returnFiber;
                return created;
              } else {
                var existing = useFiber(current2, fragment);
                existing.return = returnFiber;
                return existing;
              }
            }
            function createChild(returnFiber, newChild, lanes) {
              if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
                var created = createFiberFromText("" + newChild, returnFiber.mode, lanes);
                created.return = returnFiber;
                return created;
              }
              if (typeof newChild === "object" && newChild !== null) {
                switch (newChild.$$typeof) {
                  case REACT_ELEMENT_TYPE: {
                    var _created = createFiberFromElement(newChild, returnFiber.mode, lanes);
                    _created.ref = coerceRef(returnFiber, null, newChild);
                    _created.return = returnFiber;
                    return _created;
                  }
                  case REACT_PORTAL_TYPE: {
                    var _created2 = createFiberFromPortal(newChild, returnFiber.mode, lanes);
                    _created2.return = returnFiber;
                    return _created2;
                  }
                  case REACT_LAZY_TYPE: {
                    var payload = newChild._payload;
                    var init5 = newChild._init;
                    return createChild(returnFiber, init5(payload), lanes);
                  }
                }
                if (isArray(newChild) || getIteratorFn(newChild)) {
                  var _created3 = createFiberFromFragment(newChild, returnFiber.mode, lanes, null);
                  _created3.return = returnFiber;
                  return _created3;
                }
                throwOnInvalidObjectType(returnFiber, newChild);
              }
              {
                if (typeof newChild === "function") {
                  warnOnFunctionType(returnFiber);
                }
              }
              return null;
            }
            function updateSlot(returnFiber, oldFiber, newChild, lanes) {
              var key = oldFiber !== null ? oldFiber.key : null;
              if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
                if (key !== null) {
                  return null;
                }
                return updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
              }
              if (typeof newChild === "object" && newChild !== null) {
                switch (newChild.$$typeof) {
                  case REACT_ELEMENT_TYPE: {
                    if (newChild.key === key) {
                      return updateElement(returnFiber, oldFiber, newChild, lanes);
                    } else {
                      return null;
                    }
                  }
                  case REACT_PORTAL_TYPE: {
                    if (newChild.key === key) {
                      return updatePortal(returnFiber, oldFiber, newChild, lanes);
                    } else {
                      return null;
                    }
                  }
                  case REACT_LAZY_TYPE: {
                    var payload = newChild._payload;
                    var init5 = newChild._init;
                    return updateSlot(returnFiber, oldFiber, init5(payload), lanes);
                  }
                }
                if (isArray(newChild) || getIteratorFn(newChild)) {
                  if (key !== null) {
                    return null;
                  }
                  return updateFragment2(returnFiber, oldFiber, newChild, lanes, null);
                }
                throwOnInvalidObjectType(returnFiber, newChild);
              }
              {
                if (typeof newChild === "function") {
                  warnOnFunctionType(returnFiber);
                }
              }
              return null;
            }
            function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
              if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
                var matchedFiber = existingChildren.get(newIdx) || null;
                return updateTextNode(returnFiber, matchedFiber, "" + newChild, lanes);
              }
              if (typeof newChild === "object" && newChild !== null) {
                switch (newChild.$$typeof) {
                  case REACT_ELEMENT_TYPE: {
                    var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
                    return updateElement(returnFiber, _matchedFiber, newChild, lanes);
                  }
                  case REACT_PORTAL_TYPE: {
                    var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
                    return updatePortal(returnFiber, _matchedFiber2, newChild, lanes);
                  }
                  case REACT_LAZY_TYPE:
                    var payload = newChild._payload;
                    var init5 = newChild._init;
                    return updateFromMap(existingChildren, returnFiber, newIdx, init5(payload), lanes);
                }
                if (isArray(newChild) || getIteratorFn(newChild)) {
                  var _matchedFiber3 = existingChildren.get(newIdx) || null;
                  return updateFragment2(returnFiber, _matchedFiber3, newChild, lanes, null);
                }
                throwOnInvalidObjectType(returnFiber, newChild);
              }
              {
                if (typeof newChild === "function") {
                  warnOnFunctionType(returnFiber);
                }
              }
              return null;
            }
            function warnOnInvalidKey(child, knownKeys, returnFiber) {
              {
                if (typeof child !== "object" || child === null) {
                  return knownKeys;
                }
                switch (child.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                  case REACT_PORTAL_TYPE:
                    warnForMissingKey(child, returnFiber);
                    var key = child.key;
                    if (typeof key !== "string") {
                      break;
                    }
                    if (knownKeys === null) {
                      knownKeys = /* @__PURE__ */ new Set();
                      knownKeys.add(key);
                      break;
                    }
                    if (!knownKeys.has(key)) {
                      knownKeys.add(key);
                      break;
                    }
                    error("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted \u2014 the behavior is unsupported and could change in a future version.", key);
                    break;
                  case REACT_LAZY_TYPE:
                    var payload = child._payload;
                    var init5 = child._init;
                    warnOnInvalidKey(init5(payload), knownKeys, returnFiber);
                    break;
                }
              }
              return knownKeys;
            }
            function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
              {
                var knownKeys = null;
                for (var i = 0; i < newChildren.length; i++) {
                  var child = newChildren[i];
                  knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
                }
              }
              var resultingFirstChild = null;
              var previousNewFiber = null;
              var oldFiber = currentFirstChild;
              var lastPlacedIndex = 0;
              var newIdx = 0;
              var nextOldFiber = null;
              for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {
                if (oldFiber.index > newIdx) {
                  nextOldFiber = oldFiber;
                  oldFiber = null;
                } else {
                  nextOldFiber = oldFiber.sibling;
                }
                var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes);
                if (newFiber === null) {
                  if (oldFiber === null) {
                    oldFiber = nextOldFiber;
                  }
                  break;
                }
                if (shouldTrackSideEffects) {
                  if (oldFiber && newFiber.alternate === null) {
                    deleteChild(returnFiber, oldFiber);
                  }
                }
                lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
                if (previousNewFiber === null) {
                  resultingFirstChild = newFiber;
                } else {
                  previousNewFiber.sibling = newFiber;
                }
                previousNewFiber = newFiber;
                oldFiber = nextOldFiber;
              }
              if (newIdx === newChildren.length) {
                deleteRemainingChildren(returnFiber, oldFiber);
                if (getIsHydrating()) {
                  var numberOfForks = newIdx;
                  pushTreeFork(returnFiber, numberOfForks);
                }
                return resultingFirstChild;
              }
              if (oldFiber === null) {
                for (; newIdx < newChildren.length; newIdx++) {
                  var _newFiber = createChild(returnFiber, newChildren[newIdx], lanes);
                  if (_newFiber === null) {
                    continue;
                  }
                  lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);
                  if (previousNewFiber === null) {
                    resultingFirstChild = _newFiber;
                  } else {
                    previousNewFiber.sibling = _newFiber;
                  }
                  previousNewFiber = _newFiber;
                }
                if (getIsHydrating()) {
                  var _numberOfForks = newIdx;
                  pushTreeFork(returnFiber, _numberOfForks);
                }
                return resultingFirstChild;
              }
              var existingChildren = mapRemainingChildren(returnFiber, oldFiber);
              for (; newIdx < newChildren.length; newIdx++) {
                var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], lanes);
                if (_newFiber2 !== null) {
                  if (shouldTrackSideEffects) {
                    if (_newFiber2.alternate !== null) {
                      existingChildren.delete(_newFiber2.key === null ? newIdx : _newFiber2.key);
                    }
                  }
                  lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);
                  if (previousNewFiber === null) {
                    resultingFirstChild = _newFiber2;
                  } else {
                    previousNewFiber.sibling = _newFiber2;
                  }
                  previousNewFiber = _newFiber2;
                }
              }
              if (shouldTrackSideEffects) {
                existingChildren.forEach(function(child2) {
                  return deleteChild(returnFiber, child2);
                });
              }
              if (getIsHydrating()) {
                var _numberOfForks2 = newIdx;
                pushTreeFork(returnFiber, _numberOfForks2);
              }
              return resultingFirstChild;
            }
            function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, lanes) {
              var iteratorFn = getIteratorFn(newChildrenIterable);
              if (typeof iteratorFn !== "function") {
                throw new Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
              }
              {
                if (typeof Symbol === "function" && // $FlowFixMe Flow doesn't know about toStringTag
                newChildrenIterable[Symbol.toStringTag] === "Generator") {
                  if (!didWarnAboutGenerators) {
                    error("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers.");
                  }
                  didWarnAboutGenerators = true;
                }
                if (newChildrenIterable.entries === iteratorFn) {
                  if (!didWarnAboutMaps) {
                    error("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
                  }
                  didWarnAboutMaps = true;
                }
                var _newChildren = iteratorFn.call(newChildrenIterable);
                if (_newChildren) {
                  var knownKeys = null;
                  var _step = _newChildren.next();
                  for (; !_step.done; _step = _newChildren.next()) {
                    var child = _step.value;
                    knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
                  }
                }
              }
              var newChildren = iteratorFn.call(newChildrenIterable);
              if (newChildren == null) {
                throw new Error("An iterable object provided no iterator.");
              }
              var resultingFirstChild = null;
              var previousNewFiber = null;
              var oldFiber = currentFirstChild;
              var lastPlacedIndex = 0;
              var newIdx = 0;
              var nextOldFiber = null;
              var step = newChildren.next();
              for (; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {
                if (oldFiber.index > newIdx) {
                  nextOldFiber = oldFiber;
                  oldFiber = null;
                } else {
                  nextOldFiber = oldFiber.sibling;
                }
                var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
                if (newFiber === null) {
                  if (oldFiber === null) {
                    oldFiber = nextOldFiber;
                  }
                  break;
                }
                if (shouldTrackSideEffects) {
                  if (oldFiber && newFiber.alternate === null) {
                    deleteChild(returnFiber, oldFiber);
                  }
                }
                lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
                if (previousNewFiber === null) {
                  resultingFirstChild = newFiber;
                } else {
                  previousNewFiber.sibling = newFiber;
                }
                previousNewFiber = newFiber;
                oldFiber = nextOldFiber;
              }
              if (step.done) {
                deleteRemainingChildren(returnFiber, oldFiber);
                if (getIsHydrating()) {
                  var numberOfForks = newIdx;
                  pushTreeFork(returnFiber, numberOfForks);
                }
                return resultingFirstChild;
              }
              if (oldFiber === null) {
                for (; !step.done; newIdx++, step = newChildren.next()) {
                  var _newFiber3 = createChild(returnFiber, step.value, lanes);
                  if (_newFiber3 === null) {
                    continue;
                  }
                  lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);
                  if (previousNewFiber === null) {
                    resultingFirstChild = _newFiber3;
                  } else {
                    previousNewFiber.sibling = _newFiber3;
                  }
                  previousNewFiber = _newFiber3;
                }
                if (getIsHydrating()) {
                  var _numberOfForks3 = newIdx;
                  pushTreeFork(returnFiber, _numberOfForks3);
                }
                return resultingFirstChild;
              }
              var existingChildren = mapRemainingChildren(returnFiber, oldFiber);
              for (; !step.done; newIdx++, step = newChildren.next()) {
                var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, lanes);
                if (_newFiber4 !== null) {
                  if (shouldTrackSideEffects) {
                    if (_newFiber4.alternate !== null) {
                      existingChildren.delete(_newFiber4.key === null ? newIdx : _newFiber4.key);
                    }
                  }
                  lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);
                  if (previousNewFiber === null) {
                    resultingFirstChild = _newFiber4;
                  } else {
                    previousNewFiber.sibling = _newFiber4;
                  }
                  previousNewFiber = _newFiber4;
                }
              }
              if (shouldTrackSideEffects) {
                existingChildren.forEach(function(child2) {
                  return deleteChild(returnFiber, child2);
                });
              }
              if (getIsHydrating()) {
                var _numberOfForks4 = newIdx;
                pushTreeFork(returnFiber, _numberOfForks4);
              }
              return resultingFirstChild;
            }
            function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, lanes) {
              if (currentFirstChild !== null && currentFirstChild.tag === HostText) {
                deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
                var existing = useFiber(currentFirstChild, textContent);
                existing.return = returnFiber;
                return existing;
              }
              deleteRemainingChildren(returnFiber, currentFirstChild);
              var created = createFiberFromText(textContent, returnFiber.mode, lanes);
              created.return = returnFiber;
              return created;
            }
            function reconcileSingleElement(returnFiber, currentFirstChild, element, lanes) {
              var key = element.key;
              var child = currentFirstChild;
              while (child !== null) {
                if (child.key === key) {
                  var elementType = element.type;
                  if (elementType === REACT_FRAGMENT_TYPE) {
                    if (child.tag === Fragment7) {
                      deleteRemainingChildren(returnFiber, child.sibling);
                      var existing = useFiber(child, element.props.children);
                      existing.return = returnFiber;
                      {
                        existing._debugSource = element._source;
                        existing._debugOwner = element._owner;
                      }
                      return existing;
                    }
                  } else {
                    if (child.elementType === elementType || // Keep this check inline so it only runs on the false path:
                    isCompatibleFamilyForHotReloading(child, element) || // Lazy types should reconcile their resolved type.
                    // We need to do this after the Hot Reloading check above,
                    // because hot reloading has different semantics than prod because
                    // it doesn't resuspend. So we can't let the call below suspend.
                    typeof elementType === "object" && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === child.type) {
                      deleteRemainingChildren(returnFiber, child.sibling);
                      var _existing = useFiber(child, element.props);
                      _existing.ref = coerceRef(returnFiber, child, element);
                      _existing.return = returnFiber;
                      {
                        _existing._debugSource = element._source;
                        _existing._debugOwner = element._owner;
                      }
                      return _existing;
                    }
                  }
                  deleteRemainingChildren(returnFiber, child);
                  break;
                } else {
                  deleteChild(returnFiber, child);
                }
                child = child.sibling;
              }
              if (element.type === REACT_FRAGMENT_TYPE) {
                var created = createFiberFromFragment(element.props.children, returnFiber.mode, lanes, element.key);
                created.return = returnFiber;
                return created;
              } else {
                var _created4 = createFiberFromElement(element, returnFiber.mode, lanes);
                _created4.ref = coerceRef(returnFiber, currentFirstChild, element);
                _created4.return = returnFiber;
                return _created4;
              }
            }
            function reconcileSinglePortal(returnFiber, currentFirstChild, portal, lanes) {
              var key = portal.key;
              var child = currentFirstChild;
              while (child !== null) {
                if (child.key === key) {
                  if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {
                    deleteRemainingChildren(returnFiber, child.sibling);
                    var existing = useFiber(child, portal.children || []);
                    existing.return = returnFiber;
                    return existing;
                  } else {
                    deleteRemainingChildren(returnFiber, child);
                    break;
                  }
                } else {
                  deleteChild(returnFiber, child);
                }
                child = child.sibling;
              }
              var created = createFiberFromPortal(portal, returnFiber.mode, lanes);
              created.return = returnFiber;
              return created;
            }
            function reconcileChildFibers2(returnFiber, currentFirstChild, newChild, lanes) {
              var isUnkeyedTopLevelFragment = typeof newChild === "object" && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null;
              if (isUnkeyedTopLevelFragment) {
                newChild = newChild.props.children;
              }
              if (typeof newChild === "object" && newChild !== null) {
                switch (newChild.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                    return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, lanes));
                  case REACT_PORTAL_TYPE:
                    return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, lanes));
                  case REACT_LAZY_TYPE:
                    var payload = newChild._payload;
                    var init5 = newChild._init;
                    return reconcileChildFibers2(returnFiber, currentFirstChild, init5(payload), lanes);
                }
                if (isArray(newChild)) {
                  return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes);
                }
                if (getIteratorFn(newChild)) {
                  return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, lanes);
                }
                throwOnInvalidObjectType(returnFiber, newChild);
              }
              if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
                return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, "" + newChild, lanes));
              }
              {
                if (typeof newChild === "function") {
                  warnOnFunctionType(returnFiber);
                }
              }
              return deleteRemainingChildren(returnFiber, currentFirstChild);
            }
            return reconcileChildFibers2;
          }
          var reconcileChildFibers = ChildReconciler(true);
          var mountChildFibers = ChildReconciler(false);
          function cloneChildFibers(current2, workInProgress2) {
            if (current2 !== null && workInProgress2.child !== current2.child) {
              throw new Error("Resuming work not yet implemented.");
            }
            if (workInProgress2.child === null) {
              return;
            }
            var currentChild = workInProgress2.child;
            var newChild = createWorkInProgress(currentChild, currentChild.pendingProps);
            workInProgress2.child = newChild;
            newChild.return = workInProgress2;
            while (currentChild.sibling !== null) {
              currentChild = currentChild.sibling;
              newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps);
              newChild.return = workInProgress2;
            }
            newChild.sibling = null;
          }
          function resetChildFibers(workInProgress2, lanes) {
            var child = workInProgress2.child;
            while (child !== null) {
              resetWorkInProgress(child, lanes);
              child = child.sibling;
            }
          }
          var valueCursor = createCursor(null);
          var rendererSigil;
          {
            rendererSigil = {};
          }
          var currentlyRenderingFiber = null;
          var lastContextDependency = null;
          var lastFullyObservedContext = null;
          var isDisallowedContextReadInDEV = false;
          function resetContextDependencies() {
            currentlyRenderingFiber = null;
            lastContextDependency = null;
            lastFullyObservedContext = null;
            {
              isDisallowedContextReadInDEV = false;
            }
          }
          function enterDisallowedContextReadInDEV() {
            {
              isDisallowedContextReadInDEV = true;
            }
          }
          function exitDisallowedContextReadInDEV() {
            {
              isDisallowedContextReadInDEV = false;
            }
          }
          function pushProvider(providerFiber, context3, nextValue) {
            {
              push2(valueCursor, context3._currentValue, providerFiber);
              context3._currentValue = nextValue;
              {
                if (context3._currentRenderer !== void 0 && context3._currentRenderer !== null && context3._currentRenderer !== rendererSigil) {
                  error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
                }
                context3._currentRenderer = rendererSigil;
              }
            }
          }
          function popProvider(context3, providerFiber) {
            var currentValue = valueCursor.current;
            pop(valueCursor, providerFiber);
            {
              {
                context3._currentValue = currentValue;
              }
            }
          }
          function scheduleContextWorkOnParentPath(parent, renderLanes2, propagationRoot) {
            var node = parent;
            while (node !== null) {
              var alternate = node.alternate;
              if (!isSubsetOfLanes(node.childLanes, renderLanes2)) {
                node.childLanes = mergeLanes(node.childLanes, renderLanes2);
                if (alternate !== null) {
                  alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes2);
                }
              } else if (alternate !== null && !isSubsetOfLanes(alternate.childLanes, renderLanes2)) {
                alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes2);
              }
              if (node === propagationRoot) {
                break;
              }
              node = node.return;
            }
            {
              if (node !== propagationRoot) {
                error("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
          }
          function propagateContextChange(workInProgress2, context3, renderLanes2) {
            {
              propagateContextChange_eager(workInProgress2, context3, renderLanes2);
            }
          }
          function propagateContextChange_eager(workInProgress2, context3, renderLanes2) {
            var fiber = workInProgress2.child;
            if (fiber !== null) {
              fiber.return = workInProgress2;
            }
            while (fiber !== null) {
              var nextFiber = void 0;
              var list = fiber.dependencies;
              if (list !== null) {
                nextFiber = fiber.child;
                var dependency = list.firstContext;
                while (dependency !== null) {
                  if (dependency.context === context3) {
                    if (fiber.tag === ClassComponent) {
                      var lane = pickArbitraryLane(renderLanes2);
                      var update = createUpdate(NoTimestamp, lane);
                      update.tag = ForceUpdate;
                      var updateQueue = fiber.updateQueue;
                      if (updateQueue === null) ;
                      else {
                        var sharedQueue = updateQueue.shared;
                        var pending = sharedQueue.pending;
                        if (pending === null) {
                          update.next = update;
                        } else {
                          update.next = pending.next;
                          pending.next = update;
                        }
                        sharedQueue.pending = update;
                      }
                    }
                    fiber.lanes = mergeLanes(fiber.lanes, renderLanes2);
                    var alternate = fiber.alternate;
                    if (alternate !== null) {
                      alternate.lanes = mergeLanes(alternate.lanes, renderLanes2);
                    }
                    scheduleContextWorkOnParentPath(fiber.return, renderLanes2, workInProgress2);
                    list.lanes = mergeLanes(list.lanes, renderLanes2);
                    break;
                  }
                  dependency = dependency.next;
                }
              } else if (fiber.tag === ContextProvider) {
                nextFiber = fiber.type === workInProgress2.type ? null : fiber.child;
              } else if (fiber.tag === DehydratedFragment) {
                var parentSuspense = fiber.return;
                if (parentSuspense === null) {
                  throw new Error("We just came from a parent so we must have had a parent. This is a bug in React.");
                }
                parentSuspense.lanes = mergeLanes(parentSuspense.lanes, renderLanes2);
                var _alternate = parentSuspense.alternate;
                if (_alternate !== null) {
                  _alternate.lanes = mergeLanes(_alternate.lanes, renderLanes2);
                }
                scheduleContextWorkOnParentPath(parentSuspense, renderLanes2, workInProgress2);
                nextFiber = fiber.sibling;
              } else {
                nextFiber = fiber.child;
              }
              if (nextFiber !== null) {
                nextFiber.return = fiber;
              } else {
                nextFiber = fiber;
                while (nextFiber !== null) {
                  if (nextFiber === workInProgress2) {
                    nextFiber = null;
                    break;
                  }
                  var sibling = nextFiber.sibling;
                  if (sibling !== null) {
                    sibling.return = nextFiber.return;
                    nextFiber = sibling;
                    break;
                  }
                  nextFiber = nextFiber.return;
                }
              }
              fiber = nextFiber;
            }
          }
          function prepareToReadContext(workInProgress2, renderLanes2) {
            currentlyRenderingFiber = workInProgress2;
            lastContextDependency = null;
            lastFullyObservedContext = null;
            var dependencies = workInProgress2.dependencies;
            if (dependencies !== null) {
              {
                var firstContext = dependencies.firstContext;
                if (firstContext !== null) {
                  if (includesSomeLane(dependencies.lanes, renderLanes2)) {
                    markWorkInProgressReceivedUpdate();
                  }
                  dependencies.firstContext = null;
                }
              }
            }
          }
          function readContext(context3) {
            {
              if (isDisallowedContextReadInDEV) {
                error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
              }
            }
            var value = context3._currentValue;
            if (lastFullyObservedContext === context3) ;
            else {
              var contextItem = {
                context: context3,
                memoizedValue: value,
                next: null
              };
              if (lastContextDependency === null) {
                if (currentlyRenderingFiber === null) {
                  throw new Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
                }
                lastContextDependency = contextItem;
                currentlyRenderingFiber.dependencies = {
                  lanes: NoLanes,
                  firstContext: contextItem
                };
              } else {
                lastContextDependency = lastContextDependency.next = contextItem;
              }
            }
            return value;
          }
          var concurrentQueues = null;
          function pushConcurrentUpdateQueue(queue) {
            if (concurrentQueues === null) {
              concurrentQueues = [queue];
            } else {
              concurrentQueues.push(queue);
            }
          }
          function finishQueueingConcurrentUpdates() {
            if (concurrentQueues !== null) {
              for (var i = 0; i < concurrentQueues.length; i++) {
                var queue = concurrentQueues[i];
                var lastInterleavedUpdate = queue.interleaved;
                if (lastInterleavedUpdate !== null) {
                  queue.interleaved = null;
                  var firstInterleavedUpdate = lastInterleavedUpdate.next;
                  var lastPendingUpdate = queue.pending;
                  if (lastPendingUpdate !== null) {
                    var firstPendingUpdate = lastPendingUpdate.next;
                    lastPendingUpdate.next = firstInterleavedUpdate;
                    lastInterleavedUpdate.next = firstPendingUpdate;
                  }
                  queue.pending = lastInterleavedUpdate;
                }
              }
              concurrentQueues = null;
            }
          }
          function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
            var interleaved = queue.interleaved;
            if (interleaved === null) {
              update.next = update;
              pushConcurrentUpdateQueue(queue);
            } else {
              update.next = interleaved.next;
              interleaved.next = update;
            }
            queue.interleaved = update;
            return markUpdateLaneFromFiberToRoot(fiber, lane);
          }
          function enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update, lane) {
            var interleaved = queue.interleaved;
            if (interleaved === null) {
              update.next = update;
              pushConcurrentUpdateQueue(queue);
            } else {
              update.next = interleaved.next;
              interleaved.next = update;
            }
            queue.interleaved = update;
          }
          function enqueueConcurrentClassUpdate(fiber, queue, update, lane) {
            var interleaved = queue.interleaved;
            if (interleaved === null) {
              update.next = update;
              pushConcurrentUpdateQueue(queue);
            } else {
              update.next = interleaved.next;
              interleaved.next = update;
            }
            queue.interleaved = update;
            return markUpdateLaneFromFiberToRoot(fiber, lane);
          }
          function enqueueConcurrentRenderForLane(fiber, lane) {
            return markUpdateLaneFromFiberToRoot(fiber, lane);
          }
          var unsafe_markUpdateLaneFromFiberToRoot = markUpdateLaneFromFiberToRoot;
          function markUpdateLaneFromFiberToRoot(sourceFiber, lane) {
            sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);
            var alternate = sourceFiber.alternate;
            if (alternate !== null) {
              alternate.lanes = mergeLanes(alternate.lanes, lane);
            }
            {
              if (alternate === null && (sourceFiber.flags & (Placement | Hydrating)) !== NoFlags) {
                warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
              }
            }
            var node = sourceFiber;
            var parent = sourceFiber.return;
            while (parent !== null) {
              parent.childLanes = mergeLanes(parent.childLanes, lane);
              alternate = parent.alternate;
              if (alternate !== null) {
                alternate.childLanes = mergeLanes(alternate.childLanes, lane);
              } else {
                {
                  if ((parent.flags & (Placement | Hydrating)) !== NoFlags) {
                    warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
                  }
                }
              }
              node = parent;
              parent = parent.return;
            }
            if (node.tag === HostRoot) {
              var root3 = node.stateNode;
              return root3;
            } else {
              return null;
            }
          }
          var UpdateState = 0;
          var ReplaceState = 1;
          var ForceUpdate = 2;
          var CaptureUpdate = 3;
          var hasForceUpdate = false;
          var didWarnUpdateInsideUpdate;
          var currentlyProcessingQueue;
          {
            didWarnUpdateInsideUpdate = false;
            currentlyProcessingQueue = null;
          }
          function initializeUpdateQueue(fiber) {
            var queue = {
              baseState: fiber.memoizedState,
              firstBaseUpdate: null,
              lastBaseUpdate: null,
              shared: {
                pending: null,
                interleaved: null,
                lanes: NoLanes
              },
              effects: null
            };
            fiber.updateQueue = queue;
          }
          function cloneUpdateQueue(current2, workInProgress2) {
            var queue = workInProgress2.updateQueue;
            var currentQueue = current2.updateQueue;
            if (queue === currentQueue) {
              var clone = {
                baseState: currentQueue.baseState,
                firstBaseUpdate: currentQueue.firstBaseUpdate,
                lastBaseUpdate: currentQueue.lastBaseUpdate,
                shared: currentQueue.shared,
                effects: currentQueue.effects
              };
              workInProgress2.updateQueue = clone;
            }
          }
          function createUpdate(eventTime, lane) {
            var update = {
              eventTime,
              lane,
              tag: UpdateState,
              payload: null,
              callback: null,
              next: null
            };
            return update;
          }
          function enqueueUpdate(fiber, update, lane) {
            var updateQueue = fiber.updateQueue;
            if (updateQueue === null) {
              return null;
            }
            var sharedQueue = updateQueue.shared;
            {
              if (currentlyProcessingQueue === sharedQueue && !didWarnUpdateInsideUpdate) {
                error("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.");
                didWarnUpdateInsideUpdate = true;
              }
            }
            if (isUnsafeClassRenderPhaseUpdate()) {
              var pending = sharedQueue.pending;
              if (pending === null) {
                update.next = update;
              } else {
                update.next = pending.next;
                pending.next = update;
              }
              sharedQueue.pending = update;
              return unsafe_markUpdateLaneFromFiberToRoot(fiber, lane);
            } else {
              return enqueueConcurrentClassUpdate(fiber, sharedQueue, update, lane);
            }
          }
          function entangleTransitions(root3, fiber, lane) {
            var updateQueue = fiber.updateQueue;
            if (updateQueue === null) {
              return;
            }
            var sharedQueue = updateQueue.shared;
            if (isTransitionLane(lane)) {
              var queueLanes = sharedQueue.lanes;
              queueLanes = intersectLanes(queueLanes, root3.pendingLanes);
              var newQueueLanes = mergeLanes(queueLanes, lane);
              sharedQueue.lanes = newQueueLanes;
              markRootEntangled(root3, newQueueLanes);
            }
          }
          function enqueueCapturedUpdate(workInProgress2, capturedUpdate) {
            var queue = workInProgress2.updateQueue;
            var current2 = workInProgress2.alternate;
            if (current2 !== null) {
              var currentQueue = current2.updateQueue;
              if (queue === currentQueue) {
                var newFirst = null;
                var newLast = null;
                var firstBaseUpdate = queue.firstBaseUpdate;
                if (firstBaseUpdate !== null) {
                  var update = firstBaseUpdate;
                  do {
                    var clone = {
                      eventTime: update.eventTime,
                      lane: update.lane,
                      tag: update.tag,
                      payload: update.payload,
                      callback: update.callback,
                      next: null
                    };
                    if (newLast === null) {
                      newFirst = newLast = clone;
                    } else {
                      newLast.next = clone;
                      newLast = clone;
                    }
                    update = update.next;
                  } while (update !== null);
                  if (newLast === null) {
                    newFirst = newLast = capturedUpdate;
                  } else {
                    newLast.next = capturedUpdate;
                    newLast = capturedUpdate;
                  }
                } else {
                  newFirst = newLast = capturedUpdate;
                }
                queue = {
                  baseState: currentQueue.baseState,
                  firstBaseUpdate: newFirst,
                  lastBaseUpdate: newLast,
                  shared: currentQueue.shared,
                  effects: currentQueue.effects
                };
                workInProgress2.updateQueue = queue;
                return;
              }
            }
            var lastBaseUpdate = queue.lastBaseUpdate;
            if (lastBaseUpdate === null) {
              queue.firstBaseUpdate = capturedUpdate;
            } else {
              lastBaseUpdate.next = capturedUpdate;
            }
            queue.lastBaseUpdate = capturedUpdate;
          }
          function getStateFromUpdate(workInProgress2, queue, update, prevState, nextProps, instance) {
            switch (update.tag) {
              case ReplaceState: {
                var payload = update.payload;
                if (typeof payload === "function") {
                  {
                    enterDisallowedContextReadInDEV();
                  }
                  var nextState = payload.call(instance, prevState, nextProps);
                  {
                    if (workInProgress2.mode & StrictLegacyMode) {
                      setIsStrictModeForDevtools(true);
                      try {
                        payload.call(instance, prevState, nextProps);
                      } finally {
                        setIsStrictModeForDevtools(false);
                      }
                    }
                    exitDisallowedContextReadInDEV();
                  }
                  return nextState;
                }
                return payload;
              }
              case CaptureUpdate: {
                workInProgress2.flags = workInProgress2.flags & ~ShouldCapture | DidCapture;
              }
              // Intentional fallthrough
              case UpdateState: {
                var _payload = update.payload;
                var partialState;
                if (typeof _payload === "function") {
                  {
                    enterDisallowedContextReadInDEV();
                  }
                  partialState = _payload.call(instance, prevState, nextProps);
                  {
                    if (workInProgress2.mode & StrictLegacyMode) {
                      setIsStrictModeForDevtools(true);
                      try {
                        _payload.call(instance, prevState, nextProps);
                      } finally {
                        setIsStrictModeForDevtools(false);
                      }
                    }
                    exitDisallowedContextReadInDEV();
                  }
                } else {
                  partialState = _payload;
                }
                if (partialState === null || partialState === void 0) {
                  return prevState;
                }
                return assign({}, prevState, partialState);
              }
              case ForceUpdate: {
                hasForceUpdate = true;
                return prevState;
              }
            }
            return prevState;
          }
          function processUpdateQueue(workInProgress2, props, instance, renderLanes2) {
            var queue = workInProgress2.updateQueue;
            hasForceUpdate = false;
            {
              currentlyProcessingQueue = queue.shared;
            }
            var firstBaseUpdate = queue.firstBaseUpdate;
            var lastBaseUpdate = queue.lastBaseUpdate;
            var pendingQueue = queue.shared.pending;
            if (pendingQueue !== null) {
              queue.shared.pending = null;
              var lastPendingUpdate = pendingQueue;
              var firstPendingUpdate = lastPendingUpdate.next;
              lastPendingUpdate.next = null;
              if (lastBaseUpdate === null) {
                firstBaseUpdate = firstPendingUpdate;
              } else {
                lastBaseUpdate.next = firstPendingUpdate;
              }
              lastBaseUpdate = lastPendingUpdate;
              var current2 = workInProgress2.alternate;
              if (current2 !== null) {
                var currentQueue = current2.updateQueue;
                var currentLastBaseUpdate = currentQueue.lastBaseUpdate;
                if (currentLastBaseUpdate !== lastBaseUpdate) {
                  if (currentLastBaseUpdate === null) {
                    currentQueue.firstBaseUpdate = firstPendingUpdate;
                  } else {
                    currentLastBaseUpdate.next = firstPendingUpdate;
                  }
                  currentQueue.lastBaseUpdate = lastPendingUpdate;
                }
              }
            }
            if (firstBaseUpdate !== null) {
              var newState = queue.baseState;
              var newLanes = NoLanes;
              var newBaseState = null;
              var newFirstBaseUpdate = null;
              var newLastBaseUpdate = null;
              var update = firstBaseUpdate;
              do {
                var updateLane = update.lane;
                var updateEventTime = update.eventTime;
                if (!isSubsetOfLanes(renderLanes2, updateLane)) {
                  var clone = {
                    eventTime: updateEventTime,
                    lane: updateLane,
                    tag: update.tag,
                    payload: update.payload,
                    callback: update.callback,
                    next: null
                  };
                  if (newLastBaseUpdate === null) {
                    newFirstBaseUpdate = newLastBaseUpdate = clone;
                    newBaseState = newState;
                  } else {
                    newLastBaseUpdate = newLastBaseUpdate.next = clone;
                  }
                  newLanes = mergeLanes(newLanes, updateLane);
                } else {
                  if (newLastBaseUpdate !== null) {
                    var _clone = {
                      eventTime: updateEventTime,
                      // This update is going to be committed so we never want uncommit
                      // it. Using NoLane works because 0 is a subset of all bitmasks, so
                      // this will never be skipped by the check above.
                      lane: NoLane,
                      tag: update.tag,
                      payload: update.payload,
                      callback: update.callback,
                      next: null
                    };
                    newLastBaseUpdate = newLastBaseUpdate.next = _clone;
                  }
                  newState = getStateFromUpdate(workInProgress2, queue, update, newState, props, instance);
                  var callback = update.callback;
                  if (callback !== null && // If the update was already committed, we should not queue its
                  // callback again.
                  update.lane !== NoLane) {
                    workInProgress2.flags |= Callback;
                    var effects = queue.effects;
                    if (effects === null) {
                      queue.effects = [update];
                    } else {
                      effects.push(update);
                    }
                  }
                }
                update = update.next;
                if (update === null) {
                  pendingQueue = queue.shared.pending;
                  if (pendingQueue === null) {
                    break;
                  } else {
                    var _lastPendingUpdate = pendingQueue;
                    var _firstPendingUpdate = _lastPendingUpdate.next;
                    _lastPendingUpdate.next = null;
                    update = _firstPendingUpdate;
                    queue.lastBaseUpdate = _lastPendingUpdate;
                    queue.shared.pending = null;
                  }
                }
              } while (true);
              if (newLastBaseUpdate === null) {
                newBaseState = newState;
              }
              queue.baseState = newBaseState;
              queue.firstBaseUpdate = newFirstBaseUpdate;
              queue.lastBaseUpdate = newLastBaseUpdate;
              var lastInterleaved = queue.shared.interleaved;
              if (lastInterleaved !== null) {
                var interleaved = lastInterleaved;
                do {
                  newLanes = mergeLanes(newLanes, interleaved.lane);
                  interleaved = interleaved.next;
                } while (interleaved !== lastInterleaved);
              } else if (firstBaseUpdate === null) {
                queue.shared.lanes = NoLanes;
              }
              markSkippedUpdateLanes(newLanes);
              workInProgress2.lanes = newLanes;
              workInProgress2.memoizedState = newState;
            }
            {
              currentlyProcessingQueue = null;
            }
          }
          function callCallback(callback, context3) {
            if (typeof callback !== "function") {
              throw new Error("Invalid argument passed as callback. Expected a function. Instead " + ("received: " + callback));
            }
            callback.call(context3);
          }
          function resetHasForceUpdateBeforeProcessing() {
            hasForceUpdate = false;
          }
          function checkHasForceUpdateAfterProcessing() {
            return hasForceUpdate;
          }
          function commitUpdateQueue(finishedWork, finishedQueue, instance) {
            var effects = finishedQueue.effects;
            finishedQueue.effects = null;
            if (effects !== null) {
              for (var i = 0; i < effects.length; i++) {
                var effect = effects[i];
                var callback = effect.callback;
                if (callback !== null) {
                  effect.callback = null;
                  callCallback(callback, instance);
                }
              }
            }
          }
          var NO_CONTEXT = {};
          var contextStackCursor$1 = createCursor(NO_CONTEXT);
          var contextFiberStackCursor = createCursor(NO_CONTEXT);
          var rootInstanceStackCursor = createCursor(NO_CONTEXT);
          function requiredContext(c) {
            if (c === NO_CONTEXT) {
              throw new Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
            }
            return c;
          }
          function getRootHostContainer() {
            var rootInstance = requiredContext(rootInstanceStackCursor.current);
            return rootInstance;
          }
          function pushHostContainer(fiber, nextRootInstance) {
            push2(rootInstanceStackCursor, nextRootInstance, fiber);
            push2(contextFiberStackCursor, fiber, fiber);
            push2(contextStackCursor$1, NO_CONTEXT, fiber);
            var nextRootContext = getRootHostContext(nextRootInstance);
            pop(contextStackCursor$1, fiber);
            push2(contextStackCursor$1, nextRootContext, fiber);
          }
          function popHostContainer(fiber) {
            pop(contextStackCursor$1, fiber);
            pop(contextFiberStackCursor, fiber);
            pop(rootInstanceStackCursor, fiber);
          }
          function getHostContext() {
            var context3 = requiredContext(contextStackCursor$1.current);
            return context3;
          }
          function pushHostContext(fiber) {
            var rootInstance = requiredContext(rootInstanceStackCursor.current);
            var context3 = requiredContext(contextStackCursor$1.current);
            var nextContext = getChildHostContext(context3, fiber.type);
            if (context3 === nextContext) {
              return;
            }
            push2(contextFiberStackCursor, fiber, fiber);
            push2(contextStackCursor$1, nextContext, fiber);
          }
          function popHostContext(fiber) {
            if (contextFiberStackCursor.current !== fiber) {
              return;
            }
            pop(contextStackCursor$1, fiber);
            pop(contextFiberStackCursor, fiber);
          }
          var DefaultSuspenseContext = 0;
          var SubtreeSuspenseContextMask = 1;
          var InvisibleParentSuspenseContext = 1;
          var ForceSuspenseFallback = 2;
          var suspenseStackCursor = createCursor(DefaultSuspenseContext);
          function hasSuspenseContext(parentContext, flag) {
            return (parentContext & flag) !== 0;
          }
          function setDefaultShallowSuspenseContext(parentContext) {
            return parentContext & SubtreeSuspenseContextMask;
          }
          function setShallowSuspenseContext(parentContext, shallowContext) {
            return parentContext & SubtreeSuspenseContextMask | shallowContext;
          }
          function addSubtreeSuspenseContext(parentContext, subtreeContext) {
            return parentContext | subtreeContext;
          }
          function pushSuspenseContext(fiber, newContext) {
            push2(suspenseStackCursor, newContext, fiber);
          }
          function popSuspenseContext(fiber) {
            pop(suspenseStackCursor, fiber);
          }
          function shouldCaptureSuspense(workInProgress2, hasInvisibleParent) {
            var nextState = workInProgress2.memoizedState;
            if (nextState !== null) {
              if (nextState.dehydrated !== null) {
                return true;
              }
              return false;
            }
            var props = workInProgress2.memoizedProps;
            {
              return true;
            }
          }
          function findFirstSuspended(row) {
            var node = row;
            while (node !== null) {
              if (node.tag === SuspenseComponent) {
                var state = node.memoizedState;
                if (state !== null) {
                  var dehydrated = state.dehydrated;
                  if (dehydrated === null || isSuspenseInstancePending(dehydrated) || isSuspenseInstanceFallback(dehydrated)) {
                    return node;
                  }
                }
              } else if (node.tag === SuspenseListComponent && // revealOrder undefined can't be trusted because it don't
              // keep track of whether it suspended or not.
              node.memoizedProps.revealOrder !== void 0) {
                var didSuspend = (node.flags & DidCapture) !== NoFlags;
                if (didSuspend) {
                  return node;
                }
              } else if (node.child !== null) {
                node.child.return = node;
                node = node.child;
                continue;
              }
              if (node === row) {
                return null;
              }
              while (node.sibling === null) {
                if (node.return === null || node.return === row) {
                  return null;
                }
                node = node.return;
              }
              node.sibling.return = node.return;
              node = node.sibling;
            }
            return null;
          }
          var NoFlags$1 = (
            /*   */
            0
          );
          var HasEffect = (
            /* */
            1
          );
          var Insertion = (
            /*  */
            2
          );
          var Layout = (
            /*    */
            4
          );
          var Passive$1 = (
            /*   */
            8
          );
          var workInProgressSources = [];
          function resetWorkInProgressVersions() {
            for (var i = 0; i < workInProgressSources.length; i++) {
              var mutableSource = workInProgressSources[i];
              {
                mutableSource._workInProgressVersionPrimary = null;
              }
            }
            workInProgressSources.length = 0;
          }
          function registerMutableSourceForHydration(root3, mutableSource) {
            var getVersion = mutableSource._getVersion;
            var version2 = getVersion(mutableSource._source);
            if (root3.mutableSourceEagerHydrationData == null) {
              root3.mutableSourceEagerHydrationData = [mutableSource, version2];
            } else {
              root3.mutableSourceEagerHydrationData.push(mutableSource, version2);
            }
          }
          var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher, ReactCurrentBatchConfig$2 = ReactSharedInternals.ReactCurrentBatchConfig;
          var didWarnAboutMismatchedHooksForComponent;
          var didWarnUncachedGetSnapshot;
          {
            didWarnAboutMismatchedHooksForComponent = /* @__PURE__ */ new Set();
          }
          var renderLanes = NoLanes;
          var currentlyRenderingFiber$1 = null;
          var currentHook = null;
          var workInProgressHook = null;
          var didScheduleRenderPhaseUpdate = false;
          var didScheduleRenderPhaseUpdateDuringThisPass = false;
          var localIdCounter = 0;
          var globalClientIdCounter = 0;
          var RE_RENDER_LIMIT = 25;
          var currentHookNameInDev = null;
          var hookTypesDev = null;
          var hookTypesUpdateIndexDev = -1;
          var ignorePreviousDependencies = false;
          function mountHookTypesDev() {
            {
              var hookName = currentHookNameInDev;
              if (hookTypesDev === null) {
                hookTypesDev = [hookName];
              } else {
                hookTypesDev.push(hookName);
              }
            }
          }
          function updateHookTypesDev() {
            {
              var hookName = currentHookNameInDev;
              if (hookTypesDev !== null) {
                hookTypesUpdateIndexDev++;
                if (hookTypesDev[hookTypesUpdateIndexDev] !== hookName) {
                  warnOnHookMismatchInDev(hookName);
                }
              }
            }
          }
          function checkDepsAreArrayDev(deps) {
            {
              if (deps !== void 0 && deps !== null && !isArray(deps)) {
                error("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", currentHookNameInDev, typeof deps);
              }
            }
          }
          function warnOnHookMismatchInDev(currentHookName) {
            {
              var componentName = getComponentNameFromFiber(currentlyRenderingFiber$1);
              if (!didWarnAboutMismatchedHooksForComponent.has(componentName)) {
                didWarnAboutMismatchedHooksForComponent.add(componentName);
                if (hookTypesDev !== null) {
                  var table = "";
                  var secondColumnStart = 30;
                  for (var i = 0; i <= hookTypesUpdateIndexDev; i++) {
                    var oldHookName = hookTypesDev[i];
                    var newHookName = i === hookTypesUpdateIndexDev ? currentHookName : oldHookName;
                    var row = i + 1 + ". " + oldHookName;
                    while (row.length < secondColumnStart) {
                      row += " ";
                    }
                    row += newHookName + "\n";
                    table += row;
                  }
                  error("React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\n\n   Previous render            Next render\n   ------------------------------------------------------\n%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n", componentName, table);
                }
              }
            }
          }
          function throwInvalidHookError() {
            throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
          }
          function areHookInputsEqual(nextDeps, prevDeps) {
            {
              if (ignorePreviousDependencies) {
                return false;
              }
            }
            if (prevDeps === null) {
              {
                error("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", currentHookNameInDev);
              }
              return false;
            }
            {
              if (nextDeps.length !== prevDeps.length) {
                error("The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s", currentHookNameInDev, "[" + prevDeps.join(", ") + "]", "[" + nextDeps.join(", ") + "]");
              }
            }
            for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++) {
              if (objectIs(nextDeps[i], prevDeps[i])) {
                continue;
              }
              return false;
            }
            return true;
          }
          function renderWithHooks(current2, workInProgress2, Component3, props, secondArg, nextRenderLanes) {
            renderLanes = nextRenderLanes;
            currentlyRenderingFiber$1 = workInProgress2;
            {
              hookTypesDev = current2 !== null ? current2._debugHookTypes : null;
              hookTypesUpdateIndexDev = -1;
              ignorePreviousDependencies = current2 !== null && current2.type !== workInProgress2.type;
            }
            workInProgress2.memoizedState = null;
            workInProgress2.updateQueue = null;
            workInProgress2.lanes = NoLanes;
            {
              if (current2 !== null && current2.memoizedState !== null) {
                ReactCurrentDispatcher$1.current = HooksDispatcherOnUpdateInDEV;
              } else if (hookTypesDev !== null) {
                ReactCurrentDispatcher$1.current = HooksDispatcherOnMountWithHookTypesInDEV;
              } else {
                ReactCurrentDispatcher$1.current = HooksDispatcherOnMountInDEV;
              }
            }
            var children = Component3(props, secondArg);
            if (didScheduleRenderPhaseUpdateDuringThisPass) {
              var numberOfReRenders = 0;
              do {
                didScheduleRenderPhaseUpdateDuringThisPass = false;
                localIdCounter = 0;
                if (numberOfReRenders >= RE_RENDER_LIMIT) {
                  throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
                }
                numberOfReRenders += 1;
                {
                  ignorePreviousDependencies = false;
                }
                currentHook = null;
                workInProgressHook = null;
                workInProgress2.updateQueue = null;
                {
                  hookTypesUpdateIndexDev = -1;
                }
                ReactCurrentDispatcher$1.current = HooksDispatcherOnRerenderInDEV;
                children = Component3(props, secondArg);
              } while (didScheduleRenderPhaseUpdateDuringThisPass);
            }
            ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
            {
              workInProgress2._debugHookTypes = hookTypesDev;
            }
            var didRenderTooFewHooks = currentHook !== null && currentHook.next !== null;
            renderLanes = NoLanes;
            currentlyRenderingFiber$1 = null;
            currentHook = null;
            workInProgressHook = null;
            {
              currentHookNameInDev = null;
              hookTypesDev = null;
              hookTypesUpdateIndexDev = -1;
              if (current2 !== null && (current2.flags & StaticMask) !== (workInProgress2.flags & StaticMask) && // Disable this warning in legacy mode, because legacy Suspense is weird
              // and creates false positives. To make this work in legacy mode, we'd
              // need to mark fibers that commit in an incomplete state, somehow. For
              // now I'll disable the warning that most of the bugs that would trigger
              // it are either exclusive to concurrent mode or exist in both.
              (current2.mode & ConcurrentMode) !== NoMode) {
                error("Internal React error: Expected static flag was missing. Please notify the React team.");
              }
            }
            didScheduleRenderPhaseUpdate = false;
            if (didRenderTooFewHooks) {
              throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
            }
            return children;
          }
          function checkDidRenderIdHook() {
            var didRenderIdHook = localIdCounter !== 0;
            localIdCounter = 0;
            return didRenderIdHook;
          }
          function bailoutHooks(current2, workInProgress2, lanes) {
            workInProgress2.updateQueue = current2.updateQueue;
            if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
              workInProgress2.flags &= ~(MountPassiveDev | MountLayoutDev | Passive | Update);
            } else {
              workInProgress2.flags &= ~(Passive | Update);
            }
            current2.lanes = removeLanes(current2.lanes, lanes);
          }
          function resetHooksAfterThrow() {
            ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
            if (didScheduleRenderPhaseUpdate) {
              var hook = currentlyRenderingFiber$1.memoizedState;
              while (hook !== null) {
                var queue = hook.queue;
                if (queue !== null) {
                  queue.pending = null;
                }
                hook = hook.next;
              }
              didScheduleRenderPhaseUpdate = false;
            }
            renderLanes = NoLanes;
            currentlyRenderingFiber$1 = null;
            currentHook = null;
            workInProgressHook = null;
            {
              hookTypesDev = null;
              hookTypesUpdateIndexDev = -1;
              currentHookNameInDev = null;
              isUpdatingOpaqueValueInRenderPhase = false;
            }
            didScheduleRenderPhaseUpdateDuringThisPass = false;
            localIdCounter = 0;
          }
          function mountWorkInProgressHook() {
            var hook = {
              memoizedState: null,
              baseState: null,
              baseQueue: null,
              queue: null,
              next: null
            };
            if (workInProgressHook === null) {
              currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook;
            } else {
              workInProgressHook = workInProgressHook.next = hook;
            }
            return workInProgressHook;
          }
          function updateWorkInProgressHook() {
            var nextCurrentHook;
            if (currentHook === null) {
              var current2 = currentlyRenderingFiber$1.alternate;
              if (current2 !== null) {
                nextCurrentHook = current2.memoizedState;
              } else {
                nextCurrentHook = null;
              }
            } else {
              nextCurrentHook = currentHook.next;
            }
            var nextWorkInProgressHook;
            if (workInProgressHook === null) {
              nextWorkInProgressHook = currentlyRenderingFiber$1.memoizedState;
            } else {
              nextWorkInProgressHook = workInProgressHook.next;
            }
            if (nextWorkInProgressHook !== null) {
              workInProgressHook = nextWorkInProgressHook;
              nextWorkInProgressHook = workInProgressHook.next;
              currentHook = nextCurrentHook;
            } else {
              if (nextCurrentHook === null) {
                throw new Error("Rendered more hooks than during the previous render.");
              }
              currentHook = nextCurrentHook;
              var newHook = {
                memoizedState: currentHook.memoizedState,
                baseState: currentHook.baseState,
                baseQueue: currentHook.baseQueue,
                queue: currentHook.queue,
                next: null
              };
              if (workInProgressHook === null) {
                currentlyRenderingFiber$1.memoizedState = workInProgressHook = newHook;
              } else {
                workInProgressHook = workInProgressHook.next = newHook;
              }
            }
            return workInProgressHook;
          }
          function createFunctionComponentUpdateQueue() {
            return {
              lastEffect: null,
              stores: null
            };
          }
          function basicStateReducer(state, action) {
            return typeof action === "function" ? action(state) : action;
          }
          function mountReducer(reducer, initialArg, init5) {
            var hook = mountWorkInProgressHook();
            var initialState;
            if (init5 !== void 0) {
              initialState = init5(initialArg);
            } else {
              initialState = initialArg;
            }
            hook.memoizedState = hook.baseState = initialState;
            var queue = {
              pending: null,
              interleaved: null,
              lanes: NoLanes,
              dispatch: null,
              lastRenderedReducer: reducer,
              lastRenderedState: initialState
            };
            hook.queue = queue;
            var dispatch = queue.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber$1, queue);
            return [hook.memoizedState, dispatch];
          }
          function updateReducer(reducer, initialArg, init5) {
            var hook = updateWorkInProgressHook();
            var queue = hook.queue;
            if (queue === null) {
              throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
            }
            queue.lastRenderedReducer = reducer;
            var current2 = currentHook;
            var baseQueue = current2.baseQueue;
            var pendingQueue = queue.pending;
            if (pendingQueue !== null) {
              if (baseQueue !== null) {
                var baseFirst = baseQueue.next;
                var pendingFirst = pendingQueue.next;
                baseQueue.next = pendingFirst;
                pendingQueue.next = baseFirst;
              }
              {
                if (current2.baseQueue !== baseQueue) {
                  error("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React.");
                }
              }
              current2.baseQueue = baseQueue = pendingQueue;
              queue.pending = null;
            }
            if (baseQueue !== null) {
              var first = baseQueue.next;
              var newState = current2.baseState;
              var newBaseState = null;
              var newBaseQueueFirst = null;
              var newBaseQueueLast = null;
              var update = first;
              do {
                var updateLane = update.lane;
                if (!isSubsetOfLanes(renderLanes, updateLane)) {
                  var clone = {
                    lane: updateLane,
                    action: update.action,
                    hasEagerState: update.hasEagerState,
                    eagerState: update.eagerState,
                    next: null
                  };
                  if (newBaseQueueLast === null) {
                    newBaseQueueFirst = newBaseQueueLast = clone;
                    newBaseState = newState;
                  } else {
                    newBaseQueueLast = newBaseQueueLast.next = clone;
                  }
                  currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, updateLane);
                  markSkippedUpdateLanes(updateLane);
                } else {
                  if (newBaseQueueLast !== null) {
                    var _clone = {
                      // This update is going to be committed so we never want uncommit
                      // it. Using NoLane works because 0 is a subset of all bitmasks, so
                      // this will never be skipped by the check above.
                      lane: NoLane,
                      action: update.action,
                      hasEagerState: update.hasEagerState,
                      eagerState: update.eagerState,
                      next: null
                    };
                    newBaseQueueLast = newBaseQueueLast.next = _clone;
                  }
                  if (update.hasEagerState) {
                    newState = update.eagerState;
                  } else {
                    var action = update.action;
                    newState = reducer(newState, action);
                  }
                }
                update = update.next;
              } while (update !== null && update !== first);
              if (newBaseQueueLast === null) {
                newBaseState = newState;
              } else {
                newBaseQueueLast.next = newBaseQueueFirst;
              }
              if (!objectIs(newState, hook.memoizedState)) {
                markWorkInProgressReceivedUpdate();
              }
              hook.memoizedState = newState;
              hook.baseState = newBaseState;
              hook.baseQueue = newBaseQueueLast;
              queue.lastRenderedState = newState;
            }
            var lastInterleaved = queue.interleaved;
            if (lastInterleaved !== null) {
              var interleaved = lastInterleaved;
              do {
                var interleavedLane = interleaved.lane;
                currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, interleavedLane);
                markSkippedUpdateLanes(interleavedLane);
                interleaved = interleaved.next;
              } while (interleaved !== lastInterleaved);
            } else if (baseQueue === null) {
              queue.lanes = NoLanes;
            }
            var dispatch = queue.dispatch;
            return [hook.memoizedState, dispatch];
          }
          function rerenderReducer(reducer, initialArg, init5) {
            var hook = updateWorkInProgressHook();
            var queue = hook.queue;
            if (queue === null) {
              throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
            }
            queue.lastRenderedReducer = reducer;
            var dispatch = queue.dispatch;
            var lastRenderPhaseUpdate = queue.pending;
            var newState = hook.memoizedState;
            if (lastRenderPhaseUpdate !== null) {
              queue.pending = null;
              var firstRenderPhaseUpdate = lastRenderPhaseUpdate.next;
              var update = firstRenderPhaseUpdate;
              do {
                var action = update.action;
                newState = reducer(newState, action);
                update = update.next;
              } while (update !== firstRenderPhaseUpdate);
              if (!objectIs(newState, hook.memoizedState)) {
                markWorkInProgressReceivedUpdate();
              }
              hook.memoizedState = newState;
              if (hook.baseQueue === null) {
                hook.baseState = newState;
              }
              queue.lastRenderedState = newState;
            }
            return [newState, dispatch];
          }
          function mountMutableSource(source, getSnapshot, subscribe) {
            {
              return void 0;
            }
          }
          function updateMutableSource(source, getSnapshot, subscribe) {
            {
              return void 0;
            }
          }
          function mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
            var fiber = currentlyRenderingFiber$1;
            var hook = mountWorkInProgressHook();
            var nextSnapshot;
            var isHydrating2 = getIsHydrating();
            if (isHydrating2) {
              if (getServerSnapshot === void 0) {
                throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
              }
              nextSnapshot = getServerSnapshot();
              {
                if (!didWarnUncachedGetSnapshot) {
                  if (nextSnapshot !== getServerSnapshot()) {
                    error("The result of getServerSnapshot should be cached to avoid an infinite loop");
                    didWarnUncachedGetSnapshot = true;
                  }
                }
              }
            } else {
              nextSnapshot = getSnapshot();
              {
                if (!didWarnUncachedGetSnapshot) {
                  var cachedSnapshot = getSnapshot();
                  if (!objectIs(nextSnapshot, cachedSnapshot)) {
                    error("The result of getSnapshot should be cached to avoid an infinite loop");
                    didWarnUncachedGetSnapshot = true;
                  }
                }
              }
              var root3 = getWorkInProgressRoot();
              if (root3 === null) {
                throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
              }
              if (!includesBlockingLane(root3, renderLanes)) {
                pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
              }
            }
            hook.memoizedState = nextSnapshot;
            var inst = {
              value: nextSnapshot,
              getSnapshot
            };
            hook.queue = inst;
            mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [subscribe]);
            fiber.flags |= Passive;
            pushEffect(HasEffect | Passive$1, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), void 0, null);
            return nextSnapshot;
          }
          function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
            var fiber = currentlyRenderingFiber$1;
            var hook = updateWorkInProgressHook();
            var nextSnapshot = getSnapshot();
            {
              if (!didWarnUncachedGetSnapshot) {
                var cachedSnapshot = getSnapshot();
                if (!objectIs(nextSnapshot, cachedSnapshot)) {
                  error("The result of getSnapshot should be cached to avoid an infinite loop");
                  didWarnUncachedGetSnapshot = true;
                }
              }
            }
            var prevSnapshot = hook.memoizedState;
            var snapshotChanged = !objectIs(prevSnapshot, nextSnapshot);
            if (snapshotChanged) {
              hook.memoizedState = nextSnapshot;
              markWorkInProgressReceivedUpdate();
            }
            var inst = hook.queue;
            updateEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [subscribe]);
            if (inst.getSnapshot !== getSnapshot || snapshotChanged || // Check if the susbcribe function changed. We can save some memory by
            // checking whether we scheduled a subscription effect above.
            workInProgressHook !== null && workInProgressHook.memoizedState.tag & HasEffect) {
              fiber.flags |= Passive;
              pushEffect(HasEffect | Passive$1, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), void 0, null);
              var root3 = getWorkInProgressRoot();
              if (root3 === null) {
                throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
              }
              if (!includesBlockingLane(root3, renderLanes)) {
                pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
              }
            }
            return nextSnapshot;
          }
          function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
            fiber.flags |= StoreConsistency;
            var check = {
              getSnapshot,
              value: renderedSnapshot
            };
            var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;
            if (componentUpdateQueue === null) {
              componentUpdateQueue = createFunctionComponentUpdateQueue();
              currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;
              componentUpdateQueue.stores = [check];
            } else {
              var stores = componentUpdateQueue.stores;
              if (stores === null) {
                componentUpdateQueue.stores = [check];
              } else {
                stores.push(check);
              }
            }
          }
          function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
            inst.value = nextSnapshot;
            inst.getSnapshot = getSnapshot;
            if (checkIfSnapshotChanged(inst)) {
              forceStoreRerender(fiber);
            }
          }
          function subscribeToStore(fiber, inst, subscribe) {
            var handleStoreChange = function() {
              if (checkIfSnapshotChanged(inst)) {
                forceStoreRerender(fiber);
              }
            };
            return subscribe(handleStoreChange);
          }
          function checkIfSnapshotChanged(inst) {
            var latestGetSnapshot = inst.getSnapshot;
            var prevValue = inst.value;
            try {
              var nextValue = latestGetSnapshot();
              return !objectIs(prevValue, nextValue);
            } catch (error2) {
              return true;
            }
          }
          function forceStoreRerender(fiber) {
            var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane);
            if (root3 !== null) {
              scheduleUpdateOnFiber(root3, fiber, SyncLane, NoTimestamp);
            }
          }
          function mountState(initialState) {
            var hook = mountWorkInProgressHook();
            if (typeof initialState === "function") {
              initialState = initialState();
            }
            hook.memoizedState = hook.baseState = initialState;
            var queue = {
              pending: null,
              interleaved: null,
              lanes: NoLanes,
              dispatch: null,
              lastRenderedReducer: basicStateReducer,
              lastRenderedState: initialState
            };
            hook.queue = queue;
            var dispatch = queue.dispatch = dispatchSetState.bind(null, currentlyRenderingFiber$1, queue);
            return [hook.memoizedState, dispatch];
          }
          function updateState(initialState) {
            return updateReducer(basicStateReducer);
          }
          function rerenderState(initialState) {
            return rerenderReducer(basicStateReducer);
          }
          function pushEffect(tag, create, destroy, deps) {
            var effect = {
              tag,
              create,
              destroy,
              deps,
              // Circular
              next: null
            };
            var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;
            if (componentUpdateQueue === null) {
              componentUpdateQueue = createFunctionComponentUpdateQueue();
              currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;
              componentUpdateQueue.lastEffect = effect.next = effect;
            } else {
              var lastEffect = componentUpdateQueue.lastEffect;
              if (lastEffect === null) {
                componentUpdateQueue.lastEffect = effect.next = effect;
              } else {
                var firstEffect = lastEffect.next;
                lastEffect.next = effect;
                effect.next = firstEffect;
                componentUpdateQueue.lastEffect = effect;
              }
            }
            return effect;
          }
          function mountRef(initialValue) {
            var hook = mountWorkInProgressHook();
            {
              var _ref2 = {
                current: initialValue
              };
              hook.memoizedState = _ref2;
              return _ref2;
            }
          }
          function updateRef(initialValue) {
            var hook = updateWorkInProgressHook();
            return hook.memoizedState;
          }
          function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
            var hook = mountWorkInProgressHook();
            var nextDeps = deps === void 0 ? null : deps;
            currentlyRenderingFiber$1.flags |= fiberFlags;
            hook.memoizedState = pushEffect(HasEffect | hookFlags, create, void 0, nextDeps);
          }
          function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
            var hook = updateWorkInProgressHook();
            var nextDeps = deps === void 0 ? null : deps;
            var destroy = void 0;
            if (currentHook !== null) {
              var prevEffect = currentHook.memoizedState;
              destroy = prevEffect.destroy;
              if (nextDeps !== null) {
                var prevDeps = prevEffect.deps;
                if (areHookInputsEqual(nextDeps, prevDeps)) {
                  hook.memoizedState = pushEffect(hookFlags, create, destroy, nextDeps);
                  return;
                }
              }
            }
            currentlyRenderingFiber$1.flags |= fiberFlags;
            hook.memoizedState = pushEffect(HasEffect | hookFlags, create, destroy, nextDeps);
          }
          function mountEffect(create, deps) {
            if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {
              return mountEffectImpl(MountPassiveDev | Passive | PassiveStatic, Passive$1, create, deps);
            } else {
              return mountEffectImpl(Passive | PassiveStatic, Passive$1, create, deps);
            }
          }
          function updateEffect(create, deps) {
            return updateEffectImpl(Passive, Passive$1, create, deps);
          }
          function mountInsertionEffect(create, deps) {
            return mountEffectImpl(Update, Insertion, create, deps);
          }
          function updateInsertionEffect(create, deps) {
            return updateEffectImpl(Update, Insertion, create, deps);
          }
          function mountLayoutEffect(create, deps) {
            var fiberFlags = Update;
            {
              fiberFlags |= LayoutStatic;
            }
            if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {
              fiberFlags |= MountLayoutDev;
            }
            return mountEffectImpl(fiberFlags, Layout, create, deps);
          }
          function updateLayoutEffect(create, deps) {
            return updateEffectImpl(Update, Layout, create, deps);
          }
          function imperativeHandleEffect(create, ref2) {
            if (typeof ref2 === "function") {
              var refCallback = ref2;
              var _inst = create();
              refCallback(_inst);
              return function() {
                refCallback(null);
              };
            } else if (ref2 !== null && ref2 !== void 0) {
              var refObject = ref2;
              {
                if (!refObject.hasOwnProperty("current")) {
                  error("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(refObject).join(", ") + "}");
                }
              }
              var _inst2 = create();
              refObject.current = _inst2;
              return function() {
                refObject.current = null;
              };
            }
          }
          function mountImperativeHandle(ref2, create, deps) {
            {
              if (typeof create !== "function") {
                error("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", create !== null ? typeof create : "null");
              }
            }
            var effectDeps = deps !== null && deps !== void 0 ? deps.concat([ref2]) : null;
            var fiberFlags = Update;
            {
              fiberFlags |= LayoutStatic;
            }
            if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {
              fiberFlags |= MountLayoutDev;
            }
            return mountEffectImpl(fiberFlags, Layout, imperativeHandleEffect.bind(null, create, ref2), effectDeps);
          }
          function updateImperativeHandle(ref2, create, deps) {
            {
              if (typeof create !== "function") {
                error("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", create !== null ? typeof create : "null");
              }
            }
            var effectDeps = deps !== null && deps !== void 0 ? deps.concat([ref2]) : null;
            return updateEffectImpl(Update, Layout, imperativeHandleEffect.bind(null, create, ref2), effectDeps);
          }
          function mountDebugValue(value, formatterFn) {
          }
          var updateDebugValue = mountDebugValue;
          function mountCallback(callback, deps) {
            var hook = mountWorkInProgressHook();
            var nextDeps = deps === void 0 ? null : deps;
            hook.memoizedState = [callback, nextDeps];
            return callback;
          }
          function updateCallback(callback, deps) {
            var hook = updateWorkInProgressHook();
            var nextDeps = deps === void 0 ? null : deps;
            var prevState = hook.memoizedState;
            if (prevState !== null) {
              if (nextDeps !== null) {
                var prevDeps = prevState[1];
                if (areHookInputsEqual(nextDeps, prevDeps)) {
                  return prevState[0];
                }
              }
            }
            hook.memoizedState = [callback, nextDeps];
            return callback;
          }
          function mountMemo(nextCreate, deps) {
            var hook = mountWorkInProgressHook();
            var nextDeps = deps === void 0 ? null : deps;
            var nextValue = nextCreate();
            hook.memoizedState = [nextValue, nextDeps];
            return nextValue;
          }
          function updateMemo(nextCreate, deps) {
            var hook = updateWorkInProgressHook();
            var nextDeps = deps === void 0 ? null : deps;
            var prevState = hook.memoizedState;
            if (prevState !== null) {
              if (nextDeps !== null) {
                var prevDeps = prevState[1];
                if (areHookInputsEqual(nextDeps, prevDeps)) {
                  return prevState[0];
                }
              }
            }
            var nextValue = nextCreate();
            hook.memoizedState = [nextValue, nextDeps];
            return nextValue;
          }
          function mountDeferredValue(value) {
            var hook = mountWorkInProgressHook();
            hook.memoizedState = value;
            return value;
          }
          function updateDeferredValue(value) {
            var hook = updateWorkInProgressHook();
            var resolvedCurrentHook = currentHook;
            var prevValue = resolvedCurrentHook.memoizedState;
            return updateDeferredValueImpl(hook, prevValue, value);
          }
          function rerenderDeferredValue(value) {
            var hook = updateWorkInProgressHook();
            if (currentHook === null) {
              hook.memoizedState = value;
              return value;
            } else {
              var prevValue = currentHook.memoizedState;
              return updateDeferredValueImpl(hook, prevValue, value);
            }
          }
          function updateDeferredValueImpl(hook, prevValue, value) {
            var shouldDeferValue = !includesOnlyNonUrgentLanes(renderLanes);
            if (shouldDeferValue) {
              if (!objectIs(value, prevValue)) {
                var deferredLane = claimNextTransitionLane();
                currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, deferredLane);
                markSkippedUpdateLanes(deferredLane);
                hook.baseState = true;
              }
              return prevValue;
            } else {
              if (hook.baseState) {
                hook.baseState = false;
                markWorkInProgressReceivedUpdate();
              }
              hook.memoizedState = value;
              return value;
            }
          }
          function startTransition(setPending, callback, options2) {
            var previousPriority = getCurrentUpdatePriority();
            setCurrentUpdatePriority(higherEventPriority(previousPriority, ContinuousEventPriority));
            setPending(true);
            var prevTransition = ReactCurrentBatchConfig$2.transition;
            ReactCurrentBatchConfig$2.transition = {};
            var currentTransition = ReactCurrentBatchConfig$2.transition;
            {
              ReactCurrentBatchConfig$2.transition._updatedFibers = /* @__PURE__ */ new Set();
            }
            try {
              setPending(false);
              callback();
            } finally {
              setCurrentUpdatePriority(previousPriority);
              ReactCurrentBatchConfig$2.transition = prevTransition;
              {
                if (prevTransition === null && currentTransition._updatedFibers) {
                  var updatedFibersCount = currentTransition._updatedFibers.size;
                  if (updatedFibersCount > 10) {
                    warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.");
                  }
                  currentTransition._updatedFibers.clear();
                }
              }
            }
          }
          function mountTransition() {
            var _mountState = mountState(false), isPending = _mountState[0], setPending = _mountState[1];
            var start = startTransition.bind(null, setPending);
            var hook = mountWorkInProgressHook();
            hook.memoizedState = start;
            return [isPending, start];
          }
          function updateTransition() {
            var _updateState = updateState(), isPending = _updateState[0];
            var hook = updateWorkInProgressHook();
            var start = hook.memoizedState;
            return [isPending, start];
          }
          function rerenderTransition() {
            var _rerenderState = rerenderState(), isPending = _rerenderState[0];
            var hook = updateWorkInProgressHook();
            var start = hook.memoizedState;
            return [isPending, start];
          }
          var isUpdatingOpaqueValueInRenderPhase = false;
          function getIsUpdatingOpaqueValueInRenderPhaseInDEV() {
            {
              return isUpdatingOpaqueValueInRenderPhase;
            }
          }
          function mountId() {
            var hook = mountWorkInProgressHook();
            var root3 = getWorkInProgressRoot();
            var identifierPrefix = root3.identifierPrefix;
            var id3;
            if (getIsHydrating()) {
              var treeId = getTreeId();
              id3 = ":" + identifierPrefix + "R" + treeId;
              var localId = localIdCounter++;
              if (localId > 0) {
                id3 += "H" + localId.toString(32);
              }
              id3 += ":";
            } else {
              var globalClientId = globalClientIdCounter++;
              id3 = ":" + identifierPrefix + "r" + globalClientId.toString(32) + ":";
            }
            hook.memoizedState = id3;
            return id3;
          }
          function updateId() {
            var hook = updateWorkInProgressHook();
            var id3 = hook.memoizedState;
            return id3;
          }
          function dispatchReducerAction(fiber, queue, action) {
            {
              if (typeof arguments[3] === "function") {
                error("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
              }
            }
            var lane = requestUpdateLane(fiber);
            var update = {
              lane,
              action,
              hasEagerState: false,
              eagerState: null,
              next: null
            };
            if (isRenderPhaseUpdate(fiber)) {
              enqueueRenderPhaseUpdate(queue, update);
            } else {
              var root3 = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
              if (root3 !== null) {
                var eventTime = requestEventTime();
                scheduleUpdateOnFiber(root3, fiber, lane, eventTime);
                entangleTransitionUpdate(root3, queue, lane);
              }
            }
            markUpdateInDevTools(fiber, lane);
          }
          function dispatchSetState(fiber, queue, action) {
            {
              if (typeof arguments[3] === "function") {
                error("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
              }
            }
            var lane = requestUpdateLane(fiber);
            var update = {
              lane,
              action,
              hasEagerState: false,
              eagerState: null,
              next: null
            };
            if (isRenderPhaseUpdate(fiber)) {
              enqueueRenderPhaseUpdate(queue, update);
            } else {
              var alternate = fiber.alternate;
              if (fiber.lanes === NoLanes && (alternate === null || alternate.lanes === NoLanes)) {
                var lastRenderedReducer = queue.lastRenderedReducer;
                if (lastRenderedReducer !== null) {
                  var prevDispatcher;
                  {
                    prevDispatcher = ReactCurrentDispatcher$1.current;
                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                  }
                  try {
                    var currentState = queue.lastRenderedState;
                    var eagerState = lastRenderedReducer(currentState, action);
                    update.hasEagerState = true;
                    update.eagerState = eagerState;
                    if (objectIs(eagerState, currentState)) {
                      enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update, lane);
                      return;
                    }
                  } catch (error2) {
                  } finally {
                    {
                      ReactCurrentDispatcher$1.current = prevDispatcher;
                    }
                  }
                }
              }
              var root3 = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
              if (root3 !== null) {
                var eventTime = requestEventTime();
                scheduleUpdateOnFiber(root3, fiber, lane, eventTime);
                entangleTransitionUpdate(root3, queue, lane);
              }
            }
            markUpdateInDevTools(fiber, lane);
          }
          function isRenderPhaseUpdate(fiber) {
            var alternate = fiber.alternate;
            return fiber === currentlyRenderingFiber$1 || alternate !== null && alternate === currentlyRenderingFiber$1;
          }
          function enqueueRenderPhaseUpdate(queue, update) {
            didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
            var pending = queue.pending;
            if (pending === null) {
              update.next = update;
            } else {
              update.next = pending.next;
              pending.next = update;
            }
            queue.pending = update;
          }
          function entangleTransitionUpdate(root3, queue, lane) {
            if (isTransitionLane(lane)) {
              var queueLanes = queue.lanes;
              queueLanes = intersectLanes(queueLanes, root3.pendingLanes);
              var newQueueLanes = mergeLanes(queueLanes, lane);
              queue.lanes = newQueueLanes;
              markRootEntangled(root3, newQueueLanes);
            }
          }
          function markUpdateInDevTools(fiber, lane, action) {
            {
              markStateUpdateScheduled(fiber, lane);
            }
          }
          var ContextOnlyDispatcher = {
            readContext,
            useCallback: throwInvalidHookError,
            useContext: throwInvalidHookError,
            useEffect: throwInvalidHookError,
            useImperativeHandle: throwInvalidHookError,
            useInsertionEffect: throwInvalidHookError,
            useLayoutEffect: throwInvalidHookError,
            useMemo: throwInvalidHookError,
            useReducer: throwInvalidHookError,
            useRef: throwInvalidHookError,
            useState: throwInvalidHookError,
            useDebugValue: throwInvalidHookError,
            useDeferredValue: throwInvalidHookError,
            useTransition: throwInvalidHookError,
            useMutableSource: throwInvalidHookError,
            useSyncExternalStore: throwInvalidHookError,
            useId: throwInvalidHookError,
            unstable_isNewReconciler: enableNewReconciler
          };
          var HooksDispatcherOnMountInDEV = null;
          var HooksDispatcherOnMountWithHookTypesInDEV = null;
          var HooksDispatcherOnUpdateInDEV = null;
          var HooksDispatcherOnRerenderInDEV = null;
          var InvalidNestedHooksDispatcherOnMountInDEV = null;
          var InvalidNestedHooksDispatcherOnUpdateInDEV = null;
          var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
          {
            var warnInvalidContextAccess = function() {
              error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
            };
            var warnInvalidHookAccess = function() {
              error("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
            };
            HooksDispatcherOnMountInDEV = {
              readContext: function(context3) {
                return readContext(context3);
              },
              useCallback: function(callback, deps) {
                currentHookNameInDev = "useCallback";
                mountHookTypesDev();
                checkDepsAreArrayDev(deps);
                return mountCallback(callback, deps);
              },
              useContext: function(context3) {
                currentHookNameInDev = "useContext";
                mountHookTypesDev();
                return readContext(context3);
              },
              useEffect: function(create, deps) {
                currentHookNameInDev = "useEffect";
                mountHookTypesDev();
                checkDepsAreArrayDev(deps);
                return mountEffect(create, deps);
              },
              useImperativeHandle: function(ref2, create, deps) {
                currentHookNameInDev = "useImperativeHandle";
                mountHookTypesDev();
                checkDepsAreArrayDev(deps);
                return mountImperativeHandle(ref2, create, deps);
              },
              useInsertionEffect: function(create, deps) {
                currentHookNameInDev = "useInsertionEffect";
                mountHookTypesDev();
                checkDepsAreArrayDev(deps);
                return mountInsertionEffect(create, deps);
              },
              useLayoutEffect: function(create, deps) {
                currentHookNameInDev = "useLayoutEffect";
                mountHookTypesDev();
                checkDepsAreArrayDev(deps);
                return mountLayoutEffect(create, deps);
              },
              useMemo: function(create, deps) {
                currentHookNameInDev = "useMemo";
                mountHookTypesDev();
                checkDepsAreArrayDev(deps);
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountMemo(create, deps);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useReducer: function(reducer, initialArg, init5) {
                currentHookNameInDev = "useReducer";
                mountHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountReducer(reducer, initialArg, init5);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                mountHookTypesDev();
                return mountRef(initialValue);
              },
              useState: function(initialState) {
                currentHookNameInDev = "useState";
                mountHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountState(initialState);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useDebugValue: function(value, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                mountHookTypesDev();
                return mountDebugValue();
              },
              useDeferredValue: function(value) {
                currentHookNameInDev = "useDeferredValue";
                mountHookTypesDev();
                return mountDeferredValue(value);
              },
              useTransition: function() {
                currentHookNameInDev = "useTransition";
                mountHookTypesDev();
                return mountTransition();
              },
              useMutableSource: function(source, getSnapshot, subscribe) {
                currentHookNameInDev = "useMutableSource";
                mountHookTypesDev();
                return mountMutableSource();
              },
              useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
                currentHookNameInDev = "useSyncExternalStore";
                mountHookTypesDev();
                return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
              },
              useId: function() {
                currentHookNameInDev = "useId";
                mountHookTypesDev();
                return mountId();
              },
              unstable_isNewReconciler: enableNewReconciler
            };
            HooksDispatcherOnMountWithHookTypesInDEV = {
              readContext: function(context3) {
                return readContext(context3);
              },
              useCallback: function(callback, deps) {
                currentHookNameInDev = "useCallback";
                updateHookTypesDev();
                return mountCallback(callback, deps);
              },
              useContext: function(context3) {
                currentHookNameInDev = "useContext";
                updateHookTypesDev();
                return readContext(context3);
              },
              useEffect: function(create, deps) {
                currentHookNameInDev = "useEffect";
                updateHookTypesDev();
                return mountEffect(create, deps);
              },
              useImperativeHandle: function(ref2, create, deps) {
                currentHookNameInDev = "useImperativeHandle";
                updateHookTypesDev();
                return mountImperativeHandle(ref2, create, deps);
              },
              useInsertionEffect: function(create, deps) {
                currentHookNameInDev = "useInsertionEffect";
                updateHookTypesDev();
                return mountInsertionEffect(create, deps);
              },
              useLayoutEffect: function(create, deps) {
                currentHookNameInDev = "useLayoutEffect";
                updateHookTypesDev();
                return mountLayoutEffect(create, deps);
              },
              useMemo: function(create, deps) {
                currentHookNameInDev = "useMemo";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountMemo(create, deps);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useReducer: function(reducer, initialArg, init5) {
                currentHookNameInDev = "useReducer";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountReducer(reducer, initialArg, init5);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                updateHookTypesDev();
                return mountRef(initialValue);
              },
              useState: function(initialState) {
                currentHookNameInDev = "useState";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountState(initialState);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useDebugValue: function(value, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                updateHookTypesDev();
                return mountDebugValue();
              },
              useDeferredValue: function(value) {
                currentHookNameInDev = "useDeferredValue";
                updateHookTypesDev();
                return mountDeferredValue(value);
              },
              useTransition: function() {
                currentHookNameInDev = "useTransition";
                updateHookTypesDev();
                return mountTransition();
              },
              useMutableSource: function(source, getSnapshot, subscribe) {
                currentHookNameInDev = "useMutableSource";
                updateHookTypesDev();
                return mountMutableSource();
              },
              useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
                currentHookNameInDev = "useSyncExternalStore";
                updateHookTypesDev();
                return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
              },
              useId: function() {
                currentHookNameInDev = "useId";
                updateHookTypesDev();
                return mountId();
              },
              unstable_isNewReconciler: enableNewReconciler
            };
            HooksDispatcherOnUpdateInDEV = {
              readContext: function(context3) {
                return readContext(context3);
              },
              useCallback: function(callback, deps) {
                currentHookNameInDev = "useCallback";
                updateHookTypesDev();
                return updateCallback(callback, deps);
              },
              useContext: function(context3) {
                currentHookNameInDev = "useContext";
                updateHookTypesDev();
                return readContext(context3);
              },
              useEffect: function(create, deps) {
                currentHookNameInDev = "useEffect";
                updateHookTypesDev();
                return updateEffect(create, deps);
              },
              useImperativeHandle: function(ref2, create, deps) {
                currentHookNameInDev = "useImperativeHandle";
                updateHookTypesDev();
                return updateImperativeHandle(ref2, create, deps);
              },
              useInsertionEffect: function(create, deps) {
                currentHookNameInDev = "useInsertionEffect";
                updateHookTypesDev();
                return updateInsertionEffect(create, deps);
              },
              useLayoutEffect: function(create, deps) {
                currentHookNameInDev = "useLayoutEffect";
                updateHookTypesDev();
                return updateLayoutEffect(create, deps);
              },
              useMemo: function(create, deps) {
                currentHookNameInDev = "useMemo";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateMemo(create, deps);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useReducer: function(reducer, initialArg, init5) {
                currentHookNameInDev = "useReducer";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateReducer(reducer, initialArg, init5);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                updateHookTypesDev();
                return updateRef();
              },
              useState: function(initialState) {
                currentHookNameInDev = "useState";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateState(initialState);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useDebugValue: function(value, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                updateHookTypesDev();
                return updateDebugValue();
              },
              useDeferredValue: function(value) {
                currentHookNameInDev = "useDeferredValue";
                updateHookTypesDev();
                return updateDeferredValue(value);
              },
              useTransition: function() {
                currentHookNameInDev = "useTransition";
                updateHookTypesDev();
                return updateTransition();
              },
              useMutableSource: function(source, getSnapshot, subscribe) {
                currentHookNameInDev = "useMutableSource";
                updateHookTypesDev();
                return updateMutableSource();
              },
              useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
                currentHookNameInDev = "useSyncExternalStore";
                updateHookTypesDev();
                return updateSyncExternalStore(subscribe, getSnapshot);
              },
              useId: function() {
                currentHookNameInDev = "useId";
                updateHookTypesDev();
                return updateId();
              },
              unstable_isNewReconciler: enableNewReconciler
            };
            HooksDispatcherOnRerenderInDEV = {
              readContext: function(context3) {
                return readContext(context3);
              },
              useCallback: function(callback, deps) {
                currentHookNameInDev = "useCallback";
                updateHookTypesDev();
                return updateCallback(callback, deps);
              },
              useContext: function(context3) {
                currentHookNameInDev = "useContext";
                updateHookTypesDev();
                return readContext(context3);
              },
              useEffect: function(create, deps) {
                currentHookNameInDev = "useEffect";
                updateHookTypesDev();
                return updateEffect(create, deps);
              },
              useImperativeHandle: function(ref2, create, deps) {
                currentHookNameInDev = "useImperativeHandle";
                updateHookTypesDev();
                return updateImperativeHandle(ref2, create, deps);
              },
              useInsertionEffect: function(create, deps) {
                currentHookNameInDev = "useInsertionEffect";
                updateHookTypesDev();
                return updateInsertionEffect(create, deps);
              },
              useLayoutEffect: function(create, deps) {
                currentHookNameInDev = "useLayoutEffect";
                updateHookTypesDev();
                return updateLayoutEffect(create, deps);
              },
              useMemo: function(create, deps) {
                currentHookNameInDev = "useMemo";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
                try {
                  return updateMemo(create, deps);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useReducer: function(reducer, initialArg, init5) {
                currentHookNameInDev = "useReducer";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
                try {
                  return rerenderReducer(reducer, initialArg, init5);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                updateHookTypesDev();
                return updateRef();
              },
              useState: function(initialState) {
                currentHookNameInDev = "useState";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
                try {
                  return rerenderState(initialState);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useDebugValue: function(value, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                updateHookTypesDev();
                return updateDebugValue();
              },
              useDeferredValue: function(value) {
                currentHookNameInDev = "useDeferredValue";
                updateHookTypesDev();
                return rerenderDeferredValue(value);
              },
              useTransition: function() {
                currentHookNameInDev = "useTransition";
                updateHookTypesDev();
                return rerenderTransition();
              },
              useMutableSource: function(source, getSnapshot, subscribe) {
                currentHookNameInDev = "useMutableSource";
                updateHookTypesDev();
                return updateMutableSource();
              },
              useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
                currentHookNameInDev = "useSyncExternalStore";
                updateHookTypesDev();
                return updateSyncExternalStore(subscribe, getSnapshot);
              },
              useId: function() {
                currentHookNameInDev = "useId";
                updateHookTypesDev();
                return updateId();
              },
              unstable_isNewReconciler: enableNewReconciler
            };
            InvalidNestedHooksDispatcherOnMountInDEV = {
              readContext: function(context3) {
                warnInvalidContextAccess();
                return readContext(context3);
              },
              useCallback: function(callback, deps) {
                currentHookNameInDev = "useCallback";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountCallback(callback, deps);
              },
              useContext: function(context3) {
                currentHookNameInDev = "useContext";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return readContext(context3);
              },
              useEffect: function(create, deps) {
                currentHookNameInDev = "useEffect";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountEffect(create, deps);
              },
              useImperativeHandle: function(ref2, create, deps) {
                currentHookNameInDev = "useImperativeHandle";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountImperativeHandle(ref2, create, deps);
              },
              useInsertionEffect: function(create, deps) {
                currentHookNameInDev = "useInsertionEffect";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountInsertionEffect(create, deps);
              },
              useLayoutEffect: function(create, deps) {
                currentHookNameInDev = "useLayoutEffect";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountLayoutEffect(create, deps);
              },
              useMemo: function(create, deps) {
                currentHookNameInDev = "useMemo";
                warnInvalidHookAccess();
                mountHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountMemo(create, deps);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useReducer: function(reducer, initialArg, init5) {
                currentHookNameInDev = "useReducer";
                warnInvalidHookAccess();
                mountHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountReducer(reducer, initialArg, init5);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountRef(initialValue);
              },
              useState: function(initialState) {
                currentHookNameInDev = "useState";
                warnInvalidHookAccess();
                mountHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountState(initialState);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useDebugValue: function(value, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountDebugValue();
              },
              useDeferredValue: function(value) {
                currentHookNameInDev = "useDeferredValue";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountDeferredValue(value);
              },
              useTransition: function() {
                currentHookNameInDev = "useTransition";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountTransition();
              },
              useMutableSource: function(source, getSnapshot, subscribe) {
                currentHookNameInDev = "useMutableSource";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountMutableSource();
              },
              useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
                currentHookNameInDev = "useSyncExternalStore";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
              },
              useId: function() {
                currentHookNameInDev = "useId";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountId();
              },
              unstable_isNewReconciler: enableNewReconciler
            };
            InvalidNestedHooksDispatcherOnUpdateInDEV = {
              readContext: function(context3) {
                warnInvalidContextAccess();
                return readContext(context3);
              },
              useCallback: function(callback, deps) {
                currentHookNameInDev = "useCallback";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateCallback(callback, deps);
              },
              useContext: function(context3) {
                currentHookNameInDev = "useContext";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return readContext(context3);
              },
              useEffect: function(create, deps) {
                currentHookNameInDev = "useEffect";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateEffect(create, deps);
              },
              useImperativeHandle: function(ref2, create, deps) {
                currentHookNameInDev = "useImperativeHandle";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateImperativeHandle(ref2, create, deps);
              },
              useInsertionEffect: function(create, deps) {
                currentHookNameInDev = "useInsertionEffect";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateInsertionEffect(create, deps);
              },
              useLayoutEffect: function(create, deps) {
                currentHookNameInDev = "useLayoutEffect";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateLayoutEffect(create, deps);
              },
              useMemo: function(create, deps) {
                currentHookNameInDev = "useMemo";
                warnInvalidHookAccess();
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateMemo(create, deps);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useReducer: function(reducer, initialArg, init5) {
                currentHookNameInDev = "useReducer";
                warnInvalidHookAccess();
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateReducer(reducer, initialArg, init5);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateRef();
              },
              useState: function(initialState) {
                currentHookNameInDev = "useState";
                warnInvalidHookAccess();
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateState(initialState);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useDebugValue: function(value, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateDebugValue();
              },
              useDeferredValue: function(value) {
                currentHookNameInDev = "useDeferredValue";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateDeferredValue(value);
              },
              useTransition: function() {
                currentHookNameInDev = "useTransition";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateTransition();
              },
              useMutableSource: function(source, getSnapshot, subscribe) {
                currentHookNameInDev = "useMutableSource";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateMutableSource();
              },
              useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
                currentHookNameInDev = "useSyncExternalStore";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateSyncExternalStore(subscribe, getSnapshot);
              },
              useId: function() {
                currentHookNameInDev = "useId";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateId();
              },
              unstable_isNewReconciler: enableNewReconciler
            };
            InvalidNestedHooksDispatcherOnRerenderInDEV = {
              readContext: function(context3) {
                warnInvalidContextAccess();
                return readContext(context3);
              },
              useCallback: function(callback, deps) {
                currentHookNameInDev = "useCallback";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateCallback(callback, deps);
              },
              useContext: function(context3) {
                currentHookNameInDev = "useContext";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return readContext(context3);
              },
              useEffect: function(create, deps) {
                currentHookNameInDev = "useEffect";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateEffect(create, deps);
              },
              useImperativeHandle: function(ref2, create, deps) {
                currentHookNameInDev = "useImperativeHandle";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateImperativeHandle(ref2, create, deps);
              },
              useInsertionEffect: function(create, deps) {
                currentHookNameInDev = "useInsertionEffect";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateInsertionEffect(create, deps);
              },
              useLayoutEffect: function(create, deps) {
                currentHookNameInDev = "useLayoutEffect";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateLayoutEffect(create, deps);
              },
              useMemo: function(create, deps) {
                currentHookNameInDev = "useMemo";
                warnInvalidHookAccess();
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateMemo(create, deps);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useReducer: function(reducer, initialArg, init5) {
                currentHookNameInDev = "useReducer";
                warnInvalidHookAccess();
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return rerenderReducer(reducer, initialArg, init5);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateRef();
              },
              useState: function(initialState) {
                currentHookNameInDev = "useState";
                warnInvalidHookAccess();
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return rerenderState(initialState);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useDebugValue: function(value, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateDebugValue();
              },
              useDeferredValue: function(value) {
                currentHookNameInDev = "useDeferredValue";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return rerenderDeferredValue(value);
              },
              useTransition: function() {
                currentHookNameInDev = "useTransition";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return rerenderTransition();
              },
              useMutableSource: function(source, getSnapshot, subscribe) {
                currentHookNameInDev = "useMutableSource";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateMutableSource();
              },
              useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
                currentHookNameInDev = "useSyncExternalStore";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateSyncExternalStore(subscribe, getSnapshot);
              },
              useId: function() {
                currentHookNameInDev = "useId";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateId();
              },
              unstable_isNewReconciler: enableNewReconciler
            };
          }
          var now$1 = Scheduler.unstable_now;
          var commitTime = 0;
          var layoutEffectStartTime = -1;
          var profilerStartTime = -1;
          var passiveEffectStartTime = -1;
          var currentUpdateIsNested = false;
          var nestedUpdateScheduled = false;
          function isCurrentUpdateNested() {
            return currentUpdateIsNested;
          }
          function markNestedUpdateScheduled() {
            {
              nestedUpdateScheduled = true;
            }
          }
          function resetNestedUpdateFlag() {
            {
              currentUpdateIsNested = false;
              nestedUpdateScheduled = false;
            }
          }
          function syncNestedUpdateFlag() {
            {
              currentUpdateIsNested = nestedUpdateScheduled;
              nestedUpdateScheduled = false;
            }
          }
          function getCommitTime() {
            return commitTime;
          }
          function recordCommitTime() {
            commitTime = now$1();
          }
          function startProfilerTimer(fiber) {
            profilerStartTime = now$1();
            if (fiber.actualStartTime < 0) {
              fiber.actualStartTime = now$1();
            }
          }
          function stopProfilerTimerIfRunning(fiber) {
            profilerStartTime = -1;
          }
          function stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {
            if (profilerStartTime >= 0) {
              var elapsedTime = now$1() - profilerStartTime;
              fiber.actualDuration += elapsedTime;
              if (overrideBaseTime) {
                fiber.selfBaseDuration = elapsedTime;
              }
              profilerStartTime = -1;
            }
          }
          function recordLayoutEffectDuration(fiber) {
            if (layoutEffectStartTime >= 0) {
              var elapsedTime = now$1() - layoutEffectStartTime;
              layoutEffectStartTime = -1;
              var parentFiber = fiber.return;
              while (parentFiber !== null) {
                switch (parentFiber.tag) {
                  case HostRoot:
                    var root3 = parentFiber.stateNode;
                    root3.effectDuration += elapsedTime;
                    return;
                  case Profiler:
                    var parentStateNode = parentFiber.stateNode;
                    parentStateNode.effectDuration += elapsedTime;
                    return;
                }
                parentFiber = parentFiber.return;
              }
            }
          }
          function recordPassiveEffectDuration(fiber) {
            if (passiveEffectStartTime >= 0) {
              var elapsedTime = now$1() - passiveEffectStartTime;
              passiveEffectStartTime = -1;
              var parentFiber = fiber.return;
              while (parentFiber !== null) {
                switch (parentFiber.tag) {
                  case HostRoot:
                    var root3 = parentFiber.stateNode;
                    if (root3 !== null) {
                      root3.passiveEffectDuration += elapsedTime;
                    }
                    return;
                  case Profiler:
                    var parentStateNode = parentFiber.stateNode;
                    if (parentStateNode !== null) {
                      parentStateNode.passiveEffectDuration += elapsedTime;
                    }
                    return;
                }
                parentFiber = parentFiber.return;
              }
            }
          }
          function startLayoutEffectTimer() {
            layoutEffectStartTime = now$1();
          }
          function startPassiveEffectTimer() {
            passiveEffectStartTime = now$1();
          }
          function transferActualDuration(fiber) {
            var child = fiber.child;
            while (child) {
              fiber.actualDuration += child.actualDuration;
              child = child.sibling;
            }
          }
          function resolveDefaultProps(Component3, baseProps) {
            if (Component3 && Component3.defaultProps) {
              var props = assign({}, baseProps);
              var defaultProps = Component3.defaultProps;
              for (var propName in defaultProps) {
                if (props[propName] === void 0) {
                  props[propName] = defaultProps[propName];
                }
              }
              return props;
            }
            return baseProps;
          }
          var fakeInternalInstance = {};
          var didWarnAboutStateAssignmentForComponent;
          var didWarnAboutUninitializedState;
          var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;
          var didWarnAboutLegacyLifecyclesAndDerivedState;
          var didWarnAboutUndefinedDerivedState;
          var warnOnUndefinedDerivedState;
          var warnOnInvalidCallback;
          var didWarnAboutDirectlyAssigningPropsToState;
          var didWarnAboutContextTypeAndContextTypes;
          var didWarnAboutInvalidateContextType;
          var didWarnAboutLegacyContext$1;
          {
            didWarnAboutStateAssignmentForComponent = /* @__PURE__ */ new Set();
            didWarnAboutUninitializedState = /* @__PURE__ */ new Set();
            didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = /* @__PURE__ */ new Set();
            didWarnAboutLegacyLifecyclesAndDerivedState = /* @__PURE__ */ new Set();
            didWarnAboutDirectlyAssigningPropsToState = /* @__PURE__ */ new Set();
            didWarnAboutUndefinedDerivedState = /* @__PURE__ */ new Set();
            didWarnAboutContextTypeAndContextTypes = /* @__PURE__ */ new Set();
            didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set();
            didWarnAboutLegacyContext$1 = /* @__PURE__ */ new Set();
            var didWarnOnInvalidCallback = /* @__PURE__ */ new Set();
            warnOnInvalidCallback = function(callback, callerName) {
              if (callback === null || typeof callback === "function") {
                return;
              }
              var key = callerName + "_" + callback;
              if (!didWarnOnInvalidCallback.has(key)) {
                didWarnOnInvalidCallback.add(key);
                error("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback);
              }
            };
            warnOnUndefinedDerivedState = function(type, partialState) {
              if (partialState === void 0) {
                var componentName = getComponentNameFromType(type) || "Component";
                if (!didWarnAboutUndefinedDerivedState.has(componentName)) {
                  didWarnAboutUndefinedDerivedState.add(componentName);
                  error("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", componentName);
                }
              }
            };
            Object.defineProperty(fakeInternalInstance, "_processChildContext", {
              enumerable: false,
              value: function() {
                throw new Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");
              }
            });
            Object.freeze(fakeInternalInstance);
          }
          function applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, nextProps) {
            var prevState = workInProgress2.memoizedState;
            var partialState = getDerivedStateFromProps(nextProps, prevState);
            {
              if (workInProgress2.mode & StrictLegacyMode) {
                setIsStrictModeForDevtools(true);
                try {
                  partialState = getDerivedStateFromProps(nextProps, prevState);
                } finally {
                  setIsStrictModeForDevtools(false);
                }
              }
              warnOnUndefinedDerivedState(ctor, partialState);
            }
            var memoizedState = partialState === null || partialState === void 0 ? prevState : assign({}, prevState, partialState);
            workInProgress2.memoizedState = memoizedState;
            if (workInProgress2.lanes === NoLanes) {
              var updateQueue = workInProgress2.updateQueue;
              updateQueue.baseState = memoizedState;
            }
          }
          var classComponentUpdater = {
            isMounted,
            enqueueSetState: function(inst, payload, callback) {
              var fiber = get(inst);
              var eventTime = requestEventTime();
              var lane = requestUpdateLane(fiber);
              var update = createUpdate(eventTime, lane);
              update.payload = payload;
              if (callback !== void 0 && callback !== null) {
                {
                  warnOnInvalidCallback(callback, "setState");
                }
                update.callback = callback;
              }
              var root3 = enqueueUpdate(fiber, update, lane);
              if (root3 !== null) {
                scheduleUpdateOnFiber(root3, fiber, lane, eventTime);
                entangleTransitions(root3, fiber, lane);
              }
              {
                markStateUpdateScheduled(fiber, lane);
              }
            },
            enqueueReplaceState: function(inst, payload, callback) {
              var fiber = get(inst);
              var eventTime = requestEventTime();
              var lane = requestUpdateLane(fiber);
              var update = createUpdate(eventTime, lane);
              update.tag = ReplaceState;
              update.payload = payload;
              if (callback !== void 0 && callback !== null) {
                {
                  warnOnInvalidCallback(callback, "replaceState");
                }
                update.callback = callback;
              }
              var root3 = enqueueUpdate(fiber, update, lane);
              if (root3 !== null) {
                scheduleUpdateOnFiber(root3, fiber, lane, eventTime);
                entangleTransitions(root3, fiber, lane);
              }
              {
                markStateUpdateScheduled(fiber, lane);
              }
            },
            enqueueForceUpdate: function(inst, callback) {
              var fiber = get(inst);
              var eventTime = requestEventTime();
              var lane = requestUpdateLane(fiber);
              var update = createUpdate(eventTime, lane);
              update.tag = ForceUpdate;
              if (callback !== void 0 && callback !== null) {
                {
                  warnOnInvalidCallback(callback, "forceUpdate");
                }
                update.callback = callback;
              }
              var root3 = enqueueUpdate(fiber, update, lane);
              if (root3 !== null) {
                scheduleUpdateOnFiber(root3, fiber, lane, eventTime);
                entangleTransitions(root3, fiber, lane);
              }
              {
                markForceUpdateScheduled(fiber, lane);
              }
            }
          };
          function checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) {
            var instance = workInProgress2.stateNode;
            if (typeof instance.shouldComponentUpdate === "function") {
              var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);
              {
                if (workInProgress2.mode & StrictLegacyMode) {
                  setIsStrictModeForDevtools(true);
                  try {
                    shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);
                  } finally {
                    setIsStrictModeForDevtools(false);
                  }
                }
                if (shouldUpdate === void 0) {
                  error("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", getComponentNameFromType(ctor) || "Component");
                }
              }
              return shouldUpdate;
            }
            if (ctor.prototype && ctor.prototype.isPureReactComponent) {
              return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);
            }
            return true;
          }
          function checkClassInstance(workInProgress2, ctor, newProps) {
            var instance = workInProgress2.stateNode;
            {
              var name = getComponentNameFromType(ctor) || "Component";
              var renderPresent = instance.render;
              if (!renderPresent) {
                if (ctor.prototype && typeof ctor.prototype.render === "function") {
                  error("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", name);
                } else {
                  error("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", name);
                }
              }
              if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) {
                error("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", name);
              }
              if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) {
                error("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", name);
              }
              if (instance.propTypes) {
                error("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", name);
              }
              if (instance.contextType) {
                error("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", name);
              }
              {
                if (ctor.childContextTypes && !didWarnAboutLegacyContext$1.has(ctor) && // Strict Mode has its own warning for legacy context, so we can skip
                // this one.
                (workInProgress2.mode & StrictLegacyMode) === NoMode) {
                  didWarnAboutLegacyContext$1.add(ctor);
                  error("%s uses the legacy childContextTypes API which is no longer supported and will be removed in the next major release. Use React.createContext() instead\n\n.Learn more about this warning here: https://reactjs.org/link/legacy-context", name);
                }
                if (ctor.contextTypes && !didWarnAboutLegacyContext$1.has(ctor) && // Strict Mode has its own warning for legacy context, so we can skip
                // this one.
                (workInProgress2.mode & StrictLegacyMode) === NoMode) {
                  didWarnAboutLegacyContext$1.add(ctor);
                  error("%s uses the legacy contextTypes API which is no longer supported and will be removed in the next major release. Use React.createContext() with static contextType instead.\n\nLearn more about this warning here: https://reactjs.org/link/legacy-context", name);
                }
                if (instance.contextTypes) {
                  error("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", name);
                }
                if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {
                  didWarnAboutContextTypeAndContextTypes.add(ctor);
                  error("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", name);
                }
              }
              if (typeof instance.componentShouldUpdate === "function") {
                error("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", name);
              }
              if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== "undefined") {
                error("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", getComponentNameFromType(ctor) || "A pure component");
              }
              if (typeof instance.componentDidUnmount === "function") {
                error("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", name);
              }
              if (typeof instance.componentDidReceiveProps === "function") {
                error("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", name);
              }
              if (typeof instance.componentWillRecieveProps === "function") {
                error("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", name);
              }
              if (typeof instance.UNSAFE_componentWillRecieveProps === "function") {
                error("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", name);
              }
              var hasMutatedProps = instance.props !== newProps;
              if (instance.props !== void 0 && hasMutatedProps) {
                error("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", name, name);
              }
              if (instance.defaultProps) {
                error("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", name, name);
              }
              if (typeof instance.getSnapshotBeforeUpdate === "function" && typeof instance.componentDidUpdate !== "function" && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {
                didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);
                error("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", getComponentNameFromType(ctor));
              }
              if (typeof instance.getDerivedStateFromProps === "function") {
                error("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
              }
              if (typeof instance.getDerivedStateFromError === "function") {
                error("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
              }
              if (typeof ctor.getSnapshotBeforeUpdate === "function") {
                error("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", name);
              }
              var _state = instance.state;
              if (_state && (typeof _state !== "object" || isArray(_state))) {
                error("%s.state: must be set to an object or null", name);
              }
              if (typeof instance.getChildContext === "function" && typeof ctor.childContextTypes !== "object") {
                error("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", name);
              }
            }
          }
          function adoptClassInstance(workInProgress2, instance) {
            instance.updater = classComponentUpdater;
            workInProgress2.stateNode = instance;
            set(instance, workInProgress2);
            {
              instance._reactInternalInstance = fakeInternalInstance;
            }
          }
          function constructClassInstance(workInProgress2, ctor, props) {
            var isLegacyContextConsumer = false;
            var unmaskedContext = emptyContextObject;
            var context3 = emptyContextObject;
            var contextType = ctor.contextType;
            {
              if ("contextType" in ctor) {
                var isValid2 = (
                  // Allow null for conditional declaration
                  contextType === null || contextType !== void 0 && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === void 0
                );
                if (!isValid2 && !didWarnAboutInvalidateContextType.has(ctor)) {
                  didWarnAboutInvalidateContextType.add(ctor);
                  var addendum = "";
                  if (contextType === void 0) {
                    addendum = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.";
                  } else if (typeof contextType !== "object") {
                    addendum = " However, it is set to a " + typeof contextType + ".";
                  } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {
                    addendum = " Did you accidentally pass the Context.Provider instead?";
                  } else if (contextType._context !== void 0) {
                    addendum = " Did you accidentally pass the Context.Consumer instead?";
                  } else {
                    addendum = " However, it is set to an object with keys {" + Object.keys(contextType).join(", ") + "}.";
                  }
                  error("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", getComponentNameFromType(ctor) || "Component", addendum);
                }
              }
            }
            if (typeof contextType === "object" && contextType !== null) {
              context3 = readContext(contextType);
            } else {
              unmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
              var contextTypes = ctor.contextTypes;
              isLegacyContextConsumer = contextTypes !== null && contextTypes !== void 0;
              context3 = isLegacyContextConsumer ? getMaskedContext(workInProgress2, unmaskedContext) : emptyContextObject;
            }
            var instance = new ctor(props, context3);
            {
              if (workInProgress2.mode & StrictLegacyMode) {
                setIsStrictModeForDevtools(true);
                try {
                  instance = new ctor(props, context3);
                } finally {
                  setIsStrictModeForDevtools(false);
                }
              }
            }
            var state = workInProgress2.memoizedState = instance.state !== null && instance.state !== void 0 ? instance.state : null;
            adoptClassInstance(workInProgress2, instance);
            {
              if (typeof ctor.getDerivedStateFromProps === "function" && state === null) {
                var componentName = getComponentNameFromType(ctor) || "Component";
                if (!didWarnAboutUninitializedState.has(componentName)) {
                  didWarnAboutUninitializedState.add(componentName);
                  error("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", componentName, instance.state === null ? "null" : "undefined", componentName);
                }
              }
              if (typeof ctor.getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function") {
                var foundWillMountName = null;
                var foundWillReceivePropsName = null;
                var foundWillUpdateName = null;
                if (typeof instance.componentWillMount === "function" && instance.componentWillMount.__suppressDeprecationWarning !== true) {
                  foundWillMountName = "componentWillMount";
                } else if (typeof instance.UNSAFE_componentWillMount === "function") {
                  foundWillMountName = "UNSAFE_componentWillMount";
                }
                if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
                  foundWillReceivePropsName = "componentWillReceiveProps";
                } else if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
                  foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps";
                }
                if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
                  foundWillUpdateName = "componentWillUpdate";
                } else if (typeof instance.UNSAFE_componentWillUpdate === "function") {
                  foundWillUpdateName = "UNSAFE_componentWillUpdate";
                }
                if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
                  var _componentName = getComponentNameFromType(ctor) || "Component";
                  var newApiName = typeof ctor.getDerivedStateFromProps === "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
                  if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {
                    didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);
                    error("Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://reactjs.org/link/unsafe-component-lifecycles", _componentName, newApiName, foundWillMountName !== null ? "\n  " + foundWillMountName : "", foundWillReceivePropsName !== null ? "\n  " + foundWillReceivePropsName : "", foundWillUpdateName !== null ? "\n  " + foundWillUpdateName : "");
                  }
                }
              }
            }
            if (isLegacyContextConsumer) {
              cacheContext(workInProgress2, unmaskedContext, context3);
            }
            return instance;
          }
          function callComponentWillMount(workInProgress2, instance) {
            var oldState = instance.state;
            if (typeof instance.componentWillMount === "function") {
              instance.componentWillMount();
            }
            if (typeof instance.UNSAFE_componentWillMount === "function") {
              instance.UNSAFE_componentWillMount();
            }
            if (oldState !== instance.state) {
              {
                error("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", getComponentNameFromFiber(workInProgress2) || "Component");
              }
              classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
            }
          }
          function callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext) {
            var oldState = instance.state;
            if (typeof instance.componentWillReceiveProps === "function") {
              instance.componentWillReceiveProps(newProps, nextContext);
            }
            if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
              instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
            }
            if (instance.state !== oldState) {
              {
                var componentName = getComponentNameFromFiber(workInProgress2) || "Component";
                if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {
                  didWarnAboutStateAssignmentForComponent.add(componentName);
                  error("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", componentName);
                }
              }
              classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
            }
          }
          function mountClassInstance(workInProgress2, ctor, newProps, renderLanes2) {
            {
              checkClassInstance(workInProgress2, ctor, newProps);
            }
            var instance = workInProgress2.stateNode;
            instance.props = newProps;
            instance.state = workInProgress2.memoizedState;
            instance.refs = {};
            initializeUpdateQueue(workInProgress2);
            var contextType = ctor.contextType;
            if (typeof contextType === "object" && contextType !== null) {
              instance.context = readContext(contextType);
            } else {
              var unmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
              instance.context = getMaskedContext(workInProgress2, unmaskedContext);
            }
            {
              if (instance.state === newProps) {
                var componentName = getComponentNameFromType(ctor) || "Component";
                if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {
                  didWarnAboutDirectlyAssigningPropsToState.add(componentName);
                  error("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", componentName);
                }
              }
              if (workInProgress2.mode & StrictLegacyMode) {
                ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress2, instance);
              }
              {
                ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress2, instance);
              }
            }
            instance.state = workInProgress2.memoizedState;
            var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
            if (typeof getDerivedStateFromProps === "function") {
              applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);
              instance.state = workInProgress2.memoizedState;
            }
            if (typeof ctor.getDerivedStateFromProps !== "function" && typeof instance.getSnapshotBeforeUpdate !== "function" && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
              callComponentWillMount(workInProgress2, instance);
              processUpdateQueue(workInProgress2, newProps, instance, renderLanes2);
              instance.state = workInProgress2.memoizedState;
            }
            if (typeof instance.componentDidMount === "function") {
              var fiberFlags = Update;
              {
                fiberFlags |= LayoutStatic;
              }
              if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
                fiberFlags |= MountLayoutDev;
              }
              workInProgress2.flags |= fiberFlags;
            }
          }
          function resumeMountClassInstance(workInProgress2, ctor, newProps, renderLanes2) {
            var instance = workInProgress2.stateNode;
            var oldProps = workInProgress2.memoizedProps;
            instance.props = oldProps;
            var oldContext = instance.context;
            var contextType = ctor.contextType;
            var nextContext = emptyContextObject;
            if (typeof contextType === "object" && contextType !== null) {
              nextContext = readContext(contextType);
            } else {
              var nextLegacyUnmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
              nextContext = getMaskedContext(workInProgress2, nextLegacyUnmaskedContext);
            }
            var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
            var hasNewLifecycles = typeof getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function";
            if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === "function" || typeof instance.componentWillReceiveProps === "function")) {
              if (oldProps !== newProps || oldContext !== nextContext) {
                callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext);
              }
            }
            resetHasForceUpdateBeforeProcessing();
            var oldState = workInProgress2.memoizedState;
            var newState = instance.state = oldState;
            processUpdateQueue(workInProgress2, newProps, instance, renderLanes2);
            newState = workInProgress2.memoizedState;
            if (oldProps === newProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {
              if (typeof instance.componentDidMount === "function") {
                var fiberFlags = Update;
                {
                  fiberFlags |= LayoutStatic;
                }
                if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
                  fiberFlags |= MountLayoutDev;
                }
                workInProgress2.flags |= fiberFlags;
              }
              return false;
            }
            if (typeof getDerivedStateFromProps === "function") {
              applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);
              newState = workInProgress2.memoizedState;
            }
            var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext);
            if (shouldUpdate) {
              if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
                if (typeof instance.componentWillMount === "function") {
                  instance.componentWillMount();
                }
                if (typeof instance.UNSAFE_componentWillMount === "function") {
                  instance.UNSAFE_componentWillMount();
                }
              }
              if (typeof instance.componentDidMount === "function") {
                var _fiberFlags = Update;
                {
                  _fiberFlags |= LayoutStatic;
                }
                if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
                  _fiberFlags |= MountLayoutDev;
                }
                workInProgress2.flags |= _fiberFlags;
              }
            } else {
              if (typeof instance.componentDidMount === "function") {
                var _fiberFlags2 = Update;
                {
                  _fiberFlags2 |= LayoutStatic;
                }
                if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
                  _fiberFlags2 |= MountLayoutDev;
                }
                workInProgress2.flags |= _fiberFlags2;
              }
              workInProgress2.memoizedProps = newProps;
              workInProgress2.memoizedState = newState;
            }
            instance.props = newProps;
            instance.state = newState;
            instance.context = nextContext;
            return shouldUpdate;
          }
          function updateClassInstance(current2, workInProgress2, ctor, newProps, renderLanes2) {
            var instance = workInProgress2.stateNode;
            cloneUpdateQueue(current2, workInProgress2);
            var unresolvedOldProps = workInProgress2.memoizedProps;
            var oldProps = workInProgress2.type === workInProgress2.elementType ? unresolvedOldProps : resolveDefaultProps(workInProgress2.type, unresolvedOldProps);
            instance.props = oldProps;
            var unresolvedNewProps = workInProgress2.pendingProps;
            var oldContext = instance.context;
            var contextType = ctor.contextType;
            var nextContext = emptyContextObject;
            if (typeof contextType === "object" && contextType !== null) {
              nextContext = readContext(contextType);
            } else {
              var nextUnmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
              nextContext = getMaskedContext(workInProgress2, nextUnmaskedContext);
            }
            var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
            var hasNewLifecycles = typeof getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function";
            if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === "function" || typeof instance.componentWillReceiveProps === "function")) {
              if (unresolvedOldProps !== unresolvedNewProps || oldContext !== nextContext) {
                callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext);
              }
            }
            resetHasForceUpdateBeforeProcessing();
            var oldState = workInProgress2.memoizedState;
            var newState = instance.state = oldState;
            processUpdateQueue(workInProgress2, newProps, instance, renderLanes2);
            newState = workInProgress2.memoizedState;
            if (unresolvedOldProps === unresolvedNewProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing() && !enableLazyContextPropagation) {
              if (typeof instance.componentDidUpdate === "function") {
                if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
                  workInProgress2.flags |= Update;
                }
              }
              if (typeof instance.getSnapshotBeforeUpdate === "function") {
                if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
                  workInProgress2.flags |= Snapshot;
                }
              }
              return false;
            }
            if (typeof getDerivedStateFromProps === "function") {
              applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);
              newState = workInProgress2.memoizedState;
            }
            var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) || // TODO: In some cases, we'll end up checking if context has changed twice,
            // both before and after `shouldComponentUpdate` has been called. Not ideal,
            // but I'm loath to refactor this function. This only happens for memoized
            // components so it's not that common.
            enableLazyContextPropagation;
            if (shouldUpdate) {
              if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillUpdate === "function" || typeof instance.componentWillUpdate === "function")) {
                if (typeof instance.componentWillUpdate === "function") {
                  instance.componentWillUpdate(newProps, newState, nextContext);
                }
                if (typeof instance.UNSAFE_componentWillUpdate === "function") {
                  instance.UNSAFE_componentWillUpdate(newProps, newState, nextContext);
                }
              }
              if (typeof instance.componentDidUpdate === "function") {
                workInProgress2.flags |= Update;
              }
              if (typeof instance.getSnapshotBeforeUpdate === "function") {
                workInProgress2.flags |= Snapshot;
              }
            } else {
              if (typeof instance.componentDidUpdate === "function") {
                if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
                  workInProgress2.flags |= Update;
                }
              }
              if (typeof instance.getSnapshotBeforeUpdate === "function") {
                if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
                  workInProgress2.flags |= Snapshot;
                }
              }
              workInProgress2.memoizedProps = newProps;
              workInProgress2.memoizedState = newState;
            }
            instance.props = newProps;
            instance.state = newState;
            instance.context = nextContext;
            return shouldUpdate;
          }
          function createCapturedValueAtFiber(value, source) {
            return {
              value,
              source,
              stack: getStackByFiberInDevAndProd(source),
              digest: null
            };
          }
          function createCapturedValue(value, digest, stack) {
            return {
              value,
              source: null,
              stack: stack != null ? stack : null,
              digest: digest != null ? digest : null
            };
          }
          function showErrorDialog(boundary, errorInfo) {
            return true;
          }
          function logCapturedError(boundary, errorInfo) {
            try {
              var logError = showErrorDialog(boundary, errorInfo);
              if (logError === false) {
                return;
              }
              var error2 = errorInfo.value;
              if (true) {
                var source = errorInfo.source;
                var stack = errorInfo.stack;
                var componentStack = stack !== null ? stack : "";
                if (error2 != null && error2._suppressLogging) {
                  if (boundary.tag === ClassComponent) {
                    return;
                  }
                  console["error"](error2);
                }
                var componentName = source ? getComponentNameFromFiber(source) : null;
                var componentNameMessage = componentName ? "The above error occurred in the <" + componentName + "> component:" : "The above error occurred in one of your React components:";
                var errorBoundaryMessage;
                if (boundary.tag === HostRoot) {
                  errorBoundaryMessage = "Consider adding an error boundary to your tree to customize error handling behavior.\nVisit https://reactjs.org/link/error-boundaries to learn more about error boundaries.";
                } else {
                  var errorBoundaryName = getComponentNameFromFiber(boundary) || "Anonymous";
                  errorBoundaryMessage = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + errorBoundaryName + ".");
                }
                var combinedMessage = componentNameMessage + "\n" + componentStack + "\n\n" + ("" + errorBoundaryMessage);
                console["error"](combinedMessage);
              } else {
                console["error"](error2);
              }
            } catch (e) {
              setTimeout(function() {
                throw e;
              });
            }
          }
          var PossiblyWeakMap$1 = typeof WeakMap === "function" ? WeakMap : Map;
          function createRootErrorUpdate(fiber, errorInfo, lane) {
            var update = createUpdate(NoTimestamp, lane);
            update.tag = CaptureUpdate;
            update.payload = {
              element: null
            };
            var error2 = errorInfo.value;
            update.callback = function() {
              onUncaughtError(error2);
              logCapturedError(fiber, errorInfo);
            };
            return update;
          }
          function createClassErrorUpdate(fiber, errorInfo, lane) {
            var update = createUpdate(NoTimestamp, lane);
            update.tag = CaptureUpdate;
            var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
            if (typeof getDerivedStateFromError === "function") {
              var error$1 = errorInfo.value;
              update.payload = function() {
                return getDerivedStateFromError(error$1);
              };
              update.callback = function() {
                {
                  markFailedErrorBoundaryForHotReloading(fiber);
                }
                logCapturedError(fiber, errorInfo);
              };
            }
            var inst = fiber.stateNode;
            if (inst !== null && typeof inst.componentDidCatch === "function") {
              update.callback = function callback() {
                {
                  markFailedErrorBoundaryForHotReloading(fiber);
                }
                logCapturedError(fiber, errorInfo);
                if (typeof getDerivedStateFromError !== "function") {
                  markLegacyErrorBoundaryAsFailed(this);
                }
                var error$12 = errorInfo.value;
                var stack = errorInfo.stack;
                this.componentDidCatch(error$12, {
                  componentStack: stack !== null ? stack : ""
                });
                {
                  if (typeof getDerivedStateFromError !== "function") {
                    if (!includesSomeLane(fiber.lanes, SyncLane)) {
                      error("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", getComponentNameFromFiber(fiber) || "Unknown");
                    }
                  }
                }
              };
            }
            return update;
          }
          function attachPingListener(root3, wakeable, lanes) {
            var pingCache = root3.pingCache;
            var threadIDs;
            if (pingCache === null) {
              pingCache = root3.pingCache = new PossiblyWeakMap$1();
              threadIDs = /* @__PURE__ */ new Set();
              pingCache.set(wakeable, threadIDs);
            } else {
              threadIDs = pingCache.get(wakeable);
              if (threadIDs === void 0) {
                threadIDs = /* @__PURE__ */ new Set();
                pingCache.set(wakeable, threadIDs);
              }
            }
            if (!threadIDs.has(lanes)) {
              threadIDs.add(lanes);
              var ping = pingSuspendedRoot.bind(null, root3, wakeable, lanes);
              {
                if (isDevToolsPresent) {
                  restorePendingUpdaters(root3, lanes);
                }
              }
              wakeable.then(ping, ping);
            }
          }
          function attachRetryListener(suspenseBoundary, root3, wakeable, lanes) {
            var wakeables = suspenseBoundary.updateQueue;
            if (wakeables === null) {
              var updateQueue = /* @__PURE__ */ new Set();
              updateQueue.add(wakeable);
              suspenseBoundary.updateQueue = updateQueue;
            } else {
              wakeables.add(wakeable);
            }
          }
          function resetSuspendedComponent(sourceFiber, rootRenderLanes) {
            var tag = sourceFiber.tag;
            if ((sourceFiber.mode & ConcurrentMode) === NoMode && (tag === FunctionComponent || tag === ForwardRef || tag === SimpleMemoComponent)) {
              var currentSource = sourceFiber.alternate;
              if (currentSource) {
                sourceFiber.updateQueue = currentSource.updateQueue;
                sourceFiber.memoizedState = currentSource.memoizedState;
                sourceFiber.lanes = currentSource.lanes;
              } else {
                sourceFiber.updateQueue = null;
                sourceFiber.memoizedState = null;
              }
            }
          }
          function getNearestSuspenseBoundaryToCapture(returnFiber) {
            var node = returnFiber;
            do {
              if (node.tag === SuspenseComponent && shouldCaptureSuspense(node)) {
                return node;
              }
              node = node.return;
            } while (node !== null);
            return null;
          }
          function markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root3, rootRenderLanes) {
            if ((suspenseBoundary.mode & ConcurrentMode) === NoMode) {
              if (suspenseBoundary === returnFiber) {
                suspenseBoundary.flags |= ShouldCapture;
              } else {
                suspenseBoundary.flags |= DidCapture;
                sourceFiber.flags |= ForceUpdateForLegacySuspense;
                sourceFiber.flags &= ~(LifecycleEffectMask | Incomplete);
                if (sourceFiber.tag === ClassComponent) {
                  var currentSourceFiber = sourceFiber.alternate;
                  if (currentSourceFiber === null) {
                    sourceFiber.tag = IncompleteClassComponent;
                  } else {
                    var update = createUpdate(NoTimestamp, SyncLane);
                    update.tag = ForceUpdate;
                    enqueueUpdate(sourceFiber, update, SyncLane);
                  }
                }
                sourceFiber.lanes = mergeLanes(sourceFiber.lanes, SyncLane);
              }
              return suspenseBoundary;
            }
            suspenseBoundary.flags |= ShouldCapture;
            suspenseBoundary.lanes = rootRenderLanes;
            return suspenseBoundary;
          }
          function throwException(root3, returnFiber, sourceFiber, value, rootRenderLanes) {
            sourceFiber.flags |= Incomplete;
            {
              if (isDevToolsPresent) {
                restorePendingUpdaters(root3, rootRenderLanes);
              }
            }
            if (value !== null && typeof value === "object" && typeof value.then === "function") {
              var wakeable = value;
              resetSuspendedComponent(sourceFiber);
              {
                if (getIsHydrating() && sourceFiber.mode & ConcurrentMode) {
                  markDidThrowWhileHydratingDEV();
                }
              }
              var suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber);
              if (suspenseBoundary !== null) {
                suspenseBoundary.flags &= ~ForceClientRender;
                markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root3, rootRenderLanes);
                if (suspenseBoundary.mode & ConcurrentMode) {
                  attachPingListener(root3, wakeable, rootRenderLanes);
                }
                attachRetryListener(suspenseBoundary, root3, wakeable);
                return;
              } else {
                if (!includesSyncLane(rootRenderLanes)) {
                  attachPingListener(root3, wakeable, rootRenderLanes);
                  renderDidSuspendDelayIfPossible();
                  return;
                }
                var uncaughtSuspenseError = new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
                value = uncaughtSuspenseError;
              }
            } else {
              if (getIsHydrating() && sourceFiber.mode & ConcurrentMode) {
                markDidThrowWhileHydratingDEV();
                var _suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber);
                if (_suspenseBoundary !== null) {
                  if ((_suspenseBoundary.flags & ShouldCapture) === NoFlags) {
                    _suspenseBoundary.flags |= ForceClientRender;
                  }
                  markSuspenseBoundaryShouldCapture(_suspenseBoundary, returnFiber, sourceFiber, root3, rootRenderLanes);
                  queueHydrationError(createCapturedValueAtFiber(value, sourceFiber));
                  return;
                }
              }
            }
            value = createCapturedValueAtFiber(value, sourceFiber);
            renderDidError(value);
            var workInProgress2 = returnFiber;
            do {
              switch (workInProgress2.tag) {
                case HostRoot: {
                  var _errorInfo = value;
                  workInProgress2.flags |= ShouldCapture;
                  var lane = pickArbitraryLane(rootRenderLanes);
                  workInProgress2.lanes = mergeLanes(workInProgress2.lanes, lane);
                  var update = createRootErrorUpdate(workInProgress2, _errorInfo, lane);
                  enqueueCapturedUpdate(workInProgress2, update);
                  return;
                }
                case ClassComponent:
                  var errorInfo = value;
                  var ctor = workInProgress2.type;
                  var instance = workInProgress2.stateNode;
                  if ((workInProgress2.flags & DidCapture) === NoFlags && (typeof ctor.getDerivedStateFromError === "function" || instance !== null && typeof instance.componentDidCatch === "function" && !isAlreadyFailedLegacyErrorBoundary(instance))) {
                    workInProgress2.flags |= ShouldCapture;
                    var _lane = pickArbitraryLane(rootRenderLanes);
                    workInProgress2.lanes = mergeLanes(workInProgress2.lanes, _lane);
                    var _update = createClassErrorUpdate(workInProgress2, errorInfo, _lane);
                    enqueueCapturedUpdate(workInProgress2, _update);
                    return;
                  }
                  break;
              }
              workInProgress2 = workInProgress2.return;
            } while (workInProgress2 !== null);
          }
          function getSuspendedCache() {
            {
              return null;
            }
          }
          var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
          var didReceiveUpdate = false;
          var didWarnAboutBadClass;
          var didWarnAboutModulePatternComponent;
          var didWarnAboutContextTypeOnFunctionComponent;
          var didWarnAboutGetDerivedStateOnFunctionComponent;
          var didWarnAboutFunctionRefs;
          var didWarnAboutReassigningProps;
          var didWarnAboutRevealOrder;
          var didWarnAboutTailOptions;
          var didWarnAboutDefaultPropsOnFunctionComponent;
          {
            didWarnAboutBadClass = {};
            didWarnAboutModulePatternComponent = {};
            didWarnAboutContextTypeOnFunctionComponent = {};
            didWarnAboutGetDerivedStateOnFunctionComponent = {};
            didWarnAboutFunctionRefs = {};
            didWarnAboutReassigningProps = false;
            didWarnAboutRevealOrder = {};
            didWarnAboutTailOptions = {};
            didWarnAboutDefaultPropsOnFunctionComponent = {};
          }
          function reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2) {
            if (current2 === null) {
              workInProgress2.child = mountChildFibers(workInProgress2, null, nextChildren, renderLanes2);
            } else {
              workInProgress2.child = reconcileChildFibers(workInProgress2, current2.child, nextChildren, renderLanes2);
            }
          }
          function forceUnmountCurrentAndReconcile(current2, workInProgress2, nextChildren, renderLanes2) {
            workInProgress2.child = reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
            workInProgress2.child = reconcileChildFibers(workInProgress2, null, nextChildren, renderLanes2);
          }
          function updateForwardRef(current2, workInProgress2, Component3, nextProps, renderLanes2) {
            {
              if (workInProgress2.type !== workInProgress2.elementType) {
                var innerPropTypes = Component3.propTypes;
                if (innerPropTypes) {
                  checkPropTypes(
                    innerPropTypes,
                    nextProps,
                    // Resolved props
                    "prop",
                    getComponentNameFromType(Component3)
                  );
                }
              }
            }
            var render5 = Component3.render;
            var ref2 = workInProgress2.ref;
            var nextChildren;
            var hasId;
            prepareToReadContext(workInProgress2, renderLanes2);
            {
              markComponentRenderStarted(workInProgress2);
            }
            {
              ReactCurrentOwner$1.current = workInProgress2;
              setIsRendering(true);
              nextChildren = renderWithHooks(current2, workInProgress2, render5, nextProps, ref2, renderLanes2);
              hasId = checkDidRenderIdHook();
              if (workInProgress2.mode & StrictLegacyMode) {
                setIsStrictModeForDevtools(true);
                try {
                  nextChildren = renderWithHooks(current2, workInProgress2, render5, nextProps, ref2, renderLanes2);
                  hasId = checkDidRenderIdHook();
                } finally {
                  setIsStrictModeForDevtools(false);
                }
              }
              setIsRendering(false);
            }
            {
              markComponentRenderStopped();
            }
            if (current2 !== null && !didReceiveUpdate) {
              bailoutHooks(current2, workInProgress2, renderLanes2);
              return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
            }
            if (getIsHydrating() && hasId) {
              pushMaterializedTreeId(workInProgress2);
            }
            workInProgress2.flags |= PerformedWork;
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function updateMemoComponent(current2, workInProgress2, Component3, nextProps, renderLanes2) {
            if (current2 === null) {
              var type = Component3.type;
              if (isSimpleFunctionComponent(type) && Component3.compare === null && // SimpleMemoComponent codepath doesn't resolve outer props either.
              Component3.defaultProps === void 0) {
                var resolvedType = type;
                {
                  resolvedType = resolveFunctionForHotReloading(type);
                }
                workInProgress2.tag = SimpleMemoComponent;
                workInProgress2.type = resolvedType;
                {
                  validateFunctionComponentInDev(workInProgress2, type);
                }
                return updateSimpleMemoComponent(current2, workInProgress2, resolvedType, nextProps, renderLanes2);
              }
              {
                var innerPropTypes = type.propTypes;
                if (innerPropTypes) {
                  checkPropTypes(
                    innerPropTypes,
                    nextProps,
                    // Resolved props
                    "prop",
                    getComponentNameFromType(type)
                  );
                }
                if (Component3.defaultProps !== void 0) {
                  var componentName = getComponentNameFromType(type) || "Unknown";
                  if (!didWarnAboutDefaultPropsOnFunctionComponent[componentName]) {
                    error("%s: Support for defaultProps will be removed from memo components in a future major release. Use JavaScript default parameters instead.", componentName);
                    didWarnAboutDefaultPropsOnFunctionComponent[componentName] = true;
                  }
                }
              }
              var child = createFiberFromTypeAndProps(Component3.type, null, nextProps, workInProgress2, workInProgress2.mode, renderLanes2);
              child.ref = workInProgress2.ref;
              child.return = workInProgress2;
              workInProgress2.child = child;
              return child;
            }
            {
              var _type = Component3.type;
              var _innerPropTypes = _type.propTypes;
              if (_innerPropTypes) {
                checkPropTypes(
                  _innerPropTypes,
                  nextProps,
                  // Resolved props
                  "prop",
                  getComponentNameFromType(_type)
                );
              }
            }
            var currentChild = current2.child;
            var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current2, renderLanes2);
            if (!hasScheduledUpdateOrContext) {
              var prevProps = currentChild.memoizedProps;
              var compare = Component3.compare;
              compare = compare !== null ? compare : shallowEqual;
              if (compare(prevProps, nextProps) && current2.ref === workInProgress2.ref) {
                return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
              }
            }
            workInProgress2.flags |= PerformedWork;
            var newChild = createWorkInProgress(currentChild, nextProps);
            newChild.ref = workInProgress2.ref;
            newChild.return = workInProgress2;
            workInProgress2.child = newChild;
            return newChild;
          }
          function updateSimpleMemoComponent(current2, workInProgress2, Component3, nextProps, renderLanes2) {
            {
              if (workInProgress2.type !== workInProgress2.elementType) {
                var outerMemoType = workInProgress2.elementType;
                if (outerMemoType.$$typeof === REACT_LAZY_TYPE) {
                  var lazyComponent = outerMemoType;
                  var payload = lazyComponent._payload;
                  var init5 = lazyComponent._init;
                  try {
                    outerMemoType = init5(payload);
                  } catch (x) {
                    outerMemoType = null;
                  }
                  var outerPropTypes = outerMemoType && outerMemoType.propTypes;
                  if (outerPropTypes) {
                    checkPropTypes(
                      outerPropTypes,
                      nextProps,
                      // Resolved (SimpleMemoComponent has no defaultProps)
                      "prop",
                      getComponentNameFromType(outerMemoType)
                    );
                  }
                }
              }
            }
            if (current2 !== null) {
              var prevProps = current2.memoizedProps;
              if (shallowEqual(prevProps, nextProps) && current2.ref === workInProgress2.ref && // Prevent bailout if the implementation changed due to hot reload.
              workInProgress2.type === current2.type) {
                didReceiveUpdate = false;
                workInProgress2.pendingProps = nextProps = prevProps;
                if (!checkScheduledUpdateOrContext(current2, renderLanes2)) {
                  workInProgress2.lanes = current2.lanes;
                  return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
                } else if ((current2.flags & ForceUpdateForLegacySuspense) !== NoFlags) {
                  didReceiveUpdate = true;
                }
              }
            }
            return updateFunctionComponent(current2, workInProgress2, Component3, nextProps, renderLanes2);
          }
          function updateOffscreenComponent(current2, workInProgress2, renderLanes2) {
            var nextProps = workInProgress2.pendingProps;
            var nextChildren = nextProps.children;
            var prevState = current2 !== null ? current2.memoizedState : null;
            if (nextProps.mode === "hidden" || enableLegacyHidden) {
              if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
                var nextState = {
                  baseLanes: NoLanes,
                  cachePool: null,
                  transitions: null
                };
                workInProgress2.memoizedState = nextState;
                pushRenderLanes(workInProgress2, renderLanes2);
              } else if (!includesSomeLane(renderLanes2, OffscreenLane)) {
                var spawnedCachePool = null;
                var nextBaseLanes;
                if (prevState !== null) {
                  var prevBaseLanes = prevState.baseLanes;
                  nextBaseLanes = mergeLanes(prevBaseLanes, renderLanes2);
                } else {
                  nextBaseLanes = renderLanes2;
                }
                workInProgress2.lanes = workInProgress2.childLanes = laneToLanes(OffscreenLane);
                var _nextState = {
                  baseLanes: nextBaseLanes,
                  cachePool: spawnedCachePool,
                  transitions: null
                };
                workInProgress2.memoizedState = _nextState;
                workInProgress2.updateQueue = null;
                pushRenderLanes(workInProgress2, nextBaseLanes);
                return null;
              } else {
                var _nextState2 = {
                  baseLanes: NoLanes,
                  cachePool: null,
                  transitions: null
                };
                workInProgress2.memoizedState = _nextState2;
                var subtreeRenderLanes2 = prevState !== null ? prevState.baseLanes : renderLanes2;
                pushRenderLanes(workInProgress2, subtreeRenderLanes2);
              }
            } else {
              var _subtreeRenderLanes;
              if (prevState !== null) {
                _subtreeRenderLanes = mergeLanes(prevState.baseLanes, renderLanes2);
                workInProgress2.memoizedState = null;
              } else {
                _subtreeRenderLanes = renderLanes2;
              }
              pushRenderLanes(workInProgress2, _subtreeRenderLanes);
            }
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function updateFragment(current2, workInProgress2, renderLanes2) {
            var nextChildren = workInProgress2.pendingProps;
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function updateMode(current2, workInProgress2, renderLanes2) {
            var nextChildren = workInProgress2.pendingProps.children;
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function updateProfiler(current2, workInProgress2, renderLanes2) {
            {
              workInProgress2.flags |= Update;
              {
                var stateNode = workInProgress2.stateNode;
                stateNode.effectDuration = 0;
                stateNode.passiveEffectDuration = 0;
              }
            }
            var nextProps = workInProgress2.pendingProps;
            var nextChildren = nextProps.children;
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function markRef(current2, workInProgress2) {
            var ref2 = workInProgress2.ref;
            if (current2 === null && ref2 !== null || current2 !== null && current2.ref !== ref2) {
              workInProgress2.flags |= Ref;
              {
                workInProgress2.flags |= RefStatic;
              }
            }
          }
          function updateFunctionComponent(current2, workInProgress2, Component3, nextProps, renderLanes2) {
            {
              if (workInProgress2.type !== workInProgress2.elementType) {
                var innerPropTypes = Component3.propTypes;
                if (innerPropTypes) {
                  checkPropTypes(
                    innerPropTypes,
                    nextProps,
                    // Resolved props
                    "prop",
                    getComponentNameFromType(Component3)
                  );
                }
              }
            }
            var context3;
            {
              var unmaskedContext = getUnmaskedContext(workInProgress2, Component3, true);
              context3 = getMaskedContext(workInProgress2, unmaskedContext);
            }
            var nextChildren;
            var hasId;
            prepareToReadContext(workInProgress2, renderLanes2);
            {
              markComponentRenderStarted(workInProgress2);
            }
            {
              ReactCurrentOwner$1.current = workInProgress2;
              setIsRendering(true);
              nextChildren = renderWithHooks(current2, workInProgress2, Component3, nextProps, context3, renderLanes2);
              hasId = checkDidRenderIdHook();
              if (workInProgress2.mode & StrictLegacyMode) {
                setIsStrictModeForDevtools(true);
                try {
                  nextChildren = renderWithHooks(current2, workInProgress2, Component3, nextProps, context3, renderLanes2);
                  hasId = checkDidRenderIdHook();
                } finally {
                  setIsStrictModeForDevtools(false);
                }
              }
              setIsRendering(false);
            }
            {
              markComponentRenderStopped();
            }
            if (current2 !== null && !didReceiveUpdate) {
              bailoutHooks(current2, workInProgress2, renderLanes2);
              return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
            }
            if (getIsHydrating() && hasId) {
              pushMaterializedTreeId(workInProgress2);
            }
            workInProgress2.flags |= PerformedWork;
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function updateClassComponent(current2, workInProgress2, Component3, nextProps, renderLanes2) {
            {
              switch (shouldError(workInProgress2)) {
                case false: {
                  var _instance = workInProgress2.stateNode;
                  var ctor = workInProgress2.type;
                  var tempInstance = new ctor(workInProgress2.memoizedProps, _instance.context);
                  var state = tempInstance.state;
                  _instance.updater.enqueueSetState(_instance, state, null);
                  break;
                }
                case true: {
                  workInProgress2.flags |= DidCapture;
                  workInProgress2.flags |= ShouldCapture;
                  var error$1 = new Error("Simulated error coming from DevTools");
                  var lane = pickArbitraryLane(renderLanes2);
                  workInProgress2.lanes = mergeLanes(workInProgress2.lanes, lane);
                  var update = createClassErrorUpdate(workInProgress2, createCapturedValueAtFiber(error$1, workInProgress2), lane);
                  enqueueCapturedUpdate(workInProgress2, update);
                  break;
                }
              }
              if (workInProgress2.type !== workInProgress2.elementType) {
                var innerPropTypes = Component3.propTypes;
                if (innerPropTypes) {
                  checkPropTypes(
                    innerPropTypes,
                    nextProps,
                    // Resolved props
                    "prop",
                    getComponentNameFromType(Component3)
                  );
                }
              }
            }
            var hasContext;
            if (isContextProvider(Component3)) {
              hasContext = true;
              pushContextProvider(workInProgress2);
            } else {
              hasContext = false;
            }
            prepareToReadContext(workInProgress2, renderLanes2);
            var instance = workInProgress2.stateNode;
            var shouldUpdate;
            if (instance === null) {
              resetSuspendedCurrentOnMountInLegacyMode(current2, workInProgress2);
              constructClassInstance(workInProgress2, Component3, nextProps);
              mountClassInstance(workInProgress2, Component3, nextProps, renderLanes2);
              shouldUpdate = true;
            } else if (current2 === null) {
              shouldUpdate = resumeMountClassInstance(workInProgress2, Component3, nextProps, renderLanes2);
            } else {
              shouldUpdate = updateClassInstance(current2, workInProgress2, Component3, nextProps, renderLanes2);
            }
            var nextUnitOfWork = finishClassComponent(current2, workInProgress2, Component3, shouldUpdate, hasContext, renderLanes2);
            {
              var inst = workInProgress2.stateNode;
              if (shouldUpdate && inst.props !== nextProps) {
                if (!didWarnAboutReassigningProps) {
                  error("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", getComponentNameFromFiber(workInProgress2) || "a component");
                }
                didWarnAboutReassigningProps = true;
              }
            }
            return nextUnitOfWork;
          }
          function finishClassComponent(current2, workInProgress2, Component3, shouldUpdate, hasContext, renderLanes2) {
            markRef(current2, workInProgress2);
            var didCaptureError = (workInProgress2.flags & DidCapture) !== NoFlags;
            if (!shouldUpdate && !didCaptureError) {
              if (hasContext) {
                invalidateContextProvider(workInProgress2, Component3, false);
              }
              return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
            }
            var instance = workInProgress2.stateNode;
            ReactCurrentOwner$1.current = workInProgress2;
            var nextChildren;
            if (didCaptureError && typeof Component3.getDerivedStateFromError !== "function") {
              nextChildren = null;
              {
                stopProfilerTimerIfRunning();
              }
            } else {
              {
                markComponentRenderStarted(workInProgress2);
              }
              {
                setIsRendering(true);
                nextChildren = instance.render();
                if (workInProgress2.mode & StrictLegacyMode) {
                  setIsStrictModeForDevtools(true);
                  try {
                    instance.render();
                  } finally {
                    setIsStrictModeForDevtools(false);
                  }
                }
                setIsRendering(false);
              }
              {
                markComponentRenderStopped();
              }
            }
            workInProgress2.flags |= PerformedWork;
            if (current2 !== null && didCaptureError) {
              forceUnmountCurrentAndReconcile(current2, workInProgress2, nextChildren, renderLanes2);
            } else {
              reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            }
            workInProgress2.memoizedState = instance.state;
            if (hasContext) {
              invalidateContextProvider(workInProgress2, Component3, true);
            }
            return workInProgress2.child;
          }
          function pushHostRootContext(workInProgress2) {
            var root3 = workInProgress2.stateNode;
            if (root3.pendingContext) {
              pushTopLevelContextObject(workInProgress2, root3.pendingContext, root3.pendingContext !== root3.context);
            } else if (root3.context) {
              pushTopLevelContextObject(workInProgress2, root3.context, false);
            }
            pushHostContainer(workInProgress2, root3.containerInfo);
          }
          function updateHostRoot(current2, workInProgress2, renderLanes2) {
            pushHostRootContext(workInProgress2);
            if (current2 === null) {
              throw new Error("Should have a current fiber. This is a bug in React.");
            }
            var nextProps = workInProgress2.pendingProps;
            var prevState = workInProgress2.memoizedState;
            var prevChildren = prevState.element;
            cloneUpdateQueue(current2, workInProgress2);
            processUpdateQueue(workInProgress2, nextProps, null, renderLanes2);
            var nextState = workInProgress2.memoizedState;
            var root3 = workInProgress2.stateNode;
            var nextChildren = nextState.element;
            if (prevState.isDehydrated) {
              var overrideState = {
                element: nextChildren,
                isDehydrated: false,
                cache: nextState.cache,
                pendingSuspenseBoundaries: nextState.pendingSuspenseBoundaries,
                transitions: nextState.transitions
              };
              var updateQueue = workInProgress2.updateQueue;
              updateQueue.baseState = overrideState;
              workInProgress2.memoizedState = overrideState;
              if (workInProgress2.flags & ForceClientRender) {
                var recoverableError = createCapturedValueAtFiber(new Error("There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering."), workInProgress2);
                return mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2, recoverableError);
              } else if (nextChildren !== prevChildren) {
                var _recoverableError = createCapturedValueAtFiber(new Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."), workInProgress2);
                return mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2, _recoverableError);
              } else {
                enterHydrationState(workInProgress2);
                var child = mountChildFibers(workInProgress2, null, nextChildren, renderLanes2);
                workInProgress2.child = child;
                var node = child;
                while (node) {
                  node.flags = node.flags & ~Placement | Hydrating;
                  node = node.sibling;
                }
              }
            } else {
              resetHydrationState();
              if (nextChildren === prevChildren) {
                return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
              }
              reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            }
            return workInProgress2.child;
          }
          function mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2, recoverableError) {
            resetHydrationState();
            queueHydrationError(recoverableError);
            workInProgress2.flags |= ForceClientRender;
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function updateHostComponent(current2, workInProgress2, renderLanes2) {
            pushHostContext(workInProgress2);
            if (current2 === null) {
              tryToClaimNextHydratableInstance(workInProgress2);
            }
            var type = workInProgress2.type;
            var nextProps = workInProgress2.pendingProps;
            var prevProps = current2 !== null ? current2.memoizedProps : null;
            var nextChildren = nextProps.children;
            var isDirectTextChild = shouldSetTextContent(type, nextProps);
            if (isDirectTextChild) {
              nextChildren = null;
            } else if (prevProps !== null && shouldSetTextContent(type, prevProps)) {
              workInProgress2.flags |= ContentReset;
            }
            markRef(current2, workInProgress2);
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function updateHostText(current2, workInProgress2) {
            if (current2 === null) {
              tryToClaimNextHydratableInstance(workInProgress2);
            }
            return null;
          }
          function mountLazyComponent(_current, workInProgress2, elementType, renderLanes2) {
            resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2);
            var props = workInProgress2.pendingProps;
            var lazyComponent = elementType;
            var payload = lazyComponent._payload;
            var init5 = lazyComponent._init;
            var Component3 = init5(payload);
            workInProgress2.type = Component3;
            var resolvedTag = workInProgress2.tag = resolveLazyComponentTag(Component3);
            var resolvedProps = resolveDefaultProps(Component3, props);
            var child;
            switch (resolvedTag) {
              case FunctionComponent: {
                {
                  validateFunctionComponentInDev(workInProgress2, Component3);
                  workInProgress2.type = Component3 = resolveFunctionForHotReloading(Component3);
                }
                child = updateFunctionComponent(null, workInProgress2, Component3, resolvedProps, renderLanes2);
                return child;
              }
              case ClassComponent: {
                {
                  workInProgress2.type = Component3 = resolveClassForHotReloading(Component3);
                }
                child = updateClassComponent(null, workInProgress2, Component3, resolvedProps, renderLanes2);
                return child;
              }
              case ForwardRef: {
                {
                  workInProgress2.type = Component3 = resolveForwardRefForHotReloading(Component3);
                }
                child = updateForwardRef(null, workInProgress2, Component3, resolvedProps, renderLanes2);
                return child;
              }
              case MemoComponent: {
                {
                  if (workInProgress2.type !== workInProgress2.elementType) {
                    var outerPropTypes = Component3.propTypes;
                    if (outerPropTypes) {
                      checkPropTypes(
                        outerPropTypes,
                        resolvedProps,
                        // Resolved for outer only
                        "prop",
                        getComponentNameFromType(Component3)
                      );
                    }
                  }
                }
                child = updateMemoComponent(
                  null,
                  workInProgress2,
                  Component3,
                  resolveDefaultProps(Component3.type, resolvedProps),
                  // The inner type can have defaults too
                  renderLanes2
                );
                return child;
              }
            }
            var hint = "";
            {
              if (Component3 !== null && typeof Component3 === "object" && Component3.$$typeof === REACT_LAZY_TYPE) {
                hint = " Did you wrap a component in React.lazy() more than once?";
              }
            }
            throw new Error("Element type is invalid. Received a promise that resolves to: " + Component3 + ". " + ("Lazy element type must resolve to a class or function." + hint));
          }
          function mountIncompleteClassComponent(_current, workInProgress2, Component3, nextProps, renderLanes2) {
            resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2);
            workInProgress2.tag = ClassComponent;
            var hasContext;
            if (isContextProvider(Component3)) {
              hasContext = true;
              pushContextProvider(workInProgress2);
            } else {
              hasContext = false;
            }
            prepareToReadContext(workInProgress2, renderLanes2);
            constructClassInstance(workInProgress2, Component3, nextProps);
            mountClassInstance(workInProgress2, Component3, nextProps, renderLanes2);
            return finishClassComponent(null, workInProgress2, Component3, true, hasContext, renderLanes2);
          }
          function mountIndeterminateComponent(_current, workInProgress2, Component3, renderLanes2) {
            resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2);
            var props = workInProgress2.pendingProps;
            var context3;
            {
              var unmaskedContext = getUnmaskedContext(workInProgress2, Component3, false);
              context3 = getMaskedContext(workInProgress2, unmaskedContext);
            }
            prepareToReadContext(workInProgress2, renderLanes2);
            var value;
            var hasId;
            {
              markComponentRenderStarted(workInProgress2);
            }
            {
              if (Component3.prototype && typeof Component3.prototype.render === "function") {
                var componentName = getComponentNameFromType(Component3) || "Unknown";
                if (!didWarnAboutBadClass[componentName]) {
                  error("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", componentName, componentName);
                  didWarnAboutBadClass[componentName] = true;
                }
              }
              if (workInProgress2.mode & StrictLegacyMode) {
                ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress2, null);
              }
              setIsRendering(true);
              ReactCurrentOwner$1.current = workInProgress2;
              value = renderWithHooks(null, workInProgress2, Component3, props, context3, renderLanes2);
              hasId = checkDidRenderIdHook();
              setIsRendering(false);
            }
            {
              markComponentRenderStopped();
            }
            workInProgress2.flags |= PerformedWork;
            {
              if (typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === void 0) {
                var _componentName = getComponentNameFromType(Component3) || "Unknown";
                if (!didWarnAboutModulePatternComponent[_componentName]) {
                  error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName, _componentName, _componentName);
                  didWarnAboutModulePatternComponent[_componentName] = true;
                }
              }
            }
            if (
              // Run these checks in production only if the flag is off.
              // Eventually we'll delete this branch altogether.
              typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === void 0
            ) {
              {
                var _componentName2 = getComponentNameFromType(Component3) || "Unknown";
                if (!didWarnAboutModulePatternComponent[_componentName2]) {
                  error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName2, _componentName2, _componentName2);
                  didWarnAboutModulePatternComponent[_componentName2] = true;
                }
              }
              workInProgress2.tag = ClassComponent;
              workInProgress2.memoizedState = null;
              workInProgress2.updateQueue = null;
              var hasContext = false;
              if (isContextProvider(Component3)) {
                hasContext = true;
                pushContextProvider(workInProgress2);
              } else {
                hasContext = false;
              }
              workInProgress2.memoizedState = value.state !== null && value.state !== void 0 ? value.state : null;
              initializeUpdateQueue(workInProgress2);
              adoptClassInstance(workInProgress2, value);
              mountClassInstance(workInProgress2, Component3, props, renderLanes2);
              return finishClassComponent(null, workInProgress2, Component3, true, hasContext, renderLanes2);
            } else {
              workInProgress2.tag = FunctionComponent;
              {
                if (workInProgress2.mode & StrictLegacyMode) {
                  setIsStrictModeForDevtools(true);
                  try {
                    value = renderWithHooks(null, workInProgress2, Component3, props, context3, renderLanes2);
                    hasId = checkDidRenderIdHook();
                  } finally {
                    setIsStrictModeForDevtools(false);
                  }
                }
              }
              if (getIsHydrating() && hasId) {
                pushMaterializedTreeId(workInProgress2);
              }
              reconcileChildren(null, workInProgress2, value, renderLanes2);
              {
                validateFunctionComponentInDev(workInProgress2, Component3);
              }
              return workInProgress2.child;
            }
          }
          function validateFunctionComponentInDev(workInProgress2, Component3) {
            {
              if (Component3) {
                if (Component3.childContextTypes) {
                  error("%s(...): childContextTypes cannot be defined on a function component.", Component3.displayName || Component3.name || "Component");
                }
              }
              if (workInProgress2.ref !== null) {
                var info = "";
                var ownerName = getCurrentFiberOwnerNameInDevOrNull();
                if (ownerName) {
                  info += "\n\nCheck the render method of `" + ownerName + "`.";
                }
                var warningKey = ownerName || "";
                var debugSource = workInProgress2._debugSource;
                if (debugSource) {
                  warningKey = debugSource.fileName + ":" + debugSource.lineNumber;
                }
                if (!didWarnAboutFunctionRefs[warningKey]) {
                  didWarnAboutFunctionRefs[warningKey] = true;
                  error("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s", info);
                }
              }
              if (Component3.defaultProps !== void 0) {
                var componentName = getComponentNameFromType(Component3) || "Unknown";
                if (!didWarnAboutDefaultPropsOnFunctionComponent[componentName]) {
                  error("%s: Support for defaultProps will be removed from function components in a future major release. Use JavaScript default parameters instead.", componentName);
                  didWarnAboutDefaultPropsOnFunctionComponent[componentName] = true;
                }
              }
              if (typeof Component3.getDerivedStateFromProps === "function") {
                var _componentName3 = getComponentNameFromType(Component3) || "Unknown";
                if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {
                  error("%s: Function components do not support getDerivedStateFromProps.", _componentName3);
                  didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true;
                }
              }
              if (typeof Component3.contextType === "object" && Component3.contextType !== null) {
                var _componentName4 = getComponentNameFromType(Component3) || "Unknown";
                if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {
                  error("%s: Function components do not support contextType.", _componentName4);
                  didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true;
                }
              }
            }
          }
          var SUSPENDED_MARKER = {
            dehydrated: null,
            treeContext: null,
            retryLane: NoLane
          };
          function mountSuspenseOffscreenState(renderLanes2) {
            return {
              baseLanes: renderLanes2,
              cachePool: getSuspendedCache(),
              transitions: null
            };
          }
          function updateSuspenseOffscreenState(prevOffscreenState, renderLanes2) {
            var cachePool = null;
            return {
              baseLanes: mergeLanes(prevOffscreenState.baseLanes, renderLanes2),
              cachePool,
              transitions: prevOffscreenState.transitions
            };
          }
          function shouldRemainOnFallback(suspenseContext, current2, workInProgress2, renderLanes2) {
            if (current2 !== null) {
              var suspenseState = current2.memoizedState;
              if (suspenseState === null) {
                return false;
              }
            }
            return hasSuspenseContext(suspenseContext, ForceSuspenseFallback);
          }
          function getRemainingWorkInPrimaryTree(current2, renderLanes2) {
            return removeLanes(current2.childLanes, renderLanes2);
          }
          function updateSuspenseComponent(current2, workInProgress2, renderLanes2) {
            var nextProps = workInProgress2.pendingProps;
            {
              if (shouldSuspend(workInProgress2)) {
                workInProgress2.flags |= DidCapture;
              }
            }
            var suspenseContext = suspenseStackCursor.current;
            var showFallback = false;
            var didSuspend = (workInProgress2.flags & DidCapture) !== NoFlags;
            if (didSuspend || shouldRemainOnFallback(suspenseContext, current2)) {
              showFallback = true;
              workInProgress2.flags &= ~DidCapture;
            } else {
              if (current2 === null || current2.memoizedState !== null) {
                {
                  suspenseContext = addSubtreeSuspenseContext(suspenseContext, InvisibleParentSuspenseContext);
                }
              }
            }
            suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
            pushSuspenseContext(workInProgress2, suspenseContext);
            if (current2 === null) {
              tryToClaimNextHydratableInstance(workInProgress2);
              var suspenseState = workInProgress2.memoizedState;
              if (suspenseState !== null) {
                var dehydrated = suspenseState.dehydrated;
                if (dehydrated !== null) {
                  return mountDehydratedSuspenseComponent(workInProgress2, dehydrated);
                }
              }
              var nextPrimaryChildren = nextProps.children;
              var nextFallbackChildren = nextProps.fallback;
              if (showFallback) {
                var fallbackFragment = mountSuspenseFallbackChildren(workInProgress2, nextPrimaryChildren, nextFallbackChildren, renderLanes2);
                var primaryChildFragment = workInProgress2.child;
                primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes2);
                workInProgress2.memoizedState = SUSPENDED_MARKER;
                return fallbackFragment;
              } else {
                return mountSuspensePrimaryChildren(workInProgress2, nextPrimaryChildren);
              }
            } else {
              var prevState = current2.memoizedState;
              if (prevState !== null) {
                var _dehydrated = prevState.dehydrated;
                if (_dehydrated !== null) {
                  return updateDehydratedSuspenseComponent(current2, workInProgress2, didSuspend, nextProps, _dehydrated, prevState, renderLanes2);
                }
              }
              if (showFallback) {
                var _nextFallbackChildren = nextProps.fallback;
                var _nextPrimaryChildren = nextProps.children;
                var fallbackChildFragment = updateSuspenseFallbackChildren(current2, workInProgress2, _nextPrimaryChildren, _nextFallbackChildren, renderLanes2);
                var _primaryChildFragment2 = workInProgress2.child;
                var prevOffscreenState = current2.child.memoizedState;
                _primaryChildFragment2.memoizedState = prevOffscreenState === null ? mountSuspenseOffscreenState(renderLanes2) : updateSuspenseOffscreenState(prevOffscreenState, renderLanes2);
                _primaryChildFragment2.childLanes = getRemainingWorkInPrimaryTree(current2, renderLanes2);
                workInProgress2.memoizedState = SUSPENDED_MARKER;
                return fallbackChildFragment;
              } else {
                var _nextPrimaryChildren2 = nextProps.children;
                var _primaryChildFragment3 = updateSuspensePrimaryChildren(current2, workInProgress2, _nextPrimaryChildren2, renderLanes2);
                workInProgress2.memoizedState = null;
                return _primaryChildFragment3;
              }
            }
          }
          function mountSuspensePrimaryChildren(workInProgress2, primaryChildren, renderLanes2) {
            var mode = workInProgress2.mode;
            var primaryChildProps = {
              mode: "visible",
              children: primaryChildren
            };
            var primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode);
            primaryChildFragment.return = workInProgress2;
            workInProgress2.child = primaryChildFragment;
            return primaryChildFragment;
          }
          function mountSuspenseFallbackChildren(workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
            var mode = workInProgress2.mode;
            var progressedPrimaryFragment = workInProgress2.child;
            var primaryChildProps = {
              mode: "hidden",
              children: primaryChildren
            };
            var primaryChildFragment;
            var fallbackChildFragment;
            if ((mode & ConcurrentMode) === NoMode && progressedPrimaryFragment !== null) {
              primaryChildFragment = progressedPrimaryFragment;
              primaryChildFragment.childLanes = NoLanes;
              primaryChildFragment.pendingProps = primaryChildProps;
              if (workInProgress2.mode & ProfileMode) {
                primaryChildFragment.actualDuration = 0;
                primaryChildFragment.actualStartTime = -1;
                primaryChildFragment.selfBaseDuration = 0;
                primaryChildFragment.treeBaseDuration = 0;
              }
              fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);
            } else {
              primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode);
              fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);
            }
            primaryChildFragment.return = workInProgress2;
            fallbackChildFragment.return = workInProgress2;
            primaryChildFragment.sibling = fallbackChildFragment;
            workInProgress2.child = primaryChildFragment;
            return fallbackChildFragment;
          }
          function mountWorkInProgressOffscreenFiber(offscreenProps, mode, renderLanes2) {
            return createFiberFromOffscreen(offscreenProps, mode, NoLanes, null);
          }
          function updateWorkInProgressOffscreenFiber(current2, offscreenProps) {
            return createWorkInProgress(current2, offscreenProps);
          }
          function updateSuspensePrimaryChildren(current2, workInProgress2, primaryChildren, renderLanes2) {
            var currentPrimaryChildFragment = current2.child;
            var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
            var primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, {
              mode: "visible",
              children: primaryChildren
            });
            if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
              primaryChildFragment.lanes = renderLanes2;
            }
            primaryChildFragment.return = workInProgress2;
            primaryChildFragment.sibling = null;
            if (currentFallbackChildFragment !== null) {
              var deletions = workInProgress2.deletions;
              if (deletions === null) {
                workInProgress2.deletions = [currentFallbackChildFragment];
                workInProgress2.flags |= ChildDeletion;
              } else {
                deletions.push(currentFallbackChildFragment);
              }
            }
            workInProgress2.child = primaryChildFragment;
            return primaryChildFragment;
          }
          function updateSuspenseFallbackChildren(current2, workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
            var mode = workInProgress2.mode;
            var currentPrimaryChildFragment = current2.child;
            var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
            var primaryChildProps = {
              mode: "hidden",
              children: primaryChildren
            };
            var primaryChildFragment;
            if (
              // In legacy mode, we commit the primary tree as if it successfully
              // completed, even though it's in an inconsistent state.
              (mode & ConcurrentMode) === NoMode && // Make sure we're on the second pass, i.e. the primary child fragment was
              // already cloned. In legacy mode, the only case where this isn't true is
              // when DevTools forces us to display a fallback; we skip the first render
              // pass entirely and go straight to rendering the fallback. (In Concurrent
              // Mode, SuspenseList can also trigger this scenario, but this is a legacy-
              // only codepath.)
              workInProgress2.child !== currentPrimaryChildFragment
            ) {
              var progressedPrimaryFragment = workInProgress2.child;
              primaryChildFragment = progressedPrimaryFragment;
              primaryChildFragment.childLanes = NoLanes;
              primaryChildFragment.pendingProps = primaryChildProps;
              if (workInProgress2.mode & ProfileMode) {
                primaryChildFragment.actualDuration = 0;
                primaryChildFragment.actualStartTime = -1;
                primaryChildFragment.selfBaseDuration = currentPrimaryChildFragment.selfBaseDuration;
                primaryChildFragment.treeBaseDuration = currentPrimaryChildFragment.treeBaseDuration;
              }
              workInProgress2.deletions = null;
            } else {
              primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, primaryChildProps);
              primaryChildFragment.subtreeFlags = currentPrimaryChildFragment.subtreeFlags & StaticMask;
            }
            var fallbackChildFragment;
            if (currentFallbackChildFragment !== null) {
              fallbackChildFragment = createWorkInProgress(currentFallbackChildFragment, fallbackChildren);
            } else {
              fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);
              fallbackChildFragment.flags |= Placement;
            }
            fallbackChildFragment.return = workInProgress2;
            primaryChildFragment.return = workInProgress2;
            primaryChildFragment.sibling = fallbackChildFragment;
            workInProgress2.child = primaryChildFragment;
            return fallbackChildFragment;
          }
          function retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, recoverableError) {
            if (recoverableError !== null) {
              queueHydrationError(recoverableError);
            }
            reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
            var nextProps = workInProgress2.pendingProps;
            var primaryChildren = nextProps.children;
            var primaryChildFragment = mountSuspensePrimaryChildren(workInProgress2, primaryChildren);
            primaryChildFragment.flags |= Placement;
            workInProgress2.memoizedState = null;
            return primaryChildFragment;
          }
          function mountSuspenseFallbackAfterRetryWithoutHydrating(current2, workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
            var fiberMode = workInProgress2.mode;
            var primaryChildProps = {
              mode: "visible",
              children: primaryChildren
            };
            var primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, fiberMode);
            var fallbackChildFragment = createFiberFromFragment(fallbackChildren, fiberMode, renderLanes2, null);
            fallbackChildFragment.flags |= Placement;
            primaryChildFragment.return = workInProgress2;
            fallbackChildFragment.return = workInProgress2;
            primaryChildFragment.sibling = fallbackChildFragment;
            workInProgress2.child = primaryChildFragment;
            if ((workInProgress2.mode & ConcurrentMode) !== NoMode) {
              reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
            }
            return fallbackChildFragment;
          }
          function mountDehydratedSuspenseComponent(workInProgress2, suspenseInstance, renderLanes2) {
            if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
              {
                error("Cannot hydrate Suspense in legacy mode. Switch from ReactDOM.hydrate(element, container) to ReactDOMClient.hydrateRoot(container, <App />).render(element) or remove the Suspense components from the server rendered components.");
              }
              workInProgress2.lanes = laneToLanes(SyncLane);
            } else if (isSuspenseInstanceFallback(suspenseInstance)) {
              workInProgress2.lanes = laneToLanes(DefaultHydrationLane);
            } else {
              workInProgress2.lanes = laneToLanes(OffscreenLane);
            }
            return null;
          }
          function updateDehydratedSuspenseComponent(current2, workInProgress2, didSuspend, nextProps, suspenseInstance, suspenseState, renderLanes2) {
            if (!didSuspend) {
              warnIfHydrating();
              if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
                return retrySuspenseComponentWithoutHydrating(
                  current2,
                  workInProgress2,
                  renderLanes2,
                  // TODO: When we delete legacy mode, we should make this error argument
                  // required  every concurrent mode path that causes hydration to
                  // de-opt to client rendering should have an error message.
                  null
                );
              }
              if (isSuspenseInstanceFallback(suspenseInstance)) {
                var digest, message, stack;
                {
                  var _getSuspenseInstanceF = getSuspenseInstanceFallbackErrorDetails(suspenseInstance);
                  digest = _getSuspenseInstanceF.digest;
                  message = _getSuspenseInstanceF.message;
                  stack = _getSuspenseInstanceF.stack;
                }
                var error2;
                if (message) {
                  error2 = new Error(message);
                } else {
                  error2 = new Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.");
                }
                var capturedValue = createCapturedValue(error2, digest, stack);
                return retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, capturedValue);
              }
              var hasContextChanged2 = includesSomeLane(renderLanes2, current2.childLanes);
              if (didReceiveUpdate || hasContextChanged2) {
                var root3 = getWorkInProgressRoot();
                if (root3 !== null) {
                  var attemptHydrationAtLane = getBumpedLaneForHydration(root3, renderLanes2);
                  if (attemptHydrationAtLane !== NoLane && attemptHydrationAtLane !== suspenseState.retryLane) {
                    suspenseState.retryLane = attemptHydrationAtLane;
                    var eventTime = NoTimestamp;
                    enqueueConcurrentRenderForLane(current2, attemptHydrationAtLane);
                    scheduleUpdateOnFiber(root3, current2, attemptHydrationAtLane, eventTime);
                  }
                }
                renderDidSuspendDelayIfPossible();
                var _capturedValue = createCapturedValue(new Error("This Suspense boundary received an update before it finished hydrating. This caused the boundary to switch to client rendering. The usual way to fix this is to wrap the original update in startTransition."));
                return retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, _capturedValue);
              } else if (isSuspenseInstancePending(suspenseInstance)) {
                workInProgress2.flags |= DidCapture;
                workInProgress2.child = current2.child;
                var retry = retryDehydratedSuspenseBoundary.bind(null, current2);
                registerSuspenseInstanceRetry(suspenseInstance, retry);
                return null;
              } else {
                reenterHydrationStateFromDehydratedSuspenseInstance(workInProgress2, suspenseInstance, suspenseState.treeContext);
                var primaryChildren = nextProps.children;
                var primaryChildFragment = mountSuspensePrimaryChildren(workInProgress2, primaryChildren);
                primaryChildFragment.flags |= Hydrating;
                return primaryChildFragment;
              }
            } else {
              if (workInProgress2.flags & ForceClientRender) {
                workInProgress2.flags &= ~ForceClientRender;
                var _capturedValue2 = createCapturedValue(new Error("There was an error while hydrating this Suspense boundary. Switched to client rendering."));
                return retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, _capturedValue2);
              } else if (workInProgress2.memoizedState !== null) {
                workInProgress2.child = current2.child;
                workInProgress2.flags |= DidCapture;
                return null;
              } else {
                var nextPrimaryChildren = nextProps.children;
                var nextFallbackChildren = nextProps.fallback;
                var fallbackChildFragment = mountSuspenseFallbackAfterRetryWithoutHydrating(current2, workInProgress2, nextPrimaryChildren, nextFallbackChildren, renderLanes2);
                var _primaryChildFragment4 = workInProgress2.child;
                _primaryChildFragment4.memoizedState = mountSuspenseOffscreenState(renderLanes2);
                workInProgress2.memoizedState = SUSPENDED_MARKER;
                return fallbackChildFragment;
              }
            }
          }
          function scheduleSuspenseWorkOnFiber(fiber, renderLanes2, propagationRoot) {
            fiber.lanes = mergeLanes(fiber.lanes, renderLanes2);
            var alternate = fiber.alternate;
            if (alternate !== null) {
              alternate.lanes = mergeLanes(alternate.lanes, renderLanes2);
            }
            scheduleContextWorkOnParentPath(fiber.return, renderLanes2, propagationRoot);
          }
          function propagateSuspenseContextChange(workInProgress2, firstChild, renderLanes2) {
            var node = firstChild;
            while (node !== null) {
              if (node.tag === SuspenseComponent) {
                var state = node.memoizedState;
                if (state !== null) {
                  scheduleSuspenseWorkOnFiber(node, renderLanes2, workInProgress2);
                }
              } else if (node.tag === SuspenseListComponent) {
                scheduleSuspenseWorkOnFiber(node, renderLanes2, workInProgress2);
              } else if (node.child !== null) {
                node.child.return = node;
                node = node.child;
                continue;
              }
              if (node === workInProgress2) {
                return;
              }
              while (node.sibling === null) {
                if (node.return === null || node.return === workInProgress2) {
                  return;
                }
                node = node.return;
              }
              node.sibling.return = node.return;
              node = node.sibling;
            }
          }
          function findLastContentRow(firstChild) {
            var row = firstChild;
            var lastContentRow = null;
            while (row !== null) {
              var currentRow = row.alternate;
              if (currentRow !== null && findFirstSuspended(currentRow) === null) {
                lastContentRow = row;
              }
              row = row.sibling;
            }
            return lastContentRow;
          }
          function validateRevealOrder(revealOrder) {
            {
              if (revealOrder !== void 0 && revealOrder !== "forwards" && revealOrder !== "backwards" && revealOrder !== "together" && !didWarnAboutRevealOrder[revealOrder]) {
                didWarnAboutRevealOrder[revealOrder] = true;
                if (typeof revealOrder === "string") {
                  switch (revealOrder.toLowerCase()) {
                    case "together":
                    case "forwards":
                    case "backwards": {
                      error('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', revealOrder, revealOrder.toLowerCase());
                      break;
                    }
                    case "forward":
                    case "backward": {
                      error('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', revealOrder, revealOrder.toLowerCase());
                      break;
                    }
                    default:
                      error('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', revealOrder);
                      break;
                  }
                } else {
                  error('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', revealOrder);
                }
              }
            }
          }
          function validateTailOptions(tailMode, revealOrder) {
            {
              if (tailMode !== void 0 && !didWarnAboutTailOptions[tailMode]) {
                if (tailMode !== "collapsed" && tailMode !== "hidden") {
                  didWarnAboutTailOptions[tailMode] = true;
                  error('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', tailMode);
                } else if (revealOrder !== "forwards" && revealOrder !== "backwards") {
                  didWarnAboutTailOptions[tailMode] = true;
                  error('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', tailMode);
                }
              }
            }
          }
          function validateSuspenseListNestedChild(childSlot, index2) {
            {
              var isAnArray = isArray(childSlot);
              var isIterable = !isAnArray && typeof getIteratorFn(childSlot) === "function";
              if (isAnArray || isIterable) {
                var type = isAnArray ? "array" : "iterable";
                error("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", type, index2, type);
                return false;
              }
            }
            return true;
          }
          function validateSuspenseListChildren(children, revealOrder) {
            {
              if ((revealOrder === "forwards" || revealOrder === "backwards") && children !== void 0 && children !== null && children !== false) {
                if (isArray(children)) {
                  for (var i = 0; i < children.length; i++) {
                    if (!validateSuspenseListNestedChild(children[i], i)) {
                      return;
                    }
                  }
                } else {
                  var iteratorFn = getIteratorFn(children);
                  if (typeof iteratorFn === "function") {
                    var childrenIterator = iteratorFn.call(children);
                    if (childrenIterator) {
                      var step = childrenIterator.next();
                      var _i2 = 0;
                      for (; !step.done; step = childrenIterator.next()) {
                        if (!validateSuspenseListNestedChild(step.value, _i2)) {
                          return;
                        }
                        _i2++;
                      }
                    }
                  } else {
                    error('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', revealOrder);
                  }
                }
              }
            }
          }
          function initSuspenseListRenderState(workInProgress2, isBackwards, tail, lastContentRow, tailMode) {
            var renderState = workInProgress2.memoizedState;
            if (renderState === null) {
              workInProgress2.memoizedState = {
                isBackwards,
                rendering: null,
                renderingStartTime: 0,
                last: lastContentRow,
                tail,
                tailMode
              };
            } else {
              renderState.isBackwards = isBackwards;
              renderState.rendering = null;
              renderState.renderingStartTime = 0;
              renderState.last = lastContentRow;
              renderState.tail = tail;
              renderState.tailMode = tailMode;
            }
          }
          function updateSuspenseListComponent(current2, workInProgress2, renderLanes2) {
            var nextProps = workInProgress2.pendingProps;
            var revealOrder = nextProps.revealOrder;
            var tailMode = nextProps.tail;
            var newChildren = nextProps.children;
            validateRevealOrder(revealOrder);
            validateTailOptions(tailMode, revealOrder);
            validateSuspenseListChildren(newChildren, revealOrder);
            reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
            var suspenseContext = suspenseStackCursor.current;
            var shouldForceFallback = hasSuspenseContext(suspenseContext, ForceSuspenseFallback);
            if (shouldForceFallback) {
              suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);
              workInProgress2.flags |= DidCapture;
            } else {
              var didSuspendBefore = current2 !== null && (current2.flags & DidCapture) !== NoFlags;
              if (didSuspendBefore) {
                propagateSuspenseContextChange(workInProgress2, workInProgress2.child, renderLanes2);
              }
              suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
            }
            pushSuspenseContext(workInProgress2, suspenseContext);
            if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
              workInProgress2.memoizedState = null;
            } else {
              switch (revealOrder) {
                case "forwards": {
                  var lastContentRow = findLastContentRow(workInProgress2.child);
                  var tail;
                  if (lastContentRow === null) {
                    tail = workInProgress2.child;
                    workInProgress2.child = null;
                  } else {
                    tail = lastContentRow.sibling;
                    lastContentRow.sibling = null;
                  }
                  initSuspenseListRenderState(
                    workInProgress2,
                    false,
                    // isBackwards
                    tail,
                    lastContentRow,
                    tailMode
                  );
                  break;
                }
                case "backwards": {
                  var _tail = null;
                  var row = workInProgress2.child;
                  workInProgress2.child = null;
                  while (row !== null) {
                    var currentRow = row.alternate;
                    if (currentRow !== null && findFirstSuspended(currentRow) === null) {
                      workInProgress2.child = row;
                      break;
                    }
                    var nextRow = row.sibling;
                    row.sibling = _tail;
                    _tail = row;
                    row = nextRow;
                  }
                  initSuspenseListRenderState(
                    workInProgress2,
                    true,
                    // isBackwards
                    _tail,
                    null,
                    // last
                    tailMode
                  );
                  break;
                }
                case "together": {
                  initSuspenseListRenderState(
                    workInProgress2,
                    false,
                    // isBackwards
                    null,
                    // tail
                    null,
                    // last
                    void 0
                  );
                  break;
                }
                default: {
                  workInProgress2.memoizedState = null;
                }
              }
            }
            return workInProgress2.child;
          }
          function updatePortalComponent(current2, workInProgress2, renderLanes2) {
            pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
            var nextChildren = workInProgress2.pendingProps;
            if (current2 === null) {
              workInProgress2.child = reconcileChildFibers(workInProgress2, null, nextChildren, renderLanes2);
            } else {
              reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            }
            return workInProgress2.child;
          }
          var hasWarnedAboutUsingNoValuePropOnContextProvider = false;
          function updateContextProvider(current2, workInProgress2, renderLanes2) {
            var providerType = workInProgress2.type;
            var context3 = providerType._context;
            var newProps = workInProgress2.pendingProps;
            var oldProps = workInProgress2.memoizedProps;
            var newValue = newProps.value;
            {
              if (!("value" in newProps)) {
                if (!hasWarnedAboutUsingNoValuePropOnContextProvider) {
                  hasWarnedAboutUsingNoValuePropOnContextProvider = true;
                  error("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?");
                }
              }
              var providerPropTypes = workInProgress2.type.propTypes;
              if (providerPropTypes) {
                checkPropTypes(providerPropTypes, newProps, "prop", "Context.Provider");
              }
            }
            pushProvider(workInProgress2, context3, newValue);
            {
              if (oldProps !== null) {
                var oldValue = oldProps.value;
                if (objectIs(oldValue, newValue)) {
                  if (oldProps.children === newProps.children && !hasContextChanged()) {
                    return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
                  }
                } else {
                  propagateContextChange(workInProgress2, context3, renderLanes2);
                }
              }
            }
            var newChildren = newProps.children;
            reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
            return workInProgress2.child;
          }
          var hasWarnedAboutUsingContextAsConsumer = false;
          function updateContextConsumer(current2, workInProgress2, renderLanes2) {
            var context3 = workInProgress2.type;
            {
              if (context3._context === void 0) {
                if (context3 !== context3.Consumer) {
                  if (!hasWarnedAboutUsingContextAsConsumer) {
                    hasWarnedAboutUsingContextAsConsumer = true;
                    error("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                  }
                }
              } else {
                context3 = context3._context;
              }
            }
            var newProps = workInProgress2.pendingProps;
            var render5 = newProps.children;
            {
              if (typeof render5 !== "function") {
                error("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
              }
            }
            prepareToReadContext(workInProgress2, renderLanes2);
            var newValue = readContext(context3);
            {
              markComponentRenderStarted(workInProgress2);
            }
            var newChildren;
            {
              ReactCurrentOwner$1.current = workInProgress2;
              setIsRendering(true);
              newChildren = render5(newValue);
              setIsRendering(false);
            }
            {
              markComponentRenderStopped();
            }
            workInProgress2.flags |= PerformedWork;
            reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
            return workInProgress2.child;
          }
          function markWorkInProgressReceivedUpdate() {
            didReceiveUpdate = true;
          }
          function resetSuspendedCurrentOnMountInLegacyMode(current2, workInProgress2) {
            if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
              if (current2 !== null) {
                current2.alternate = null;
                workInProgress2.alternate = null;
                workInProgress2.flags |= Placement;
              }
            }
          }
          function bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2) {
            if (current2 !== null) {
              workInProgress2.dependencies = current2.dependencies;
            }
            {
              stopProfilerTimerIfRunning();
            }
            markSkippedUpdateLanes(workInProgress2.lanes);
            if (!includesSomeLane(renderLanes2, workInProgress2.childLanes)) {
              {
                return null;
              }
            }
            cloneChildFibers(current2, workInProgress2);
            return workInProgress2.child;
          }
          function remountFiber(current2, oldWorkInProgress, newWorkInProgress) {
            {
              var returnFiber = oldWorkInProgress.return;
              if (returnFiber === null) {
                throw new Error("Cannot swap the root fiber.");
              }
              current2.alternate = null;
              oldWorkInProgress.alternate = null;
              newWorkInProgress.index = oldWorkInProgress.index;
              newWorkInProgress.sibling = oldWorkInProgress.sibling;
              newWorkInProgress.return = oldWorkInProgress.return;
              newWorkInProgress.ref = oldWorkInProgress.ref;
              if (oldWorkInProgress === returnFiber.child) {
                returnFiber.child = newWorkInProgress;
              } else {
                var prevSibling = returnFiber.child;
                if (prevSibling === null) {
                  throw new Error("Expected parent to have a child.");
                }
                while (prevSibling.sibling !== oldWorkInProgress) {
                  prevSibling = prevSibling.sibling;
                  if (prevSibling === null) {
                    throw new Error("Expected to find the previous sibling.");
                  }
                }
                prevSibling.sibling = newWorkInProgress;
              }
              var deletions = returnFiber.deletions;
              if (deletions === null) {
                returnFiber.deletions = [current2];
                returnFiber.flags |= ChildDeletion;
              } else {
                deletions.push(current2);
              }
              newWorkInProgress.flags |= Placement;
              return newWorkInProgress;
            }
          }
          function checkScheduledUpdateOrContext(current2, renderLanes2) {
            var updateLanes = current2.lanes;
            if (includesSomeLane(updateLanes, renderLanes2)) {
              return true;
            }
            return false;
          }
          function attemptEarlyBailoutIfNoScheduledUpdate(current2, workInProgress2, renderLanes2) {
            switch (workInProgress2.tag) {
              case HostRoot:
                pushHostRootContext(workInProgress2);
                var root3 = workInProgress2.stateNode;
                resetHydrationState();
                break;
              case HostComponent:
                pushHostContext(workInProgress2);
                break;
              case ClassComponent: {
                var Component3 = workInProgress2.type;
                if (isContextProvider(Component3)) {
                  pushContextProvider(workInProgress2);
                }
                break;
              }
              case HostPortal:
                pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
                break;
              case ContextProvider: {
                var newValue = workInProgress2.memoizedProps.value;
                var context3 = workInProgress2.type._context;
                pushProvider(workInProgress2, context3, newValue);
                break;
              }
              case Profiler:
                {
                  var hasChildWork = includesSomeLane(renderLanes2, workInProgress2.childLanes);
                  if (hasChildWork) {
                    workInProgress2.flags |= Update;
                  }
                  {
                    var stateNode = workInProgress2.stateNode;
                    stateNode.effectDuration = 0;
                    stateNode.passiveEffectDuration = 0;
                  }
                }
                break;
              case SuspenseComponent: {
                var state = workInProgress2.memoizedState;
                if (state !== null) {
                  if (state.dehydrated !== null) {
                    pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
                    workInProgress2.flags |= DidCapture;
                    return null;
                  }
                  var primaryChildFragment = workInProgress2.child;
                  var primaryChildLanes = primaryChildFragment.childLanes;
                  if (includesSomeLane(renderLanes2, primaryChildLanes)) {
                    return updateSuspenseComponent(current2, workInProgress2, renderLanes2);
                  } else {
                    pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
                    var child = bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
                    if (child !== null) {
                      return child.sibling;
                    } else {
                      return null;
                    }
                  }
                } else {
                  pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
                }
                break;
              }
              case SuspenseListComponent: {
                var didSuspendBefore = (current2.flags & DidCapture) !== NoFlags;
                var _hasChildWork = includesSomeLane(renderLanes2, workInProgress2.childLanes);
                if (didSuspendBefore) {
                  if (_hasChildWork) {
                    return updateSuspenseListComponent(current2, workInProgress2, renderLanes2);
                  }
                  workInProgress2.flags |= DidCapture;
                }
                var renderState = workInProgress2.memoizedState;
                if (renderState !== null) {
                  renderState.rendering = null;
                  renderState.tail = null;
                  renderState.lastEffect = null;
                }
                pushSuspenseContext(workInProgress2, suspenseStackCursor.current);
                if (_hasChildWork) {
                  break;
                } else {
                  return null;
                }
              }
              case OffscreenComponent:
              case LegacyHiddenComponent: {
                workInProgress2.lanes = NoLanes;
                return updateOffscreenComponent(current2, workInProgress2, renderLanes2);
              }
            }
            return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
          }
          function beginWork(current2, workInProgress2, renderLanes2) {
            {
              if (workInProgress2._debugNeedsRemount && current2 !== null) {
                return remountFiber(current2, workInProgress2, createFiberFromTypeAndProps(workInProgress2.type, workInProgress2.key, workInProgress2.pendingProps, workInProgress2._debugOwner || null, workInProgress2.mode, workInProgress2.lanes));
              }
            }
            if (current2 !== null) {
              var oldProps = current2.memoizedProps;
              var newProps = workInProgress2.pendingProps;
              if (oldProps !== newProps || hasContextChanged() || // Force a re-render if the implementation changed due to hot reload:
              workInProgress2.type !== current2.type) {
                didReceiveUpdate = true;
              } else {
                var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current2, renderLanes2);
                if (!hasScheduledUpdateOrContext && // If this is the second pass of an error or suspense boundary, there
                // may not be work scheduled on `current`, so we check for this flag.
                (workInProgress2.flags & DidCapture) === NoFlags) {
                  didReceiveUpdate = false;
                  return attemptEarlyBailoutIfNoScheduledUpdate(current2, workInProgress2, renderLanes2);
                }
                if ((current2.flags & ForceUpdateForLegacySuspense) !== NoFlags) {
                  didReceiveUpdate = true;
                } else {
                  didReceiveUpdate = false;
                }
              }
            } else {
              didReceiveUpdate = false;
              if (getIsHydrating() && isForkedChild(workInProgress2)) {
                var slotIndex = workInProgress2.index;
                var numberOfForks = getForksAtLevel();
                pushTreeId(workInProgress2, numberOfForks, slotIndex);
              }
            }
            workInProgress2.lanes = NoLanes;
            switch (workInProgress2.tag) {
              case IndeterminateComponent: {
                return mountIndeterminateComponent(current2, workInProgress2, workInProgress2.type, renderLanes2);
              }
              case LazyComponent: {
                var elementType = workInProgress2.elementType;
                return mountLazyComponent(current2, workInProgress2, elementType, renderLanes2);
              }
              case FunctionComponent: {
                var Component3 = workInProgress2.type;
                var unresolvedProps = workInProgress2.pendingProps;
                var resolvedProps = workInProgress2.elementType === Component3 ? unresolvedProps : resolveDefaultProps(Component3, unresolvedProps);
                return updateFunctionComponent(current2, workInProgress2, Component3, resolvedProps, renderLanes2);
              }
              case ClassComponent: {
                var _Component = workInProgress2.type;
                var _unresolvedProps = workInProgress2.pendingProps;
                var _resolvedProps = workInProgress2.elementType === _Component ? _unresolvedProps : resolveDefaultProps(_Component, _unresolvedProps);
                return updateClassComponent(current2, workInProgress2, _Component, _resolvedProps, renderLanes2);
              }
              case HostRoot:
                return updateHostRoot(current2, workInProgress2, renderLanes2);
              case HostComponent:
                return updateHostComponent(current2, workInProgress2, renderLanes2);
              case HostText:
                return updateHostText(current2, workInProgress2);
              case SuspenseComponent:
                return updateSuspenseComponent(current2, workInProgress2, renderLanes2);
              case HostPortal:
                return updatePortalComponent(current2, workInProgress2, renderLanes2);
              case ForwardRef: {
                var type = workInProgress2.type;
                var _unresolvedProps2 = workInProgress2.pendingProps;
                var _resolvedProps2 = workInProgress2.elementType === type ? _unresolvedProps2 : resolveDefaultProps(type, _unresolvedProps2);
                return updateForwardRef(current2, workInProgress2, type, _resolvedProps2, renderLanes2);
              }
              case Fragment7:
                return updateFragment(current2, workInProgress2, renderLanes2);
              case Mode:
                return updateMode(current2, workInProgress2, renderLanes2);
              case Profiler:
                return updateProfiler(current2, workInProgress2, renderLanes2);
              case ContextProvider:
                return updateContextProvider(current2, workInProgress2, renderLanes2);
              case ContextConsumer:
                return updateContextConsumer(current2, workInProgress2, renderLanes2);
              case MemoComponent: {
                var _type2 = workInProgress2.type;
                var _unresolvedProps3 = workInProgress2.pendingProps;
                var _resolvedProps3 = resolveDefaultProps(_type2, _unresolvedProps3);
                {
                  if (workInProgress2.type !== workInProgress2.elementType) {
                    var outerPropTypes = _type2.propTypes;
                    if (outerPropTypes) {
                      checkPropTypes(
                        outerPropTypes,
                        _resolvedProps3,
                        // Resolved for outer only
                        "prop",
                        getComponentNameFromType(_type2)
                      );
                    }
                  }
                }
                _resolvedProps3 = resolveDefaultProps(_type2.type, _resolvedProps3);
                return updateMemoComponent(current2, workInProgress2, _type2, _resolvedProps3, renderLanes2);
              }
              case SimpleMemoComponent: {
                return updateSimpleMemoComponent(current2, workInProgress2, workInProgress2.type, workInProgress2.pendingProps, renderLanes2);
              }
              case IncompleteClassComponent: {
                var _Component2 = workInProgress2.type;
                var _unresolvedProps4 = workInProgress2.pendingProps;
                var _resolvedProps4 = workInProgress2.elementType === _Component2 ? _unresolvedProps4 : resolveDefaultProps(_Component2, _unresolvedProps4);
                return mountIncompleteClassComponent(current2, workInProgress2, _Component2, _resolvedProps4, renderLanes2);
              }
              case SuspenseListComponent: {
                return updateSuspenseListComponent(current2, workInProgress2, renderLanes2);
              }
              case ScopeComponent: {
                break;
              }
              case OffscreenComponent: {
                return updateOffscreenComponent(current2, workInProgress2, renderLanes2);
              }
            }
            throw new Error("Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue.");
          }
          function markUpdate(workInProgress2) {
            workInProgress2.flags |= Update;
          }
          function markRef$1(workInProgress2) {
            workInProgress2.flags |= Ref;
            {
              workInProgress2.flags |= RefStatic;
            }
          }
          var appendAllChildren;
          var updateHostContainer;
          var updateHostComponent$1;
          var updateHostText$1;
          {
            appendAllChildren = function(parent, workInProgress2, needsVisibilityToggle, isHidden) {
              var node = workInProgress2.child;
              while (node !== null) {
                if (node.tag === HostComponent || node.tag === HostText) {
                  appendInitialChild(parent, node.stateNode);
                } else if (node.tag === HostPortal) ;
                else if (node.child !== null) {
                  node.child.return = node;
                  node = node.child;
                  continue;
                }
                if (node === workInProgress2) {
                  return;
                }
                while (node.sibling === null) {
                  if (node.return === null || node.return === workInProgress2) {
                    return;
                  }
                  node = node.return;
                }
                node.sibling.return = node.return;
                node = node.sibling;
              }
            };
            updateHostContainer = function(current2, workInProgress2) {
            };
            updateHostComponent$1 = function(current2, workInProgress2, type, newProps, rootContainerInstance) {
              var oldProps = current2.memoizedProps;
              if (oldProps === newProps) {
                return;
              }
              var instance = workInProgress2.stateNode;
              var currentHostContext = getHostContext();
              var updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext);
              workInProgress2.updateQueue = updatePayload;
              if (updatePayload) {
                markUpdate(workInProgress2);
              }
            };
            updateHostText$1 = function(current2, workInProgress2, oldText, newText) {
              if (oldText !== newText) {
                markUpdate(workInProgress2);
              }
            };
          }
          function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
            if (getIsHydrating()) {
              return;
            }
            switch (renderState.tailMode) {
              case "hidden": {
                var tailNode = renderState.tail;
                var lastTailNode = null;
                while (tailNode !== null) {
                  if (tailNode.alternate !== null) {
                    lastTailNode = tailNode;
                  }
                  tailNode = tailNode.sibling;
                }
                if (lastTailNode === null) {
                  renderState.tail = null;
                } else {
                  lastTailNode.sibling = null;
                }
                break;
              }
              case "collapsed": {
                var _tailNode = renderState.tail;
                var _lastTailNode = null;
                while (_tailNode !== null) {
                  if (_tailNode.alternate !== null) {
                    _lastTailNode = _tailNode;
                  }
                  _tailNode = _tailNode.sibling;
                }
                if (_lastTailNode === null) {
                  if (!hasRenderedATailFallback && renderState.tail !== null) {
                    renderState.tail.sibling = null;
                  } else {
                    renderState.tail = null;
                  }
                } else {
                  _lastTailNode.sibling = null;
                }
                break;
              }
            }
          }
          function bubbleProperties(completedWork) {
            var didBailout = completedWork.alternate !== null && completedWork.alternate.child === completedWork.child;
            var newChildLanes = NoLanes;
            var subtreeFlags = NoFlags;
            if (!didBailout) {
              if ((completedWork.mode & ProfileMode) !== NoMode) {
                var actualDuration = completedWork.actualDuration;
                var treeBaseDuration = completedWork.selfBaseDuration;
                var child = completedWork.child;
                while (child !== null) {
                  newChildLanes = mergeLanes(newChildLanes, mergeLanes(child.lanes, child.childLanes));
                  subtreeFlags |= child.subtreeFlags;
                  subtreeFlags |= child.flags;
                  actualDuration += child.actualDuration;
                  treeBaseDuration += child.treeBaseDuration;
                  child = child.sibling;
                }
                completedWork.actualDuration = actualDuration;
                completedWork.treeBaseDuration = treeBaseDuration;
              } else {
                var _child = completedWork.child;
                while (_child !== null) {
                  newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child.lanes, _child.childLanes));
                  subtreeFlags |= _child.subtreeFlags;
                  subtreeFlags |= _child.flags;
                  _child.return = completedWork;
                  _child = _child.sibling;
                }
              }
              completedWork.subtreeFlags |= subtreeFlags;
            } else {
              if ((completedWork.mode & ProfileMode) !== NoMode) {
                var _treeBaseDuration = completedWork.selfBaseDuration;
                var _child2 = completedWork.child;
                while (_child2 !== null) {
                  newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child2.lanes, _child2.childLanes));
                  subtreeFlags |= _child2.subtreeFlags & StaticMask;
                  subtreeFlags |= _child2.flags & StaticMask;
                  _treeBaseDuration += _child2.treeBaseDuration;
                  _child2 = _child2.sibling;
                }
                completedWork.treeBaseDuration = _treeBaseDuration;
              } else {
                var _child3 = completedWork.child;
                while (_child3 !== null) {
                  newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child3.lanes, _child3.childLanes));
                  subtreeFlags |= _child3.subtreeFlags & StaticMask;
                  subtreeFlags |= _child3.flags & StaticMask;
                  _child3.return = completedWork;
                  _child3 = _child3.sibling;
                }
              }
              completedWork.subtreeFlags |= subtreeFlags;
            }
            completedWork.childLanes = newChildLanes;
            return didBailout;
          }
          function completeDehydratedSuspenseBoundary(current2, workInProgress2, nextState) {
            if (hasUnhydratedTailNodes() && (workInProgress2.mode & ConcurrentMode) !== NoMode && (workInProgress2.flags & DidCapture) === NoFlags) {
              warnIfUnhydratedTailNodes(workInProgress2);
              resetHydrationState();
              workInProgress2.flags |= ForceClientRender | Incomplete | ShouldCapture;
              return false;
            }
            var wasHydrated = popHydrationState(workInProgress2);
            if (nextState !== null && nextState.dehydrated !== null) {
              if (current2 === null) {
                if (!wasHydrated) {
                  throw new Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
                }
                prepareToHydrateHostSuspenseInstance(workInProgress2);
                bubbleProperties(workInProgress2);
                {
                  if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                    var isTimedOutSuspense = nextState !== null;
                    if (isTimedOutSuspense) {
                      var primaryChildFragment = workInProgress2.child;
                      if (primaryChildFragment !== null) {
                        workInProgress2.treeBaseDuration -= primaryChildFragment.treeBaseDuration;
                      }
                    }
                  }
                }
                return false;
              } else {
                resetHydrationState();
                if ((workInProgress2.flags & DidCapture) === NoFlags) {
                  workInProgress2.memoizedState = null;
                }
                workInProgress2.flags |= Update;
                bubbleProperties(workInProgress2);
                {
                  if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                    var _isTimedOutSuspense = nextState !== null;
                    if (_isTimedOutSuspense) {
                      var _primaryChildFragment = workInProgress2.child;
                      if (_primaryChildFragment !== null) {
                        workInProgress2.treeBaseDuration -= _primaryChildFragment.treeBaseDuration;
                      }
                    }
                  }
                }
                return false;
              }
            } else {
              upgradeHydrationErrorsToRecoverable();
              return true;
            }
          }
          function completeWork(current2, workInProgress2, renderLanes2) {
            var newProps = workInProgress2.pendingProps;
            popTreeContext(workInProgress2);
            switch (workInProgress2.tag) {
              case IndeterminateComponent:
              case LazyComponent:
              case SimpleMemoComponent:
              case FunctionComponent:
              case ForwardRef:
              case Fragment7:
              case Mode:
              case Profiler:
              case ContextConsumer:
              case MemoComponent:
                bubbleProperties(workInProgress2);
                return null;
              case ClassComponent: {
                var Component3 = workInProgress2.type;
                if (isContextProvider(Component3)) {
                  popContext(workInProgress2);
                }
                bubbleProperties(workInProgress2);
                return null;
              }
              case HostRoot: {
                var fiberRoot = workInProgress2.stateNode;
                popHostContainer(workInProgress2);
                popTopLevelContextObject(workInProgress2);
                resetWorkInProgressVersions();
                if (fiberRoot.pendingContext) {
                  fiberRoot.context = fiberRoot.pendingContext;
                  fiberRoot.pendingContext = null;
                }
                if (current2 === null || current2.child === null) {
                  var wasHydrated = popHydrationState(workInProgress2);
                  if (wasHydrated) {
                    markUpdate(workInProgress2);
                  } else {
                    if (current2 !== null) {
                      var prevState = current2.memoizedState;
                      if (
                        // Check if this is a client root
                        !prevState.isDehydrated || // Check if we reverted to client rendering (e.g. due to an error)
                        (workInProgress2.flags & ForceClientRender) !== NoFlags
                      ) {
                        workInProgress2.flags |= Snapshot;
                        upgradeHydrationErrorsToRecoverable();
                      }
                    }
                  }
                }
                updateHostContainer(current2, workInProgress2);
                bubbleProperties(workInProgress2);
                return null;
              }
              case HostComponent: {
                popHostContext(workInProgress2);
                var rootContainerInstance = getRootHostContainer();
                var type = workInProgress2.type;
                if (current2 !== null && workInProgress2.stateNode != null) {
                  updateHostComponent$1(current2, workInProgress2, type, newProps, rootContainerInstance);
                  if (current2.ref !== workInProgress2.ref) {
                    markRef$1(workInProgress2);
                  }
                } else {
                  if (!newProps) {
                    if (workInProgress2.stateNode === null) {
                      throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
                    }
                    bubbleProperties(workInProgress2);
                    return null;
                  }
                  var currentHostContext = getHostContext();
                  var _wasHydrated = popHydrationState(workInProgress2);
                  if (_wasHydrated) {
                    if (prepareToHydrateHostInstance(workInProgress2, rootContainerInstance, currentHostContext)) {
                      markUpdate(workInProgress2);
                    }
                  } else {
                    var instance = createInstance(type, newProps, rootContainerInstance, currentHostContext, workInProgress2);
                    appendAllChildren(instance, workInProgress2, false, false);
                    workInProgress2.stateNode = instance;
                    if (finalizeInitialChildren(instance, type, newProps, rootContainerInstance)) {
                      markUpdate(workInProgress2);
                    }
                  }
                  if (workInProgress2.ref !== null) {
                    markRef$1(workInProgress2);
                  }
                }
                bubbleProperties(workInProgress2);
                return null;
              }
              case HostText: {
                var newText = newProps;
                if (current2 && workInProgress2.stateNode != null) {
                  var oldText = current2.memoizedProps;
                  updateHostText$1(current2, workInProgress2, oldText, newText);
                } else {
                  if (typeof newText !== "string") {
                    if (workInProgress2.stateNode === null) {
                      throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
                    }
                  }
                  var _rootContainerInstance = getRootHostContainer();
                  var _currentHostContext = getHostContext();
                  var _wasHydrated2 = popHydrationState(workInProgress2);
                  if (_wasHydrated2) {
                    if (prepareToHydrateHostTextInstance(workInProgress2)) {
                      markUpdate(workInProgress2);
                    }
                  } else {
                    workInProgress2.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext, workInProgress2);
                  }
                }
                bubbleProperties(workInProgress2);
                return null;
              }
              case SuspenseComponent: {
                popSuspenseContext(workInProgress2);
                var nextState = workInProgress2.memoizedState;
                if (current2 === null || current2.memoizedState !== null && current2.memoizedState.dehydrated !== null) {
                  var fallthroughToNormalSuspensePath = completeDehydratedSuspenseBoundary(current2, workInProgress2, nextState);
                  if (!fallthroughToNormalSuspensePath) {
                    if (workInProgress2.flags & ShouldCapture) {
                      return workInProgress2;
                    } else {
                      return null;
                    }
                  }
                }
                if ((workInProgress2.flags & DidCapture) !== NoFlags) {
                  workInProgress2.lanes = renderLanes2;
                  if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                    transferActualDuration(workInProgress2);
                  }
                  return workInProgress2;
                }
                var nextDidTimeout = nextState !== null;
                var prevDidTimeout = current2 !== null && current2.memoizedState !== null;
                if (nextDidTimeout !== prevDidTimeout) {
                  if (nextDidTimeout) {
                    var _offscreenFiber2 = workInProgress2.child;
                    _offscreenFiber2.flags |= Visibility;
                    if ((workInProgress2.mode & ConcurrentMode) !== NoMode) {
                      var hasInvisibleChildContext = current2 === null && (workInProgress2.memoizedProps.unstable_avoidThisFallback !== true || !enableSuspenseAvoidThisFallback);
                      if (hasInvisibleChildContext || hasSuspenseContext(suspenseStackCursor.current, InvisibleParentSuspenseContext)) {
                        renderDidSuspend();
                      } else {
                        renderDidSuspendDelayIfPossible();
                      }
                    }
                  }
                }
                var wakeables = workInProgress2.updateQueue;
                if (wakeables !== null) {
                  workInProgress2.flags |= Update;
                }
                bubbleProperties(workInProgress2);
                {
                  if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                    if (nextDidTimeout) {
                      var primaryChildFragment = workInProgress2.child;
                      if (primaryChildFragment !== null) {
                        workInProgress2.treeBaseDuration -= primaryChildFragment.treeBaseDuration;
                      }
                    }
                  }
                }
                return null;
              }
              case HostPortal:
                popHostContainer(workInProgress2);
                updateHostContainer(current2, workInProgress2);
                if (current2 === null) {
                  preparePortalMount(workInProgress2.stateNode.containerInfo);
                }
                bubbleProperties(workInProgress2);
                return null;
              case ContextProvider:
                var context3 = workInProgress2.type._context;
                popProvider(context3, workInProgress2);
                bubbleProperties(workInProgress2);
                return null;
              case IncompleteClassComponent: {
                var _Component = workInProgress2.type;
                if (isContextProvider(_Component)) {
                  popContext(workInProgress2);
                }
                bubbleProperties(workInProgress2);
                return null;
              }
              case SuspenseListComponent: {
                popSuspenseContext(workInProgress2);
                var renderState = workInProgress2.memoizedState;
                if (renderState === null) {
                  bubbleProperties(workInProgress2);
                  return null;
                }
                var didSuspendAlready = (workInProgress2.flags & DidCapture) !== NoFlags;
                var renderedTail = renderState.rendering;
                if (renderedTail === null) {
                  if (!didSuspendAlready) {
                    var cannotBeSuspended = renderHasNotSuspendedYet() && (current2 === null || (current2.flags & DidCapture) === NoFlags);
                    if (!cannotBeSuspended) {
                      var row = workInProgress2.child;
                      while (row !== null) {
                        var suspended = findFirstSuspended(row);
                        if (suspended !== null) {
                          didSuspendAlready = true;
                          workInProgress2.flags |= DidCapture;
                          cutOffTailIfNeeded(renderState, false);
                          var newThenables = suspended.updateQueue;
                          if (newThenables !== null) {
                            workInProgress2.updateQueue = newThenables;
                            workInProgress2.flags |= Update;
                          }
                          workInProgress2.subtreeFlags = NoFlags;
                          resetChildFibers(workInProgress2, renderLanes2);
                          pushSuspenseContext(workInProgress2, setShallowSuspenseContext(suspenseStackCursor.current, ForceSuspenseFallback));
                          return workInProgress2.child;
                        }
                        row = row.sibling;
                      }
                    }
                    if (renderState.tail !== null && now3() > getRenderTargetTime()) {
                      workInProgress2.flags |= DidCapture;
                      didSuspendAlready = true;
                      cutOffTailIfNeeded(renderState, false);
                      workInProgress2.lanes = SomeRetryLane;
                    }
                  } else {
                    cutOffTailIfNeeded(renderState, false);
                  }
                } else {
                  if (!didSuspendAlready) {
                    var _suspended = findFirstSuspended(renderedTail);
                    if (_suspended !== null) {
                      workInProgress2.flags |= DidCapture;
                      didSuspendAlready = true;
                      var _newThenables = _suspended.updateQueue;
                      if (_newThenables !== null) {
                        workInProgress2.updateQueue = _newThenables;
                        workInProgress2.flags |= Update;
                      }
                      cutOffTailIfNeeded(renderState, true);
                      if (renderState.tail === null && renderState.tailMode === "hidden" && !renderedTail.alternate && !getIsHydrating()) {
                        bubbleProperties(workInProgress2);
                        return null;
                      }
                    } else if (
                      // The time it took to render last row is greater than the remaining
                      // time we have to render. So rendering one more row would likely
                      // exceed it.
                      now3() * 2 - renderState.renderingStartTime > getRenderTargetTime() && renderLanes2 !== OffscreenLane
                    ) {
                      workInProgress2.flags |= DidCapture;
                      didSuspendAlready = true;
                      cutOffTailIfNeeded(renderState, false);
                      workInProgress2.lanes = SomeRetryLane;
                    }
                  }
                  if (renderState.isBackwards) {
                    renderedTail.sibling = workInProgress2.child;
                    workInProgress2.child = renderedTail;
                  } else {
                    var previousSibling = renderState.last;
                    if (previousSibling !== null) {
                      previousSibling.sibling = renderedTail;
                    } else {
                      workInProgress2.child = renderedTail;
                    }
                    renderState.last = renderedTail;
                  }
                }
                if (renderState.tail !== null) {
                  var next = renderState.tail;
                  renderState.rendering = next;
                  renderState.tail = next.sibling;
                  renderState.renderingStartTime = now3();
                  next.sibling = null;
                  var suspenseContext = suspenseStackCursor.current;
                  if (didSuspendAlready) {
                    suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);
                  } else {
                    suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
                  }
                  pushSuspenseContext(workInProgress2, suspenseContext);
                  return next;
                }
                bubbleProperties(workInProgress2);
                return null;
              }
              case ScopeComponent: {
                break;
              }
              case OffscreenComponent:
              case LegacyHiddenComponent: {
                popRenderLanes(workInProgress2);
                var _nextState = workInProgress2.memoizedState;
                var nextIsHidden = _nextState !== null;
                if (current2 !== null) {
                  var _prevState = current2.memoizedState;
                  var prevIsHidden = _prevState !== null;
                  if (prevIsHidden !== nextIsHidden && // LegacyHidden doesn't do any hiding  it only pre-renders.
                  !enableLegacyHidden) {
                    workInProgress2.flags |= Visibility;
                  }
                }
                if (!nextIsHidden || (workInProgress2.mode & ConcurrentMode) === NoMode) {
                  bubbleProperties(workInProgress2);
                } else {
                  if (includesSomeLane(subtreeRenderLanes, OffscreenLane)) {
                    bubbleProperties(workInProgress2);
                    {
                      if (workInProgress2.subtreeFlags & (Placement | Update)) {
                        workInProgress2.flags |= Visibility;
                      }
                    }
                  }
                }
                return null;
              }
              case CacheComponent: {
                return null;
              }
              case TracingMarkerComponent: {
                return null;
              }
            }
            throw new Error("Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue.");
          }
          function unwindWork(current2, workInProgress2, renderLanes2) {
            popTreeContext(workInProgress2);
            switch (workInProgress2.tag) {
              case ClassComponent: {
                var Component3 = workInProgress2.type;
                if (isContextProvider(Component3)) {
                  popContext(workInProgress2);
                }
                var flags = workInProgress2.flags;
                if (flags & ShouldCapture) {
                  workInProgress2.flags = flags & ~ShouldCapture | DidCapture;
                  if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                    transferActualDuration(workInProgress2);
                  }
                  return workInProgress2;
                }
                return null;
              }
              case HostRoot: {
                var root3 = workInProgress2.stateNode;
                popHostContainer(workInProgress2);
                popTopLevelContextObject(workInProgress2);
                resetWorkInProgressVersions();
                var _flags = workInProgress2.flags;
                if ((_flags & ShouldCapture) !== NoFlags && (_flags & DidCapture) === NoFlags) {
                  workInProgress2.flags = _flags & ~ShouldCapture | DidCapture;
                  return workInProgress2;
                }
                return null;
              }
              case HostComponent: {
                popHostContext(workInProgress2);
                return null;
              }
              case SuspenseComponent: {
                popSuspenseContext(workInProgress2);
                var suspenseState = workInProgress2.memoizedState;
                if (suspenseState !== null && suspenseState.dehydrated !== null) {
                  if (workInProgress2.alternate === null) {
                    throw new Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
                  }
                  resetHydrationState();
                }
                var _flags2 = workInProgress2.flags;
                if (_flags2 & ShouldCapture) {
                  workInProgress2.flags = _flags2 & ~ShouldCapture | DidCapture;
                  if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                    transferActualDuration(workInProgress2);
                  }
                  return workInProgress2;
                }
                return null;
              }
              case SuspenseListComponent: {
                popSuspenseContext(workInProgress2);
                return null;
              }
              case HostPortal:
                popHostContainer(workInProgress2);
                return null;
              case ContextProvider:
                var context3 = workInProgress2.type._context;
                popProvider(context3, workInProgress2);
                return null;
              case OffscreenComponent:
              case LegacyHiddenComponent:
                popRenderLanes(workInProgress2);
                return null;
              case CacheComponent:
                return null;
              default:
                return null;
            }
          }
          function unwindInterruptedWork(current2, interruptedWork, renderLanes2) {
            popTreeContext(interruptedWork);
            switch (interruptedWork.tag) {
              case ClassComponent: {
                var childContextTypes = interruptedWork.type.childContextTypes;
                if (childContextTypes !== null && childContextTypes !== void 0) {
                  popContext(interruptedWork);
                }
                break;
              }
              case HostRoot: {
                var root3 = interruptedWork.stateNode;
                popHostContainer(interruptedWork);
                popTopLevelContextObject(interruptedWork);
                resetWorkInProgressVersions();
                break;
              }
              case HostComponent: {
                popHostContext(interruptedWork);
                break;
              }
              case HostPortal:
                popHostContainer(interruptedWork);
                break;
              case SuspenseComponent:
                popSuspenseContext(interruptedWork);
                break;
              case SuspenseListComponent:
                popSuspenseContext(interruptedWork);
                break;
              case ContextProvider:
                var context3 = interruptedWork.type._context;
                popProvider(context3, interruptedWork);
                break;
              case OffscreenComponent:
              case LegacyHiddenComponent:
                popRenderLanes(interruptedWork);
                break;
            }
          }
          var didWarnAboutUndefinedSnapshotBeforeUpdate = null;
          {
            didWarnAboutUndefinedSnapshotBeforeUpdate = /* @__PURE__ */ new Set();
          }
          var offscreenSubtreeIsHidden = false;
          var offscreenSubtreeWasHidden = false;
          var PossiblyWeakSet = typeof WeakSet === "function" ? WeakSet : Set;
          var nextEffect = null;
          var inProgressLanes = null;
          var inProgressRoot = null;
          function reportUncaughtErrorInDEV(error2) {
            {
              invokeGuardedCallback(null, function() {
                throw error2;
              });
              clearCaughtError();
            }
          }
          var callComponentWillUnmountWithTimer = function(current2, instance) {
            instance.props = current2.memoizedProps;
            instance.state = current2.memoizedState;
            if (current2.mode & ProfileMode) {
              try {
                startLayoutEffectTimer();
                instance.componentWillUnmount();
              } finally {
                recordLayoutEffectDuration(current2);
              }
            } else {
              instance.componentWillUnmount();
            }
          };
          function safelyCallCommitHookLayoutEffectListMount(current2, nearestMountedAncestor) {
            try {
              commitHookEffectListMount(Layout, current2);
            } catch (error2) {
              captureCommitPhaseError(current2, nearestMountedAncestor, error2);
            }
          }
          function safelyCallComponentWillUnmount(current2, nearestMountedAncestor, instance) {
            try {
              callComponentWillUnmountWithTimer(current2, instance);
            } catch (error2) {
              captureCommitPhaseError(current2, nearestMountedAncestor, error2);
            }
          }
          function safelyCallComponentDidMount(current2, nearestMountedAncestor, instance) {
            try {
              instance.componentDidMount();
            } catch (error2) {
              captureCommitPhaseError(current2, nearestMountedAncestor, error2);
            }
          }
          function safelyAttachRef(current2, nearestMountedAncestor) {
            try {
              commitAttachRef(current2);
            } catch (error2) {
              captureCommitPhaseError(current2, nearestMountedAncestor, error2);
            }
          }
          function safelyDetachRef(current2, nearestMountedAncestor) {
            var ref2 = current2.ref;
            if (ref2 !== null) {
              if (typeof ref2 === "function") {
                var retVal;
                try {
                  if (enableProfilerTimer && enableProfilerCommitHooks && current2.mode & ProfileMode) {
                    try {
                      startLayoutEffectTimer();
                      retVal = ref2(null);
                    } finally {
                      recordLayoutEffectDuration(current2);
                    }
                  } else {
                    retVal = ref2(null);
                  }
                } catch (error2) {
                  captureCommitPhaseError(current2, nearestMountedAncestor, error2);
                }
                {
                  if (typeof retVal === "function") {
                    error("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", getComponentNameFromFiber(current2));
                  }
                }
              } else {
                ref2.current = null;
              }
            }
          }
          function safelyCallDestroy(current2, nearestMountedAncestor, destroy) {
            try {
              destroy();
            } catch (error2) {
              captureCommitPhaseError(current2, nearestMountedAncestor, error2);
            }
          }
          var focusedInstanceHandle = null;
          var shouldFireAfterActiveInstanceBlur = false;
          function commitBeforeMutationEffects(root3, firstChild) {
            focusedInstanceHandle = prepareForCommit(root3.containerInfo);
            nextEffect = firstChild;
            commitBeforeMutationEffects_begin();
            var shouldFire = shouldFireAfterActiveInstanceBlur;
            shouldFireAfterActiveInstanceBlur = false;
            focusedInstanceHandle = null;
            return shouldFire;
          }
          function commitBeforeMutationEffects_begin() {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              var child = fiber.child;
              if ((fiber.subtreeFlags & BeforeMutationMask) !== NoFlags && child !== null) {
                child.return = fiber;
                nextEffect = child;
              } else {
                commitBeforeMutationEffects_complete();
              }
            }
          }
          function commitBeforeMutationEffects_complete() {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              setCurrentFiber(fiber);
              try {
                commitBeforeMutationEffectsOnFiber(fiber);
              } catch (error2) {
                captureCommitPhaseError(fiber, fiber.return, error2);
              }
              resetCurrentFiber();
              var sibling = fiber.sibling;
              if (sibling !== null) {
                sibling.return = fiber.return;
                nextEffect = sibling;
                return;
              }
              nextEffect = fiber.return;
            }
          }
          function commitBeforeMutationEffectsOnFiber(finishedWork) {
            var current2 = finishedWork.alternate;
            var flags = finishedWork.flags;
            if ((flags & Snapshot) !== NoFlags) {
              setCurrentFiber(finishedWork);
              switch (finishedWork.tag) {
                case FunctionComponent:
                case ForwardRef:
                case SimpleMemoComponent: {
                  break;
                }
                case ClassComponent: {
                  if (current2 !== null) {
                    var prevProps = current2.memoizedProps;
                    var prevState = current2.memoizedState;
                    var instance = finishedWork.stateNode;
                    {
                      if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                        if (instance.props !== finishedWork.memoizedProps) {
                          error("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                        }
                        if (instance.state !== finishedWork.memoizedState) {
                          error("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                        }
                      }
                    }
                    var snapshot = instance.getSnapshotBeforeUpdate(finishedWork.elementType === finishedWork.type ? prevProps : resolveDefaultProps(finishedWork.type, prevProps), prevState);
                    {
                      var didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;
                      if (snapshot === void 0 && !didWarnSet.has(finishedWork.type)) {
                        didWarnSet.add(finishedWork.type);
                        error("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", getComponentNameFromFiber(finishedWork));
                      }
                    }
                    instance.__reactInternalSnapshotBeforeUpdate = snapshot;
                  }
                  break;
                }
                case HostRoot: {
                  {
                    var root3 = finishedWork.stateNode;
                    clearContainer(root3.containerInfo);
                  }
                  break;
                }
                case HostComponent:
                case HostText:
                case HostPortal:
                case IncompleteClassComponent:
                  break;
                default: {
                  throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
                }
              }
              resetCurrentFiber();
            }
          }
          function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor) {
            var updateQueue = finishedWork.updateQueue;
            var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
            if (lastEffect !== null) {
              var firstEffect = lastEffect.next;
              var effect = firstEffect;
              do {
                if ((effect.tag & flags) === flags) {
                  var destroy = effect.destroy;
                  effect.destroy = void 0;
                  if (destroy !== void 0) {
                    {
                      if ((flags & Passive$1) !== NoFlags$1) {
                        markComponentPassiveEffectUnmountStarted(finishedWork);
                      } else if ((flags & Layout) !== NoFlags$1) {
                        markComponentLayoutEffectUnmountStarted(finishedWork);
                      }
                    }
                    {
                      if ((flags & Insertion) !== NoFlags$1) {
                        setIsRunningInsertionEffect(true);
                      }
                    }
                    safelyCallDestroy(finishedWork, nearestMountedAncestor, destroy);
                    {
                      if ((flags & Insertion) !== NoFlags$1) {
                        setIsRunningInsertionEffect(false);
                      }
                    }
                    {
                      if ((flags & Passive$1) !== NoFlags$1) {
                        markComponentPassiveEffectUnmountStopped();
                      } else if ((flags & Layout) !== NoFlags$1) {
                        markComponentLayoutEffectUnmountStopped();
                      }
                    }
                  }
                }
                effect = effect.next;
              } while (effect !== firstEffect);
            }
          }
          function commitHookEffectListMount(flags, finishedWork) {
            var updateQueue = finishedWork.updateQueue;
            var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
            if (lastEffect !== null) {
              var firstEffect = lastEffect.next;
              var effect = firstEffect;
              do {
                if ((effect.tag & flags) === flags) {
                  {
                    if ((flags & Passive$1) !== NoFlags$1) {
                      markComponentPassiveEffectMountStarted(finishedWork);
                    } else if ((flags & Layout) !== NoFlags$1) {
                      markComponentLayoutEffectMountStarted(finishedWork);
                    }
                  }
                  var create = effect.create;
                  {
                    if ((flags & Insertion) !== NoFlags$1) {
                      setIsRunningInsertionEffect(true);
                    }
                  }
                  effect.destroy = create();
                  {
                    if ((flags & Insertion) !== NoFlags$1) {
                      setIsRunningInsertionEffect(false);
                    }
                  }
                  {
                    if ((flags & Passive$1) !== NoFlags$1) {
                      markComponentPassiveEffectMountStopped();
                    } else if ((flags & Layout) !== NoFlags$1) {
                      markComponentLayoutEffectMountStopped();
                    }
                  }
                  {
                    var destroy = effect.destroy;
                    if (destroy !== void 0 && typeof destroy !== "function") {
                      var hookName = void 0;
                      if ((effect.tag & Layout) !== NoFlags) {
                        hookName = "useLayoutEffect";
                      } else if ((effect.tag & Insertion) !== NoFlags) {
                        hookName = "useInsertionEffect";
                      } else {
                        hookName = "useEffect";
                      }
                      var addendum = void 0;
                      if (destroy === null) {
                        addendum = " You returned null. If your effect does not require clean up, return undefined (or nothing).";
                      } else if (typeof destroy.then === "function") {
                        addendum = "\n\nIt looks like you wrote " + hookName + "(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:\n\n" + hookName + "(() => {\n  async function fetchData() {\n    // You can await here\n    const response = await MyAPI.getData(someId);\n    // ...\n  }\n  fetchData();\n}, [someId]); // Or [] if effect doesn't need props or state\n\nLearn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching";
                      } else {
                        addendum = " You returned: " + destroy;
                      }
                      error("%s must not return anything besides a function, which is used for clean-up.%s", hookName, addendum);
                    }
                  }
                }
                effect = effect.next;
              } while (effect !== firstEffect);
            }
          }
          function commitPassiveEffectDurations(finishedRoot, finishedWork) {
            {
              if ((finishedWork.flags & Update) !== NoFlags) {
                switch (finishedWork.tag) {
                  case Profiler: {
                    var passiveEffectDuration = finishedWork.stateNode.passiveEffectDuration;
                    var _finishedWork$memoize = finishedWork.memoizedProps, id3 = _finishedWork$memoize.id, onPostCommit = _finishedWork$memoize.onPostCommit;
                    var commitTime2 = getCommitTime();
                    var phase = finishedWork.alternate === null ? "mount" : "update";
                    {
                      if (isCurrentUpdateNested()) {
                        phase = "nested-update";
                      }
                    }
                    if (typeof onPostCommit === "function") {
                      onPostCommit(id3, phase, passiveEffectDuration, commitTime2);
                    }
                    var parentFiber = finishedWork.return;
                    outer: while (parentFiber !== null) {
                      switch (parentFiber.tag) {
                        case HostRoot:
                          var root3 = parentFiber.stateNode;
                          root3.passiveEffectDuration += passiveEffectDuration;
                          break outer;
                        case Profiler:
                          var parentStateNode = parentFiber.stateNode;
                          parentStateNode.passiveEffectDuration += passiveEffectDuration;
                          break outer;
                      }
                      parentFiber = parentFiber.return;
                    }
                    break;
                  }
                }
              }
            }
          }
          function commitLayoutEffectOnFiber(finishedRoot, current2, finishedWork, committedLanes) {
            if ((finishedWork.flags & LayoutMask) !== NoFlags) {
              switch (finishedWork.tag) {
                case FunctionComponent:
                case ForwardRef:
                case SimpleMemoComponent: {
                  if (!offscreenSubtreeWasHidden) {
                    if (finishedWork.mode & ProfileMode) {
                      try {
                        startLayoutEffectTimer();
                        commitHookEffectListMount(Layout | HasEffect, finishedWork);
                      } finally {
                        recordLayoutEffectDuration(finishedWork);
                      }
                    } else {
                      commitHookEffectListMount(Layout | HasEffect, finishedWork);
                    }
                  }
                  break;
                }
                case ClassComponent: {
                  var instance = finishedWork.stateNode;
                  if (finishedWork.flags & Update) {
                    if (!offscreenSubtreeWasHidden) {
                      if (current2 === null) {
                        {
                          if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                            if (instance.props !== finishedWork.memoizedProps) {
                              error("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                            }
                            if (instance.state !== finishedWork.memoizedState) {
                              error("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                            }
                          }
                        }
                        if (finishedWork.mode & ProfileMode) {
                          try {
                            startLayoutEffectTimer();
                            instance.componentDidMount();
                          } finally {
                            recordLayoutEffectDuration(finishedWork);
                          }
                        } else {
                          instance.componentDidMount();
                        }
                      } else {
                        var prevProps = finishedWork.elementType === finishedWork.type ? current2.memoizedProps : resolveDefaultProps(finishedWork.type, current2.memoizedProps);
                        var prevState = current2.memoizedState;
                        {
                          if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                            if (instance.props !== finishedWork.memoizedProps) {
                              error("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                            }
                            if (instance.state !== finishedWork.memoizedState) {
                              error("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                            }
                          }
                        }
                        if (finishedWork.mode & ProfileMode) {
                          try {
                            startLayoutEffectTimer();
                            instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);
                          } finally {
                            recordLayoutEffectDuration(finishedWork);
                          }
                        } else {
                          instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);
                        }
                      }
                    }
                  }
                  var updateQueue = finishedWork.updateQueue;
                  if (updateQueue !== null) {
                    {
                      if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                        if (instance.props !== finishedWork.memoizedProps) {
                          error("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                        }
                        if (instance.state !== finishedWork.memoizedState) {
                          error("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                        }
                      }
                    }
                    commitUpdateQueue(finishedWork, updateQueue, instance);
                  }
                  break;
                }
                case HostRoot: {
                  var _updateQueue = finishedWork.updateQueue;
                  if (_updateQueue !== null) {
                    var _instance = null;
                    if (finishedWork.child !== null) {
                      switch (finishedWork.child.tag) {
                        case HostComponent:
                          _instance = getPublicInstance(finishedWork.child.stateNode);
                          break;
                        case ClassComponent:
                          _instance = finishedWork.child.stateNode;
                          break;
                      }
                    }
                    commitUpdateQueue(finishedWork, _updateQueue, _instance);
                  }
                  break;
                }
                case HostComponent: {
                  var _instance2 = finishedWork.stateNode;
                  if (current2 === null && finishedWork.flags & Update) {
                    var type = finishedWork.type;
                    var props = finishedWork.memoizedProps;
                    commitMount(_instance2, type, props);
                  }
                  break;
                }
                case HostText: {
                  break;
                }
                case HostPortal: {
                  break;
                }
                case Profiler: {
                  {
                    var _finishedWork$memoize2 = finishedWork.memoizedProps, onCommit = _finishedWork$memoize2.onCommit, onRender = _finishedWork$memoize2.onRender;
                    var effectDuration = finishedWork.stateNode.effectDuration;
                    var commitTime2 = getCommitTime();
                    var phase = current2 === null ? "mount" : "update";
                    {
                      if (isCurrentUpdateNested()) {
                        phase = "nested-update";
                      }
                    }
                    if (typeof onRender === "function") {
                      onRender(finishedWork.memoizedProps.id, phase, finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, commitTime2);
                    }
                    {
                      if (typeof onCommit === "function") {
                        onCommit(finishedWork.memoizedProps.id, phase, effectDuration, commitTime2);
                      }
                      enqueuePendingPassiveProfilerEffect(finishedWork);
                      var parentFiber = finishedWork.return;
                      outer: while (parentFiber !== null) {
                        switch (parentFiber.tag) {
                          case HostRoot:
                            var root3 = parentFiber.stateNode;
                            root3.effectDuration += effectDuration;
                            break outer;
                          case Profiler:
                            var parentStateNode = parentFiber.stateNode;
                            parentStateNode.effectDuration += effectDuration;
                            break outer;
                        }
                        parentFiber = parentFiber.return;
                      }
                    }
                  }
                  break;
                }
                case SuspenseComponent: {
                  commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
                  break;
                }
                case SuspenseListComponent:
                case IncompleteClassComponent:
                case ScopeComponent:
                case OffscreenComponent:
                case LegacyHiddenComponent:
                case TracingMarkerComponent: {
                  break;
                }
                default:
                  throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
            if (!offscreenSubtreeWasHidden) {
              {
                if (finishedWork.flags & Ref) {
                  commitAttachRef(finishedWork);
                }
              }
            }
          }
          function reappearLayoutEffectsOnFiber(node) {
            switch (node.tag) {
              case FunctionComponent:
              case ForwardRef:
              case SimpleMemoComponent: {
                if (node.mode & ProfileMode) {
                  try {
                    startLayoutEffectTimer();
                    safelyCallCommitHookLayoutEffectListMount(node, node.return);
                  } finally {
                    recordLayoutEffectDuration(node);
                  }
                } else {
                  safelyCallCommitHookLayoutEffectListMount(node, node.return);
                }
                break;
              }
              case ClassComponent: {
                var instance = node.stateNode;
                if (typeof instance.componentDidMount === "function") {
                  safelyCallComponentDidMount(node, node.return, instance);
                }
                safelyAttachRef(node, node.return);
                break;
              }
              case HostComponent: {
                safelyAttachRef(node, node.return);
                break;
              }
            }
          }
          function hideOrUnhideAllChildren(finishedWork, isHidden) {
            var hostSubtreeRoot = null;
            {
              var node = finishedWork;
              while (true) {
                if (node.tag === HostComponent) {
                  if (hostSubtreeRoot === null) {
                    hostSubtreeRoot = node;
                    try {
                      var instance = node.stateNode;
                      if (isHidden) {
                        hideInstance(instance);
                      } else {
                        unhideInstance(node.stateNode, node.memoizedProps);
                      }
                    } catch (error2) {
                      captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                    }
                  }
                } else if (node.tag === HostText) {
                  if (hostSubtreeRoot === null) {
                    try {
                      var _instance3 = node.stateNode;
                      if (isHidden) {
                        hideTextInstance(_instance3);
                      } else {
                        unhideTextInstance(_instance3, node.memoizedProps);
                      }
                    } catch (error2) {
                      captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                    }
                  }
                } else if ((node.tag === OffscreenComponent || node.tag === LegacyHiddenComponent) && node.memoizedState !== null && node !== finishedWork) ;
                else if (node.child !== null) {
                  node.child.return = node;
                  node = node.child;
                  continue;
                }
                if (node === finishedWork) {
                  return;
                }
                while (node.sibling === null) {
                  if (node.return === null || node.return === finishedWork) {
                    return;
                  }
                  if (hostSubtreeRoot === node) {
                    hostSubtreeRoot = null;
                  }
                  node = node.return;
                }
                if (hostSubtreeRoot === node) {
                  hostSubtreeRoot = null;
                }
                node.sibling.return = node.return;
                node = node.sibling;
              }
            }
          }
          function commitAttachRef(finishedWork) {
            var ref2 = finishedWork.ref;
            if (ref2 !== null) {
              var instance = finishedWork.stateNode;
              var instanceToUse;
              switch (finishedWork.tag) {
                case HostComponent:
                  instanceToUse = getPublicInstance(instance);
                  break;
                default:
                  instanceToUse = instance;
              }
              if (typeof ref2 === "function") {
                var retVal;
                if (finishedWork.mode & ProfileMode) {
                  try {
                    startLayoutEffectTimer();
                    retVal = ref2(instanceToUse);
                  } finally {
                    recordLayoutEffectDuration(finishedWork);
                  }
                } else {
                  retVal = ref2(instanceToUse);
                }
                {
                  if (typeof retVal === "function") {
                    error("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", getComponentNameFromFiber(finishedWork));
                  }
                }
              } else {
                {
                  if (!ref2.hasOwnProperty("current")) {
                    error("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", getComponentNameFromFiber(finishedWork));
                  }
                }
                ref2.current = instanceToUse;
              }
            }
          }
          function detachFiberMutation(fiber) {
            var alternate = fiber.alternate;
            if (alternate !== null) {
              alternate.return = null;
            }
            fiber.return = null;
          }
          function detachFiberAfterEffects(fiber) {
            var alternate = fiber.alternate;
            if (alternate !== null) {
              fiber.alternate = null;
              detachFiberAfterEffects(alternate);
            }
            {
              fiber.child = null;
              fiber.deletions = null;
              fiber.sibling = null;
              if (fiber.tag === HostComponent) {
                var hostInstance = fiber.stateNode;
                if (hostInstance !== null) {
                  detachDeletedInstance(hostInstance);
                }
              }
              fiber.stateNode = null;
              {
                fiber._debugOwner = null;
              }
              {
                fiber.return = null;
                fiber.dependencies = null;
                fiber.memoizedProps = null;
                fiber.memoizedState = null;
                fiber.pendingProps = null;
                fiber.stateNode = null;
                fiber.updateQueue = null;
              }
            }
          }
          function getHostParentFiber(fiber) {
            var parent = fiber.return;
            while (parent !== null) {
              if (isHostParent(parent)) {
                return parent;
              }
              parent = parent.return;
            }
            throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
          }
          function isHostParent(fiber) {
            return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;
          }
          function getHostSibling(fiber) {
            var node = fiber;
            siblings: while (true) {
              while (node.sibling === null) {
                if (node.return === null || isHostParent(node.return)) {
                  return null;
                }
                node = node.return;
              }
              node.sibling.return = node.return;
              node = node.sibling;
              while (node.tag !== HostComponent && node.tag !== HostText && node.tag !== DehydratedFragment) {
                if (node.flags & Placement) {
                  continue siblings;
                }
                if (node.child === null || node.tag === HostPortal) {
                  continue siblings;
                } else {
                  node.child.return = node;
                  node = node.child;
                }
              }
              if (!(node.flags & Placement)) {
                return node.stateNode;
              }
            }
          }
          function commitPlacement(finishedWork) {
            var parentFiber = getHostParentFiber(finishedWork);
            switch (parentFiber.tag) {
              case HostComponent: {
                var parent = parentFiber.stateNode;
                if (parentFiber.flags & ContentReset) {
                  resetTextContent(parent);
                  parentFiber.flags &= ~ContentReset;
                }
                var before = getHostSibling(finishedWork);
                insertOrAppendPlacementNode(finishedWork, before, parent);
                break;
              }
              case HostRoot:
              case HostPortal: {
                var _parent = parentFiber.stateNode.containerInfo;
                var _before = getHostSibling(finishedWork);
                insertOrAppendPlacementNodeIntoContainer(finishedWork, _before, _parent);
                break;
              }
              // eslint-disable-next-line-no-fallthrough
              default:
                throw new Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
            }
          }
          function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
            var tag = node.tag;
            var isHost = tag === HostComponent || tag === HostText;
            if (isHost) {
              var stateNode = node.stateNode;
              if (before) {
                insertInContainerBefore(parent, stateNode, before);
              } else {
                appendChildToContainer(parent, stateNode);
              }
            } else if (tag === HostPortal) ;
            else {
              var child = node.child;
              if (child !== null) {
                insertOrAppendPlacementNodeIntoContainer(child, before, parent);
                var sibling = child.sibling;
                while (sibling !== null) {
                  insertOrAppendPlacementNodeIntoContainer(sibling, before, parent);
                  sibling = sibling.sibling;
                }
              }
            }
          }
          function insertOrAppendPlacementNode(node, before, parent) {
            var tag = node.tag;
            var isHost = tag === HostComponent || tag === HostText;
            if (isHost) {
              var stateNode = node.stateNode;
              if (before) {
                insertBefore(parent, stateNode, before);
              } else {
                appendChild(parent, stateNode);
              }
            } else if (tag === HostPortal) ;
            else {
              var child = node.child;
              if (child !== null) {
                insertOrAppendPlacementNode(child, before, parent);
                var sibling = child.sibling;
                while (sibling !== null) {
                  insertOrAppendPlacementNode(sibling, before, parent);
                  sibling = sibling.sibling;
                }
              }
            }
          }
          var hostParent = null;
          var hostParentIsContainer = false;
          function commitDeletionEffects(root3, returnFiber, deletedFiber) {
            {
              var parent = returnFiber;
              findParent: while (parent !== null) {
                switch (parent.tag) {
                  case HostComponent: {
                    hostParent = parent.stateNode;
                    hostParentIsContainer = false;
                    break findParent;
                  }
                  case HostRoot: {
                    hostParent = parent.stateNode.containerInfo;
                    hostParentIsContainer = true;
                    break findParent;
                  }
                  case HostPortal: {
                    hostParent = parent.stateNode.containerInfo;
                    hostParentIsContainer = true;
                    break findParent;
                  }
                }
                parent = parent.return;
              }
              if (hostParent === null) {
                throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
              }
              commitDeletionEffectsOnFiber(root3, returnFiber, deletedFiber);
              hostParent = null;
              hostParentIsContainer = false;
            }
            detachFiberMutation(deletedFiber);
          }
          function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
            var child = parent.child;
            while (child !== null) {
              commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, child);
              child = child.sibling;
            }
          }
          function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
            onCommitUnmount(deletedFiber);
            switch (deletedFiber.tag) {
              case HostComponent: {
                if (!offscreenSubtreeWasHidden) {
                  safelyDetachRef(deletedFiber, nearestMountedAncestor);
                }
              }
              // eslint-disable-next-line-no-fallthrough
              case HostText: {
                {
                  var prevHostParent = hostParent;
                  var prevHostParentIsContainer = hostParentIsContainer;
                  hostParent = null;
                  recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                  hostParent = prevHostParent;
                  hostParentIsContainer = prevHostParentIsContainer;
                  if (hostParent !== null) {
                    if (hostParentIsContainer) {
                      removeChildFromContainer(hostParent, deletedFiber.stateNode);
                    } else {
                      removeChild(hostParent, deletedFiber.stateNode);
                    }
                  }
                }
                return;
              }
              case DehydratedFragment: {
                {
                  if (hostParent !== null) {
                    if (hostParentIsContainer) {
                      clearSuspenseBoundaryFromContainer(hostParent, deletedFiber.stateNode);
                    } else {
                      clearSuspenseBoundary(hostParent, deletedFiber.stateNode);
                    }
                  }
                }
                return;
              }
              case HostPortal: {
                {
                  var _prevHostParent = hostParent;
                  var _prevHostParentIsContainer = hostParentIsContainer;
                  hostParent = deletedFiber.stateNode.containerInfo;
                  hostParentIsContainer = true;
                  recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                  hostParent = _prevHostParent;
                  hostParentIsContainer = _prevHostParentIsContainer;
                }
                return;
              }
              case FunctionComponent:
              case ForwardRef:
              case MemoComponent:
              case SimpleMemoComponent: {
                if (!offscreenSubtreeWasHidden) {
                  var updateQueue = deletedFiber.updateQueue;
                  if (updateQueue !== null) {
                    var lastEffect = updateQueue.lastEffect;
                    if (lastEffect !== null) {
                      var firstEffect = lastEffect.next;
                      var effect = firstEffect;
                      do {
                        var _effect = effect, destroy = _effect.destroy, tag = _effect.tag;
                        if (destroy !== void 0) {
                          if ((tag & Insertion) !== NoFlags$1) {
                            safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);
                          } else if ((tag & Layout) !== NoFlags$1) {
                            {
                              markComponentLayoutEffectUnmountStarted(deletedFiber);
                            }
                            if (deletedFiber.mode & ProfileMode) {
                              startLayoutEffectTimer();
                              safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);
                              recordLayoutEffectDuration(deletedFiber);
                            } else {
                              safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);
                            }
                            {
                              markComponentLayoutEffectUnmountStopped();
                            }
                          }
                        }
                        effect = effect.next;
                      } while (effect !== firstEffect);
                    }
                  }
                }
                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                return;
              }
              case ClassComponent: {
                if (!offscreenSubtreeWasHidden) {
                  safelyDetachRef(deletedFiber, nearestMountedAncestor);
                  var instance = deletedFiber.stateNode;
                  if (typeof instance.componentWillUnmount === "function") {
                    safelyCallComponentWillUnmount(deletedFiber, nearestMountedAncestor, instance);
                  }
                }
                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                return;
              }
              case ScopeComponent: {
                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                return;
              }
              case OffscreenComponent: {
                if (
                  // TODO: Remove this dead flag
                  deletedFiber.mode & ConcurrentMode
                ) {
                  var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
                  offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || deletedFiber.memoizedState !== null;
                  recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                  offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
                } else {
                  recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                }
                break;
              }
              default: {
                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                return;
              }
            }
          }
          function commitSuspenseCallback(finishedWork) {
            var newState = finishedWork.memoizedState;
          }
          function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
            var newState = finishedWork.memoizedState;
            if (newState === null) {
              var current2 = finishedWork.alternate;
              if (current2 !== null) {
                var prevState = current2.memoizedState;
                if (prevState !== null) {
                  var suspenseInstance = prevState.dehydrated;
                  if (suspenseInstance !== null) {
                    commitHydratedSuspenseInstance(suspenseInstance);
                  }
                }
              }
            }
          }
          function attachSuspenseRetryListeners(finishedWork) {
            var wakeables = finishedWork.updateQueue;
            if (wakeables !== null) {
              finishedWork.updateQueue = null;
              var retryCache = finishedWork.stateNode;
              if (retryCache === null) {
                retryCache = finishedWork.stateNode = new PossiblyWeakSet();
              }
              wakeables.forEach(function(wakeable) {
                var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
                if (!retryCache.has(wakeable)) {
                  retryCache.add(wakeable);
                  {
                    if (isDevToolsPresent) {
                      if (inProgressLanes !== null && inProgressRoot !== null) {
                        restorePendingUpdaters(inProgressRoot, inProgressLanes);
                      } else {
                        throw Error("Expected finished root and lanes to be set. This is a bug in React.");
                      }
                    }
                  }
                  wakeable.then(retry, retry);
                }
              });
            }
          }
          function commitMutationEffects(root3, finishedWork, committedLanes) {
            inProgressLanes = committedLanes;
            inProgressRoot = root3;
            setCurrentFiber(finishedWork);
            commitMutationEffectsOnFiber(finishedWork, root3);
            setCurrentFiber(finishedWork);
            inProgressLanes = null;
            inProgressRoot = null;
          }
          function recursivelyTraverseMutationEffects(root3, parentFiber, lanes) {
            var deletions = parentFiber.deletions;
            if (deletions !== null) {
              for (var i = 0; i < deletions.length; i++) {
                var childToDelete = deletions[i];
                try {
                  commitDeletionEffects(root3, parentFiber, childToDelete);
                } catch (error2) {
                  captureCommitPhaseError(childToDelete, parentFiber, error2);
                }
              }
            }
            var prevDebugFiber = getCurrentFiber();
            if (parentFiber.subtreeFlags & MutationMask) {
              var child = parentFiber.child;
              while (child !== null) {
                setCurrentFiber(child);
                commitMutationEffectsOnFiber(child, root3);
                child = child.sibling;
              }
            }
            setCurrentFiber(prevDebugFiber);
          }
          function commitMutationEffectsOnFiber(finishedWork, root3, lanes) {
            var current2 = finishedWork.alternate;
            var flags = finishedWork.flags;
            switch (finishedWork.tag) {
              case FunctionComponent:
              case ForwardRef:
              case MemoComponent:
              case SimpleMemoComponent: {
                recursivelyTraverseMutationEffects(root3, finishedWork);
                commitReconciliationEffects(finishedWork);
                if (flags & Update) {
                  try {
                    commitHookEffectListUnmount(Insertion | HasEffect, finishedWork, finishedWork.return);
                    commitHookEffectListMount(Insertion | HasEffect, finishedWork);
                  } catch (error2) {
                    captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                  }
                  if (finishedWork.mode & ProfileMode) {
                    try {
                      startLayoutEffectTimer();
                      commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);
                    } catch (error2) {
                      captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                    }
                    recordLayoutEffectDuration(finishedWork);
                  } else {
                    try {
                      commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);
                    } catch (error2) {
                      captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                    }
                  }
                }
                return;
              }
              case ClassComponent: {
                recursivelyTraverseMutationEffects(root3, finishedWork);
                commitReconciliationEffects(finishedWork);
                if (flags & Ref) {
                  if (current2 !== null) {
                    safelyDetachRef(current2, current2.return);
                  }
                }
                return;
              }
              case HostComponent: {
                recursivelyTraverseMutationEffects(root3, finishedWork);
                commitReconciliationEffects(finishedWork);
                if (flags & Ref) {
                  if (current2 !== null) {
                    safelyDetachRef(current2, current2.return);
                  }
                }
                {
                  if (finishedWork.flags & ContentReset) {
                    var instance = finishedWork.stateNode;
                    try {
                      resetTextContent(instance);
                    } catch (error2) {
                      captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                    }
                  }
                  if (flags & Update) {
                    var _instance4 = finishedWork.stateNode;
                    if (_instance4 != null) {
                      var newProps = finishedWork.memoizedProps;
                      var oldProps = current2 !== null ? current2.memoizedProps : newProps;
                      var type = finishedWork.type;
                      var updatePayload = finishedWork.updateQueue;
                      finishedWork.updateQueue = null;
                      if (updatePayload !== null) {
                        try {
                          commitUpdate(_instance4, updatePayload, type, oldProps, newProps, finishedWork);
                        } catch (error2) {
                          captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                        }
                      }
                    }
                  }
                }
                return;
              }
              case HostText: {
                recursivelyTraverseMutationEffects(root3, finishedWork);
                commitReconciliationEffects(finishedWork);
                if (flags & Update) {
                  {
                    if (finishedWork.stateNode === null) {
                      throw new Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
                    }
                    var textInstance = finishedWork.stateNode;
                    var newText = finishedWork.memoizedProps;
                    var oldText = current2 !== null ? current2.memoizedProps : newText;
                    try {
                      commitTextUpdate(textInstance, oldText, newText);
                    } catch (error2) {
                      captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                    }
                  }
                }
                return;
              }
              case HostRoot: {
                recursivelyTraverseMutationEffects(root3, finishedWork);
                commitReconciliationEffects(finishedWork);
                if (flags & Update) {
                  {
                    if (current2 !== null) {
                      var prevRootState = current2.memoizedState;
                      if (prevRootState.isDehydrated) {
                        try {
                          commitHydratedContainer(root3.containerInfo);
                        } catch (error2) {
                          captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                        }
                      }
                    }
                  }
                }
                return;
              }
              case HostPortal: {
                recursivelyTraverseMutationEffects(root3, finishedWork);
                commitReconciliationEffects(finishedWork);
                return;
              }
              case SuspenseComponent: {
                recursivelyTraverseMutationEffects(root3, finishedWork);
                commitReconciliationEffects(finishedWork);
                var offscreenFiber = finishedWork.child;
                if (offscreenFiber.flags & Visibility) {
                  var offscreenInstance = offscreenFiber.stateNode;
                  var newState = offscreenFiber.memoizedState;
                  var isHidden = newState !== null;
                  offscreenInstance.isHidden = isHidden;
                  if (isHidden) {
                    var wasHidden = offscreenFiber.alternate !== null && offscreenFiber.alternate.memoizedState !== null;
                    if (!wasHidden) {
                      markCommitTimeOfFallback();
                    }
                  }
                }
                if (flags & Update) {
                  try {
                    commitSuspenseCallback(finishedWork);
                  } catch (error2) {
                    captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                  }
                  attachSuspenseRetryListeners(finishedWork);
                }
                return;
              }
              case OffscreenComponent: {
                var _wasHidden = current2 !== null && current2.memoizedState !== null;
                if (
                  // TODO: Remove this dead flag
                  finishedWork.mode & ConcurrentMode
                ) {
                  var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
                  offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || _wasHidden;
                  recursivelyTraverseMutationEffects(root3, finishedWork);
                  offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
                } else {
                  recursivelyTraverseMutationEffects(root3, finishedWork);
                }
                commitReconciliationEffects(finishedWork);
                if (flags & Visibility) {
                  var _offscreenInstance = finishedWork.stateNode;
                  var _newState = finishedWork.memoizedState;
                  var _isHidden = _newState !== null;
                  var offscreenBoundary = finishedWork;
                  _offscreenInstance.isHidden = _isHidden;
                  {
                    if (_isHidden) {
                      if (!_wasHidden) {
                        if ((offscreenBoundary.mode & ConcurrentMode) !== NoMode) {
                          nextEffect = offscreenBoundary;
                          var offscreenChild = offscreenBoundary.child;
                          while (offscreenChild !== null) {
                            nextEffect = offscreenChild;
                            disappearLayoutEffects_begin(offscreenChild);
                            offscreenChild = offscreenChild.sibling;
                          }
                        }
                      }
                    }
                  }
                  {
                    hideOrUnhideAllChildren(offscreenBoundary, _isHidden);
                  }
                }
                return;
              }
              case SuspenseListComponent: {
                recursivelyTraverseMutationEffects(root3, finishedWork);
                commitReconciliationEffects(finishedWork);
                if (flags & Update) {
                  attachSuspenseRetryListeners(finishedWork);
                }
                return;
              }
              case ScopeComponent: {
                return;
              }
              default: {
                recursivelyTraverseMutationEffects(root3, finishedWork);
                commitReconciliationEffects(finishedWork);
                return;
              }
            }
          }
          function commitReconciliationEffects(finishedWork) {
            var flags = finishedWork.flags;
            if (flags & Placement) {
              try {
                commitPlacement(finishedWork);
              } catch (error2) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error2);
              }
              finishedWork.flags &= ~Placement;
            }
            if (flags & Hydrating) {
              finishedWork.flags &= ~Hydrating;
            }
          }
          function commitLayoutEffects(finishedWork, root3, committedLanes) {
            inProgressLanes = committedLanes;
            inProgressRoot = root3;
            nextEffect = finishedWork;
            commitLayoutEffects_begin(finishedWork, root3, committedLanes);
            inProgressLanes = null;
            inProgressRoot = null;
          }
          function commitLayoutEffects_begin(subtreeRoot, root3, committedLanes) {
            var isModernRoot = (subtreeRoot.mode & ConcurrentMode) !== NoMode;
            while (nextEffect !== null) {
              var fiber = nextEffect;
              var firstChild = fiber.child;
              if (fiber.tag === OffscreenComponent && isModernRoot) {
                var isHidden = fiber.memoizedState !== null;
                var newOffscreenSubtreeIsHidden = isHidden || offscreenSubtreeIsHidden;
                if (newOffscreenSubtreeIsHidden) {
                  commitLayoutMountEffects_complete(subtreeRoot, root3, committedLanes);
                  continue;
                } else {
                  var current2 = fiber.alternate;
                  var wasHidden = current2 !== null && current2.memoizedState !== null;
                  var newOffscreenSubtreeWasHidden = wasHidden || offscreenSubtreeWasHidden;
                  var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden;
                  var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
                  offscreenSubtreeIsHidden = newOffscreenSubtreeIsHidden;
                  offscreenSubtreeWasHidden = newOffscreenSubtreeWasHidden;
                  if (offscreenSubtreeWasHidden && !prevOffscreenSubtreeWasHidden) {
                    nextEffect = fiber;
                    reappearLayoutEffects_begin(fiber);
                  }
                  var child = firstChild;
                  while (child !== null) {
                    nextEffect = child;
                    commitLayoutEffects_begin(
                      child,
                      // New root; bubble back up to here and stop.
                      root3,
                      committedLanes
                    );
                    child = child.sibling;
                  }
                  nextEffect = fiber;
                  offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
                  offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
                  commitLayoutMountEffects_complete(subtreeRoot, root3, committedLanes);
                  continue;
                }
              }
              if ((fiber.subtreeFlags & LayoutMask) !== NoFlags && firstChild !== null) {
                firstChild.return = fiber;
                nextEffect = firstChild;
              } else {
                commitLayoutMountEffects_complete(subtreeRoot, root3, committedLanes);
              }
            }
          }
          function commitLayoutMountEffects_complete(subtreeRoot, root3, committedLanes) {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              if ((fiber.flags & LayoutMask) !== NoFlags) {
                var current2 = fiber.alternate;
                setCurrentFiber(fiber);
                try {
                  commitLayoutEffectOnFiber(root3, current2, fiber, committedLanes);
                } catch (error2) {
                  captureCommitPhaseError(fiber, fiber.return, error2);
                }
                resetCurrentFiber();
              }
              if (fiber === subtreeRoot) {
                nextEffect = null;
                return;
              }
              var sibling = fiber.sibling;
              if (sibling !== null) {
                sibling.return = fiber.return;
                nextEffect = sibling;
                return;
              }
              nextEffect = fiber.return;
            }
          }
          function disappearLayoutEffects_begin(subtreeRoot) {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              var firstChild = fiber.child;
              switch (fiber.tag) {
                case FunctionComponent:
                case ForwardRef:
                case MemoComponent:
                case SimpleMemoComponent: {
                  if (fiber.mode & ProfileMode) {
                    try {
                      startLayoutEffectTimer();
                      commitHookEffectListUnmount(Layout, fiber, fiber.return);
                    } finally {
                      recordLayoutEffectDuration(fiber);
                    }
                  } else {
                    commitHookEffectListUnmount(Layout, fiber, fiber.return);
                  }
                  break;
                }
                case ClassComponent: {
                  safelyDetachRef(fiber, fiber.return);
                  var instance = fiber.stateNode;
                  if (typeof instance.componentWillUnmount === "function") {
                    safelyCallComponentWillUnmount(fiber, fiber.return, instance);
                  }
                  break;
                }
                case HostComponent: {
                  safelyDetachRef(fiber, fiber.return);
                  break;
                }
                case OffscreenComponent: {
                  var isHidden = fiber.memoizedState !== null;
                  if (isHidden) {
                    disappearLayoutEffects_complete(subtreeRoot);
                    continue;
                  }
                  break;
                }
              }
              if (firstChild !== null) {
                firstChild.return = fiber;
                nextEffect = firstChild;
              } else {
                disappearLayoutEffects_complete(subtreeRoot);
              }
            }
          }
          function disappearLayoutEffects_complete(subtreeRoot) {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              if (fiber === subtreeRoot) {
                nextEffect = null;
                return;
              }
              var sibling = fiber.sibling;
              if (sibling !== null) {
                sibling.return = fiber.return;
                nextEffect = sibling;
                return;
              }
              nextEffect = fiber.return;
            }
          }
          function reappearLayoutEffects_begin(subtreeRoot) {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              var firstChild = fiber.child;
              if (fiber.tag === OffscreenComponent) {
                var isHidden = fiber.memoizedState !== null;
                if (isHidden) {
                  reappearLayoutEffects_complete(subtreeRoot);
                  continue;
                }
              }
              if (firstChild !== null) {
                firstChild.return = fiber;
                nextEffect = firstChild;
              } else {
                reappearLayoutEffects_complete(subtreeRoot);
              }
            }
          }
          function reappearLayoutEffects_complete(subtreeRoot) {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              setCurrentFiber(fiber);
              try {
                reappearLayoutEffectsOnFiber(fiber);
              } catch (error2) {
                captureCommitPhaseError(fiber, fiber.return, error2);
              }
              resetCurrentFiber();
              if (fiber === subtreeRoot) {
                nextEffect = null;
                return;
              }
              var sibling = fiber.sibling;
              if (sibling !== null) {
                sibling.return = fiber.return;
                nextEffect = sibling;
                return;
              }
              nextEffect = fiber.return;
            }
          }
          function commitPassiveMountEffects(root3, finishedWork, committedLanes, committedTransitions) {
            nextEffect = finishedWork;
            commitPassiveMountEffects_begin(finishedWork, root3, committedLanes, committedTransitions);
          }
          function commitPassiveMountEffects_begin(subtreeRoot, root3, committedLanes, committedTransitions) {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              var firstChild = fiber.child;
              if ((fiber.subtreeFlags & PassiveMask) !== NoFlags && firstChild !== null) {
                firstChild.return = fiber;
                nextEffect = firstChild;
              } else {
                commitPassiveMountEffects_complete(subtreeRoot, root3, committedLanes, committedTransitions);
              }
            }
          }
          function commitPassiveMountEffects_complete(subtreeRoot, root3, committedLanes, committedTransitions) {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              if ((fiber.flags & Passive) !== NoFlags) {
                setCurrentFiber(fiber);
                try {
                  commitPassiveMountOnFiber(root3, fiber, committedLanes, committedTransitions);
                } catch (error2) {
                  captureCommitPhaseError(fiber, fiber.return, error2);
                }
                resetCurrentFiber();
              }
              if (fiber === subtreeRoot) {
                nextEffect = null;
                return;
              }
              var sibling = fiber.sibling;
              if (sibling !== null) {
                sibling.return = fiber.return;
                nextEffect = sibling;
                return;
              }
              nextEffect = fiber.return;
            }
          }
          function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {
            switch (finishedWork.tag) {
              case FunctionComponent:
              case ForwardRef:
              case SimpleMemoComponent: {
                if (finishedWork.mode & ProfileMode) {
                  startPassiveEffectTimer();
                  try {
                    commitHookEffectListMount(Passive$1 | HasEffect, finishedWork);
                  } finally {
                    recordPassiveEffectDuration(finishedWork);
                  }
                } else {
                  commitHookEffectListMount(Passive$1 | HasEffect, finishedWork);
                }
                break;
              }
            }
          }
          function commitPassiveUnmountEffects(firstChild) {
            nextEffect = firstChild;
            commitPassiveUnmountEffects_begin();
          }
          function commitPassiveUnmountEffects_begin() {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              var child = fiber.child;
              if ((nextEffect.flags & ChildDeletion) !== NoFlags) {
                var deletions = fiber.deletions;
                if (deletions !== null) {
                  for (var i = 0; i < deletions.length; i++) {
                    var fiberToDelete = deletions[i];
                    nextEffect = fiberToDelete;
                    commitPassiveUnmountEffectsInsideOfDeletedTree_begin(fiberToDelete, fiber);
                  }
                  {
                    var previousFiber = fiber.alternate;
                    if (previousFiber !== null) {
                      var detachedChild = previousFiber.child;
                      if (detachedChild !== null) {
                        previousFiber.child = null;
                        do {
                          var detachedSibling = detachedChild.sibling;
                          detachedChild.sibling = null;
                          detachedChild = detachedSibling;
                        } while (detachedChild !== null);
                      }
                    }
                  }
                  nextEffect = fiber;
                }
              }
              if ((fiber.subtreeFlags & PassiveMask) !== NoFlags && child !== null) {
                child.return = fiber;
                nextEffect = child;
              } else {
                commitPassiveUnmountEffects_complete();
              }
            }
          }
          function commitPassiveUnmountEffects_complete() {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              if ((fiber.flags & Passive) !== NoFlags) {
                setCurrentFiber(fiber);
                commitPassiveUnmountOnFiber(fiber);
                resetCurrentFiber();
              }
              var sibling = fiber.sibling;
              if (sibling !== null) {
                sibling.return = fiber.return;
                nextEffect = sibling;
                return;
              }
              nextEffect = fiber.return;
            }
          }
          function commitPassiveUnmountOnFiber(finishedWork) {
            switch (finishedWork.tag) {
              case FunctionComponent:
              case ForwardRef:
              case SimpleMemoComponent: {
                if (finishedWork.mode & ProfileMode) {
                  startPassiveEffectTimer();
                  commitHookEffectListUnmount(Passive$1 | HasEffect, finishedWork, finishedWork.return);
                  recordPassiveEffectDuration(finishedWork);
                } else {
                  commitHookEffectListUnmount(Passive$1 | HasEffect, finishedWork, finishedWork.return);
                }
                break;
              }
            }
          }
          function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              setCurrentFiber(fiber);
              commitPassiveUnmountInsideDeletedTreeOnFiber(fiber, nearestMountedAncestor);
              resetCurrentFiber();
              var child = fiber.child;
              if (child !== null) {
                child.return = fiber;
                nextEffect = child;
              } else {
                commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot);
              }
            }
          }
          function commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot) {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              var sibling = fiber.sibling;
              var returnFiber = fiber.return;
              {
                detachFiberAfterEffects(fiber);
                if (fiber === deletedSubtreeRoot) {
                  nextEffect = null;
                  return;
                }
              }
              if (sibling !== null) {
                sibling.return = returnFiber;
                nextEffect = sibling;
                return;
              }
              nextEffect = returnFiber;
            }
          }
          function commitPassiveUnmountInsideDeletedTreeOnFiber(current2, nearestMountedAncestor) {
            switch (current2.tag) {
              case FunctionComponent:
              case ForwardRef:
              case SimpleMemoComponent: {
                if (current2.mode & ProfileMode) {
                  startPassiveEffectTimer();
                  commitHookEffectListUnmount(Passive$1, current2, nearestMountedAncestor);
                  recordPassiveEffectDuration(current2);
                } else {
                  commitHookEffectListUnmount(Passive$1, current2, nearestMountedAncestor);
                }
                break;
              }
            }
          }
          function invokeLayoutEffectMountInDEV(fiber) {
            {
              switch (fiber.tag) {
                case FunctionComponent:
                case ForwardRef:
                case SimpleMemoComponent: {
                  try {
                    commitHookEffectListMount(Layout | HasEffect, fiber);
                  } catch (error2) {
                    captureCommitPhaseError(fiber, fiber.return, error2);
                  }
                  break;
                }
                case ClassComponent: {
                  var instance = fiber.stateNode;
                  try {
                    instance.componentDidMount();
                  } catch (error2) {
                    captureCommitPhaseError(fiber, fiber.return, error2);
                  }
                  break;
                }
              }
            }
          }
          function invokePassiveEffectMountInDEV(fiber) {
            {
              switch (fiber.tag) {
                case FunctionComponent:
                case ForwardRef:
                case SimpleMemoComponent: {
                  try {
                    commitHookEffectListMount(Passive$1 | HasEffect, fiber);
                  } catch (error2) {
                    captureCommitPhaseError(fiber, fiber.return, error2);
                  }
                  break;
                }
              }
            }
          }
          function invokeLayoutEffectUnmountInDEV(fiber) {
            {
              switch (fiber.tag) {
                case FunctionComponent:
                case ForwardRef:
                case SimpleMemoComponent: {
                  try {
                    commitHookEffectListUnmount(Layout | HasEffect, fiber, fiber.return);
                  } catch (error2) {
                    captureCommitPhaseError(fiber, fiber.return, error2);
                  }
                  break;
                }
                case ClassComponent: {
                  var instance = fiber.stateNode;
                  if (typeof instance.componentWillUnmount === "function") {
                    safelyCallComponentWillUnmount(fiber, fiber.return, instance);
                  }
                  break;
                }
              }
            }
          }
          function invokePassiveEffectUnmountInDEV(fiber) {
            {
              switch (fiber.tag) {
                case FunctionComponent:
                case ForwardRef:
                case SimpleMemoComponent: {
                  try {
                    commitHookEffectListUnmount(Passive$1 | HasEffect, fiber, fiber.return);
                  } catch (error2) {
                    captureCommitPhaseError(fiber, fiber.return, error2);
                  }
                }
              }
            }
          }
          var COMPONENT_TYPE = 0;
          var HAS_PSEUDO_CLASS_TYPE = 1;
          var ROLE_TYPE = 2;
          var TEST_NAME_TYPE = 3;
          var TEXT_TYPE = 4;
          if (typeof Symbol === "function" && Symbol.for) {
            var symbolFor = Symbol.for;
            COMPONENT_TYPE = symbolFor("selector.component");
            HAS_PSEUDO_CLASS_TYPE = symbolFor("selector.has_pseudo_class");
            ROLE_TYPE = symbolFor("selector.role");
            TEST_NAME_TYPE = symbolFor("selector.test_id");
            TEXT_TYPE = symbolFor("selector.text");
          }
          var commitHooks = [];
          function onCommitRoot$1() {
            {
              commitHooks.forEach(function(commitHook) {
                return commitHook();
              });
            }
          }
          var ReactCurrentActQueue = ReactSharedInternals.ReactCurrentActQueue;
          function isLegacyActEnvironment(fiber) {
            {
              var isReactActEnvironmentGlobal = (
                // $FlowExpectedError  Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
                typeof IS_REACT_ACT_ENVIRONMENT !== "undefined" ? IS_REACT_ACT_ENVIRONMENT : void 0
              );
              var jestIsDefined = typeof jest !== "undefined";
              return jestIsDefined && isReactActEnvironmentGlobal !== false;
            }
          }
          function isConcurrentActEnvironment() {
            {
              var isReactActEnvironmentGlobal = (
                // $FlowExpectedError  Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
                typeof IS_REACT_ACT_ENVIRONMENT !== "undefined" ? IS_REACT_ACT_ENVIRONMENT : void 0
              );
              if (!isReactActEnvironmentGlobal && ReactCurrentActQueue.current !== null) {
                error("The current testing environment is not configured to support act(...)");
              }
              return isReactActEnvironmentGlobal;
            }
          }
          var ceil = Math.ceil;
          var ReactCurrentDispatcher$2 = ReactSharedInternals.ReactCurrentDispatcher, ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner, ReactCurrentBatchConfig$3 = ReactSharedInternals.ReactCurrentBatchConfig, ReactCurrentActQueue$1 = ReactSharedInternals.ReactCurrentActQueue;
          var NoContext = (
            /*             */
            0
          );
          var BatchedContext = (
            /*               */
            1
          );
          var RenderContext = (
            /*                */
            2
          );
          var CommitContext = (
            /*                */
            4
          );
          var RootInProgress = 0;
          var RootFatalErrored = 1;
          var RootErrored = 2;
          var RootSuspended = 3;
          var RootSuspendedWithDelay = 4;
          var RootCompleted = 5;
          var RootDidNotComplete = 6;
          var executionContext = NoContext;
          var workInProgressRoot = null;
          var workInProgress = null;
          var workInProgressRootRenderLanes = NoLanes;
          var subtreeRenderLanes = NoLanes;
          var subtreeRenderLanesCursor = createCursor(NoLanes);
          var workInProgressRootExitStatus = RootInProgress;
          var workInProgressRootFatalError = null;
          var workInProgressRootIncludedLanes = NoLanes;
          var workInProgressRootSkippedLanes = NoLanes;
          var workInProgressRootInterleavedUpdatedLanes = NoLanes;
          var workInProgressRootPingedLanes = NoLanes;
          var workInProgressRootConcurrentErrors = null;
          var workInProgressRootRecoverableErrors = null;
          var globalMostRecentFallbackTime = 0;
          var FALLBACK_THROTTLE_MS = 500;
          var workInProgressRootRenderTargetTime = Infinity;
          var RENDER_TIMEOUT_MS = 500;
          var workInProgressTransitions = null;
          function resetRenderTimer() {
            workInProgressRootRenderTargetTime = now3() + RENDER_TIMEOUT_MS;
          }
          function getRenderTargetTime() {
            return workInProgressRootRenderTargetTime;
          }
          var hasUncaughtError = false;
          var firstUncaughtError = null;
          var legacyErrorBoundariesThatAlreadyFailed = null;
          var rootDoesHavePassiveEffects = false;
          var rootWithPendingPassiveEffects = null;
          var pendingPassiveEffectsLanes = NoLanes;
          var pendingPassiveProfilerEffects = [];
          var pendingPassiveTransitions = null;
          var NESTED_UPDATE_LIMIT = 50;
          var nestedUpdateCount = 0;
          var rootWithNestedUpdates = null;
          var isFlushingPassiveEffects = false;
          var didScheduleUpdateDuringPassiveEffects = false;
          var NESTED_PASSIVE_UPDATE_LIMIT = 50;
          var nestedPassiveUpdateCount = 0;
          var rootWithPassiveNestedUpdates = null;
          var currentEventTime = NoTimestamp;
          var currentEventTransitionLane = NoLanes;
          var isRunningInsertionEffect = false;
          function getWorkInProgressRoot() {
            return workInProgressRoot;
          }
          function requestEventTime() {
            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
              return now3();
            }
            if (currentEventTime !== NoTimestamp) {
              return currentEventTime;
            }
            currentEventTime = now3();
            return currentEventTime;
          }
          function requestUpdateLane(fiber) {
            var mode = fiber.mode;
            if ((mode & ConcurrentMode) === NoMode) {
              return SyncLane;
            } else if ((executionContext & RenderContext) !== NoContext && workInProgressRootRenderLanes !== NoLanes) {
              return pickArbitraryLane(workInProgressRootRenderLanes);
            }
            var isTransition = requestCurrentTransition() !== NoTransition;
            if (isTransition) {
              if (ReactCurrentBatchConfig$3.transition !== null) {
                var transition = ReactCurrentBatchConfig$3.transition;
                if (!transition._updatedFibers) {
                  transition._updatedFibers = /* @__PURE__ */ new Set();
                }
                transition._updatedFibers.add(fiber);
              }
              if (currentEventTransitionLane === NoLane) {
                currentEventTransitionLane = claimNextTransitionLane();
              }
              return currentEventTransitionLane;
            }
            var updateLane = getCurrentUpdatePriority();
            if (updateLane !== NoLane) {
              return updateLane;
            }
            var eventLane = getCurrentEventPriority();
            return eventLane;
          }
          function requestRetryLane(fiber) {
            var mode = fiber.mode;
            if ((mode & ConcurrentMode) === NoMode) {
              return SyncLane;
            }
            return claimNextRetryLane();
          }
          function scheduleUpdateOnFiber(root3, fiber, lane, eventTime) {
            checkForNestedUpdates();
            {
              if (isRunningInsertionEffect) {
                error("useInsertionEffect must not schedule updates.");
              }
            }
            {
              if (isFlushingPassiveEffects) {
                didScheduleUpdateDuringPassiveEffects = true;
              }
            }
            markRootUpdated(root3, lane, eventTime);
            if ((executionContext & RenderContext) !== NoLanes && root3 === workInProgressRoot) {
              warnAboutRenderPhaseUpdatesInDEV(fiber);
            } else {
              {
                if (isDevToolsPresent) {
                  addFiberToLanesMap(root3, fiber, lane);
                }
              }
              warnIfUpdatesNotWrappedWithActDEV(fiber);
              if (root3 === workInProgressRoot) {
                if ((executionContext & RenderContext) === NoContext) {
                  workInProgressRootInterleavedUpdatedLanes = mergeLanes(workInProgressRootInterleavedUpdatedLanes, lane);
                }
                if (workInProgressRootExitStatus === RootSuspendedWithDelay) {
                  markRootSuspended$1(root3, workInProgressRootRenderLanes);
                }
              }
              ensureRootIsScheduled(root3, eventTime);
              if (lane === SyncLane && executionContext === NoContext && (fiber.mode & ConcurrentMode) === NoMode && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
              !ReactCurrentActQueue$1.isBatchingLegacy) {
                resetRenderTimer();
                flushSyncCallbacksOnlyInLegacyMode();
              }
            }
          }
          function scheduleInitialHydrationOnRoot(root3, lane, eventTime) {
            var current2 = root3.current;
            current2.lanes = lane;
            markRootUpdated(root3, lane, eventTime);
            ensureRootIsScheduled(root3, eventTime);
          }
          function isUnsafeClassRenderPhaseUpdate(fiber) {
            return (
              // TODO: Remove outdated deferRenderPhaseUpdateToNextBatch experiment. We
              // decided not to enable it.
              (executionContext & RenderContext) !== NoContext
            );
          }
          function ensureRootIsScheduled(root3, currentTime) {
            var existingCallbackNode = root3.callbackNode;
            markStarvedLanesAsExpired(root3, currentTime);
            var nextLanes = getNextLanes(root3, root3 === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);
            if (nextLanes === NoLanes) {
              if (existingCallbackNode !== null) {
                cancelCallback$1(existingCallbackNode);
              }
              root3.callbackNode = null;
              root3.callbackPriority = NoLane;
              return;
            }
            var newCallbackPriority = getHighestPriorityLane(nextLanes);
            var existingCallbackPriority = root3.callbackPriority;
            if (existingCallbackPriority === newCallbackPriority && // Special case related to `act`. If the currently scheduled task is a
            // Scheduler task, rather than an `act` task, cancel it and re-scheduled
            // on the `act` queue.
            !(ReactCurrentActQueue$1.current !== null && existingCallbackNode !== fakeActCallbackNode)) {
              {
                if (existingCallbackNode == null && existingCallbackPriority !== SyncLane) {
                  error("Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.");
                }
              }
              return;
            }
            if (existingCallbackNode != null) {
              cancelCallback$1(existingCallbackNode);
            }
            var newCallbackNode;
            if (newCallbackPriority === SyncLane) {
              if (root3.tag === LegacyRoot) {
                if (ReactCurrentActQueue$1.isBatchingLegacy !== null) {
                  ReactCurrentActQueue$1.didScheduleLegacyUpdate = true;
                }
                scheduleLegacySyncCallback(performSyncWorkOnRoot.bind(null, root3));
              } else {
                scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root3));
              }
              {
                if (ReactCurrentActQueue$1.current !== null) {
                  ReactCurrentActQueue$1.current.push(flushSyncCallbacks);
                } else {
                  scheduleMicrotask(function() {
                    if ((executionContext & (RenderContext | CommitContext)) === NoContext) {
                      flushSyncCallbacks();
                    }
                  });
                }
              }
              newCallbackNode = null;
            } else {
              var schedulerPriorityLevel;
              switch (lanesToEventPriority(nextLanes)) {
                case DiscreteEventPriority:
                  schedulerPriorityLevel = ImmediatePriority;
                  break;
                case ContinuousEventPriority:
                  schedulerPriorityLevel = UserBlockingPriority;
                  break;
                case DefaultEventPriority:
                  schedulerPriorityLevel = NormalPriority;
                  break;
                case IdleEventPriority:
                  schedulerPriorityLevel = IdlePriority;
                  break;
                default:
                  schedulerPriorityLevel = NormalPriority;
                  break;
              }
              newCallbackNode = scheduleCallback$1(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(null, root3));
            }
            root3.callbackPriority = newCallbackPriority;
            root3.callbackNode = newCallbackNode;
          }
          function performConcurrentWorkOnRoot(root3, didTimeout) {
            {
              resetNestedUpdateFlag();
            }
            currentEventTime = NoTimestamp;
            currentEventTransitionLane = NoLanes;
            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
              throw new Error("Should not already be working.");
            }
            var originalCallbackNode = root3.callbackNode;
            var didFlushPassiveEffects = flushPassiveEffects();
            if (didFlushPassiveEffects) {
              if (root3.callbackNode !== originalCallbackNode) {
                return null;
              }
            }
            var lanes = getNextLanes(root3, root3 === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);
            if (lanes === NoLanes) {
              return null;
            }
            var shouldTimeSlice = !includesBlockingLane(root3, lanes) && !includesExpiredLane(root3, lanes) && !didTimeout;
            var exitStatus = shouldTimeSlice ? renderRootConcurrent(root3, lanes) : renderRootSync(root3, lanes);
            if (exitStatus !== RootInProgress) {
              if (exitStatus === RootErrored) {
                var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root3);
                if (errorRetryLanes !== NoLanes) {
                  lanes = errorRetryLanes;
                  exitStatus = recoverFromConcurrentError(root3, errorRetryLanes);
                }
              }
              if (exitStatus === RootFatalErrored) {
                var fatalError = workInProgressRootFatalError;
                prepareFreshStack(root3, NoLanes);
                markRootSuspended$1(root3, lanes);
                ensureRootIsScheduled(root3, now3());
                throw fatalError;
              }
              if (exitStatus === RootDidNotComplete) {
                markRootSuspended$1(root3, lanes);
              } else {
                var renderWasConcurrent = !includesBlockingLane(root3, lanes);
                var finishedWork = root3.current.alternate;
                if (renderWasConcurrent && !isRenderConsistentWithExternalStores(finishedWork)) {
                  exitStatus = renderRootSync(root3, lanes);
                  if (exitStatus === RootErrored) {
                    var _errorRetryLanes = getLanesToRetrySynchronouslyOnError(root3);
                    if (_errorRetryLanes !== NoLanes) {
                      lanes = _errorRetryLanes;
                      exitStatus = recoverFromConcurrentError(root3, _errorRetryLanes);
                    }
                  }
                  if (exitStatus === RootFatalErrored) {
                    var _fatalError = workInProgressRootFatalError;
                    prepareFreshStack(root3, NoLanes);
                    markRootSuspended$1(root3, lanes);
                    ensureRootIsScheduled(root3, now3());
                    throw _fatalError;
                  }
                }
                root3.finishedWork = finishedWork;
                root3.finishedLanes = lanes;
                finishConcurrentRender(root3, exitStatus, lanes);
              }
            }
            ensureRootIsScheduled(root3, now3());
            if (root3.callbackNode === originalCallbackNode) {
              return performConcurrentWorkOnRoot.bind(null, root3);
            }
            return null;
          }
          function recoverFromConcurrentError(root3, errorRetryLanes) {
            var errorsFromFirstAttempt = workInProgressRootConcurrentErrors;
            if (isRootDehydrated(root3)) {
              var rootWorkInProgress = prepareFreshStack(root3, errorRetryLanes);
              rootWorkInProgress.flags |= ForceClientRender;
              {
                errorHydratingContainer(root3.containerInfo);
              }
            }
            var exitStatus = renderRootSync(root3, errorRetryLanes);
            if (exitStatus !== RootErrored) {
              var errorsFromSecondAttempt = workInProgressRootRecoverableErrors;
              workInProgressRootRecoverableErrors = errorsFromFirstAttempt;
              if (errorsFromSecondAttempt !== null) {
                queueRecoverableErrors(errorsFromSecondAttempt);
              }
            }
            return exitStatus;
          }
          function queueRecoverableErrors(errors) {
            if (workInProgressRootRecoverableErrors === null) {
              workInProgressRootRecoverableErrors = errors;
            } else {
              workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, errors);
            }
          }
          function finishConcurrentRender(root3, exitStatus, lanes) {
            switch (exitStatus) {
              case RootInProgress:
              case RootFatalErrored: {
                throw new Error("Root did not complete. This is a bug in React.");
              }
              // Flow knows about invariant, so it complains if I add a break
              // statement, but eslint doesn't know about invariant, so it complains
              // if I do. eslint-disable-next-line no-fallthrough
              case RootErrored: {
                commitRoot(root3, workInProgressRootRecoverableErrors, workInProgressTransitions);
                break;
              }
              case RootSuspended: {
                markRootSuspended$1(root3, lanes);
                if (includesOnlyRetries(lanes) && // do not delay if we're inside an act() scope
                !shouldForceFlushFallbacksInDEV()) {
                  var msUntilTimeout = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now3();
                  if (msUntilTimeout > 10) {
                    var nextLanes = getNextLanes(root3, NoLanes);
                    if (nextLanes !== NoLanes) {
                      break;
                    }
                    var suspendedLanes = root3.suspendedLanes;
                    if (!isSubsetOfLanes(suspendedLanes, lanes)) {
                      var eventTime = requestEventTime();
                      markRootPinged(root3, suspendedLanes);
                      break;
                    }
                    root3.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root3, workInProgressRootRecoverableErrors, workInProgressTransitions), msUntilTimeout);
                    break;
                  }
                }
                commitRoot(root3, workInProgressRootRecoverableErrors, workInProgressTransitions);
                break;
              }
              case RootSuspendedWithDelay: {
                markRootSuspended$1(root3, lanes);
                if (includesOnlyTransitions(lanes)) {
                  break;
                }
                if (!shouldForceFlushFallbacksInDEV()) {
                  var mostRecentEventTime = getMostRecentEventTime(root3, lanes);
                  var eventTimeMs = mostRecentEventTime;
                  var timeElapsedMs = now3() - eventTimeMs;
                  var _msUntilTimeout = jnd(timeElapsedMs) - timeElapsedMs;
                  if (_msUntilTimeout > 10) {
                    root3.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root3, workInProgressRootRecoverableErrors, workInProgressTransitions), _msUntilTimeout);
                    break;
                  }
                }
                commitRoot(root3, workInProgressRootRecoverableErrors, workInProgressTransitions);
                break;
              }
              case RootCompleted: {
                commitRoot(root3, workInProgressRootRecoverableErrors, workInProgressTransitions);
                break;
              }
              default: {
                throw new Error("Unknown root exit status.");
              }
            }
          }
          function isRenderConsistentWithExternalStores(finishedWork) {
            var node = finishedWork;
            while (true) {
              if (node.flags & StoreConsistency) {
                var updateQueue = node.updateQueue;
                if (updateQueue !== null) {
                  var checks = updateQueue.stores;
                  if (checks !== null) {
                    for (var i = 0; i < checks.length; i++) {
                      var check = checks[i];
                      var getSnapshot = check.getSnapshot;
                      var renderedValue = check.value;
                      try {
                        if (!objectIs(getSnapshot(), renderedValue)) {
                          return false;
                        }
                      } catch (error2) {
                        return false;
                      }
                    }
                  }
                }
              }
              var child = node.child;
              if (node.subtreeFlags & StoreConsistency && child !== null) {
                child.return = node;
                node = child;
                continue;
              }
              if (node === finishedWork) {
                return true;
              }
              while (node.sibling === null) {
                if (node.return === null || node.return === finishedWork) {
                  return true;
                }
                node = node.return;
              }
              node.sibling.return = node.return;
              node = node.sibling;
            }
            return true;
          }
          function markRootSuspended$1(root3, suspendedLanes) {
            suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes);
            suspendedLanes = removeLanes(suspendedLanes, workInProgressRootInterleavedUpdatedLanes);
            markRootSuspended(root3, suspendedLanes);
          }
          function performSyncWorkOnRoot(root3) {
            {
              syncNestedUpdateFlag();
            }
            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
              throw new Error("Should not already be working.");
            }
            flushPassiveEffects();
            var lanes = getNextLanes(root3, NoLanes);
            if (!includesSomeLane(lanes, SyncLane)) {
              ensureRootIsScheduled(root3, now3());
              return null;
            }
            var exitStatus = renderRootSync(root3, lanes);
            if (root3.tag !== LegacyRoot && exitStatus === RootErrored) {
              var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root3);
              if (errorRetryLanes !== NoLanes) {
                lanes = errorRetryLanes;
                exitStatus = recoverFromConcurrentError(root3, errorRetryLanes);
              }
            }
            if (exitStatus === RootFatalErrored) {
              var fatalError = workInProgressRootFatalError;
              prepareFreshStack(root3, NoLanes);
              markRootSuspended$1(root3, lanes);
              ensureRootIsScheduled(root3, now3());
              throw fatalError;
            }
            if (exitStatus === RootDidNotComplete) {
              throw new Error("Root did not complete. This is a bug in React.");
            }
            var finishedWork = root3.current.alternate;
            root3.finishedWork = finishedWork;
            root3.finishedLanes = lanes;
            commitRoot(root3, workInProgressRootRecoverableErrors, workInProgressTransitions);
            ensureRootIsScheduled(root3, now3());
            return null;
          }
          function flushRoot(root3, lanes) {
            if (lanes !== NoLanes) {
              markRootEntangled(root3, mergeLanes(lanes, SyncLane));
              ensureRootIsScheduled(root3, now3());
              if ((executionContext & (RenderContext | CommitContext)) === NoContext) {
                resetRenderTimer();
                flushSyncCallbacks();
              }
            }
          }
          function batchedUpdates$1(fn, a) {
            var prevExecutionContext = executionContext;
            executionContext |= BatchedContext;
            try {
              return fn(a);
            } finally {
              executionContext = prevExecutionContext;
              if (executionContext === NoContext && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
              !ReactCurrentActQueue$1.isBatchingLegacy) {
                resetRenderTimer();
                flushSyncCallbacksOnlyInLegacyMode();
              }
            }
          }
          function discreteUpdates(fn, a, b, c, d) {
            var previousPriority = getCurrentUpdatePriority();
            var prevTransition = ReactCurrentBatchConfig$3.transition;
            try {
              ReactCurrentBatchConfig$3.transition = null;
              setCurrentUpdatePriority(DiscreteEventPriority);
              return fn(a, b, c, d);
            } finally {
              setCurrentUpdatePriority(previousPriority);
              ReactCurrentBatchConfig$3.transition = prevTransition;
              if (executionContext === NoContext) {
                resetRenderTimer();
              }
            }
          }
          function flushSync(fn) {
            if (rootWithPendingPassiveEffects !== null && rootWithPendingPassiveEffects.tag === LegacyRoot && (executionContext & (RenderContext | CommitContext)) === NoContext) {
              flushPassiveEffects();
            }
            var prevExecutionContext = executionContext;
            executionContext |= BatchedContext;
            var prevTransition = ReactCurrentBatchConfig$3.transition;
            var previousPriority = getCurrentUpdatePriority();
            try {
              ReactCurrentBatchConfig$3.transition = null;
              setCurrentUpdatePriority(DiscreteEventPriority);
              if (fn) {
                return fn();
              } else {
                return void 0;
              }
            } finally {
              setCurrentUpdatePriority(previousPriority);
              ReactCurrentBatchConfig$3.transition = prevTransition;
              executionContext = prevExecutionContext;
              if ((executionContext & (RenderContext | CommitContext)) === NoContext) {
                flushSyncCallbacks();
              }
            }
          }
          function isAlreadyRendering() {
            return (executionContext & (RenderContext | CommitContext)) !== NoContext;
          }
          function pushRenderLanes(fiber, lanes) {
            push2(subtreeRenderLanesCursor, subtreeRenderLanes, fiber);
            subtreeRenderLanes = mergeLanes(subtreeRenderLanes, lanes);
            workInProgressRootIncludedLanes = mergeLanes(workInProgressRootIncludedLanes, lanes);
          }
          function popRenderLanes(fiber) {
            subtreeRenderLanes = subtreeRenderLanesCursor.current;
            pop(subtreeRenderLanesCursor, fiber);
          }
          function prepareFreshStack(root3, lanes) {
            root3.finishedWork = null;
            root3.finishedLanes = NoLanes;
            var timeoutHandle = root3.timeoutHandle;
            if (timeoutHandle !== noTimeout) {
              root3.timeoutHandle = noTimeout;
              cancelTimeout(timeoutHandle);
            }
            if (workInProgress !== null) {
              var interruptedWork = workInProgress.return;
              while (interruptedWork !== null) {
                var current2 = interruptedWork.alternate;
                unwindInterruptedWork(current2, interruptedWork);
                interruptedWork = interruptedWork.return;
              }
            }
            workInProgressRoot = root3;
            var rootWorkInProgress = createWorkInProgress(root3.current, null);
            workInProgress = rootWorkInProgress;
            workInProgressRootRenderLanes = subtreeRenderLanes = workInProgressRootIncludedLanes = lanes;
            workInProgressRootExitStatus = RootInProgress;
            workInProgressRootFatalError = null;
            workInProgressRootSkippedLanes = NoLanes;
            workInProgressRootInterleavedUpdatedLanes = NoLanes;
            workInProgressRootPingedLanes = NoLanes;
            workInProgressRootConcurrentErrors = null;
            workInProgressRootRecoverableErrors = null;
            finishQueueingConcurrentUpdates();
            {
              ReactStrictModeWarnings.discardPendingWarnings();
            }
            return rootWorkInProgress;
          }
          function handleError(root3, thrownValue) {
            do {
              var erroredWork = workInProgress;
              try {
                resetContextDependencies();
                resetHooksAfterThrow();
                resetCurrentFiber();
                ReactCurrentOwner$2.current = null;
                if (erroredWork === null || erroredWork.return === null) {
                  workInProgressRootExitStatus = RootFatalErrored;
                  workInProgressRootFatalError = thrownValue;
                  workInProgress = null;
                  return;
                }
                if (enableProfilerTimer && erroredWork.mode & ProfileMode) {
                  stopProfilerTimerIfRunningAndRecordDelta(erroredWork, true);
                }
                if (enableSchedulingProfiler) {
                  markComponentRenderStopped();
                  if (thrownValue !== null && typeof thrownValue === "object" && typeof thrownValue.then === "function") {
                    var wakeable = thrownValue;
                    markComponentSuspended(erroredWork, wakeable, workInProgressRootRenderLanes);
                  } else {
                    markComponentErrored(erroredWork, thrownValue, workInProgressRootRenderLanes);
                  }
                }
                throwException(root3, erroredWork.return, erroredWork, thrownValue, workInProgressRootRenderLanes);
                completeUnitOfWork(erroredWork);
              } catch (yetAnotherThrownValue) {
                thrownValue = yetAnotherThrownValue;
                if (workInProgress === erroredWork && erroredWork !== null) {
                  erroredWork = erroredWork.return;
                  workInProgress = erroredWork;
                } else {
                  erroredWork = workInProgress;
                }
                continue;
              }
              return;
            } while (true);
          }
          function pushDispatcher() {
            var prevDispatcher = ReactCurrentDispatcher$2.current;
            ReactCurrentDispatcher$2.current = ContextOnlyDispatcher;
            if (prevDispatcher === null) {
              return ContextOnlyDispatcher;
            } else {
              return prevDispatcher;
            }
          }
          function popDispatcher(prevDispatcher) {
            ReactCurrentDispatcher$2.current = prevDispatcher;
          }
          function markCommitTimeOfFallback() {
            globalMostRecentFallbackTime = now3();
          }
          function markSkippedUpdateLanes(lane) {
            workInProgressRootSkippedLanes = mergeLanes(lane, workInProgressRootSkippedLanes);
          }
          function renderDidSuspend() {
            if (workInProgressRootExitStatus === RootInProgress) {
              workInProgressRootExitStatus = RootSuspended;
            }
          }
          function renderDidSuspendDelayIfPossible() {
            if (workInProgressRootExitStatus === RootInProgress || workInProgressRootExitStatus === RootSuspended || workInProgressRootExitStatus === RootErrored) {
              workInProgressRootExitStatus = RootSuspendedWithDelay;
            }
            if (workInProgressRoot !== null && (includesNonIdleWork(workInProgressRootSkippedLanes) || includesNonIdleWork(workInProgressRootInterleavedUpdatedLanes))) {
              markRootSuspended$1(workInProgressRoot, workInProgressRootRenderLanes);
            }
          }
          function renderDidError(error2) {
            if (workInProgressRootExitStatus !== RootSuspendedWithDelay) {
              workInProgressRootExitStatus = RootErrored;
            }
            if (workInProgressRootConcurrentErrors === null) {
              workInProgressRootConcurrentErrors = [error2];
            } else {
              workInProgressRootConcurrentErrors.push(error2);
            }
          }
          function renderHasNotSuspendedYet() {
            return workInProgressRootExitStatus === RootInProgress;
          }
          function renderRootSync(root3, lanes) {
            var prevExecutionContext = executionContext;
            executionContext |= RenderContext;
            var prevDispatcher = pushDispatcher();
            if (workInProgressRoot !== root3 || workInProgressRootRenderLanes !== lanes) {
              {
                if (isDevToolsPresent) {
                  var memoizedUpdaters = root3.memoizedUpdaters;
                  if (memoizedUpdaters.size > 0) {
                    restorePendingUpdaters(root3, workInProgressRootRenderLanes);
                    memoizedUpdaters.clear();
                  }
                  movePendingFibersToMemoized(root3, lanes);
                }
              }
              workInProgressTransitions = getTransitionsForLanes();
              prepareFreshStack(root3, lanes);
            }
            {
              markRenderStarted(lanes);
            }
            do {
              try {
                workLoopSync();
                break;
              } catch (thrownValue) {
                handleError(root3, thrownValue);
              }
            } while (true);
            resetContextDependencies();
            executionContext = prevExecutionContext;
            popDispatcher(prevDispatcher);
            if (workInProgress !== null) {
              throw new Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
            }
            {
              markRenderStopped();
            }
            workInProgressRoot = null;
            workInProgressRootRenderLanes = NoLanes;
            return workInProgressRootExitStatus;
          }
          function workLoopSync() {
            while (workInProgress !== null) {
              performUnitOfWork(workInProgress);
            }
          }
          function renderRootConcurrent(root3, lanes) {
            var prevExecutionContext = executionContext;
            executionContext |= RenderContext;
            var prevDispatcher = pushDispatcher();
            if (workInProgressRoot !== root3 || workInProgressRootRenderLanes !== lanes) {
              {
                if (isDevToolsPresent) {
                  var memoizedUpdaters = root3.memoizedUpdaters;
                  if (memoizedUpdaters.size > 0) {
                    restorePendingUpdaters(root3, workInProgressRootRenderLanes);
                    memoizedUpdaters.clear();
                  }
                  movePendingFibersToMemoized(root3, lanes);
                }
              }
              workInProgressTransitions = getTransitionsForLanes();
              resetRenderTimer();
              prepareFreshStack(root3, lanes);
            }
            {
              markRenderStarted(lanes);
            }
            do {
              try {
                workLoopConcurrent();
                break;
              } catch (thrownValue) {
                handleError(root3, thrownValue);
              }
            } while (true);
            resetContextDependencies();
            popDispatcher(prevDispatcher);
            executionContext = prevExecutionContext;
            if (workInProgress !== null) {
              {
                markRenderYielded();
              }
              return RootInProgress;
            } else {
              {
                markRenderStopped();
              }
              workInProgressRoot = null;
              workInProgressRootRenderLanes = NoLanes;
              return workInProgressRootExitStatus;
            }
          }
          function workLoopConcurrent() {
            while (workInProgress !== null && !shouldYield()) {
              performUnitOfWork(workInProgress);
            }
          }
          function performUnitOfWork(unitOfWork) {
            var current2 = unitOfWork.alternate;
            setCurrentFiber(unitOfWork);
            var next;
            if ((unitOfWork.mode & ProfileMode) !== NoMode) {
              startProfilerTimer(unitOfWork);
              next = beginWork$1(current2, unitOfWork, subtreeRenderLanes);
              stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);
            } else {
              next = beginWork$1(current2, unitOfWork, subtreeRenderLanes);
            }
            resetCurrentFiber();
            unitOfWork.memoizedProps = unitOfWork.pendingProps;
            if (next === null) {
              completeUnitOfWork(unitOfWork);
            } else {
              workInProgress = next;
            }
            ReactCurrentOwner$2.current = null;
          }
          function completeUnitOfWork(unitOfWork) {
            var completedWork = unitOfWork;
            do {
              var current2 = completedWork.alternate;
              var returnFiber = completedWork.return;
              if ((completedWork.flags & Incomplete) === NoFlags) {
                setCurrentFiber(completedWork);
                var next = void 0;
                if ((completedWork.mode & ProfileMode) === NoMode) {
                  next = completeWork(current2, completedWork, subtreeRenderLanes);
                } else {
                  startProfilerTimer(completedWork);
                  next = completeWork(current2, completedWork, subtreeRenderLanes);
                  stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);
                }
                resetCurrentFiber();
                if (next !== null) {
                  workInProgress = next;
                  return;
                }
              } else {
                var _next = unwindWork(current2, completedWork);
                if (_next !== null) {
                  _next.flags &= HostEffectMask;
                  workInProgress = _next;
                  return;
                }
                if ((completedWork.mode & ProfileMode) !== NoMode) {
                  stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);
                  var actualDuration = completedWork.actualDuration;
                  var child = completedWork.child;
                  while (child !== null) {
                    actualDuration += child.actualDuration;
                    child = child.sibling;
                  }
                  completedWork.actualDuration = actualDuration;
                }
                if (returnFiber !== null) {
                  returnFiber.flags |= Incomplete;
                  returnFiber.subtreeFlags = NoFlags;
                  returnFiber.deletions = null;
                } else {
                  workInProgressRootExitStatus = RootDidNotComplete;
                  workInProgress = null;
                  return;
                }
              }
              var siblingFiber = completedWork.sibling;
              if (siblingFiber !== null) {
                workInProgress = siblingFiber;
                return;
              }
              completedWork = returnFiber;
              workInProgress = completedWork;
            } while (completedWork !== null);
            if (workInProgressRootExitStatus === RootInProgress) {
              workInProgressRootExitStatus = RootCompleted;
            }
          }
          function commitRoot(root3, recoverableErrors, transitions) {
            var previousUpdateLanePriority = getCurrentUpdatePriority();
            var prevTransition = ReactCurrentBatchConfig$3.transition;
            try {
              ReactCurrentBatchConfig$3.transition = null;
              setCurrentUpdatePriority(DiscreteEventPriority);
              commitRootImpl(root3, recoverableErrors, transitions, previousUpdateLanePriority);
            } finally {
              ReactCurrentBatchConfig$3.transition = prevTransition;
              setCurrentUpdatePriority(previousUpdateLanePriority);
            }
            return null;
          }
          function commitRootImpl(root3, recoverableErrors, transitions, renderPriorityLevel) {
            do {
              flushPassiveEffects();
            } while (rootWithPendingPassiveEffects !== null);
            flushRenderPhaseStrictModeWarningsInDEV();
            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
              throw new Error("Should not already be working.");
            }
            var finishedWork = root3.finishedWork;
            var lanes = root3.finishedLanes;
            {
              markCommitStarted(lanes);
            }
            if (finishedWork === null) {
              {
                markCommitStopped();
              }
              return null;
            } else {
              {
                if (lanes === NoLanes) {
                  error("root.finishedLanes should not be empty during a commit. This is a bug in React.");
                }
              }
            }
            root3.finishedWork = null;
            root3.finishedLanes = NoLanes;
            if (finishedWork === root3.current) {
              throw new Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
            }
            root3.callbackNode = null;
            root3.callbackPriority = NoLane;
            var remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);
            markRootFinished(root3, remainingLanes);
            if (root3 === workInProgressRoot) {
              workInProgressRoot = null;
              workInProgress = null;
              workInProgressRootRenderLanes = NoLanes;
            }
            if ((finishedWork.subtreeFlags & PassiveMask) !== NoFlags || (finishedWork.flags & PassiveMask) !== NoFlags) {
              if (!rootDoesHavePassiveEffects) {
                rootDoesHavePassiveEffects = true;
                pendingPassiveTransitions = transitions;
                scheduleCallback$1(NormalPriority, function() {
                  flushPassiveEffects();
                  return null;
                });
              }
            }
            var subtreeHasEffects = (finishedWork.subtreeFlags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags;
            var rootHasEffect = (finishedWork.flags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags;
            if (subtreeHasEffects || rootHasEffect) {
              var prevTransition = ReactCurrentBatchConfig$3.transition;
              ReactCurrentBatchConfig$3.transition = null;
              var previousPriority = getCurrentUpdatePriority();
              setCurrentUpdatePriority(DiscreteEventPriority);
              var prevExecutionContext = executionContext;
              executionContext |= CommitContext;
              ReactCurrentOwner$2.current = null;
              var shouldFireAfterActiveInstanceBlur2 = commitBeforeMutationEffects(root3, finishedWork);
              {
                recordCommitTime();
              }
              commitMutationEffects(root3, finishedWork, lanes);
              resetAfterCommit(root3.containerInfo);
              root3.current = finishedWork;
              {
                markLayoutEffectsStarted(lanes);
              }
              commitLayoutEffects(finishedWork, root3, lanes);
              {
                markLayoutEffectsStopped();
              }
              requestPaint();
              executionContext = prevExecutionContext;
              setCurrentUpdatePriority(previousPriority);
              ReactCurrentBatchConfig$3.transition = prevTransition;
            } else {
              root3.current = finishedWork;
              {
                recordCommitTime();
              }
            }
            var rootDidHavePassiveEffects = rootDoesHavePassiveEffects;
            if (rootDoesHavePassiveEffects) {
              rootDoesHavePassiveEffects = false;
              rootWithPendingPassiveEffects = root3;
              pendingPassiveEffectsLanes = lanes;
            } else {
              {
                nestedPassiveUpdateCount = 0;
                rootWithPassiveNestedUpdates = null;
              }
            }
            remainingLanes = root3.pendingLanes;
            if (remainingLanes === NoLanes) {
              legacyErrorBoundariesThatAlreadyFailed = null;
            }
            {
              if (!rootDidHavePassiveEffects) {
                commitDoubleInvokeEffectsInDEV(root3.current, false);
              }
            }
            onCommitRoot(finishedWork.stateNode, renderPriorityLevel);
            {
              if (isDevToolsPresent) {
                root3.memoizedUpdaters.clear();
              }
            }
            {
              onCommitRoot$1();
            }
            ensureRootIsScheduled(root3, now3());
            if (recoverableErrors !== null) {
              var onRecoverableError = root3.onRecoverableError;
              for (var i = 0; i < recoverableErrors.length; i++) {
                var recoverableError = recoverableErrors[i];
                var componentStack = recoverableError.stack;
                var digest = recoverableError.digest;
                onRecoverableError(recoverableError.value, {
                  componentStack,
                  digest
                });
              }
            }
            if (hasUncaughtError) {
              hasUncaughtError = false;
              var error$1 = firstUncaughtError;
              firstUncaughtError = null;
              throw error$1;
            }
            if (includesSomeLane(pendingPassiveEffectsLanes, SyncLane) && root3.tag !== LegacyRoot) {
              flushPassiveEffects();
            }
            remainingLanes = root3.pendingLanes;
            if (includesSomeLane(remainingLanes, SyncLane)) {
              {
                markNestedUpdateScheduled();
              }
              if (root3 === rootWithNestedUpdates) {
                nestedUpdateCount++;
              } else {
                nestedUpdateCount = 0;
                rootWithNestedUpdates = root3;
              }
            } else {
              nestedUpdateCount = 0;
            }
            flushSyncCallbacks();
            {
              markCommitStopped();
            }
            return null;
          }
          function flushPassiveEffects() {
            if (rootWithPendingPassiveEffects !== null) {
              var renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes);
              var priority = lowerEventPriority(DefaultEventPriority, renderPriority);
              var prevTransition = ReactCurrentBatchConfig$3.transition;
              var previousPriority = getCurrentUpdatePriority();
              try {
                ReactCurrentBatchConfig$3.transition = null;
                setCurrentUpdatePriority(priority);
                return flushPassiveEffectsImpl();
              } finally {
                setCurrentUpdatePriority(previousPriority);
                ReactCurrentBatchConfig$3.transition = prevTransition;
              }
            }
            return false;
          }
          function enqueuePendingPassiveProfilerEffect(fiber) {
            {
              pendingPassiveProfilerEffects.push(fiber);
              if (!rootDoesHavePassiveEffects) {
                rootDoesHavePassiveEffects = true;
                scheduleCallback$1(NormalPriority, function() {
                  flushPassiveEffects();
                  return null;
                });
              }
            }
          }
          function flushPassiveEffectsImpl() {
            if (rootWithPendingPassiveEffects === null) {
              return false;
            }
            var transitions = pendingPassiveTransitions;
            pendingPassiveTransitions = null;
            var root3 = rootWithPendingPassiveEffects;
            var lanes = pendingPassiveEffectsLanes;
            rootWithPendingPassiveEffects = null;
            pendingPassiveEffectsLanes = NoLanes;
            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
              throw new Error("Cannot flush passive effects while already rendering.");
            }
            {
              isFlushingPassiveEffects = true;
              didScheduleUpdateDuringPassiveEffects = false;
            }
            {
              markPassiveEffectsStarted(lanes);
            }
            var prevExecutionContext = executionContext;
            executionContext |= CommitContext;
            commitPassiveUnmountEffects(root3.current);
            commitPassiveMountEffects(root3, root3.current, lanes, transitions);
            {
              var profilerEffects = pendingPassiveProfilerEffects;
              pendingPassiveProfilerEffects = [];
              for (var i = 0; i < profilerEffects.length; i++) {
                var _fiber = profilerEffects[i];
                commitPassiveEffectDurations(root3, _fiber);
              }
            }
            {
              markPassiveEffectsStopped();
            }
            {
              commitDoubleInvokeEffectsInDEV(root3.current, true);
            }
            executionContext = prevExecutionContext;
            flushSyncCallbacks();
            {
              if (didScheduleUpdateDuringPassiveEffects) {
                if (root3 === rootWithPassiveNestedUpdates) {
                  nestedPassiveUpdateCount++;
                } else {
                  nestedPassiveUpdateCount = 0;
                  rootWithPassiveNestedUpdates = root3;
                }
              } else {
                nestedPassiveUpdateCount = 0;
              }
              isFlushingPassiveEffects = false;
              didScheduleUpdateDuringPassiveEffects = false;
            }
            onPostCommitRoot(root3);
            {
              var stateNode = root3.current.stateNode;
              stateNode.effectDuration = 0;
              stateNode.passiveEffectDuration = 0;
            }
            return true;
          }
          function isAlreadyFailedLegacyErrorBoundary(instance) {
            return legacyErrorBoundariesThatAlreadyFailed !== null && legacyErrorBoundariesThatAlreadyFailed.has(instance);
          }
          function markLegacyErrorBoundaryAsFailed(instance) {
            if (legacyErrorBoundariesThatAlreadyFailed === null) {
              legacyErrorBoundariesThatAlreadyFailed = /* @__PURE__ */ new Set([instance]);
            } else {
              legacyErrorBoundariesThatAlreadyFailed.add(instance);
            }
          }
          function prepareToThrowUncaughtError(error2) {
            if (!hasUncaughtError) {
              hasUncaughtError = true;
              firstUncaughtError = error2;
            }
          }
          var onUncaughtError = prepareToThrowUncaughtError;
          function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error2) {
            var errorInfo = createCapturedValueAtFiber(error2, sourceFiber);
            var update = createRootErrorUpdate(rootFiber, errorInfo, SyncLane);
            var root3 = enqueueUpdate(rootFiber, update, SyncLane);
            var eventTime = requestEventTime();
            if (root3 !== null) {
              markRootUpdated(root3, SyncLane, eventTime);
              ensureRootIsScheduled(root3, eventTime);
            }
          }
          function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error$1) {
            {
              reportUncaughtErrorInDEV(error$1);
              setIsRunningInsertionEffect(false);
            }
            if (sourceFiber.tag === HostRoot) {
              captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error$1);
              return;
            }
            var fiber = null;
            {
              fiber = nearestMountedAncestor;
            }
            while (fiber !== null) {
              if (fiber.tag === HostRoot) {
                captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error$1);
                return;
              } else if (fiber.tag === ClassComponent) {
                var ctor = fiber.type;
                var instance = fiber.stateNode;
                if (typeof ctor.getDerivedStateFromError === "function" || typeof instance.componentDidCatch === "function" && !isAlreadyFailedLegacyErrorBoundary(instance)) {
                  var errorInfo = createCapturedValueAtFiber(error$1, sourceFiber);
                  var update = createClassErrorUpdate(fiber, errorInfo, SyncLane);
                  var root3 = enqueueUpdate(fiber, update, SyncLane);
                  var eventTime = requestEventTime();
                  if (root3 !== null) {
                    markRootUpdated(root3, SyncLane, eventTime);
                    ensureRootIsScheduled(root3, eventTime);
                  }
                  return;
                }
              }
              fiber = fiber.return;
            }
            {
              error("Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Likely causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.\n\nError message:\n\n%s", error$1);
            }
          }
          function pingSuspendedRoot(root3, wakeable, pingedLanes) {
            var pingCache = root3.pingCache;
            if (pingCache !== null) {
              pingCache.delete(wakeable);
            }
            var eventTime = requestEventTime();
            markRootPinged(root3, pingedLanes);
            warnIfSuspenseResolutionNotWrappedWithActDEV(root3);
            if (workInProgressRoot === root3 && isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes)) {
              if (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && includesOnlyRetries(workInProgressRootRenderLanes) && now3() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS) {
                prepareFreshStack(root3, NoLanes);
              } else {
                workInProgressRootPingedLanes = mergeLanes(workInProgressRootPingedLanes, pingedLanes);
              }
            }
            ensureRootIsScheduled(root3, eventTime);
          }
          function retryTimedOutBoundary(boundaryFiber, retryLane) {
            if (retryLane === NoLane) {
              retryLane = requestRetryLane(boundaryFiber);
            }
            var eventTime = requestEventTime();
            var root3 = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
            if (root3 !== null) {
              markRootUpdated(root3, retryLane, eventTime);
              ensureRootIsScheduled(root3, eventTime);
            }
          }
          function retryDehydratedSuspenseBoundary(boundaryFiber) {
            var suspenseState = boundaryFiber.memoizedState;
            var retryLane = NoLane;
            if (suspenseState !== null) {
              retryLane = suspenseState.retryLane;
            }
            retryTimedOutBoundary(boundaryFiber, retryLane);
          }
          function resolveRetryWakeable(boundaryFiber, wakeable) {
            var retryLane = NoLane;
            var retryCache;
            switch (boundaryFiber.tag) {
              case SuspenseComponent:
                retryCache = boundaryFiber.stateNode;
                var suspenseState = boundaryFiber.memoizedState;
                if (suspenseState !== null) {
                  retryLane = suspenseState.retryLane;
                }
                break;
              case SuspenseListComponent:
                retryCache = boundaryFiber.stateNode;
                break;
              default:
                throw new Error("Pinged unknown suspense boundary type. This is probably a bug in React.");
            }
            if (retryCache !== null) {
              retryCache.delete(wakeable);
            }
            retryTimedOutBoundary(boundaryFiber, retryLane);
          }
          function jnd(timeElapsed) {
            return timeElapsed < 120 ? 120 : timeElapsed < 480 ? 480 : timeElapsed < 1080 ? 1080 : timeElapsed < 1920 ? 1920 : timeElapsed < 3e3 ? 3e3 : timeElapsed < 4320 ? 4320 : ceil(timeElapsed / 1960) * 1960;
          }
          function checkForNestedUpdates() {
            if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {
              nestedUpdateCount = 0;
              rootWithNestedUpdates = null;
              throw new Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
            }
            {
              if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {
                nestedPassiveUpdateCount = 0;
                rootWithPassiveNestedUpdates = null;
                error("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render.");
              }
            }
          }
          function flushRenderPhaseStrictModeWarningsInDEV() {
            {
              ReactStrictModeWarnings.flushLegacyContextWarning();
              {
                ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();
              }
            }
          }
          function commitDoubleInvokeEffectsInDEV(fiber, hasPassiveEffects) {
            {
              setCurrentFiber(fiber);
              invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectUnmountInDEV);
              if (hasPassiveEffects) {
                invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectUnmountInDEV);
              }
              invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectMountInDEV);
              if (hasPassiveEffects) {
                invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectMountInDEV);
              }
              resetCurrentFiber();
            }
          }
          function invokeEffectsInDev(firstChild, fiberFlags, invokeEffectFn) {
            {
              var current2 = firstChild;
              var subtreeRoot = null;
              while (current2 !== null) {
                var primarySubtreeFlag = current2.subtreeFlags & fiberFlags;
                if (current2 !== subtreeRoot && current2.child !== null && primarySubtreeFlag !== NoFlags) {
                  current2 = current2.child;
                } else {
                  if ((current2.flags & fiberFlags) !== NoFlags) {
                    invokeEffectFn(current2);
                  }
                  if (current2.sibling !== null) {
                    current2 = current2.sibling;
                  } else {
                    current2 = subtreeRoot = current2.return;
                  }
                }
              }
            }
          }
          var didWarnStateUpdateForNotYetMountedComponent = null;
          function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {
            {
              if ((executionContext & RenderContext) !== NoContext) {
                return;
              }
              if (!(fiber.mode & ConcurrentMode)) {
                return;
              }
              var tag = fiber.tag;
              if (tag !== IndeterminateComponent && tag !== HostRoot && tag !== ClassComponent && tag !== FunctionComponent && tag !== ForwardRef && tag !== MemoComponent && tag !== SimpleMemoComponent) {
                return;
              }
              var componentName = getComponentNameFromFiber(fiber) || "ReactComponent";
              if (didWarnStateUpdateForNotYetMountedComponent !== null) {
                if (didWarnStateUpdateForNotYetMountedComponent.has(componentName)) {
                  return;
                }
                didWarnStateUpdateForNotYetMountedComponent.add(componentName);
              } else {
                didWarnStateUpdateForNotYetMountedComponent = /* @__PURE__ */ new Set([componentName]);
              }
              var previousFiber = current;
              try {
                setCurrentFiber(fiber);
                error("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
              } finally {
                if (previousFiber) {
                  setCurrentFiber(fiber);
                } else {
                  resetCurrentFiber();
                }
              }
            }
          }
          var beginWork$1;
          {
            var dummyFiber = null;
            beginWork$1 = function(current2, unitOfWork, lanes) {
              var originalWorkInProgressCopy = assignFiberPropertiesInDEV(dummyFiber, unitOfWork);
              try {
                return beginWork(current2, unitOfWork, lanes);
              } catch (originalError) {
                if (didSuspendOrErrorWhileHydratingDEV() || originalError !== null && typeof originalError === "object" && typeof originalError.then === "function") {
                  throw originalError;
                }
                resetContextDependencies();
                resetHooksAfterThrow();
                unwindInterruptedWork(current2, unitOfWork);
                assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);
                if (unitOfWork.mode & ProfileMode) {
                  startProfilerTimer(unitOfWork);
                }
                invokeGuardedCallback(null, beginWork, null, current2, unitOfWork, lanes);
                if (hasCaughtError()) {
                  var replayError = clearCaughtError();
                  if (typeof replayError === "object" && replayError !== null && replayError._suppressLogging && typeof originalError === "object" && originalError !== null && !originalError._suppressLogging) {
                    originalError._suppressLogging = true;
                  }
                }
                throw originalError;
              }
            };
          }
          var didWarnAboutUpdateInRender = false;
          var didWarnAboutUpdateInRenderForAnotherComponent;
          {
            didWarnAboutUpdateInRenderForAnotherComponent = /* @__PURE__ */ new Set();
          }
          function warnAboutRenderPhaseUpdatesInDEV(fiber) {
            {
              if (isRendering && !getIsUpdatingOpaqueValueInRenderPhaseInDEV()) {
                switch (fiber.tag) {
                  case FunctionComponent:
                  case ForwardRef:
                  case SimpleMemoComponent: {
                    var renderingComponentName = workInProgress && getComponentNameFromFiber(workInProgress) || "Unknown";
                    var dedupeKey = renderingComponentName;
                    if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {
                      didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);
                      var setStateComponentName = getComponentNameFromFiber(fiber) || "Unknown";
                      error("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render", setStateComponentName, renderingComponentName, renderingComponentName);
                    }
                    break;
                  }
                  case ClassComponent: {
                    if (!didWarnAboutUpdateInRender) {
                      error("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state.");
                      didWarnAboutUpdateInRender = true;
                    }
                    break;
                  }
                }
              }
            }
          }
          function restorePendingUpdaters(root3, lanes) {
            {
              if (isDevToolsPresent) {
                var memoizedUpdaters = root3.memoizedUpdaters;
                memoizedUpdaters.forEach(function(schedulingFiber) {
                  addFiberToLanesMap(root3, schedulingFiber, lanes);
                });
              }
            }
          }
          var fakeActCallbackNode = {};
          function scheduleCallback$1(priorityLevel, callback) {
            {
              var actQueue = ReactCurrentActQueue$1.current;
              if (actQueue !== null) {
                actQueue.push(callback);
                return fakeActCallbackNode;
              } else {
                return scheduleCallback(priorityLevel, callback);
              }
            }
          }
          function cancelCallback$1(callbackNode) {
            if (callbackNode === fakeActCallbackNode) {
              return;
            }
            return cancelCallback(callbackNode);
          }
          function shouldForceFlushFallbacksInDEV() {
            return ReactCurrentActQueue$1.current !== null;
          }
          function warnIfUpdatesNotWrappedWithActDEV(fiber) {
            {
              if (fiber.mode & ConcurrentMode) {
                if (!isConcurrentActEnvironment()) {
                  return;
                }
              } else {
                if (!isLegacyActEnvironment()) {
                  return;
                }
                if (executionContext !== NoContext) {
                  return;
                }
                if (fiber.tag !== FunctionComponent && fiber.tag !== ForwardRef && fiber.tag !== SimpleMemoComponent) {
                  return;
                }
              }
              if (ReactCurrentActQueue$1.current === null) {
                var previousFiber = current;
                try {
                  setCurrentFiber(fiber);
                  error("An update to %s inside a test was not wrapped in act(...).\n\nWhen testing, code that causes React state updates should be wrapped into act(...):\n\nact(() => {\n  /* fire events that update state */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act", getComponentNameFromFiber(fiber));
                } finally {
                  if (previousFiber) {
                    setCurrentFiber(fiber);
                  } else {
                    resetCurrentFiber();
                  }
                }
              }
            }
          }
          function warnIfSuspenseResolutionNotWrappedWithActDEV(root3) {
            {
              if (root3.tag !== LegacyRoot && isConcurrentActEnvironment() && ReactCurrentActQueue$1.current === null) {
                error("A suspended resource finished loading inside a test, but the event was not wrapped in act(...).\n\nWhen testing, code that resolves suspended data should be wrapped into act(...):\n\nact(() => {\n  /* finish loading suspended data */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act");
              }
            }
          }
          function setIsRunningInsertionEffect(isRunning) {
            {
              isRunningInsertionEffect = isRunning;
            }
          }
          var resolveFamily = null;
          var failedBoundaries = null;
          var setRefreshHandler = function(handler) {
            {
              resolveFamily = handler;
            }
          };
          function resolveFunctionForHotReloading(type) {
            {
              if (resolveFamily === null) {
                return type;
              }
              var family = resolveFamily(type);
              if (family === void 0) {
                return type;
              }
              return family.current;
            }
          }
          function resolveClassForHotReloading(type) {
            return resolveFunctionForHotReloading(type);
          }
          function resolveForwardRefForHotReloading(type) {
            {
              if (resolveFamily === null) {
                return type;
              }
              var family = resolveFamily(type);
              if (family === void 0) {
                if (type !== null && type !== void 0 && typeof type.render === "function") {
                  var currentRender = resolveFunctionForHotReloading(type.render);
                  if (type.render !== currentRender) {
                    var syntheticType = {
                      $$typeof: REACT_FORWARD_REF_TYPE,
                      render: currentRender
                    };
                    if (type.displayName !== void 0) {
                      syntheticType.displayName = type.displayName;
                    }
                    return syntheticType;
                  }
                }
                return type;
              }
              return family.current;
            }
          }
          function isCompatibleFamilyForHotReloading(fiber, element) {
            {
              if (resolveFamily === null) {
                return false;
              }
              var prevType = fiber.elementType;
              var nextType = element.type;
              var needsCompareFamilies = false;
              var $$typeofNextType = typeof nextType === "object" && nextType !== null ? nextType.$$typeof : null;
              switch (fiber.tag) {
                case ClassComponent: {
                  if (typeof nextType === "function") {
                    needsCompareFamilies = true;
                  }
                  break;
                }
                case FunctionComponent: {
                  if (typeof nextType === "function") {
                    needsCompareFamilies = true;
                  } else if ($$typeofNextType === REACT_LAZY_TYPE) {
                    needsCompareFamilies = true;
                  }
                  break;
                }
                case ForwardRef: {
                  if ($$typeofNextType === REACT_FORWARD_REF_TYPE) {
                    needsCompareFamilies = true;
                  } else if ($$typeofNextType === REACT_LAZY_TYPE) {
                    needsCompareFamilies = true;
                  }
                  break;
                }
                case MemoComponent:
                case SimpleMemoComponent: {
                  if ($$typeofNextType === REACT_MEMO_TYPE) {
                    needsCompareFamilies = true;
                  } else if ($$typeofNextType === REACT_LAZY_TYPE) {
                    needsCompareFamilies = true;
                  }
                  break;
                }
                default:
                  return false;
              }
              if (needsCompareFamilies) {
                var prevFamily = resolveFamily(prevType);
                if (prevFamily !== void 0 && prevFamily === resolveFamily(nextType)) {
                  return true;
                }
              }
              return false;
            }
          }
          function markFailedErrorBoundaryForHotReloading(fiber) {
            {
              if (resolveFamily === null) {
                return;
              }
              if (typeof WeakSet !== "function") {
                return;
              }
              if (failedBoundaries === null) {
                failedBoundaries = /* @__PURE__ */ new WeakSet();
              }
              failedBoundaries.add(fiber);
            }
          }
          var scheduleRefresh = function(root3, update) {
            {
              if (resolveFamily === null) {
                return;
              }
              var staleFamilies = update.staleFamilies, updatedFamilies = update.updatedFamilies;
              flushPassiveEffects();
              flushSync(function() {
                scheduleFibersWithFamiliesRecursively(root3.current, updatedFamilies, staleFamilies);
              });
            }
          };
          var scheduleRoot = function(root3, element) {
            {
              if (root3.context !== emptyContextObject) {
                return;
              }
              flushPassiveEffects();
              flushSync(function() {
                updateContainer(element, root3, null, null);
              });
            }
          };
          function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {
            {
              var alternate = fiber.alternate, child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type;
              var candidateType = null;
              switch (tag) {
                case FunctionComponent:
                case SimpleMemoComponent:
                case ClassComponent:
                  candidateType = type;
                  break;
                case ForwardRef:
                  candidateType = type.render;
                  break;
              }
              if (resolveFamily === null) {
                throw new Error("Expected resolveFamily to be set during hot reload.");
              }
              var needsRender = false;
              var needsRemount = false;
              if (candidateType !== null) {
                var family = resolveFamily(candidateType);
                if (family !== void 0) {
                  if (staleFamilies.has(family)) {
                    needsRemount = true;
                  } else if (updatedFamilies.has(family)) {
                    if (tag === ClassComponent) {
                      needsRemount = true;
                    } else {
                      needsRender = true;
                    }
                  }
                }
              }
              if (failedBoundaries !== null) {
                if (failedBoundaries.has(fiber) || alternate !== null && failedBoundaries.has(alternate)) {
                  needsRemount = true;
                }
              }
              if (needsRemount) {
                fiber._debugNeedsRemount = true;
              }
              if (needsRemount || needsRender) {
                var _root3 = enqueueConcurrentRenderForLane(fiber, SyncLane);
                if (_root3 !== null) {
                  scheduleUpdateOnFiber(_root3, fiber, SyncLane, NoTimestamp);
                }
              }
              if (child !== null && !needsRemount) {
                scheduleFibersWithFamiliesRecursively(child, updatedFamilies, staleFamilies);
              }
              if (sibling !== null) {
                scheduleFibersWithFamiliesRecursively(sibling, updatedFamilies, staleFamilies);
              }
            }
          }
          var findHostInstancesForRefresh = function(root3, families) {
            {
              var hostInstances = /* @__PURE__ */ new Set();
              var types = new Set(families.map(function(family) {
                return family.current;
              }));
              findHostInstancesForMatchingFibersRecursively(root3.current, types, hostInstances);
              return hostInstances;
            }
          };
          function findHostInstancesForMatchingFibersRecursively(fiber, types, hostInstances) {
            {
              var child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type;
              var candidateType = null;
              switch (tag) {
                case FunctionComponent:
                case SimpleMemoComponent:
                case ClassComponent:
                  candidateType = type;
                  break;
                case ForwardRef:
                  candidateType = type.render;
                  break;
              }
              var didMatch = false;
              if (candidateType !== null) {
                if (types.has(candidateType)) {
                  didMatch = true;
                }
              }
              if (didMatch) {
                findHostInstancesForFiberShallowly(fiber, hostInstances);
              } else {
                if (child !== null) {
                  findHostInstancesForMatchingFibersRecursively(child, types, hostInstances);
                }
              }
              if (sibling !== null) {
                findHostInstancesForMatchingFibersRecursively(sibling, types, hostInstances);
              }
            }
          }
          function findHostInstancesForFiberShallowly(fiber, hostInstances) {
            {
              var foundHostInstances = findChildHostInstancesForFiberShallowly(fiber, hostInstances);
              if (foundHostInstances) {
                return;
              }
              var node = fiber;
              while (true) {
                switch (node.tag) {
                  case HostComponent:
                    hostInstances.add(node.stateNode);
                    return;
                  case HostPortal:
                    hostInstances.add(node.stateNode.containerInfo);
                    return;
                  case HostRoot:
                    hostInstances.add(node.stateNode.containerInfo);
                    return;
                }
                if (node.return === null) {
                  throw new Error("Expected to reach root first.");
                }
                node = node.return;
              }
            }
          }
          function findChildHostInstancesForFiberShallowly(fiber, hostInstances) {
            {
              var node = fiber;
              var foundHostInstances = false;
              while (true) {
                if (node.tag === HostComponent) {
                  foundHostInstances = true;
                  hostInstances.add(node.stateNode);
                } else if (node.child !== null) {
                  node.child.return = node;
                  node = node.child;
                  continue;
                }
                if (node === fiber) {
                  return foundHostInstances;
                }
                while (node.sibling === null) {
                  if (node.return === null || node.return === fiber) {
                    return foundHostInstances;
                  }
                  node = node.return;
                }
                node.sibling.return = node.return;
                node = node.sibling;
              }
            }
            return false;
          }
          var hasBadMapPolyfill;
          {
            hasBadMapPolyfill = false;
            try {
              var nonExtensibleObject = Object.preventExtensions({});
              /* @__PURE__ */ new Map([[nonExtensibleObject, null]]);
              /* @__PURE__ */ new Set([nonExtensibleObject]);
            } catch (e) {
              hasBadMapPolyfill = true;
            }
          }
          function FiberNode(tag, pendingProps, key, mode) {
            this.tag = tag;
            this.key = key;
            this.elementType = null;
            this.type = null;
            this.stateNode = null;
            this.return = null;
            this.child = null;
            this.sibling = null;
            this.index = 0;
            this.ref = null;
            this.pendingProps = pendingProps;
            this.memoizedProps = null;
            this.updateQueue = null;
            this.memoizedState = null;
            this.dependencies = null;
            this.mode = mode;
            this.flags = NoFlags;
            this.subtreeFlags = NoFlags;
            this.deletions = null;
            this.lanes = NoLanes;
            this.childLanes = NoLanes;
            this.alternate = null;
            {
              this.actualDuration = Number.NaN;
              this.actualStartTime = Number.NaN;
              this.selfBaseDuration = Number.NaN;
              this.treeBaseDuration = Number.NaN;
              this.actualDuration = 0;
              this.actualStartTime = -1;
              this.selfBaseDuration = 0;
              this.treeBaseDuration = 0;
            }
            {
              this._debugSource = null;
              this._debugOwner = null;
              this._debugNeedsRemount = false;
              this._debugHookTypes = null;
              if (!hasBadMapPolyfill && typeof Object.preventExtensions === "function") {
                Object.preventExtensions(this);
              }
            }
          }
          var createFiber = function(tag, pendingProps, key, mode) {
            return new FiberNode(tag, pendingProps, key, mode);
          };
          function shouldConstruct$1(Component3) {
            var prototype = Component3.prototype;
            return !!(prototype && prototype.isReactComponent);
          }
          function isSimpleFunctionComponent(type) {
            return typeof type === "function" && !shouldConstruct$1(type) && type.defaultProps === void 0;
          }
          function resolveLazyComponentTag(Component3) {
            if (typeof Component3 === "function") {
              return shouldConstruct$1(Component3) ? ClassComponent : FunctionComponent;
            } else if (Component3 !== void 0 && Component3 !== null) {
              var $$typeof = Component3.$$typeof;
              if ($$typeof === REACT_FORWARD_REF_TYPE) {
                return ForwardRef;
              }
              if ($$typeof === REACT_MEMO_TYPE) {
                return MemoComponent;
              }
            }
            return IndeterminateComponent;
          }
          function createWorkInProgress(current2, pendingProps) {
            var workInProgress2 = current2.alternate;
            if (workInProgress2 === null) {
              workInProgress2 = createFiber(current2.tag, pendingProps, current2.key, current2.mode);
              workInProgress2.elementType = current2.elementType;
              workInProgress2.type = current2.type;
              workInProgress2.stateNode = current2.stateNode;
              {
                workInProgress2._debugSource = current2._debugSource;
                workInProgress2._debugOwner = current2._debugOwner;
                workInProgress2._debugHookTypes = current2._debugHookTypes;
              }
              workInProgress2.alternate = current2;
              current2.alternate = workInProgress2;
            } else {
              workInProgress2.pendingProps = pendingProps;
              workInProgress2.type = current2.type;
              workInProgress2.flags = NoFlags;
              workInProgress2.subtreeFlags = NoFlags;
              workInProgress2.deletions = null;
              {
                workInProgress2.actualDuration = 0;
                workInProgress2.actualStartTime = -1;
              }
            }
            workInProgress2.flags = current2.flags & StaticMask;
            workInProgress2.childLanes = current2.childLanes;
            workInProgress2.lanes = current2.lanes;
            workInProgress2.child = current2.child;
            workInProgress2.memoizedProps = current2.memoizedProps;
            workInProgress2.memoizedState = current2.memoizedState;
            workInProgress2.updateQueue = current2.updateQueue;
            var currentDependencies = current2.dependencies;
            workInProgress2.dependencies = currentDependencies === null ? null : {
              lanes: currentDependencies.lanes,
              firstContext: currentDependencies.firstContext
            };
            workInProgress2.sibling = current2.sibling;
            workInProgress2.index = current2.index;
            workInProgress2.ref = current2.ref;
            {
              workInProgress2.selfBaseDuration = current2.selfBaseDuration;
              workInProgress2.treeBaseDuration = current2.treeBaseDuration;
            }
            {
              workInProgress2._debugNeedsRemount = current2._debugNeedsRemount;
              switch (workInProgress2.tag) {
                case IndeterminateComponent:
                case FunctionComponent:
                case SimpleMemoComponent:
                  workInProgress2.type = resolveFunctionForHotReloading(current2.type);
                  break;
                case ClassComponent:
                  workInProgress2.type = resolveClassForHotReloading(current2.type);
                  break;
                case ForwardRef:
                  workInProgress2.type = resolveForwardRefForHotReloading(current2.type);
                  break;
              }
            }
            return workInProgress2;
          }
          function resetWorkInProgress(workInProgress2, renderLanes2) {
            workInProgress2.flags &= StaticMask | Placement;
            var current2 = workInProgress2.alternate;
            if (current2 === null) {
              workInProgress2.childLanes = NoLanes;
              workInProgress2.lanes = renderLanes2;
              workInProgress2.child = null;
              workInProgress2.subtreeFlags = NoFlags;
              workInProgress2.memoizedProps = null;
              workInProgress2.memoizedState = null;
              workInProgress2.updateQueue = null;
              workInProgress2.dependencies = null;
              workInProgress2.stateNode = null;
              {
                workInProgress2.selfBaseDuration = 0;
                workInProgress2.treeBaseDuration = 0;
              }
            } else {
              workInProgress2.childLanes = current2.childLanes;
              workInProgress2.lanes = current2.lanes;
              workInProgress2.child = current2.child;
              workInProgress2.subtreeFlags = NoFlags;
              workInProgress2.deletions = null;
              workInProgress2.memoizedProps = current2.memoizedProps;
              workInProgress2.memoizedState = current2.memoizedState;
              workInProgress2.updateQueue = current2.updateQueue;
              workInProgress2.type = current2.type;
              var currentDependencies = current2.dependencies;
              workInProgress2.dependencies = currentDependencies === null ? null : {
                lanes: currentDependencies.lanes,
                firstContext: currentDependencies.firstContext
              };
              {
                workInProgress2.selfBaseDuration = current2.selfBaseDuration;
                workInProgress2.treeBaseDuration = current2.treeBaseDuration;
              }
            }
            return workInProgress2;
          }
          function createHostRootFiber(tag, isStrictMode, concurrentUpdatesByDefaultOverride) {
            var mode;
            if (tag === ConcurrentRoot) {
              mode = ConcurrentMode;
              if (isStrictMode === true) {
                mode |= StrictLegacyMode;
                {
                  mode |= StrictEffectsMode;
                }
              }
            } else {
              mode = NoMode;
            }
            if (isDevToolsPresent) {
              mode |= ProfileMode;
            }
            return createFiber(HostRoot, null, null, mode);
          }
          function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {
            var fiberTag = IndeterminateComponent;
            var resolvedType = type;
            if (typeof type === "function") {
              if (shouldConstruct$1(type)) {
                fiberTag = ClassComponent;
                {
                  resolvedType = resolveClassForHotReloading(resolvedType);
                }
              } else {
                {
                  resolvedType = resolveFunctionForHotReloading(resolvedType);
                }
              }
            } else if (typeof type === "string") {
              fiberTag = HostComponent;
            } else {
              getTag: switch (type) {
                case REACT_FRAGMENT_TYPE:
                  return createFiberFromFragment(pendingProps.children, mode, lanes, key);
                case REACT_STRICT_MODE_TYPE:
                  fiberTag = Mode;
                  mode |= StrictLegacyMode;
                  if ((mode & ConcurrentMode) !== NoMode) {
                    mode |= StrictEffectsMode;
                  }
                  break;
                case REACT_PROFILER_TYPE:
                  return createFiberFromProfiler(pendingProps, mode, lanes, key);
                case REACT_SUSPENSE_TYPE:
                  return createFiberFromSuspense(pendingProps, mode, lanes, key);
                case REACT_SUSPENSE_LIST_TYPE:
                  return createFiberFromSuspenseList(pendingProps, mode, lanes, key);
                case REACT_OFFSCREEN_TYPE:
                  return createFiberFromOffscreen(pendingProps, mode, lanes, key);
                case REACT_LEGACY_HIDDEN_TYPE:
                // eslint-disable-next-line no-fallthrough
                case REACT_SCOPE_TYPE:
                // eslint-disable-next-line no-fallthrough
                case REACT_CACHE_TYPE:
                // eslint-disable-next-line no-fallthrough
                case REACT_TRACING_MARKER_TYPE:
                // eslint-disable-next-line no-fallthrough
                case REACT_DEBUG_TRACING_MODE_TYPE:
                // eslint-disable-next-line no-fallthrough
                default: {
                  if (typeof type === "object" && type !== null) {
                    switch (type.$$typeof) {
                      case REACT_PROVIDER_TYPE:
                        fiberTag = ContextProvider;
                        break getTag;
                      case REACT_CONTEXT_TYPE:
                        fiberTag = ContextConsumer;
                        break getTag;
                      case REACT_FORWARD_REF_TYPE:
                        fiberTag = ForwardRef;
                        {
                          resolvedType = resolveForwardRefForHotReloading(resolvedType);
                        }
                        break getTag;
                      case REACT_MEMO_TYPE:
                        fiberTag = MemoComponent;
                        break getTag;
                      case REACT_LAZY_TYPE:
                        fiberTag = LazyComponent;
                        resolvedType = null;
                        break getTag;
                    }
                  }
                  var info = "";
                  {
                    if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
                      info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
                    }
                    var ownerName = owner ? getComponentNameFromFiber(owner) : null;
                    if (ownerName) {
                      info += "\n\nCheck the render method of `" + ownerName + "`.";
                    }
                  }
                  throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (type == null ? type : typeof type) + "." + info));
                }
              }
            }
            var fiber = createFiber(fiberTag, pendingProps, key, mode);
            fiber.elementType = type;
            fiber.type = resolvedType;
            fiber.lanes = lanes;
            {
              fiber._debugOwner = owner;
            }
            return fiber;
          }
          function createFiberFromElement(element, mode, lanes) {
            var owner = null;
            {
              owner = element._owner;
            }
            var type = element.type;
            var key = element.key;
            var pendingProps = element.props;
            var fiber = createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes);
            {
              fiber._debugSource = element._source;
              fiber._debugOwner = element._owner;
            }
            return fiber;
          }
          function createFiberFromFragment(elements, mode, lanes, key) {
            var fiber = createFiber(Fragment7, elements, key, mode);
            fiber.lanes = lanes;
            return fiber;
          }
          function createFiberFromProfiler(pendingProps, mode, lanes, key) {
            {
              if (typeof pendingProps.id !== "string") {
                error('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof pendingProps.id);
              }
            }
            var fiber = createFiber(Profiler, pendingProps, key, mode | ProfileMode);
            fiber.elementType = REACT_PROFILER_TYPE;
            fiber.lanes = lanes;
            {
              fiber.stateNode = {
                effectDuration: 0,
                passiveEffectDuration: 0
              };
            }
            return fiber;
          }
          function createFiberFromSuspense(pendingProps, mode, lanes, key) {
            var fiber = createFiber(SuspenseComponent, pendingProps, key, mode);
            fiber.elementType = REACT_SUSPENSE_TYPE;
            fiber.lanes = lanes;
            return fiber;
          }
          function createFiberFromSuspenseList(pendingProps, mode, lanes, key) {
            var fiber = createFiber(SuspenseListComponent, pendingProps, key, mode);
            fiber.elementType = REACT_SUSPENSE_LIST_TYPE;
            fiber.lanes = lanes;
            return fiber;
          }
          function createFiberFromOffscreen(pendingProps, mode, lanes, key) {
            var fiber = createFiber(OffscreenComponent, pendingProps, key, mode);
            fiber.elementType = REACT_OFFSCREEN_TYPE;
            fiber.lanes = lanes;
            var primaryChildInstance = {
              isHidden: false
            };
            fiber.stateNode = primaryChildInstance;
            return fiber;
          }
          function createFiberFromText(content, mode, lanes) {
            var fiber = createFiber(HostText, content, null, mode);
            fiber.lanes = lanes;
            return fiber;
          }
          function createFiberFromHostInstanceForDeletion() {
            var fiber = createFiber(HostComponent, null, null, NoMode);
            fiber.elementType = "DELETED";
            return fiber;
          }
          function createFiberFromDehydratedFragment(dehydratedNode) {
            var fiber = createFiber(DehydratedFragment, null, null, NoMode);
            fiber.stateNode = dehydratedNode;
            return fiber;
          }
          function createFiberFromPortal(portal, mode, lanes) {
            var pendingProps = portal.children !== null ? portal.children : [];
            var fiber = createFiber(HostPortal, pendingProps, portal.key, mode);
            fiber.lanes = lanes;
            fiber.stateNode = {
              containerInfo: portal.containerInfo,
              pendingChildren: null,
              // Used by persistent updates
              implementation: portal.implementation
            };
            return fiber;
          }
          function assignFiberPropertiesInDEV(target, source) {
            if (target === null) {
              target = createFiber(IndeterminateComponent, null, null, NoMode);
            }
            target.tag = source.tag;
            target.key = source.key;
            target.elementType = source.elementType;
            target.type = source.type;
            target.stateNode = source.stateNode;
            target.return = source.return;
            target.child = source.child;
            target.sibling = source.sibling;
            target.index = source.index;
            target.ref = source.ref;
            target.pendingProps = source.pendingProps;
            target.memoizedProps = source.memoizedProps;
            target.updateQueue = source.updateQueue;
            target.memoizedState = source.memoizedState;
            target.dependencies = source.dependencies;
            target.mode = source.mode;
            target.flags = source.flags;
            target.subtreeFlags = source.subtreeFlags;
            target.deletions = source.deletions;
            target.lanes = source.lanes;
            target.childLanes = source.childLanes;
            target.alternate = source.alternate;
            {
              target.actualDuration = source.actualDuration;
              target.actualStartTime = source.actualStartTime;
              target.selfBaseDuration = source.selfBaseDuration;
              target.treeBaseDuration = source.treeBaseDuration;
            }
            target._debugSource = source._debugSource;
            target._debugOwner = source._debugOwner;
            target._debugNeedsRemount = source._debugNeedsRemount;
            target._debugHookTypes = source._debugHookTypes;
            return target;
          }
          function FiberRootNode(containerInfo, tag, hydrate2, identifierPrefix, onRecoverableError) {
            this.tag = tag;
            this.containerInfo = containerInfo;
            this.pendingChildren = null;
            this.current = null;
            this.pingCache = null;
            this.finishedWork = null;
            this.timeoutHandle = noTimeout;
            this.context = null;
            this.pendingContext = null;
            this.callbackNode = null;
            this.callbackPriority = NoLane;
            this.eventTimes = createLaneMap(NoLanes);
            this.expirationTimes = createLaneMap(NoTimestamp);
            this.pendingLanes = NoLanes;
            this.suspendedLanes = NoLanes;
            this.pingedLanes = NoLanes;
            this.expiredLanes = NoLanes;
            this.mutableReadLanes = NoLanes;
            this.finishedLanes = NoLanes;
            this.entangledLanes = NoLanes;
            this.entanglements = createLaneMap(NoLanes);
            this.identifierPrefix = identifierPrefix;
            this.onRecoverableError = onRecoverableError;
            {
              this.mutableSourceEagerHydrationData = null;
            }
            {
              this.effectDuration = 0;
              this.passiveEffectDuration = 0;
            }
            {
              this.memoizedUpdaters = /* @__PURE__ */ new Set();
              var pendingUpdatersLaneMap = this.pendingUpdatersLaneMap = [];
              for (var _i2 = 0; _i2 < TotalLanes; _i2++) {
                pendingUpdatersLaneMap.push(/* @__PURE__ */ new Set());
              }
            }
            {
              switch (tag) {
                case ConcurrentRoot:
                  this._debugRootType = hydrate2 ? "hydrateRoot()" : "createRoot()";
                  break;
                case LegacyRoot:
                  this._debugRootType = hydrate2 ? "hydrate()" : "render()";
                  break;
              }
            }
          }
          function createFiberRoot(containerInfo, tag, hydrate2, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {
            var root3 = new FiberRootNode(containerInfo, tag, hydrate2, identifierPrefix, onRecoverableError);
            var uninitializedFiber = createHostRootFiber(tag, isStrictMode);
            root3.current = uninitializedFiber;
            uninitializedFiber.stateNode = root3;
            {
              var _initialState = {
                element: initialChildren,
                isDehydrated: hydrate2,
                cache: null,
                // not enabled yet
                transitions: null,
                pendingSuspenseBoundaries: null
              };
              uninitializedFiber.memoizedState = _initialState;
            }
            initializeUpdateQueue(uninitializedFiber);
            return root3;
          }
          var ReactVersion = "18.3.1";
          function createPortal(children, containerInfo, implementation) {
            var key = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
            {
              checkKeyStringCoercion(key);
            }
            return {
              // This tag allow us to uniquely identify this as a React Portal
              $$typeof: REACT_PORTAL_TYPE,
              key: key == null ? null : "" + key,
              children,
              containerInfo,
              implementation
            };
          }
          var didWarnAboutNestedUpdates;
          var didWarnAboutFindNodeInStrictMode;
          {
            didWarnAboutNestedUpdates = false;
            didWarnAboutFindNodeInStrictMode = {};
          }
          function getContextForSubtree(parentComponent) {
            if (!parentComponent) {
              return emptyContextObject;
            }
            var fiber = get(parentComponent);
            var parentContext = findCurrentUnmaskedContext(fiber);
            if (fiber.tag === ClassComponent) {
              var Component3 = fiber.type;
              if (isContextProvider(Component3)) {
                return processChildContext(fiber, Component3, parentContext);
              }
            }
            return parentContext;
          }
          function findHostInstanceWithWarning(component, methodName) {
            {
              var fiber = get(component);
              if (fiber === void 0) {
                if (typeof component.render === "function") {
                  throw new Error("Unable to find node on an unmounted component.");
                } else {
                  var keys2 = Object.keys(component).join(",");
                  throw new Error("Argument appears to not be a ReactComponent. Keys: " + keys2);
                }
              }
              var hostFiber = findCurrentHostFiber(fiber);
              if (hostFiber === null) {
                return null;
              }
              if (hostFiber.mode & StrictLegacyMode) {
                var componentName = getComponentNameFromFiber(fiber) || "Component";
                if (!didWarnAboutFindNodeInStrictMode[componentName]) {
                  didWarnAboutFindNodeInStrictMode[componentName] = true;
                  var previousFiber = current;
                  try {
                    setCurrentFiber(hostFiber);
                    if (fiber.mode & StrictLegacyMode) {
                      error("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", methodName, methodName, componentName);
                    } else {
                      error("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", methodName, methodName, componentName);
                    }
                  } finally {
                    if (previousFiber) {
                      setCurrentFiber(previousFiber);
                    } else {
                      resetCurrentFiber();
                    }
                  }
                }
              }
              return hostFiber.stateNode;
            }
          }
          function createContainer(containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {
            var hydrate2 = false;
            var initialChildren = null;
            return createFiberRoot(containerInfo, tag, hydrate2, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
          }
          function createHydrationContainer(initialChildren, callback, containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {
            var hydrate2 = true;
            var root3 = createFiberRoot(containerInfo, tag, hydrate2, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
            root3.context = getContextForSubtree(null);
            var current2 = root3.current;
            var eventTime = requestEventTime();
            var lane = requestUpdateLane(current2);
            var update = createUpdate(eventTime, lane);
            update.callback = callback !== void 0 && callback !== null ? callback : null;
            enqueueUpdate(current2, update, lane);
            scheduleInitialHydrationOnRoot(root3, lane, eventTime);
            return root3;
          }
          function updateContainer(element, container2, parentComponent, callback) {
            {
              onScheduleRoot(container2, element);
            }
            var current$1 = container2.current;
            var eventTime = requestEventTime();
            var lane = requestUpdateLane(current$1);
            {
              markRenderScheduled(lane);
            }
            var context3 = getContextForSubtree(parentComponent);
            if (container2.context === null) {
              container2.context = context3;
            } else {
              container2.pendingContext = context3;
            }
            {
              if (isRendering && current !== null && !didWarnAboutNestedUpdates) {
                didWarnAboutNestedUpdates = true;
                error("Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.\n\nCheck the render method of %s.", getComponentNameFromFiber(current) || "Unknown");
              }
            }
            var update = createUpdate(eventTime, lane);
            update.payload = {
              element
            };
            callback = callback === void 0 ? null : callback;
            if (callback !== null) {
              {
                if (typeof callback !== "function") {
                  error("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callback);
                }
              }
              update.callback = callback;
            }
            var root3 = enqueueUpdate(current$1, update, lane);
            if (root3 !== null) {
              scheduleUpdateOnFiber(root3, current$1, lane, eventTime);
              entangleTransitions(root3, current$1, lane);
            }
            return lane;
          }
          function getPublicRootInstance(container2) {
            var containerFiber = container2.current;
            if (!containerFiber.child) {
              return null;
            }
            switch (containerFiber.child.tag) {
              case HostComponent:
                return getPublicInstance(containerFiber.child.stateNode);
              default:
                return containerFiber.child.stateNode;
            }
          }
          function attemptSynchronousHydration$1(fiber) {
            switch (fiber.tag) {
              case HostRoot: {
                var root3 = fiber.stateNode;
                if (isRootDehydrated(root3)) {
                  var lanes = getHighestPriorityPendingLanes(root3);
                  flushRoot(root3, lanes);
                }
                break;
              }
              case SuspenseComponent: {
                flushSync(function() {
                  var root4 = enqueueConcurrentRenderForLane(fiber, SyncLane);
                  if (root4 !== null) {
                    var eventTime = requestEventTime();
                    scheduleUpdateOnFiber(root4, fiber, SyncLane, eventTime);
                  }
                });
                var retryLane = SyncLane;
                markRetryLaneIfNotHydrated(fiber, retryLane);
                break;
              }
            }
          }
          function markRetryLaneImpl(fiber, retryLane) {
            var suspenseState = fiber.memoizedState;
            if (suspenseState !== null && suspenseState.dehydrated !== null) {
              suspenseState.retryLane = higherPriorityLane(suspenseState.retryLane, retryLane);
            }
          }
          function markRetryLaneIfNotHydrated(fiber, retryLane) {
            markRetryLaneImpl(fiber, retryLane);
            var alternate = fiber.alternate;
            if (alternate) {
              markRetryLaneImpl(alternate, retryLane);
            }
          }
          function attemptContinuousHydration$1(fiber) {
            if (fiber.tag !== SuspenseComponent) {
              return;
            }
            var lane = SelectiveHydrationLane;
            var root3 = enqueueConcurrentRenderForLane(fiber, lane);
            if (root3 !== null) {
              var eventTime = requestEventTime();
              scheduleUpdateOnFiber(root3, fiber, lane, eventTime);
            }
            markRetryLaneIfNotHydrated(fiber, lane);
          }
          function attemptHydrationAtCurrentPriority$1(fiber) {
            if (fiber.tag !== SuspenseComponent) {
              return;
            }
            var lane = requestUpdateLane(fiber);
            var root3 = enqueueConcurrentRenderForLane(fiber, lane);
            if (root3 !== null) {
              var eventTime = requestEventTime();
              scheduleUpdateOnFiber(root3, fiber, lane, eventTime);
            }
            markRetryLaneIfNotHydrated(fiber, lane);
          }
          function findHostInstanceWithNoPortals(fiber) {
            var hostFiber = findCurrentHostFiberWithNoPortals(fiber);
            if (hostFiber === null) {
              return null;
            }
            return hostFiber.stateNode;
          }
          var shouldErrorImpl = function(fiber) {
            return null;
          };
          function shouldError(fiber) {
            return shouldErrorImpl(fiber);
          }
          var shouldSuspendImpl = function(fiber) {
            return false;
          };
          function shouldSuspend(fiber) {
            return shouldSuspendImpl(fiber);
          }
          var overrideHookState = null;
          var overrideHookStateDeletePath = null;
          var overrideHookStateRenamePath = null;
          var overrideProps = null;
          var overridePropsDeletePath = null;
          var overridePropsRenamePath = null;
          var scheduleUpdate = null;
          var setErrorHandler = null;
          var setSuspenseHandler = null;
          {
            var copyWithDeleteImpl = function(obj, path, index2) {
              var key = path[index2];
              var updated = isArray(obj) ? obj.slice() : assign({}, obj);
              if (index2 + 1 === path.length) {
                if (isArray(updated)) {
                  updated.splice(key, 1);
                } else {
                  delete updated[key];
                }
                return updated;
              }
              updated[key] = copyWithDeleteImpl(obj[key], path, index2 + 1);
              return updated;
            };
            var copyWithDelete = function(obj, path) {
              return copyWithDeleteImpl(obj, path, 0);
            };
            var copyWithRenameImpl = function(obj, oldPath, newPath, index2) {
              var oldKey = oldPath[index2];
              var updated = isArray(obj) ? obj.slice() : assign({}, obj);
              if (index2 + 1 === oldPath.length) {
                var newKey = newPath[index2];
                updated[newKey] = updated[oldKey];
                if (isArray(updated)) {
                  updated.splice(oldKey, 1);
                } else {
                  delete updated[oldKey];
                }
              } else {
                updated[oldKey] = copyWithRenameImpl(
                  // $FlowFixMe number or string is fine here
                  obj[oldKey],
                  oldPath,
                  newPath,
                  index2 + 1
                );
              }
              return updated;
            };
            var copyWithRename = function(obj, oldPath, newPath) {
              if (oldPath.length !== newPath.length) {
                warn("copyWithRename() expects paths of the same length");
                return;
              } else {
                for (var i = 0; i < newPath.length - 1; i++) {
                  if (oldPath[i] !== newPath[i]) {
                    warn("copyWithRename() expects paths to be the same except for the deepest key");
                    return;
                  }
                }
              }
              return copyWithRenameImpl(obj, oldPath, newPath, 0);
            };
            var copyWithSetImpl = function(obj, path, index2, value) {
              if (index2 >= path.length) {
                return value;
              }
              var key = path[index2];
              var updated = isArray(obj) ? obj.slice() : assign({}, obj);
              updated[key] = copyWithSetImpl(obj[key], path, index2 + 1, value);
              return updated;
            };
            var copyWithSet = function(obj, path, value) {
              return copyWithSetImpl(obj, path, 0, value);
            };
            var findHook = function(fiber, id3) {
              var currentHook2 = fiber.memoizedState;
              while (currentHook2 !== null && id3 > 0) {
                currentHook2 = currentHook2.next;
                id3--;
              }
              return currentHook2;
            };
            overrideHookState = function(fiber, id3, path, value) {
              var hook = findHook(fiber, id3);
              if (hook !== null) {
                var newState = copyWithSet(hook.memoizedState, path, value);
                hook.memoizedState = newState;
                hook.baseState = newState;
                fiber.memoizedProps = assign({}, fiber.memoizedProps);
                var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane);
                if (root3 !== null) {
                  scheduleUpdateOnFiber(root3, fiber, SyncLane, NoTimestamp);
                }
              }
            };
            overrideHookStateDeletePath = function(fiber, id3, path) {
              var hook = findHook(fiber, id3);
              if (hook !== null) {
                var newState = copyWithDelete(hook.memoizedState, path);
                hook.memoizedState = newState;
                hook.baseState = newState;
                fiber.memoizedProps = assign({}, fiber.memoizedProps);
                var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane);
                if (root3 !== null) {
                  scheduleUpdateOnFiber(root3, fiber, SyncLane, NoTimestamp);
                }
              }
            };
            overrideHookStateRenamePath = function(fiber, id3, oldPath, newPath) {
              var hook = findHook(fiber, id3);
              if (hook !== null) {
                var newState = copyWithRename(hook.memoizedState, oldPath, newPath);
                hook.memoizedState = newState;
                hook.baseState = newState;
                fiber.memoizedProps = assign({}, fiber.memoizedProps);
                var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane);
                if (root3 !== null) {
                  scheduleUpdateOnFiber(root3, fiber, SyncLane, NoTimestamp);
                }
              }
            };
            overrideProps = function(fiber, path, value) {
              fiber.pendingProps = copyWithSet(fiber.memoizedProps, path, value);
              if (fiber.alternate) {
                fiber.alternate.pendingProps = fiber.pendingProps;
              }
              var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane);
              if (root3 !== null) {
                scheduleUpdateOnFiber(root3, fiber, SyncLane, NoTimestamp);
              }
            };
            overridePropsDeletePath = function(fiber, path) {
              fiber.pendingProps = copyWithDelete(fiber.memoizedProps, path);
              if (fiber.alternate) {
                fiber.alternate.pendingProps = fiber.pendingProps;
              }
              var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane);
              if (root3 !== null) {
                scheduleUpdateOnFiber(root3, fiber, SyncLane, NoTimestamp);
              }
            };
            overridePropsRenamePath = function(fiber, oldPath, newPath) {
              fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath);
              if (fiber.alternate) {
                fiber.alternate.pendingProps = fiber.pendingProps;
              }
              var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane);
              if (root3 !== null) {
                scheduleUpdateOnFiber(root3, fiber, SyncLane, NoTimestamp);
              }
            };
            scheduleUpdate = function(fiber) {
              var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane);
              if (root3 !== null) {
                scheduleUpdateOnFiber(root3, fiber, SyncLane, NoTimestamp);
              }
            };
            setErrorHandler = function(newShouldErrorImpl) {
              shouldErrorImpl = newShouldErrorImpl;
            };
            setSuspenseHandler = function(newShouldSuspendImpl) {
              shouldSuspendImpl = newShouldSuspendImpl;
            };
          }
          function findHostInstanceByFiber(fiber) {
            var hostFiber = findCurrentHostFiber(fiber);
            if (hostFiber === null) {
              return null;
            }
            return hostFiber.stateNode;
          }
          function emptyFindFiberByHostInstance(instance) {
            return null;
          }
          function getCurrentFiberForDevTools() {
            return current;
          }
          function injectIntoDevTools(devToolsConfig) {
            var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;
            var ReactCurrentDispatcher2 = ReactSharedInternals.ReactCurrentDispatcher;
            return injectInternals({
              bundleType: devToolsConfig.bundleType,
              version: devToolsConfig.version,
              rendererPackageName: devToolsConfig.rendererPackageName,
              rendererConfig: devToolsConfig.rendererConfig,
              overrideHookState,
              overrideHookStateDeletePath,
              overrideHookStateRenamePath,
              overrideProps,
              overridePropsDeletePath,
              overridePropsRenamePath,
              setErrorHandler,
              setSuspenseHandler,
              scheduleUpdate,
              currentDispatcherRef: ReactCurrentDispatcher2,
              findHostInstanceByFiber,
              findFiberByHostInstance: findFiberByHostInstance || emptyFindFiberByHostInstance,
              // React Refresh
              findHostInstancesForRefresh,
              scheduleRefresh,
              scheduleRoot,
              setRefreshHandler,
              // Enables DevTools to append owner stacks to error messages in DEV mode.
              getCurrentFiber: getCurrentFiberForDevTools,
              // Enables DevTools to detect reconciler version rather than renderer version
              // which may not match for third party renderers.
              reconcilerVersion: ReactVersion
            });
          }
          var defaultOnRecoverableError = typeof reportError === "function" ? (
            // In modern browsers, reportError will dispatch an error event,
            // emulating an uncaught JavaScript error.
            reportError
          ) : function(error2) {
            console["error"](error2);
          };
          function ReactDOMRoot(internalRoot) {
            this._internalRoot = internalRoot;
          }
          ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function(children) {
            var root3 = this._internalRoot;
            if (root3 === null) {
              throw new Error("Cannot update an unmounted root.");
            }
            {
              if (typeof arguments[1] === "function") {
                error("render(...): does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
              } else if (isValidContainer(arguments[1])) {
                error("You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root.");
              } else if (typeof arguments[1] !== "undefined") {
                error("You passed a second argument to root.render(...) but it only accepts one argument.");
              }
              var container2 = root3.containerInfo;
              if (container2.nodeType !== COMMENT_NODE) {
                var hostInstance = findHostInstanceWithNoPortals(root3.current);
                if (hostInstance) {
                  if (hostInstance.parentNode !== container2) {
                    error("render(...): It looks like the React-rendered content of the root container was removed without using React. This is not supported and will cause errors. Instead, call root.unmount() to empty a root's container.");
                  }
                }
              }
            }
            updateContainer(children, root3, null, null);
          };
          ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function() {
            {
              if (typeof arguments[0] === "function") {
                error("unmount(...): does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
              }
            }
            var root3 = this._internalRoot;
            if (root3 !== null) {
              this._internalRoot = null;
              var container2 = root3.containerInfo;
              {
                if (isAlreadyRendering()) {
                  error("Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition.");
                }
              }
              flushSync(function() {
                updateContainer(null, root3, null, null);
              });
              unmarkContainerAsRoot(container2);
            }
          };
          function createRoot2(container2, options2) {
            if (!isValidContainer(container2)) {
              throw new Error("createRoot(...): Target container is not a DOM element.");
            }
            warnIfReactDOMContainerInDEV(container2);
            var isStrictMode = false;
            var concurrentUpdatesByDefaultOverride = false;
            var identifierPrefix = "";
            var onRecoverableError = defaultOnRecoverableError;
            var transitionCallbacks = null;
            if (options2 !== null && options2 !== void 0) {
              {
                if (options2.hydrate) {
                  warn("hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.");
                } else {
                  if (typeof options2 === "object" && options2 !== null && options2.$$typeof === REACT_ELEMENT_TYPE) {
                    error("You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:\n\n  let root = createRoot(domContainer);\n  root.render(<App />);");
                  }
                }
              }
              if (options2.unstable_strictMode === true) {
                isStrictMode = true;
              }
              if (options2.identifierPrefix !== void 0) {
                identifierPrefix = options2.identifierPrefix;
              }
              if (options2.onRecoverableError !== void 0) {
                onRecoverableError = options2.onRecoverableError;
              }
              if (options2.transitionCallbacks !== void 0) {
                transitionCallbacks = options2.transitionCallbacks;
              }
            }
            var root3 = createContainer(container2, ConcurrentRoot, null, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
            markContainerAsRoot(root3.current, container2);
            var rootContainerElement = container2.nodeType === COMMENT_NODE ? container2.parentNode : container2;
            listenToAllSupportedEvents(rootContainerElement);
            return new ReactDOMRoot(root3);
          }
          function ReactDOMHydrationRoot(internalRoot) {
            this._internalRoot = internalRoot;
          }
          function scheduleHydration(target) {
            if (target) {
              queueExplicitHydrationTarget(target);
            }
          }
          ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = scheduleHydration;
          function hydrateRoot(container2, initialChildren, options2) {
            if (!isValidContainer(container2)) {
              throw new Error("hydrateRoot(...): Target container is not a DOM element.");
            }
            warnIfReactDOMContainerInDEV(container2);
            {
              if (initialChildren === void 0) {
                error("Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)");
              }
            }
            var hydrationCallbacks = options2 != null ? options2 : null;
            var mutableSources = options2 != null && options2.hydratedSources || null;
            var isStrictMode = false;
            var concurrentUpdatesByDefaultOverride = false;
            var identifierPrefix = "";
            var onRecoverableError = defaultOnRecoverableError;
            if (options2 !== null && options2 !== void 0) {
              if (options2.unstable_strictMode === true) {
                isStrictMode = true;
              }
              if (options2.identifierPrefix !== void 0) {
                identifierPrefix = options2.identifierPrefix;
              }
              if (options2.onRecoverableError !== void 0) {
                onRecoverableError = options2.onRecoverableError;
              }
            }
            var root3 = createHydrationContainer(initialChildren, null, container2, ConcurrentRoot, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
            markContainerAsRoot(root3.current, container2);
            listenToAllSupportedEvents(container2);
            if (mutableSources) {
              for (var i = 0; i < mutableSources.length; i++) {
                var mutableSource = mutableSources[i];
                registerMutableSourceForHydration(root3, mutableSource);
              }
            }
            return new ReactDOMHydrationRoot(root3);
          }
          function isValidContainer(node) {
            return !!(node && (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE || !disableCommentsAsDOMContainers));
          }
          function isValidContainerLegacy(node) {
            return !!(node && (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE || node.nodeType === COMMENT_NODE && node.nodeValue === " react-mount-point-unstable "));
          }
          function warnIfReactDOMContainerInDEV(container2) {
            {
              if (container2.nodeType === ELEMENT_NODE && container2.tagName && container2.tagName.toUpperCase() === "BODY") {
                error("createRoot(): Creating roots directly with document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try using a container element created for your app.");
              }
              if (isContainerMarkedAsRoot(container2)) {
                if (container2._reactRootContainer) {
                  error("You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported.");
                } else {
                  error("You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it.");
                }
              }
            }
          }
          var ReactCurrentOwner$3 = ReactSharedInternals.ReactCurrentOwner;
          var topLevelUpdateWarnings;
          {
            topLevelUpdateWarnings = function(container2) {
              if (container2._reactRootContainer && container2.nodeType !== COMMENT_NODE) {
                var hostInstance = findHostInstanceWithNoPortals(container2._reactRootContainer.current);
                if (hostInstance) {
                  if (hostInstance.parentNode !== container2) {
                    error("render(...): It looks like the React-rendered content of this container was removed without using React. This is not supported and will cause errors. Instead, call ReactDOM.unmountComponentAtNode to empty a container.");
                  }
                }
              }
              var isRootRenderedBySomeReact = !!container2._reactRootContainer;
              var rootEl = getReactRootElementInContainer(container2);
              var hasNonRootReactChild = !!(rootEl && getInstanceFromNode(rootEl));
              if (hasNonRootReactChild && !isRootRenderedBySomeReact) {
                error("render(...): Replacing React-rendered children with a new root component. If you intended to update the children of this node, you should instead have the existing children update their state and render the new components instead of calling ReactDOM.render.");
              }
              if (container2.nodeType === ELEMENT_NODE && container2.tagName && container2.tagName.toUpperCase() === "BODY") {
                error("render(): Rendering components directly into document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try rendering into a container element created for your app.");
              }
            };
          }
          function getReactRootElementInContainer(container2) {
            if (!container2) {
              return null;
            }
            if (container2.nodeType === DOCUMENT_NODE) {
              return container2.documentElement;
            } else {
              return container2.firstChild;
            }
          }
          function noopOnRecoverableError() {
          }
          function legacyCreateRootFromDOMContainer(container2, initialChildren, parentComponent, callback, isHydrationContainer) {
            if (isHydrationContainer) {
              if (typeof callback === "function") {
                var originalCallback = callback;
                callback = function() {
                  var instance = getPublicRootInstance(root3);
                  originalCallback.call(instance);
                };
              }
              var root3 = createHydrationContainer(
                initialChildren,
                callback,
                container2,
                LegacyRoot,
                null,
                // hydrationCallbacks
                false,
                // isStrictMode
                false,
                // concurrentUpdatesByDefaultOverride,
                "",
                // identifierPrefix
                noopOnRecoverableError
              );
              container2._reactRootContainer = root3;
              markContainerAsRoot(root3.current, container2);
              var rootContainerElement = container2.nodeType === COMMENT_NODE ? container2.parentNode : container2;
              listenToAllSupportedEvents(rootContainerElement);
              flushSync();
              return root3;
            } else {
              var rootSibling;
              while (rootSibling = container2.lastChild) {
                container2.removeChild(rootSibling);
              }
              if (typeof callback === "function") {
                var _originalCallback = callback;
                callback = function() {
                  var instance = getPublicRootInstance(_root3);
                  _originalCallback.call(instance);
                };
              }
              var _root3 = createContainer(
                container2,
                LegacyRoot,
                null,
                // hydrationCallbacks
                false,
                // isStrictMode
                false,
                // concurrentUpdatesByDefaultOverride,
                "",
                // identifierPrefix
                noopOnRecoverableError
              );
              container2._reactRootContainer = _root3;
              markContainerAsRoot(_root3.current, container2);
              var _rootContainerElement = container2.nodeType === COMMENT_NODE ? container2.parentNode : container2;
              listenToAllSupportedEvents(_rootContainerElement);
              flushSync(function() {
                updateContainer(initialChildren, _root3, parentComponent, callback);
              });
              return _root3;
            }
          }
          function warnOnInvalidCallback$1(callback, callerName) {
            {
              if (callback !== null && typeof callback !== "function") {
                error("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback);
              }
            }
          }
          function legacyRenderSubtreeIntoContainer(parentComponent, children, container2, forceHydrate, callback) {
            {
              topLevelUpdateWarnings(container2);
              warnOnInvalidCallback$1(callback === void 0 ? null : callback, "render");
            }
            var maybeRoot = container2._reactRootContainer;
            var root3;
            if (!maybeRoot) {
              root3 = legacyCreateRootFromDOMContainer(container2, children, parentComponent, callback, forceHydrate);
            } else {
              root3 = maybeRoot;
              if (typeof callback === "function") {
                var originalCallback = callback;
                callback = function() {
                  var instance = getPublicRootInstance(root3);
                  originalCallback.call(instance);
                };
              }
              updateContainer(children, root3, parentComponent, callback);
            }
            return getPublicRootInstance(root3);
          }
          var didWarnAboutFindDOMNode = false;
          function findDOMNode(componentOrElement) {
            {
              if (!didWarnAboutFindDOMNode) {
                didWarnAboutFindDOMNode = true;
                error("findDOMNode is deprecated and will be removed in the next major release. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node");
              }
              var owner = ReactCurrentOwner$3.current;
              if (owner !== null && owner.stateNode !== null) {
                var warnedAboutRefsInRender = owner.stateNode._warnedAboutRefsInRender;
                if (!warnedAboutRefsInRender) {
                  error("%s is accessing findDOMNode inside its render(). render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", getComponentNameFromType(owner.type) || "A component");
                }
                owner.stateNode._warnedAboutRefsInRender = true;
              }
            }
            if (componentOrElement == null) {
              return null;
            }
            if (componentOrElement.nodeType === ELEMENT_NODE) {
              return componentOrElement;
            }
            {
              return findHostInstanceWithWarning(componentOrElement, "findDOMNode");
            }
          }
          function hydrate(element, container2, callback) {
            {
              error("ReactDOM.hydrate is no longer supported in React 18. Use hydrateRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot");
            }
            if (!isValidContainerLegacy(container2)) {
              throw new Error("Target container is not a DOM element.");
            }
            {
              var isModernRoot = isContainerMarkedAsRoot(container2) && container2._reactRootContainer === void 0;
              if (isModernRoot) {
                error("You are calling ReactDOM.hydrate() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call hydrateRoot(container, element)?");
              }
            }
            return legacyRenderSubtreeIntoContainer(null, element, container2, true, callback);
          }
          function render4(element, container2, callback) {
            {
              error("ReactDOM.render is no longer supported in React 18. Use createRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot");
            }
            if (!isValidContainerLegacy(container2)) {
              throw new Error("Target container is not a DOM element.");
            }
            {
              var isModernRoot = isContainerMarkedAsRoot(container2) && container2._reactRootContainer === void 0;
              if (isModernRoot) {
                error("You are calling ReactDOM.render() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.render(element)?");
              }
            }
            return legacyRenderSubtreeIntoContainer(null, element, container2, false, callback);
          }
          function unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback) {
            {
              error("ReactDOM.unstable_renderSubtreeIntoContainer() is no longer supported in React 18. Consider using a portal instead. Until you switch to the createRoot API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot");
            }
            if (!isValidContainerLegacy(containerNode)) {
              throw new Error("Target container is not a DOM element.");
            }
            if (parentComponent == null || !has(parentComponent)) {
              throw new Error("parentComponent must be a valid React Component");
            }
            return legacyRenderSubtreeIntoContainer(parentComponent, element, containerNode, false, callback);
          }
          var didWarnAboutUnmountComponentAtNode = false;
          function unmountComponentAtNode(container2) {
            {
              if (!didWarnAboutUnmountComponentAtNode) {
                didWarnAboutUnmountComponentAtNode = true;
                error("unmountComponentAtNode is deprecated and will be removed in the next major release. Switch to the createRoot API. Learn more: https://reactjs.org/link/switch-to-createroot");
              }
            }
            if (!isValidContainerLegacy(container2)) {
              throw new Error("unmountComponentAtNode(...): Target container is not a DOM element.");
            }
            {
              var isModernRoot = isContainerMarkedAsRoot(container2) && container2._reactRootContainer === void 0;
              if (isModernRoot) {
                error("You are calling ReactDOM.unmountComponentAtNode() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.unmount()?");
              }
            }
            if (container2._reactRootContainer) {
              {
                var rootEl = getReactRootElementInContainer(container2);
                var renderedByDifferentReact = rootEl && !getInstanceFromNode(rootEl);
                if (renderedByDifferentReact) {
                  error("unmountComponentAtNode(): The node you're attempting to unmount was rendered by another copy of React.");
                }
              }
              flushSync(function() {
                legacyRenderSubtreeIntoContainer(null, null, container2, false, function() {
                  container2._reactRootContainer = null;
                  unmarkContainerAsRoot(container2);
                });
              });
              return true;
            } else {
              {
                var _rootEl = getReactRootElementInContainer(container2);
                var hasNonRootReactChild = !!(_rootEl && getInstanceFromNode(_rootEl));
                var isContainerReactRoot = container2.nodeType === ELEMENT_NODE && isValidContainerLegacy(container2.parentNode) && !!container2.parentNode._reactRootContainer;
                if (hasNonRootReactChild) {
                  error("unmountComponentAtNode(): The node you're attempting to unmount was rendered by React and is not a top-level container. %s", isContainerReactRoot ? "You may have accidentally passed in a React root node instead of its container." : "Instead, have the parent component update its state and rerender in order to remove this component.");
                }
              }
              return false;
            }
          }
          setAttemptSynchronousHydration(attemptSynchronousHydration$1);
          setAttemptContinuousHydration(attemptContinuousHydration$1);
          setAttemptHydrationAtCurrentPriority(attemptHydrationAtCurrentPriority$1);
          setGetCurrentUpdatePriority(getCurrentUpdatePriority);
          setAttemptHydrationAtPriority(runWithPriority);
          {
            if (typeof Map !== "function" || // $FlowIssue Flow incorrectly thinks Map has no prototype
            Map.prototype == null || typeof Map.prototype.forEach !== "function" || typeof Set !== "function" || // $FlowIssue Flow incorrectly thinks Set has no prototype
            Set.prototype == null || typeof Set.prototype.clear !== "function" || typeof Set.prototype.forEach !== "function") {
              error("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
            }
          }
          setRestoreImplementation(restoreControlledState$3);
          setBatchingImplementation(batchedUpdates$1, discreteUpdates, flushSync);
          function createPortal$1(children, container2) {
            var key = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
            if (!isValidContainer(container2)) {
              throw new Error("Target container is not a DOM element.");
            }
            return createPortal(children, container2, null, key);
          }
          function renderSubtreeIntoContainer(parentComponent, element, containerNode, callback) {
            return unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback);
          }
          var Internals = {
            usingClientEntryPoint: false,
            // Keep in sync with ReactTestUtils.js.
            // This is an array for better minification.
            Events: [getInstanceFromNode, getNodeFromInstance, getFiberCurrentPropsFromNode, enqueueStateRestore, restoreStateIfNeeded, batchedUpdates$1]
          };
          function createRoot$1(container2, options2) {
            {
              if (!Internals.usingClientEntryPoint && true) {
                error('You are importing createRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".');
              }
            }
            return createRoot2(container2, options2);
          }
          function hydrateRoot$1(container2, initialChildren, options2) {
            {
              if (!Internals.usingClientEntryPoint && true) {
                error('You are importing hydrateRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".');
              }
            }
            return hydrateRoot(container2, initialChildren, options2);
          }
          function flushSync$1(fn) {
            {
              if (isAlreadyRendering()) {
                error("flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task.");
              }
            }
            return flushSync(fn);
          }
          var foundDevTools = injectIntoDevTools({
            findFiberByHostInstance: getClosestInstanceFromNode,
            bundleType: 1,
            version: ReactVersion,
            rendererPackageName: "react-dom"
          });
          {
            if (!foundDevTools && canUseDOM && window.top === window.self) {
              if (navigator.userAgent.indexOf("Chrome") > -1 && navigator.userAgent.indexOf("Edge") === -1 || navigator.userAgent.indexOf("Firefox") > -1) {
                var protocol = window.location.protocol;
                if (/^(https?|file):$/.test(protocol)) {
                  console.info("%cDownload the React DevTools for a better development experience: https://reactjs.org/link/react-devtools" + (protocol === "file:" ? "\nYou might need to use a local HTTP server (instead of file://): https://reactjs.org/link/react-devtools-faq" : ""), "font-weight:bold");
                }
              }
            }
          }
          exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Internals;
          exports.createPortal = createPortal$1;
          exports.createRoot = createRoot$1;
          exports.findDOMNode = findDOMNode;
          exports.flushSync = flushSync$1;
          exports.hydrate = hydrate;
          exports.hydrateRoot = hydrateRoot$1;
          exports.render = render4;
          exports.unmountComponentAtNode = unmountComponentAtNode;
          exports.unstable_batchedUpdates = batchedUpdates$1;
          exports.unstable_renderSubtreeIntoContainer = renderSubtreeIntoContainer;
          exports.version = ReactVersion;
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
          }
        })();
      }
    }
  });

  // node_modules/react-dom/index.js
  var require_react_dom = __commonJS({
    "node_modules/react-dom/index.js"(exports, module) {
      "use strict";
      if (false) {
        checkDCE();
        module.exports = null;
      } else {
        module.exports = require_react_dom_development();
      }
    }
  });

  // node_modules/react-dom/client.js
  var require_client = __commonJS({
    "node_modules/react-dom/client.js"(exports) {
      "use strict";
      var m = require_react_dom();
      if (false) {
        exports.createRoot = m.createRoot;
        exports.hydrateRoot = m.hydrateRoot;
      } else {
        i = m.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        exports.createRoot = function(c, o) {
          i.usingClientEntryPoint = true;
          try {
            return m.createRoot(c, o);
          } finally {
            i.usingClientEntryPoint = false;
          }
        };
        exports.hydrateRoot = function(c, h, o) {
          i.usingClientEntryPoint = true;
          try {
            return m.hydrateRoot(c, h, o);
          } finally {
            i.usingClientEntryPoint = false;
          }
        };
      }
      var i;
    }
  });

  // node_modules/react/cjs/react-jsx-runtime.development.js
  var require_react_jsx_runtime_development = __commonJS({
    "node_modules/react/cjs/react-jsx-runtime.development.js"(exports) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          var React5 = require_react();
          var REACT_ELEMENT_TYPE = Symbol.for("react.element");
          var REACT_PORTAL_TYPE = Symbol.for("react.portal");
          var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
          var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
          var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
          var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
          var REACT_CONTEXT_TYPE = Symbol.for("react.context");
          var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
          var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
          var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
          var REACT_MEMO_TYPE = Symbol.for("react.memo");
          var REACT_LAZY_TYPE = Symbol.for("react.lazy");
          var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
          var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
          var FAUX_ITERATOR_SYMBOL = "@@iterator";
          function getIteratorFn(maybeIterable) {
            if (maybeIterable === null || typeof maybeIterable !== "object") {
              return null;
            }
            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
            if (typeof maybeIterator === "function") {
              return maybeIterator;
            }
            return null;
          }
          var ReactSharedInternals = React5.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
          function error(format2) {
            {
              {
                for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                  args[_key2 - 1] = arguments[_key2];
                }
                printWarning("error", format2, args);
              }
            }
          }
          function printWarning(level, format2, args) {
            {
              var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
              var stack = ReactDebugCurrentFrame2.getStackAddendum();
              if (stack !== "") {
                format2 += "%s";
                args = args.concat([stack]);
              }
              var argsWithFormat = args.map(function(item) {
                return String(item);
              });
              argsWithFormat.unshift("Warning: " + format2);
              Function.prototype.apply.call(console[level], console, argsWithFormat);
            }
          }
          var enableScopeAPI = false;
          var enableCacheElement = false;
          var enableTransitionTracing = false;
          var enableLegacyHidden = false;
          var enableDebugTracing = false;
          var REACT_MODULE_REFERENCE;
          {
            REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
          }
          function isValidElementType(type) {
            if (typeof type === "string" || typeof type === "function") {
              return true;
            }
            if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
              return true;
            }
            if (typeof type === "object" && type !== null) {
              if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
              // types supported by any Flight configuration anywhere since
              // we don't know which Flight build this will end up being used
              // with.
              type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {
                return true;
              }
            }
            return false;
          }
          function getWrappedName(outerType, innerType, wrapperName) {
            var displayName = outerType.displayName;
            if (displayName) {
              return displayName;
            }
            var functionName = innerType.displayName || innerType.name || "";
            return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
          }
          function getContextName(type) {
            return type.displayName || "Context";
          }
          function getComponentNameFromType(type) {
            if (type == null) {
              return null;
            }
            {
              if (typeof type.tag === "number") {
                error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
              }
            }
            if (typeof type === "function") {
              return type.displayName || type.name || null;
            }
            if (typeof type === "string") {
              return type;
            }
            switch (type) {
              case REACT_FRAGMENT_TYPE:
                return "Fragment";
              case REACT_PORTAL_TYPE:
                return "Portal";
              case REACT_PROFILER_TYPE:
                return "Profiler";
              case REACT_STRICT_MODE_TYPE:
                return "StrictMode";
              case REACT_SUSPENSE_TYPE:
                return "Suspense";
              case REACT_SUSPENSE_LIST_TYPE:
                return "SuspenseList";
            }
            if (typeof type === "object") {
              switch (type.$$typeof) {
                case REACT_CONTEXT_TYPE:
                  var context3 = type;
                  return getContextName(context3) + ".Consumer";
                case REACT_PROVIDER_TYPE:
                  var provider = type;
                  return getContextName(provider._context) + ".Provider";
                case REACT_FORWARD_REF_TYPE:
                  return getWrappedName(type, type.render, "ForwardRef");
                case REACT_MEMO_TYPE:
                  var outerName = type.displayName || null;
                  if (outerName !== null) {
                    return outerName;
                  }
                  return getComponentNameFromType(type.type) || "Memo";
                case REACT_LAZY_TYPE: {
                  var lazyComponent = type;
                  var payload = lazyComponent._payload;
                  var init5 = lazyComponent._init;
                  try {
                    return getComponentNameFromType(init5(payload));
                  } catch (x) {
                    return null;
                  }
                }
              }
            }
            return null;
          }
          var assign = Object.assign;
          var disabledDepth = 0;
          var prevLog;
          var prevInfo;
          var prevWarn;
          var prevError;
          var prevGroup;
          var prevGroupCollapsed;
          var prevGroupEnd;
          function disabledLog() {
          }
          disabledLog.__reactDisabledLog = true;
          function disableLogs() {
            {
              if (disabledDepth === 0) {
                prevLog = console.log;
                prevInfo = console.info;
                prevWarn = console.warn;
                prevError = console.error;
                prevGroup = console.group;
                prevGroupCollapsed = console.groupCollapsed;
                prevGroupEnd = console.groupEnd;
                var props = {
                  configurable: true,
                  enumerable: true,
                  value: disabledLog,
                  writable: true
                };
                Object.defineProperties(console, {
                  info: props,
                  log: props,
                  warn: props,
                  error: props,
                  group: props,
                  groupCollapsed: props,
                  groupEnd: props
                });
              }
              disabledDepth++;
            }
          }
          function reenableLogs() {
            {
              disabledDepth--;
              if (disabledDepth === 0) {
                var props = {
                  configurable: true,
                  enumerable: true,
                  writable: true
                };
                Object.defineProperties(console, {
                  log: assign({}, props, {
                    value: prevLog
                  }),
                  info: assign({}, props, {
                    value: prevInfo
                  }),
                  warn: assign({}, props, {
                    value: prevWarn
                  }),
                  error: assign({}, props, {
                    value: prevError
                  }),
                  group: assign({}, props, {
                    value: prevGroup
                  }),
                  groupCollapsed: assign({}, props, {
                    value: prevGroupCollapsed
                  }),
                  groupEnd: assign({}, props, {
                    value: prevGroupEnd
                  })
                });
              }
              if (disabledDepth < 0) {
                error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
              }
            }
          }
          var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
          var prefix;
          function describeBuiltInComponentFrame(name, source, ownerFn) {
            {
              if (prefix === void 0) {
                try {
                  throw Error();
                } catch (x) {
                  var match = x.stack.trim().match(/\n( *(at )?)/);
                  prefix = match && match[1] || "";
                }
              }
              return "\n" + prefix + name;
            }
          }
          var reentry = false;
          var componentFrameCache;
          {
            var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
            componentFrameCache = new PossiblyWeakMap();
          }
          function describeNativeComponentFrame(fn, construct) {
            if (!fn || reentry) {
              return "";
            }
            {
              var frame2 = componentFrameCache.get(fn);
              if (frame2 !== void 0) {
                return frame2;
              }
            }
            var control;
            reentry = true;
            var previousPrepareStackTrace = Error.prepareStackTrace;
            Error.prepareStackTrace = void 0;
            var previousDispatcher;
            {
              previousDispatcher = ReactCurrentDispatcher.current;
              ReactCurrentDispatcher.current = null;
              disableLogs();
            }
            try {
              if (construct) {
                var Fake = function() {
                  throw Error();
                };
                Object.defineProperty(Fake.prototype, "props", {
                  set: function() {
                    throw Error();
                  }
                });
                if (typeof Reflect === "object" && Reflect.construct) {
                  try {
                    Reflect.construct(Fake, []);
                  } catch (x) {
                    control = x;
                  }
                  Reflect.construct(fn, [], Fake);
                } else {
                  try {
                    Fake.call();
                  } catch (x) {
                    control = x;
                  }
                  fn.call(Fake.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (x) {
                  control = x;
                }
                fn();
              }
            } catch (sample) {
              if (sample && control && typeof sample.stack === "string") {
                var sampleLines = sample.stack.split("\n");
                var controlLines = control.stack.split("\n");
                var s = sampleLines.length - 1;
                var c = controlLines.length - 1;
                while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
                  c--;
                }
                for (; s >= 1 && c >= 0; s--, c--) {
                  if (sampleLines[s] !== controlLines[c]) {
                    if (s !== 1 || c !== 1) {
                      do {
                        s--;
                        c--;
                        if (c < 0 || sampleLines[s] !== controlLines[c]) {
                          var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                          if (fn.displayName && _frame.includes("<anonymous>")) {
                            _frame = _frame.replace("<anonymous>", fn.displayName);
                          }
                          {
                            if (typeof fn === "function") {
                              componentFrameCache.set(fn, _frame);
                            }
                          }
                          return _frame;
                        }
                      } while (s >= 1 && c >= 0);
                    }
                    break;
                  }
                }
              }
            } finally {
              reentry = false;
              {
                ReactCurrentDispatcher.current = previousDispatcher;
                reenableLogs();
              }
              Error.prepareStackTrace = previousPrepareStackTrace;
            }
            var name = fn ? fn.displayName || fn.name : "";
            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
            {
              if (typeof fn === "function") {
                componentFrameCache.set(fn, syntheticFrame);
              }
            }
            return syntheticFrame;
          }
          function describeFunctionComponentFrame(fn, source, ownerFn) {
            {
              return describeNativeComponentFrame(fn, false);
            }
          }
          function shouldConstruct(Component3) {
            var prototype = Component3.prototype;
            return !!(prototype && prototype.isReactComponent);
          }
          function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
            if (type == null) {
              return "";
            }
            if (typeof type === "function") {
              {
                return describeNativeComponentFrame(type, shouldConstruct(type));
              }
            }
            if (typeof type === "string") {
              return describeBuiltInComponentFrame(type);
            }
            switch (type) {
              case REACT_SUSPENSE_TYPE:
                return describeBuiltInComponentFrame("Suspense");
              case REACT_SUSPENSE_LIST_TYPE:
                return describeBuiltInComponentFrame("SuspenseList");
            }
            if (typeof type === "object") {
              switch (type.$$typeof) {
                case REACT_FORWARD_REF_TYPE:
                  return describeFunctionComponentFrame(type.render);
                case REACT_MEMO_TYPE:
                  return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
                case REACT_LAZY_TYPE: {
                  var lazyComponent = type;
                  var payload = lazyComponent._payload;
                  var init5 = lazyComponent._init;
                  try {
                    return describeUnknownElementTypeFrameInDEV(init5(payload), source, ownerFn);
                  } catch (x) {
                  }
                }
              }
            }
            return "";
          }
          var hasOwnProperty = Object.prototype.hasOwnProperty;
          var loggedTypeFailures = {};
          var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
          function setCurrentlyValidatingElement(element) {
            {
              if (element) {
                var owner = element._owner;
                var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                ReactDebugCurrentFrame.setExtraStackFrame(stack);
              } else {
                ReactDebugCurrentFrame.setExtraStackFrame(null);
              }
            }
          }
          function checkPropTypes(typeSpecs, values, location2, componentName, element) {
            {
              var has = Function.call.bind(hasOwnProperty);
              for (var typeSpecName in typeSpecs) {
                if (has(typeSpecs, typeSpecName)) {
                  var error$1 = void 0;
                  try {
                    if (typeof typeSpecs[typeSpecName] !== "function") {
                      var err = Error((componentName || "React class") + ": " + location2 + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                      err.name = "Invariant Violation";
                      throw err;
                    }
                    error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location2, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                  } catch (ex) {
                    error$1 = ex;
                  }
                  if (error$1 && !(error$1 instanceof Error)) {
                    setCurrentlyValidatingElement(element);
                    error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location2, typeSpecName, typeof error$1);
                    setCurrentlyValidatingElement(null);
                  }
                  if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                    loggedTypeFailures[error$1.message] = true;
                    setCurrentlyValidatingElement(element);
                    error("Failed %s type: %s", location2, error$1.message);
                    setCurrentlyValidatingElement(null);
                  }
                }
              }
            }
          }
          var isArrayImpl = Array.isArray;
          function isArray(a) {
            return isArrayImpl(a);
          }
          function typeName(value) {
            {
              var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
              var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
              return type;
            }
          }
          function willCoercionThrow(value) {
            {
              try {
                testStringCoercion(value);
                return false;
              } catch (e) {
                return true;
              }
            }
          }
          function testStringCoercion(value) {
            return "" + value;
          }
          function checkKeyStringCoercion(value) {
            {
              if (willCoercionThrow(value)) {
                error("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
                return testStringCoercion(value);
              }
            }
          }
          var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
          var RESERVED_PROPS = {
            key: true,
            ref: true,
            __self: true,
            __source: true
          };
          var specialPropKeyWarningShown;
          var specialPropRefWarningShown;
          var didWarnAboutStringRefs;
          {
            didWarnAboutStringRefs = {};
          }
          function hasValidRef(config3) {
            {
              if (hasOwnProperty.call(config3, "ref")) {
                var getter = Object.getOwnPropertyDescriptor(config3, "ref").get;
                if (getter && getter.isReactWarning) {
                  return false;
                }
              }
            }
            return config3.ref !== void 0;
          }
          function hasValidKey(config3) {
            {
              if (hasOwnProperty.call(config3, "key")) {
                var getter = Object.getOwnPropertyDescriptor(config3, "key").get;
                if (getter && getter.isReactWarning) {
                  return false;
                }
              }
            }
            return config3.key !== void 0;
          }
          function warnIfStringRefCannotBeAutoConverted(config3, self2) {
            {
              if (typeof config3.ref === "string" && ReactCurrentOwner.current && self2 && ReactCurrentOwner.current.stateNode !== self2) {
                var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
                if (!didWarnAboutStringRefs[componentName]) {
                  error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config3.ref);
                  didWarnAboutStringRefs[componentName] = true;
                }
              }
            }
          }
          function defineKeyPropWarningGetter(props, displayName) {
            {
              var warnAboutAccessingKey = function() {
                if (!specialPropKeyWarningShown) {
                  specialPropKeyWarningShown = true;
                  error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
                }
              };
              warnAboutAccessingKey.isReactWarning = true;
              Object.defineProperty(props, "key", {
                get: warnAboutAccessingKey,
                configurable: true
              });
            }
          }
          function defineRefPropWarningGetter(props, displayName) {
            {
              var warnAboutAccessingRef = function() {
                if (!specialPropRefWarningShown) {
                  specialPropRefWarningShown = true;
                  error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
                }
              };
              warnAboutAccessingRef.isReactWarning = true;
              Object.defineProperty(props, "ref", {
                get: warnAboutAccessingRef,
                configurable: true
              });
            }
          }
          var ReactElement = function(type, key, ref2, self2, source, owner, props) {
            var element = {
              // This tag allows us to uniquely identify this as a React Element
              $$typeof: REACT_ELEMENT_TYPE,
              // Built-in properties that belong on the element
              type,
              key,
              ref: ref2,
              props,
              // Record the component responsible for creating this element.
              _owner: owner
            };
            {
              element._store = {};
              Object.defineProperty(element._store, "validated", {
                configurable: false,
                enumerable: false,
                writable: true,
                value: false
              });
              Object.defineProperty(element, "_self", {
                configurable: false,
                enumerable: false,
                writable: false,
                value: self2
              });
              Object.defineProperty(element, "_source", {
                configurable: false,
                enumerable: false,
                writable: false,
                value: source
              });
              if (Object.freeze) {
                Object.freeze(element.props);
                Object.freeze(element);
              }
            }
            return element;
          };
          function jsxDEV(type, config3, maybeKey, source, self2) {
            {
              var propName;
              var props = {};
              var key = null;
              var ref2 = null;
              if (maybeKey !== void 0) {
                {
                  checkKeyStringCoercion(maybeKey);
                }
                key = "" + maybeKey;
              }
              if (hasValidKey(config3)) {
                {
                  checkKeyStringCoercion(config3.key);
                }
                key = "" + config3.key;
              }
              if (hasValidRef(config3)) {
                ref2 = config3.ref;
                warnIfStringRefCannotBeAutoConverted(config3, self2);
              }
              for (propName in config3) {
                if (hasOwnProperty.call(config3, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                  props[propName] = config3[propName];
                }
              }
              if (type && type.defaultProps) {
                var defaultProps = type.defaultProps;
                for (propName in defaultProps) {
                  if (props[propName] === void 0) {
                    props[propName] = defaultProps[propName];
                  }
                }
              }
              if (key || ref2) {
                var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
                if (key) {
                  defineKeyPropWarningGetter(props, displayName);
                }
                if (ref2) {
                  defineRefPropWarningGetter(props, displayName);
                }
              }
              return ReactElement(type, key, ref2, self2, source, ReactCurrentOwner.current, props);
            }
          }
          var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
          var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
          function setCurrentlyValidatingElement$1(element) {
            {
              if (element) {
                var owner = element._owner;
                var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
              } else {
                ReactDebugCurrentFrame$1.setExtraStackFrame(null);
              }
            }
          }
          var propTypesMisspellWarningShown;
          {
            propTypesMisspellWarningShown = false;
          }
          function isValidElement2(object) {
            {
              return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
            }
          }
          function getDeclarationErrorAddendum() {
            {
              if (ReactCurrentOwner$1.current) {
                var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);
                if (name) {
                  return "\n\nCheck the render method of `" + name + "`.";
                }
              }
              return "";
            }
          }
          function getSourceInfoErrorAddendum(source) {
            {
              if (source !== void 0) {
                var fileName = source.fileName.replace(/^.*[\\\/]/, "");
                var lineNumber = source.lineNumber;
                return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
              }
              return "";
            }
          }
          var ownerHasKeyUseWarning = {};
          function getCurrentComponentErrorInfo(parentType) {
            {
              var info = getDeclarationErrorAddendum();
              if (!info) {
                var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
                if (parentName) {
                  info = "\n\nCheck the top-level render call using <" + parentName + ">.";
                }
              }
              return info;
            }
          }
          function validateExplicitKey(element, parentType) {
            {
              if (!element._store || element._store.validated || element.key != null) {
                return;
              }
              element._store.validated = true;
              var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
              if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
                return;
              }
              ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
              var childOwner = "";
              if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {
                childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
              }
              setCurrentlyValidatingElement$1(element);
              error('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
              setCurrentlyValidatingElement$1(null);
            }
          }
          function validateChildKeys(node, parentType) {
            {
              if (typeof node !== "object") {
                return;
              }
              if (isArray(node)) {
                for (var i = 0; i < node.length; i++) {
                  var child = node[i];
                  if (isValidElement2(child)) {
                    validateExplicitKey(child, parentType);
                  }
                }
              } else if (isValidElement2(node)) {
                if (node._store) {
                  node._store.validated = true;
                }
              } else if (node) {
                var iteratorFn = getIteratorFn(node);
                if (typeof iteratorFn === "function") {
                  if (iteratorFn !== node.entries) {
                    var iterator = iteratorFn.call(node);
                    var step;
                    while (!(step = iterator.next()).done) {
                      if (isValidElement2(step.value)) {
                        validateExplicitKey(step.value, parentType);
                      }
                    }
                  }
                }
              }
            }
          }
          function validatePropTypes(element) {
            {
              var type = element.type;
              if (type === null || type === void 0 || typeof type === "string") {
                return;
              }
              var propTypes;
              if (typeof type === "function") {
                propTypes = type.propTypes;
              } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
              // Inner props are checked in the reconciler.
              type.$$typeof === REACT_MEMO_TYPE)) {
                propTypes = type.propTypes;
              } else {
                return;
              }
              if (propTypes) {
                var name = getComponentNameFromType(type);
                checkPropTypes(propTypes, element.props, "prop", name, element);
              } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
                propTypesMisspellWarningShown = true;
                var _name = getComponentNameFromType(type);
                error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
              }
              if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
                error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
              }
            }
          }
          function validateFragmentProps(fragment) {
            {
              var keys2 = Object.keys(fragment.props);
              for (var i = 0; i < keys2.length; i++) {
                var key = keys2[i];
                if (key !== "children" && key !== "key") {
                  setCurrentlyValidatingElement$1(fragment);
                  error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
                  setCurrentlyValidatingElement$1(null);
                  break;
                }
              }
              if (fragment.ref !== null) {
                setCurrentlyValidatingElement$1(fragment);
                error("Invalid attribute `ref` supplied to `React.Fragment`.");
                setCurrentlyValidatingElement$1(null);
              }
            }
          }
          var didWarnAboutKeySpread = {};
          function jsxWithValidation(type, props, key, isStaticChildren, source, self2) {
            {
              var validType = isValidElementType(type);
              if (!validType) {
                var info = "";
                if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
                  info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
                }
                var sourceInfo = getSourceInfoErrorAddendum(source);
                if (sourceInfo) {
                  info += sourceInfo;
                } else {
                  info += getDeclarationErrorAddendum();
                }
                var typeString;
                if (type === null) {
                  typeString = "null";
                } else if (isArray(type)) {
                  typeString = "array";
                } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {
                  typeString = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />";
                  info = " Did you accidentally export a JSX literal instead of a component?";
                } else {
                  typeString = typeof type;
                }
                error("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
              }
              var element = jsxDEV(type, props, key, source, self2);
              if (element == null) {
                return element;
              }
              if (validType) {
                var children = props.children;
                if (children !== void 0) {
                  if (isStaticChildren) {
                    if (isArray(children)) {
                      for (var i = 0; i < children.length; i++) {
                        validateChildKeys(children[i], type);
                      }
                      if (Object.freeze) {
                        Object.freeze(children);
                      }
                    } else {
                      error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
                    }
                  } else {
                    validateChildKeys(children, type);
                  }
                }
              }
              {
                if (hasOwnProperty.call(props, "key")) {
                  var componentName = getComponentNameFromType(type);
                  var keys2 = Object.keys(props).filter(function(k) {
                    return k !== "key";
                  });
                  var beforeExample = keys2.length > 0 ? "{key: someKey, " + keys2.join(": ..., ") + ": ...}" : "{key: someKey}";
                  if (!didWarnAboutKeySpread[componentName + beforeExample]) {
                    var afterExample = keys2.length > 0 ? "{" + keys2.join(": ..., ") + ": ...}" : "{}";
                    error('A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);
                    didWarnAboutKeySpread[componentName + beforeExample] = true;
                  }
                }
              }
              if (type === REACT_FRAGMENT_TYPE) {
                validateFragmentProps(element);
              } else {
                validatePropTypes(element);
              }
              return element;
            }
          }
          function jsxWithValidationStatic(type, props, key) {
            {
              return jsxWithValidation(type, props, key, true);
            }
          }
          function jsxWithValidationDynamic(type, props, key) {
            {
              return jsxWithValidation(type, props, key, false);
            }
          }
          var jsx11 = jsxWithValidationDynamic;
          var jsxs6 = jsxWithValidationStatic;
          exports.Fragment = REACT_FRAGMENT_TYPE;
          exports.jsx = jsx11;
          exports.jsxs = jsxs6;
        })();
      }
    }
  });

  // node_modules/react/jsx-runtime.js
  var require_jsx_runtime = __commonJS({
    "node_modules/react/jsx-runtime.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_react_jsx_runtime_development();
      }
    }
  });

  // frontend/src/index.jsx
  var import_react36 = __toESM(require_react());
  var import_client = __toESM(require_client());

  // frontend/src/App.jsx
  var import_react35 = __toESM(require_react());

  // node_modules/react-router-dom/dist/index.js
  var React2 = __toESM(require_react());
  var ReactDOM = __toESM(require_react_dom());

  // node_modules/react-router/dist/index.js
  var React = __toESM(require_react());

  // node_modules/@remix-run/router/dist/router.js
  function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends.apply(this, arguments);
  }
  var Action;
  (function(Action2) {
    Action2["Pop"] = "POP";
    Action2["Push"] = "PUSH";
    Action2["Replace"] = "REPLACE";
  })(Action || (Action = {}));
  var PopStateEventType = "popstate";
  function createHashHistory(options) {
    if (options === void 0) {
      options = {};
    }
    function createHashLocation(window2, globalHistory) {
      let {
        pathname = "/",
        search = "",
        hash: hash2 = ""
      } = parsePath(window2.location.hash.substr(1));
      if (!pathname.startsWith("/") && !pathname.startsWith(".")) {
        pathname = "/" + pathname;
      }
      return createLocation(
        "",
        {
          pathname,
          search,
          hash: hash2
        },
        // state defaults to `null` because `window.history.state` does
        globalHistory.state && globalHistory.state.usr || null,
        globalHistory.state && globalHistory.state.key || "default"
      );
    }
    function createHashHref(window2, to) {
      let base = window2.document.querySelector("base");
      let href = "";
      if (base && base.getAttribute("href")) {
        let url = window2.location.href;
        let hashIndex = url.indexOf("#");
        href = hashIndex === -1 ? url : url.slice(0, hashIndex);
      }
      return href + "#" + (typeof to === "string" ? to : createPath(to));
    }
    function validateHashLocation(location2, to) {
      warning(location2.pathname.charAt(0) === "/", "relative pathnames are not supported in hash history.push(" + JSON.stringify(to) + ")");
    }
    return getUrlBasedHistory(createHashLocation, createHashHref, validateHashLocation, options);
  }
  function invariant(value, message) {
    if (value === false || value === null || typeof value === "undefined") {
      throw new Error(message);
    }
  }
  function warning(cond, message) {
    if (!cond) {
      if (typeof console !== "undefined") console.warn(message);
      try {
        throw new Error(message);
      } catch (e) {
      }
    }
  }
  function createKey() {
    return Math.random().toString(36).substr(2, 8);
  }
  function getHistoryState(location2, index) {
    return {
      usr: location2.state,
      key: location2.key,
      idx: index
    };
  }
  function createLocation(current, to, state, key) {
    if (state === void 0) {
      state = null;
    }
    let location2 = _extends({
      pathname: typeof current === "string" ? current : current.pathname,
      search: "",
      hash: ""
    }, typeof to === "string" ? parsePath(to) : to, {
      state,
      // TODO: This could be cleaned up.  push/replace should probably just take
      // full Locations now and avoid the need to run through this flow at all
      // But that's a pretty big refactor to the current test suite so going to
      // keep as is for the time being and just let any incoming keys take precedence
      key: to && to.key || key || createKey()
    });
    return location2;
  }
  function createPath(_ref) {
    let {
      pathname = "/",
      search = "",
      hash: hash2 = ""
    } = _ref;
    if (search && search !== "?") pathname += search.charAt(0) === "?" ? search : "?" + search;
    if (hash2 && hash2 !== "#") pathname += hash2.charAt(0) === "#" ? hash2 : "#" + hash2;
    return pathname;
  }
  function parsePath(path) {
    let parsedPath = {};
    if (path) {
      let hashIndex = path.indexOf("#");
      if (hashIndex >= 0) {
        parsedPath.hash = path.substr(hashIndex);
        path = path.substr(0, hashIndex);
      }
      let searchIndex = path.indexOf("?");
      if (searchIndex >= 0) {
        parsedPath.search = path.substr(searchIndex);
        path = path.substr(0, searchIndex);
      }
      if (path) {
        parsedPath.pathname = path;
      }
    }
    return parsedPath;
  }
  function getUrlBasedHistory(getLocation, createHref, validateLocation, options) {
    if (options === void 0) {
      options = {};
    }
    let {
      window: window2 = document.defaultView,
      v5Compat = false
    } = options;
    let globalHistory = window2.history;
    let action = Action.Pop;
    let listener = null;
    let index = getIndex();
    if (index == null) {
      index = 0;
      globalHistory.replaceState(_extends({}, globalHistory.state, {
        idx: index
      }), "");
    }
    function getIndex() {
      let state = globalHistory.state || {
        idx: null
      };
      return state.idx;
    }
    function handlePop() {
      action = Action.Pop;
      let nextIndex = getIndex();
      let delta = nextIndex == null ? null : nextIndex - index;
      index = nextIndex;
      if (listener) {
        listener({
          action,
          location: history.location,
          delta
        });
      }
    }
    function push2(to, state) {
      action = Action.Push;
      let location2 = createLocation(history.location, to, state);
      if (validateLocation) validateLocation(location2, to);
      index = getIndex() + 1;
      let historyState = getHistoryState(location2, index);
      let url = history.createHref(location2);
      try {
        globalHistory.pushState(historyState, "", url);
      } catch (error) {
        if (error instanceof DOMException && error.name === "DataCloneError") {
          throw error;
        }
        window2.location.assign(url);
      }
      if (v5Compat && listener) {
        listener({
          action,
          location: history.location,
          delta: 1
        });
      }
    }
    function replace2(to, state) {
      action = Action.Replace;
      let location2 = createLocation(history.location, to, state);
      if (validateLocation) validateLocation(location2, to);
      index = getIndex();
      let historyState = getHistoryState(location2, index);
      let url = history.createHref(location2);
      globalHistory.replaceState(historyState, "", url);
      if (v5Compat && listener) {
        listener({
          action,
          location: history.location,
          delta: 0
        });
      }
    }
    function createURL(to) {
      let base = window2.location.origin !== "null" ? window2.location.origin : window2.location.href;
      let href = typeof to === "string" ? to : createPath(to);
      href = href.replace(/ $/, "%20");
      invariant(base, "No window.location.(origin|href) available to create URL for href: " + href);
      return new URL(href, base);
    }
    let history = {
      get action() {
        return action;
      },
      get location() {
        return getLocation(window2, globalHistory);
      },
      listen(fn) {
        if (listener) {
          throw new Error("A history only accepts one active listener");
        }
        window2.addEventListener(PopStateEventType, handlePop);
        listener = fn;
        return () => {
          window2.removeEventListener(PopStateEventType, handlePop);
          listener = null;
        };
      },
      createHref(to) {
        return createHref(window2, to);
      },
      createURL,
      encodeLocation(to) {
        let url = createURL(to);
        return {
          pathname: url.pathname,
          search: url.search,
          hash: url.hash
        };
      },
      push: push2,
      replace: replace2,
      go(n) {
        return globalHistory.go(n);
      }
    };
    return history;
  }
  var ResultType;
  (function(ResultType2) {
    ResultType2["data"] = "data";
    ResultType2["deferred"] = "deferred";
    ResultType2["redirect"] = "redirect";
    ResultType2["error"] = "error";
  })(ResultType || (ResultType = {}));
  function matchRoutes(routes, locationArg, basename) {
    if (basename === void 0) {
      basename = "/";
    }
    return matchRoutesImpl(routes, locationArg, basename, false);
  }
  function matchRoutesImpl(routes, locationArg, basename, allowPartial) {
    let location2 = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
    let pathname = stripBasename(location2.pathname || "/", basename);
    if (pathname == null) {
      return null;
    }
    let branches = flattenRoutes(routes);
    rankRouteBranches(branches);
    let matches = null;
    for (let i = 0; matches == null && i < branches.length; ++i) {
      let decoded = decodePath(pathname);
      matches = matchRouteBranch(branches[i], decoded, allowPartial);
    }
    return matches;
  }
  function convertRouteMatchToUiMatch(match, loaderData) {
    let {
      route,
      pathname,
      params
    } = match;
    return {
      id: route.id,
      pathname,
      params,
      data: loaderData[route.id],
      handle: route.handle
    };
  }
  function flattenRoutes(routes, branches, parentsMeta, parentPath) {
    if (branches === void 0) {
      branches = [];
    }
    if (parentsMeta === void 0) {
      parentsMeta = [];
    }
    if (parentPath === void 0) {
      parentPath = "";
    }
    let flattenRoute = (route, index, relativePath) => {
      let meta = {
        relativePath: relativePath === void 0 ? route.path || "" : relativePath,
        caseSensitive: route.caseSensitive === true,
        childrenIndex: index,
        route
      };
      if (meta.relativePath.startsWith("/")) {
        invariant(meta.relativePath.startsWith(parentPath), 'Absolute route path "' + meta.relativePath + '" nested under path ' + ('"' + parentPath + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes.");
        meta.relativePath = meta.relativePath.slice(parentPath.length);
      }
      let path = joinPaths([parentPath, meta.relativePath]);
      let routesMeta = parentsMeta.concat(meta);
      if (route.children && route.children.length > 0) {
        invariant(
          // Our types know better, but runtime JS may not!
          // @ts-expect-error
          route.index !== true,
          "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + path + '".')
        );
        flattenRoutes(route.children, branches, routesMeta, path);
      }
      if (route.path == null && !route.index) {
        return;
      }
      branches.push({
        path,
        score: computeScore(path, route.index),
        routesMeta
      });
    };
    routes.forEach((route, index) => {
      var _route$path;
      if (route.path === "" || !((_route$path = route.path) != null && _route$path.includes("?"))) {
        flattenRoute(route, index);
      } else {
        for (let exploded of explodeOptionalSegments(route.path)) {
          flattenRoute(route, index, exploded);
        }
      }
    });
    return branches;
  }
  function explodeOptionalSegments(path) {
    let segments = path.split("/");
    if (segments.length === 0) return [];
    let [first, ...rest] = segments;
    let isOptional = first.endsWith("?");
    let required = first.replace(/\?$/, "");
    if (rest.length === 0) {
      return isOptional ? [required, ""] : [required];
    }
    let restExploded = explodeOptionalSegments(rest.join("/"));
    let result = [];
    result.push(...restExploded.map((subpath) => subpath === "" ? required : [required, subpath].join("/")));
    if (isOptional) {
      result.push(...restExploded);
    }
    return result.map((exploded) => path.startsWith("/") && exploded === "" ? "/" : exploded);
  }
  function rankRouteBranches(branches) {
    branches.sort((a, b) => a.score !== b.score ? b.score - a.score : compareIndexes(a.routesMeta.map((meta) => meta.childrenIndex), b.routesMeta.map((meta) => meta.childrenIndex)));
  }
  var paramRe = /^:[\w-]+$/;
  var dynamicSegmentValue = 3;
  var indexRouteValue = 2;
  var emptySegmentValue = 1;
  var staticSegmentValue = 10;
  var splatPenalty = -2;
  var isSplat = (s) => s === "*";
  function computeScore(path, index) {
    let segments = path.split("/");
    let initialScore = segments.length;
    if (segments.some(isSplat)) {
      initialScore += splatPenalty;
    }
    if (index) {
      initialScore += indexRouteValue;
    }
    return segments.filter((s) => !isSplat(s)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);
  }
  function compareIndexes(a, b) {
    let siblings = a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);
    return siblings ? (
      // If two routes are siblings, we should try to match the earlier sibling
      // first. This allows people to have fine-grained control over the matching
      // behavior by simply putting routes with identical paths in the order they
      // want them tried.
      a[a.length - 1] - b[b.length - 1]
    ) : (
      // Otherwise, it doesn't really make sense to rank non-siblings by index,
      // so they sort equally.
      0
    );
  }
  function matchRouteBranch(branch, pathname, allowPartial) {
    if (allowPartial === void 0) {
      allowPartial = false;
    }
    let {
      routesMeta
    } = branch;
    let matchedParams = {};
    let matchedPathname = "/";
    let matches = [];
    for (let i = 0; i < routesMeta.length; ++i) {
      let meta = routesMeta[i];
      let end = i === routesMeta.length - 1;
      let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
      let match = matchPath({
        path: meta.relativePath,
        caseSensitive: meta.caseSensitive,
        end
      }, remainingPathname);
      let route = meta.route;
      if (!match && end && allowPartial && !routesMeta[routesMeta.length - 1].route.index) {
        match = matchPath({
          path: meta.relativePath,
          caseSensitive: meta.caseSensitive,
          end: false
        }, remainingPathname);
      }
      if (!match) {
        return null;
      }
      Object.assign(matchedParams, match.params);
      matches.push({
        // TODO: Can this as be avoided?
        params: matchedParams,
        pathname: joinPaths([matchedPathname, match.pathname]),
        pathnameBase: normalizePathname(joinPaths([matchedPathname, match.pathnameBase])),
        route
      });
      if (match.pathnameBase !== "/") {
        matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);
      }
    }
    return matches;
  }
  function matchPath(pattern, pathname) {
    if (typeof pattern === "string") {
      pattern = {
        path: pattern,
        caseSensitive: false,
        end: true
      };
    }
    let [matcher, compiledParams] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);
    let match = pathname.match(matcher);
    if (!match) return null;
    let matchedPathname = match[0];
    let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
    let captureGroups = match.slice(1);
    let params = compiledParams.reduce((memo3, _ref, index) => {
      let {
        paramName,
        isOptional
      } = _ref;
      if (paramName === "*") {
        let splatValue = captureGroups[index] || "";
        pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
      }
      const value = captureGroups[index];
      if (isOptional && !value) {
        memo3[paramName] = void 0;
      } else {
        memo3[paramName] = (value || "").replace(/%2F/g, "/");
      }
      return memo3;
    }, {});
    return {
      params,
      pathname: matchedPathname,
      pathnameBase,
      pattern
    };
  }
  function compilePath(path, caseSensitive, end) {
    if (caseSensitive === void 0) {
      caseSensitive = false;
    }
    if (end === void 0) {
      end = true;
    }
    warning(path === "*" || !path.endsWith("*") || path.endsWith("/*"), 'Route path "' + path + '" will be treated as if it were ' + ('"' + path.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + path.replace(/\*$/, "/*") + '".'));
    let params = [];
    let regexpSource = "^" + path.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (_, paramName, isOptional) => {
      params.push({
        paramName,
        isOptional: isOptional != null
      });
      return isOptional ? "/?([^\\/]+)?" : "/([^\\/]+)";
    });
    if (path.endsWith("*")) {
      params.push({
        paramName: "*"
      });
      regexpSource += path === "*" || path === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$";
    } else if (end) {
      regexpSource += "\\/*$";
    } else if (path !== "" && path !== "/") {
      regexpSource += "(?:(?=\\/|$))";
    } else ;
    let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : "i");
    return [matcher, params];
  }
  function decodePath(value) {
    try {
      return value.split("/").map((v) => decodeURIComponent(v).replace(/\//g, "%2F")).join("/");
    } catch (error) {
      warning(false, 'The URL path "' + value + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + error + ")."));
      return value;
    }
  }
  function stripBasename(pathname, basename) {
    if (basename === "/") return pathname;
    if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
      return null;
    }
    let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length;
    let nextChar = pathname.charAt(startIndex);
    if (nextChar && nextChar !== "/") {
      return null;
    }
    return pathname.slice(startIndex) || "/";
  }
  function resolvePath(to, fromPathname) {
    if (fromPathname === void 0) {
      fromPathname = "/";
    }
    let {
      pathname: toPathname,
      search = "",
      hash: hash2 = ""
    } = typeof to === "string" ? parsePath(to) : to;
    let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
    return {
      pathname,
      search: normalizeSearch(search),
      hash: normalizeHash(hash2)
    };
  }
  function resolvePathname(relativePath, fromPathname) {
    let segments = fromPathname.replace(/\/+$/, "").split("/");
    let relativeSegments = relativePath.split("/");
    relativeSegments.forEach((segment) => {
      if (segment === "..") {
        if (segments.length > 1) segments.pop();
      } else if (segment !== ".") {
        segments.push(segment);
      }
    });
    return segments.length > 1 ? segments.join("/") : "/";
  }
  function getInvalidPathError(char, field, dest, path) {
    return "Cannot include a '" + char + "' character in a manually specified " + ("`to." + field + "` field [" + JSON.stringify(path) + "].  Please separate it out to the ") + ("`to." + dest + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.';
  }
  function getPathContributingMatches(matches) {
    return matches.filter((match, index) => index === 0 || match.route.path && match.route.path.length > 0);
  }
  function getResolveToMatches(matches, v7_relativeSplatPath) {
    let pathMatches = getPathContributingMatches(matches);
    if (v7_relativeSplatPath) {
      return pathMatches.map((match, idx) => idx === pathMatches.length - 1 ? match.pathname : match.pathnameBase);
    }
    return pathMatches.map((match) => match.pathnameBase);
  }
  function resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {
    if (isPathRelative === void 0) {
      isPathRelative = false;
    }
    let to;
    if (typeof toArg === "string") {
      to = parsePath(toArg);
    } else {
      to = _extends({}, toArg);
      invariant(!to.pathname || !to.pathname.includes("?"), getInvalidPathError("?", "pathname", "search", to));
      invariant(!to.pathname || !to.pathname.includes("#"), getInvalidPathError("#", "pathname", "hash", to));
      invariant(!to.search || !to.search.includes("#"), getInvalidPathError("#", "search", "hash", to));
    }
    let isEmptyPath = toArg === "" || to.pathname === "";
    let toPathname = isEmptyPath ? "/" : to.pathname;
    let from;
    if (toPathname == null) {
      from = locationPathname;
    } else {
      let routePathnameIndex = routePathnames.length - 1;
      if (!isPathRelative && toPathname.startsWith("..")) {
        let toSegments = toPathname.split("/");
        while (toSegments[0] === "..") {
          toSegments.shift();
          routePathnameIndex -= 1;
        }
        to.pathname = toSegments.join("/");
      }
      from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
    }
    let path = resolvePath(to, from);
    let hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/");
    let hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
    if (!path.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {
      path.pathname += "/";
    }
    return path;
  }
  var joinPaths = (paths) => paths.join("/").replace(/\/\/+/g, "/");
  var normalizePathname = (pathname) => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
  var normalizeSearch = (search) => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;
  var normalizeHash = (hash2) => !hash2 || hash2 === "#" ? "" : hash2.startsWith("#") ? hash2 : "#" + hash2;
  function isRouteErrorResponse(error) {
    return error != null && typeof error.status === "number" && typeof error.statusText === "string" && typeof error.internal === "boolean" && "data" in error;
  }
  var validMutationMethodsArr = ["post", "put", "patch", "delete"];
  var validMutationMethods = new Set(validMutationMethodsArr);
  var validRequestMethodsArr = ["get", ...validMutationMethodsArr];
  var validRequestMethods = new Set(validRequestMethodsArr);
  var UNSAFE_DEFERRED_SYMBOL = Symbol("deferred");

  // node_modules/react-router/dist/index.js
  function _extends2() {
    _extends2 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends2.apply(this, arguments);
  }
  var DataRouterContext = /* @__PURE__ */ React.createContext(null);
  if (true) {
    DataRouterContext.displayName = "DataRouter";
  }
  var DataRouterStateContext = /* @__PURE__ */ React.createContext(null);
  if (true) {
    DataRouterStateContext.displayName = "DataRouterState";
  }
  var AwaitContext = /* @__PURE__ */ React.createContext(null);
  if (true) {
    AwaitContext.displayName = "Await";
  }
  var NavigationContext = /* @__PURE__ */ React.createContext(null);
  if (true) {
    NavigationContext.displayName = "Navigation";
  }
  var LocationContext = /* @__PURE__ */ React.createContext(null);
  if (true) {
    LocationContext.displayName = "Location";
  }
  var RouteContext = /* @__PURE__ */ React.createContext({
    outlet: null,
    matches: [],
    isDataRoute: false
  });
  if (true) {
    RouteContext.displayName = "Route";
  }
  var RouteErrorContext = /* @__PURE__ */ React.createContext(null);
  if (true) {
    RouteErrorContext.displayName = "RouteError";
  }
  function useHref(to, _temp) {
    let {
      relative
    } = _temp === void 0 ? {} : _temp;
    !useInRouterContext() ? true ? invariant(
      false,
      // TODO: This error is probably because they somehow have 2 versions of the
      // router loaded. We can help them understand how to avoid that.
      "useHref() may be used only in the context of a <Router> component."
    ) : invariant(false) : void 0;
    let {
      basename,
      navigator: navigator2
    } = React.useContext(NavigationContext);
    let {
      hash: hash2,
      pathname,
      search
    } = useResolvedPath(to, {
      relative
    });
    let joinedPathname = pathname;
    if (basename !== "/") {
      joinedPathname = pathname === "/" ? basename : joinPaths([basename, pathname]);
    }
    return navigator2.createHref({
      pathname: joinedPathname,
      search,
      hash: hash2
    });
  }
  function useInRouterContext() {
    return React.useContext(LocationContext) != null;
  }
  function useLocation() {
    !useInRouterContext() ? true ? invariant(
      false,
      // TODO: This error is probably because they somehow have 2 versions of the
      // router loaded. We can help them understand how to avoid that.
      "useLocation() may be used only in the context of a <Router> component."
    ) : invariant(false) : void 0;
    return React.useContext(LocationContext).location;
  }
  var navigateEffectWarning = "You should call navigate() in a React.useEffect(), not when your component is first rendered.";
  function useIsomorphicLayoutEffect(cb) {
    let isStatic = React.useContext(NavigationContext).static;
    if (!isStatic) {
      React.useLayoutEffect(cb);
    }
  }
  function useNavigate() {
    let {
      isDataRoute
    } = React.useContext(RouteContext);
    return isDataRoute ? useNavigateStable() : useNavigateUnstable();
  }
  function useNavigateUnstable() {
    !useInRouterContext() ? true ? invariant(
      false,
      // TODO: This error is probably because they somehow have 2 versions of the
      // router loaded. We can help them understand how to avoid that.
      "useNavigate() may be used only in the context of a <Router> component."
    ) : invariant(false) : void 0;
    let dataRouterContext = React.useContext(DataRouterContext);
    let {
      basename,
      future,
      navigator: navigator2
    } = React.useContext(NavigationContext);
    let {
      matches
    } = React.useContext(RouteContext);
    let {
      pathname: locationPathname
    } = useLocation();
    let routePathnamesJson = JSON.stringify(getResolveToMatches(matches, future.v7_relativeSplatPath));
    let activeRef = React.useRef(false);
    useIsomorphicLayoutEffect(() => {
      activeRef.current = true;
    });
    let navigate = React.useCallback(function(to, options) {
      if (options === void 0) {
        options = {};
      }
      true ? warning(activeRef.current, navigateEffectWarning) : void 0;
      if (!activeRef.current) return;
      if (typeof to === "number") {
        navigator2.go(to);
        return;
      }
      let path = resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, options.relative === "path");
      if (dataRouterContext == null && basename !== "/") {
        path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
      }
      (!!options.replace ? navigator2.replace : navigator2.push)(path, options.state, options);
    }, [basename, navigator2, routePathnamesJson, locationPathname, dataRouterContext]);
    return navigate;
  }
  function useResolvedPath(to, _temp2) {
    let {
      relative
    } = _temp2 === void 0 ? {} : _temp2;
    let {
      future
    } = React.useContext(NavigationContext);
    let {
      matches
    } = React.useContext(RouteContext);
    let {
      pathname: locationPathname
    } = useLocation();
    let routePathnamesJson = JSON.stringify(getResolveToMatches(matches, future.v7_relativeSplatPath));
    return React.useMemo(() => resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, relative === "path"), [to, routePathnamesJson, locationPathname, relative]);
  }
  function useRoutes(routes, locationArg) {
    return useRoutesImpl(routes, locationArg);
  }
  function useRoutesImpl(routes, locationArg, dataRouterState, future) {
    !useInRouterContext() ? true ? invariant(
      false,
      // TODO: This error is probably because they somehow have 2 versions of the
      // router loaded. We can help them understand how to avoid that.
      "useRoutes() may be used only in the context of a <Router> component."
    ) : invariant(false) : void 0;
    let {
      navigator: navigator2
    } = React.useContext(NavigationContext);
    let {
      matches: parentMatches
    } = React.useContext(RouteContext);
    let routeMatch = parentMatches[parentMatches.length - 1];
    let parentParams = routeMatch ? routeMatch.params : {};
    let parentPathname = routeMatch ? routeMatch.pathname : "/";
    let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
    let parentRoute = routeMatch && routeMatch.route;
    if (true) {
      let parentPath = parentRoute && parentRoute.path || "";
      warningOnce(parentPathname, !parentRoute || parentPath.endsWith("*"), "You rendered descendant <Routes> (or called `useRoutes()`) at " + ('"' + parentPathname + '" (under <Route path="' + parentPath + '">) but the ') + `parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

` + ('Please change the parent <Route path="' + parentPath + '"> to <Route ') + ('path="' + (parentPath === "/" ? "*" : parentPath + "/*") + '">.'));
    }
    let locationFromContext = useLocation();
    let location2;
    if (locationArg) {
      var _parsedLocationArg$pa;
      let parsedLocationArg = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
      !(parentPathnameBase === "/" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ? true ? invariant(false, "When overriding the location using `<Routes location>` or `useRoutes(routes, location)`, the location pathname must begin with the portion of the URL pathname that was " + ('matched by all parent routes. The current pathname base is "' + parentPathnameBase + '" ') + ('but pathname "' + parsedLocationArg.pathname + '" was given in the `location` prop.')) : invariant(false) : void 0;
      location2 = parsedLocationArg;
    } else {
      location2 = locationFromContext;
    }
    let pathname = location2.pathname || "/";
    let remainingPathname = pathname;
    if (parentPathnameBase !== "/") {
      let parentSegments = parentPathnameBase.replace(/^\//, "").split("/");
      let segments = pathname.replace(/^\//, "").split("/");
      remainingPathname = "/" + segments.slice(parentSegments.length).join("/");
    }
    let matches = matchRoutes(routes, {
      pathname: remainingPathname
    });
    if (true) {
      true ? warning(parentRoute || matches != null, 'No routes matched location "' + location2.pathname + location2.search + location2.hash + '" ') : void 0;
      true ? warning(matches == null || matches[matches.length - 1].route.element !== void 0 || matches[matches.length - 1].route.Component !== void 0 || matches[matches.length - 1].route.lazy !== void 0, 'Matched leaf route at location "' + location2.pathname + location2.search + location2.hash + '" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.') : void 0;
    }
    let renderedMatches = _renderMatches(matches && matches.map((match) => Object.assign({}, match, {
      params: Object.assign({}, parentParams, match.params),
      pathname: joinPaths([
        parentPathnameBase,
        // Re-encode pathnames that were decoded inside matchRoutes
        navigator2.encodeLocation ? navigator2.encodeLocation(match.pathname).pathname : match.pathname
      ]),
      pathnameBase: match.pathnameBase === "/" ? parentPathnameBase : joinPaths([
        parentPathnameBase,
        // Re-encode pathnames that were decoded inside matchRoutes
        navigator2.encodeLocation ? navigator2.encodeLocation(match.pathnameBase).pathname : match.pathnameBase
      ])
    })), parentMatches, dataRouterState, future);
    if (locationArg && renderedMatches) {
      return /* @__PURE__ */ React.createElement(LocationContext.Provider, {
        value: {
          location: _extends2({
            pathname: "/",
            search: "",
            hash: "",
            state: null,
            key: "default"
          }, location2),
          navigationType: Action.Pop
        }
      }, renderedMatches);
    }
    return renderedMatches;
  }
  function DefaultErrorComponent() {
    let error = useRouteError();
    let message = isRouteErrorResponse(error) ? error.status + " " + error.statusText : error instanceof Error ? error.message : JSON.stringify(error);
    let stack = error instanceof Error ? error.stack : null;
    let lightgrey = "rgba(200,200,200, 0.5)";
    let preStyles = {
      padding: "0.5rem",
      backgroundColor: lightgrey
    };
    let codeStyles = {
      padding: "2px 4px",
      backgroundColor: lightgrey
    };
    let devInfo = null;
    if (true) {
      console.error("Error handled by React Router default ErrorBoundary:", error);
      devInfo = /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("p", null, "\u{1F4BF} Hey developer \u{1F44B}"), /* @__PURE__ */ React.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own ", /* @__PURE__ */ React.createElement("code", {
        style: codeStyles
      }, "ErrorBoundary"), " or", " ", /* @__PURE__ */ React.createElement("code", {
        style: codeStyles
      }, "errorElement"), " prop on your route."));
    }
    return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("h2", null, "Unexpected Application Error!"), /* @__PURE__ */ React.createElement("h3", {
      style: {
        fontStyle: "italic"
      }
    }, message), stack ? /* @__PURE__ */ React.createElement("pre", {
      style: preStyles
    }, stack) : null, devInfo);
  }
  var defaultErrorElement = /* @__PURE__ */ React.createElement(DefaultErrorComponent, null);
  var RenderErrorBoundary = class extends React.Component {
    constructor(props) {
      super(props);
      this.state = {
        location: props.location,
        revalidation: props.revalidation,
        error: props.error
      };
    }
    static getDerivedStateFromError(error) {
      return {
        error
      };
    }
    static getDerivedStateFromProps(props, state) {
      if (state.location !== props.location || state.revalidation !== "idle" && props.revalidation === "idle") {
        return {
          error: props.error,
          location: props.location,
          revalidation: props.revalidation
        };
      }
      return {
        error: props.error !== void 0 ? props.error : state.error,
        location: state.location,
        revalidation: props.revalidation || state.revalidation
      };
    }
    componentDidCatch(error, errorInfo) {
      console.error("React Router caught the following error during render", error, errorInfo);
    }
    render() {
      return this.state.error !== void 0 ? /* @__PURE__ */ React.createElement(RouteContext.Provider, {
        value: this.props.routeContext
      }, /* @__PURE__ */ React.createElement(RouteErrorContext.Provider, {
        value: this.state.error,
        children: this.props.component
      })) : this.props.children;
    }
  };
  function RenderedRoute(_ref) {
    let {
      routeContext,
      match,
      children
    } = _ref;
    let dataRouterContext = React.useContext(DataRouterContext);
    if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match.route.errorElement || match.route.ErrorBoundary)) {
      dataRouterContext.staticContext._deepestRenderedBoundaryId = match.route.id;
    }
    return /* @__PURE__ */ React.createElement(RouteContext.Provider, {
      value: routeContext
    }, children);
  }
  function _renderMatches(matches, parentMatches, dataRouterState, future) {
    var _dataRouterState;
    if (parentMatches === void 0) {
      parentMatches = [];
    }
    if (dataRouterState === void 0) {
      dataRouterState = null;
    }
    if (future === void 0) {
      future = null;
    }
    if (matches == null) {
      var _future;
      if (!dataRouterState) {
        return null;
      }
      if (dataRouterState.errors) {
        matches = dataRouterState.matches;
      } else if ((_future = future) != null && _future.v7_partialHydration && parentMatches.length === 0 && !dataRouterState.initialized && dataRouterState.matches.length > 0) {
        matches = dataRouterState.matches;
      } else {
        return null;
      }
    }
    let renderedMatches = matches;
    let errors = (_dataRouterState = dataRouterState) == null ? void 0 : _dataRouterState.errors;
    if (errors != null) {
      let errorIndex = renderedMatches.findIndex((m) => m.route.id && (errors == null ? void 0 : errors[m.route.id]) !== void 0);
      !(errorIndex >= 0) ? true ? invariant(false, "Could not find a matching route for errors on route IDs: " + Object.keys(errors).join(",")) : invariant(false) : void 0;
      renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));
    }
    let renderFallback = false;
    let fallbackIndex = -1;
    if (dataRouterState && future && future.v7_partialHydration) {
      for (let i = 0; i < renderedMatches.length; i++) {
        let match = renderedMatches[i];
        if (match.route.HydrateFallback || match.route.hydrateFallbackElement) {
          fallbackIndex = i;
        }
        if (match.route.id) {
          let {
            loaderData,
            errors: errors2
          } = dataRouterState;
          let needsToRunLoader = match.route.loader && loaderData[match.route.id] === void 0 && (!errors2 || errors2[match.route.id] === void 0);
          if (match.route.lazy || needsToRunLoader) {
            renderFallback = true;
            if (fallbackIndex >= 0) {
              renderedMatches = renderedMatches.slice(0, fallbackIndex + 1);
            } else {
              renderedMatches = [renderedMatches[0]];
            }
            break;
          }
        }
      }
    }
    return renderedMatches.reduceRight((outlet, match, index) => {
      let error;
      let shouldRenderHydrateFallback = false;
      let errorElement = null;
      let hydrateFallbackElement = null;
      if (dataRouterState) {
        error = errors && match.route.id ? errors[match.route.id] : void 0;
        errorElement = match.route.errorElement || defaultErrorElement;
        if (renderFallback) {
          if (fallbackIndex < 0 && index === 0) {
            warningOnce("route-fallback", false, "No `HydrateFallback` element provided to render during initial hydration");
            shouldRenderHydrateFallback = true;
            hydrateFallbackElement = null;
          } else if (fallbackIndex === index) {
            shouldRenderHydrateFallback = true;
            hydrateFallbackElement = match.route.hydrateFallbackElement || null;
          }
        }
      }
      let matches2 = parentMatches.concat(renderedMatches.slice(0, index + 1));
      let getChildren = () => {
        let children;
        if (error) {
          children = errorElement;
        } else if (shouldRenderHydrateFallback) {
          children = hydrateFallbackElement;
        } else if (match.route.Component) {
          children = /* @__PURE__ */ React.createElement(match.route.Component, null);
        } else if (match.route.element) {
          children = match.route.element;
        } else {
          children = outlet;
        }
        return /* @__PURE__ */ React.createElement(RenderedRoute, {
          match,
          routeContext: {
            outlet,
            matches: matches2,
            isDataRoute: dataRouterState != null
          },
          children
        });
      };
      return dataRouterState && (match.route.ErrorBoundary || match.route.errorElement || index === 0) ? /* @__PURE__ */ React.createElement(RenderErrorBoundary, {
        location: dataRouterState.location,
        revalidation: dataRouterState.revalidation,
        component: errorElement,
        error,
        children: getChildren(),
        routeContext: {
          outlet: null,
          matches: matches2,
          isDataRoute: true
        }
      }) : getChildren();
    }, null);
  }
  var DataRouterHook = /* @__PURE__ */ (function(DataRouterHook3) {
    DataRouterHook3["UseBlocker"] = "useBlocker";
    DataRouterHook3["UseRevalidator"] = "useRevalidator";
    DataRouterHook3["UseNavigateStable"] = "useNavigate";
    return DataRouterHook3;
  })(DataRouterHook || {});
  var DataRouterStateHook = /* @__PURE__ */ (function(DataRouterStateHook3) {
    DataRouterStateHook3["UseBlocker"] = "useBlocker";
    DataRouterStateHook3["UseLoaderData"] = "useLoaderData";
    DataRouterStateHook3["UseActionData"] = "useActionData";
    DataRouterStateHook3["UseRouteError"] = "useRouteError";
    DataRouterStateHook3["UseNavigation"] = "useNavigation";
    DataRouterStateHook3["UseRouteLoaderData"] = "useRouteLoaderData";
    DataRouterStateHook3["UseMatches"] = "useMatches";
    DataRouterStateHook3["UseRevalidator"] = "useRevalidator";
    DataRouterStateHook3["UseNavigateStable"] = "useNavigate";
    DataRouterStateHook3["UseRouteId"] = "useRouteId";
    return DataRouterStateHook3;
  })(DataRouterStateHook || {});
  function getDataRouterConsoleError(hookName) {
    return hookName + " must be used within a data router.  See https://reactrouter.com/v6/routers/picking-a-router.";
  }
  function useDataRouterContext(hookName) {
    let ctx = React.useContext(DataRouterContext);
    !ctx ? true ? invariant(false, getDataRouterConsoleError(hookName)) : invariant(false) : void 0;
    return ctx;
  }
  function useDataRouterState(hookName) {
    let state = React.useContext(DataRouterStateContext);
    !state ? true ? invariant(false, getDataRouterConsoleError(hookName)) : invariant(false) : void 0;
    return state;
  }
  function useRouteContext(hookName) {
    let route = React.useContext(RouteContext);
    !route ? true ? invariant(false, getDataRouterConsoleError(hookName)) : invariant(false) : void 0;
    return route;
  }
  function useCurrentRouteId(hookName) {
    let route = useRouteContext(hookName);
    let thisRoute = route.matches[route.matches.length - 1];
    !thisRoute.route.id ? true ? invariant(false, hookName + ' can only be used on routes that contain a unique "id"') : invariant(false) : void 0;
    return thisRoute.route.id;
  }
  function useRouteId() {
    return useCurrentRouteId(DataRouterStateHook.UseRouteId);
  }
  function useNavigation() {
    let state = useDataRouterState(DataRouterStateHook.UseNavigation);
    return state.navigation;
  }
  function useMatches() {
    let {
      matches,
      loaderData
    } = useDataRouterState(DataRouterStateHook.UseMatches);
    return React.useMemo(() => matches.map((m) => convertRouteMatchToUiMatch(m, loaderData)), [matches, loaderData]);
  }
  function useRouteError() {
    var _state$errors;
    let error = React.useContext(RouteErrorContext);
    let state = useDataRouterState(DataRouterStateHook.UseRouteError);
    let routeId = useCurrentRouteId(DataRouterStateHook.UseRouteError);
    if (error !== void 0) {
      return error;
    }
    return (_state$errors = state.errors) == null ? void 0 : _state$errors[routeId];
  }
  function useNavigateStable() {
    let {
      router
    } = useDataRouterContext(DataRouterHook.UseNavigateStable);
    let id3 = useCurrentRouteId(DataRouterStateHook.UseNavigateStable);
    let activeRef = React.useRef(false);
    useIsomorphicLayoutEffect(() => {
      activeRef.current = true;
    });
    let navigate = React.useCallback(function(to, options) {
      if (options === void 0) {
        options = {};
      }
      true ? warning(activeRef.current, navigateEffectWarning) : void 0;
      if (!activeRef.current) return;
      if (typeof to === "number") {
        router.navigate(to);
      } else {
        router.navigate(to, _extends2({
          fromRouteId: id3
        }, options));
      }
    }, [router, id3]);
    return navigate;
  }
  var alreadyWarned$1 = {};
  function warningOnce(key, cond, message) {
    if (!cond && !alreadyWarned$1[key]) {
      alreadyWarned$1[key] = true;
      true ? warning(false, message) : void 0;
    }
  }
  var alreadyWarned = {};
  function warnOnce(key, message) {
    if (!alreadyWarned[message]) {
      alreadyWarned[message] = true;
      console.warn(message);
    }
  }
  var logDeprecation = (flag, msg, link) => warnOnce(flag, "\u26A0\uFE0F React Router Future Flag Warning: " + msg + ". " + ("You can use the `" + flag + "` future flag to opt-in early. ") + ("For more information, see " + link + "."));
  function logV6DeprecationWarnings(renderFuture, routerFuture) {
    if ((renderFuture == null ? void 0 : renderFuture.v7_startTransition) === void 0) {
      logDeprecation("v7_startTransition", "React Router will begin wrapping state updates in `React.startTransition` in v7", "https://reactrouter.com/v6/upgrading/future#v7_starttransition");
    }
    if ((renderFuture == null ? void 0 : renderFuture.v7_relativeSplatPath) === void 0 && (!routerFuture || routerFuture.v7_relativeSplatPath === void 0)) {
      logDeprecation("v7_relativeSplatPath", "Relative route resolution within Splat routes is changing in v7", "https://reactrouter.com/v6/upgrading/future#v7_relativesplatpath");
    }
    if (routerFuture) {
      if (routerFuture.v7_fetcherPersist === void 0) {
        logDeprecation("v7_fetcherPersist", "The persistence behavior of fetchers is changing in v7", "https://reactrouter.com/v6/upgrading/future#v7_fetcherpersist");
      }
      if (routerFuture.v7_normalizeFormMethod === void 0) {
        logDeprecation("v7_normalizeFormMethod", "Casing of `formMethod` fields is being normalized to uppercase in v7", "https://reactrouter.com/v6/upgrading/future#v7_normalizeformmethod");
      }
      if (routerFuture.v7_partialHydration === void 0) {
        logDeprecation("v7_partialHydration", "`RouterProvider` hydration behavior is changing in v7", "https://reactrouter.com/v6/upgrading/future#v7_partialhydration");
      }
      if (routerFuture.v7_skipActionErrorRevalidation === void 0) {
        logDeprecation("v7_skipActionErrorRevalidation", "The revalidation behavior after 4xx/5xx `action` responses is changing in v7", "https://reactrouter.com/v6/upgrading/future#v7_skipactionerrorrevalidation");
      }
    }
  }
  var START_TRANSITION = "startTransition";
  var startTransitionImpl = React[START_TRANSITION];
  function Route(_props) {
    true ? invariant(false, "A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.") : invariant(false);
  }
  function Router(_ref5) {
    let {
      basename: basenameProp = "/",
      children = null,
      location: locationProp,
      navigationType = Action.Pop,
      navigator: navigator2,
      static: staticProp = false,
      future
    } = _ref5;
    !!useInRouterContext() ? true ? invariant(false, "You cannot render a <Router> inside another <Router>. You should never have more than one in your app.") : invariant(false) : void 0;
    let basename = basenameProp.replace(/^\/*/, "/");
    let navigationContext = React.useMemo(() => ({
      basename,
      navigator: navigator2,
      static: staticProp,
      future: _extends2({
        v7_relativeSplatPath: false
      }, future)
    }), [basename, future, navigator2, staticProp]);
    if (typeof locationProp === "string") {
      locationProp = parsePath(locationProp);
    }
    let {
      pathname = "/",
      search = "",
      hash: hash2 = "",
      state = null,
      key = "default"
    } = locationProp;
    let locationContext = React.useMemo(() => {
      let trailingPathname = stripBasename(pathname, basename);
      if (trailingPathname == null) {
        return null;
      }
      return {
        location: {
          pathname: trailingPathname,
          search,
          hash: hash2,
          state,
          key
        },
        navigationType
      };
    }, [basename, pathname, search, hash2, state, key, navigationType]);
    true ? warning(locationContext != null, '<Router basename="' + basename + '"> is not able to match the URL ' + ('"' + pathname + search + hash2 + '" because it does not start with the ') + "basename, so the <Router> won't render anything.") : void 0;
    if (locationContext == null) {
      return null;
    }
    return /* @__PURE__ */ React.createElement(NavigationContext.Provider, {
      value: navigationContext
    }, /* @__PURE__ */ React.createElement(LocationContext.Provider, {
      children,
      value: locationContext
    }));
  }
  function Routes(_ref6) {
    let {
      children,
      location: location2
    } = _ref6;
    return useRoutes(createRoutesFromChildren(children), location2);
  }
  var neverSettledPromise = new Promise(() => {
  });
  function createRoutesFromChildren(children, parentPath) {
    if (parentPath === void 0) {
      parentPath = [];
    }
    let routes = [];
    React.Children.forEach(children, (element, index) => {
      if (!/* @__PURE__ */ React.isValidElement(element)) {
        return;
      }
      let treePath = [...parentPath, index];
      if (element.type === React.Fragment) {
        routes.push.apply(routes, createRoutesFromChildren(element.props.children, treePath));
        return;
      }
      !(element.type === Route) ? true ? invariant(false, "[" + (typeof element.type === "string" ? element.type : element.type.name) + "] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>") : invariant(false) : void 0;
      !(!element.props.index || !element.props.children) ? true ? invariant(false, "An index route cannot have child routes.") : invariant(false) : void 0;
      let route = {
        id: element.props.id || treePath.join("-"),
        caseSensitive: element.props.caseSensitive,
        element: element.props.element,
        Component: element.props.Component,
        index: element.props.index,
        path: element.props.path,
        loader: element.props.loader,
        action: element.props.action,
        errorElement: element.props.errorElement,
        ErrorBoundary: element.props.ErrorBoundary,
        hasErrorBoundary: element.props.ErrorBoundary != null || element.props.errorElement != null,
        shouldRevalidate: element.props.shouldRevalidate,
        handle: element.props.handle,
        lazy: element.props.lazy
      };
      if (element.props.children) {
        route.children = createRoutesFromChildren(element.props.children, treePath);
      }
      routes.push(route);
    });
    return routes;
  }

  // node_modules/react-router-dom/dist/index.js
  function _extends3() {
    _extends3 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends3.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }
    return target;
  }
  var defaultMethod = "get";
  var defaultEncType = "application/x-www-form-urlencoded";
  function isHtmlElement(object) {
    return object != null && typeof object.tagName === "string";
  }
  function isButtonElement(object) {
    return isHtmlElement(object) && object.tagName.toLowerCase() === "button";
  }
  function isFormElement(object) {
    return isHtmlElement(object) && object.tagName.toLowerCase() === "form";
  }
  function isInputElement(object) {
    return isHtmlElement(object) && object.tagName.toLowerCase() === "input";
  }
  function isModifiedEvent(event) {
    return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
  }
  function shouldProcessLinkClick(event, target) {
    return event.button === 0 && // Ignore everything but left clicks
    (!target || target === "_self") && // Let browser handle "target=_blank" etc.
    !isModifiedEvent(event);
  }
  var _formDataSupportsSubmitter = null;
  function isFormDataSubmitterSupported() {
    if (_formDataSupportsSubmitter === null) {
      try {
        new FormData(
          document.createElement("form"),
          // @ts-expect-error if FormData supports the submitter parameter, this will throw
          0
        );
        _formDataSupportsSubmitter = false;
      } catch (e) {
        _formDataSupportsSubmitter = true;
      }
    }
    return _formDataSupportsSubmitter;
  }
  var supportedFormEncTypes = /* @__PURE__ */ new Set(["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"]);
  function getFormEncType(encType) {
    if (encType != null && !supportedFormEncTypes.has(encType)) {
      true ? warning(false, '"' + encType + '" is not a valid `encType` for `<Form>`/`<fetcher.Form>` ' + ('and will default to "' + defaultEncType + '"')) : void 0;
      return null;
    }
    return encType;
  }
  function getFormSubmissionInfo(target, basename) {
    let method;
    let action;
    let encType;
    let formData;
    let body;
    if (isFormElement(target)) {
      let attr = target.getAttribute("action");
      action = attr ? stripBasename(attr, basename) : null;
      method = target.getAttribute("method") || defaultMethod;
      encType = getFormEncType(target.getAttribute("enctype")) || defaultEncType;
      formData = new FormData(target);
    } else if (isButtonElement(target) || isInputElement(target) && (target.type === "submit" || target.type === "image")) {
      let form = target.form;
      if (form == null) {
        throw new Error('Cannot submit a <button> or <input type="submit"> without a <form>');
      }
      let attr = target.getAttribute("formaction") || form.getAttribute("action");
      action = attr ? stripBasename(attr, basename) : null;
      method = target.getAttribute("formmethod") || form.getAttribute("method") || defaultMethod;
      encType = getFormEncType(target.getAttribute("formenctype")) || getFormEncType(form.getAttribute("enctype")) || defaultEncType;
      formData = new FormData(form, target);
      if (!isFormDataSubmitterSupported()) {
        let {
          name,
          type,
          value
        } = target;
        if (type === "image") {
          let prefix = name ? name + "." : "";
          formData.append(prefix + "x", "0");
          formData.append(prefix + "y", "0");
        } else if (name) {
          formData.append(name, value);
        }
      }
    } else if (isHtmlElement(target)) {
      throw new Error('Cannot submit element that is not <form>, <button>, or <input type="submit|image">');
    } else {
      method = defaultMethod;
      action = null;
      encType = defaultEncType;
      body = target;
    }
    if (formData && encType === "text/plain") {
      body = formData;
      formData = void 0;
    }
    return {
      action,
      method: method.toLowerCase(),
      encType,
      formData,
      body
    };
  }
  var _excluded = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset", "viewTransition"];
  var _excluded2 = ["aria-current", "caseSensitive", "className", "end", "style", "to", "viewTransition", "children"];
  var _excluded3 = ["fetcherKey", "navigate", "reloadDocument", "replace", "state", "method", "action", "onSubmit", "relative", "preventScrollReset", "viewTransition"];
  var REACT_ROUTER_VERSION = "6";
  try {
    window.__reactRouterVersion = REACT_ROUTER_VERSION;
  } catch (e) {
  }
  var ViewTransitionContext = /* @__PURE__ */ React2.createContext({
    isTransitioning: false
  });
  if (true) {
    ViewTransitionContext.displayName = "ViewTransition";
  }
  var FetchersContext = /* @__PURE__ */ React2.createContext(/* @__PURE__ */ new Map());
  if (true) {
    FetchersContext.displayName = "Fetchers";
  }
  var START_TRANSITION2 = "startTransition";
  var startTransitionImpl2 = React2[START_TRANSITION2];
  var FLUSH_SYNC = "flushSync";
  var flushSyncImpl = ReactDOM[FLUSH_SYNC];
  var USE_ID = "useId";
  var useIdImpl = React2[USE_ID];
  function HashRouter(_ref5) {
    let {
      basename,
      children,
      future,
      window: window2
    } = _ref5;
    let historyRef = React2.useRef();
    if (historyRef.current == null) {
      historyRef.current = createHashHistory({
        window: window2,
        v5Compat: true
      });
    }
    let history = historyRef.current;
    let [state, setStateImpl] = React2.useState({
      action: history.action,
      location: history.location
    });
    let {
      v7_startTransition
    } = future || {};
    let setState = React2.useCallback((newState) => {
      v7_startTransition && startTransitionImpl2 ? startTransitionImpl2(() => setStateImpl(newState)) : setStateImpl(newState);
    }, [setStateImpl, v7_startTransition]);
    React2.useLayoutEffect(() => history.listen(setState), [history, setState]);
    React2.useEffect(() => logV6DeprecationWarnings(future), [future]);
    return /* @__PURE__ */ React2.createElement(Router, {
      basename,
      children,
      location: state.location,
      navigationType: state.action,
      navigator: history,
      future
    });
  }
  function HistoryRouter(_ref6) {
    let {
      basename,
      children,
      future,
      history
    } = _ref6;
    let [state, setStateImpl] = React2.useState({
      action: history.action,
      location: history.location
    });
    let {
      v7_startTransition
    } = future || {};
    let setState = React2.useCallback((newState) => {
      v7_startTransition && startTransitionImpl2 ? startTransitionImpl2(() => setStateImpl(newState)) : setStateImpl(newState);
    }, [setStateImpl, v7_startTransition]);
    React2.useLayoutEffect(() => history.listen(setState), [history, setState]);
    React2.useEffect(() => logV6DeprecationWarnings(future), [future]);
    return /* @__PURE__ */ React2.createElement(Router, {
      basename,
      children,
      location: state.location,
      navigationType: state.action,
      navigator: history,
      future
    });
  }
  if (true) {
    HistoryRouter.displayName = "unstable_HistoryRouter";
  }
  var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
  var ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
  var Link = /* @__PURE__ */ React2.forwardRef(function LinkWithRef(_ref7, ref2) {
    let {
      onClick,
      relative,
      reloadDocument,
      replace: replace2,
      state,
      target,
      to,
      preventScrollReset,
      viewTransition
    } = _ref7, rest = _objectWithoutPropertiesLoose(_ref7, _excluded);
    let {
      basename
    } = React2.useContext(NavigationContext);
    let absoluteHref;
    let isExternal = false;
    if (typeof to === "string" && ABSOLUTE_URL_REGEX.test(to)) {
      absoluteHref = to;
      if (isBrowser) {
        try {
          let currentUrl = new URL(window.location.href);
          let targetUrl = to.startsWith("//") ? new URL(currentUrl.protocol + to) : new URL(to);
          let path = stripBasename(targetUrl.pathname, basename);
          if (targetUrl.origin === currentUrl.origin && path != null) {
            to = path + targetUrl.search + targetUrl.hash;
          } else {
            isExternal = true;
          }
        } catch (e) {
          true ? warning(false, '<Link to="' + to + '"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.') : void 0;
        }
      }
    }
    let href = useHref(to, {
      relative
    });
    let internalOnClick = useLinkClickHandler(to, {
      replace: replace2,
      state,
      target,
      preventScrollReset,
      relative,
      viewTransition
    });
    function handleClick(event) {
      if (onClick) onClick(event);
      if (!event.defaultPrevented) {
        internalOnClick(event);
      }
    }
    return (
      // eslint-disable-next-line jsx-a11y/anchor-has-content
      /* @__PURE__ */ React2.createElement("a", _extends3({}, rest, {
        href: absoluteHref || href,
        onClick: isExternal || reloadDocument ? onClick : handleClick,
        ref: ref2,
        target
      }))
    );
  });
  if (true) {
    Link.displayName = "Link";
  }
  var NavLink = /* @__PURE__ */ React2.forwardRef(function NavLinkWithRef(_ref8, ref2) {
    let {
      "aria-current": ariaCurrentProp = "page",
      caseSensitive = false,
      className: classNameProp = "",
      end = false,
      style: styleProp,
      to,
      viewTransition,
      children
    } = _ref8, rest = _objectWithoutPropertiesLoose(_ref8, _excluded2);
    let path = useResolvedPath(to, {
      relative: rest.relative
    });
    let location2 = useLocation();
    let routerState = React2.useContext(DataRouterStateContext);
    let {
      navigator: navigator2,
      basename
    } = React2.useContext(NavigationContext);
    let isTransitioning = routerState != null && // Conditional usage is OK here because the usage of a data router is static
    // eslint-disable-next-line react-hooks/rules-of-hooks
    useViewTransitionState(path) && viewTransition === true;
    let toPathname = navigator2.encodeLocation ? navigator2.encodeLocation(path).pathname : path.pathname;
    let locationPathname = location2.pathname;
    let nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;
    if (!caseSensitive) {
      locationPathname = locationPathname.toLowerCase();
      nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;
      toPathname = toPathname.toLowerCase();
    }
    if (nextLocationPathname && basename) {
      nextLocationPathname = stripBasename(nextLocationPathname, basename) || nextLocationPathname;
    }
    const endSlashPosition = toPathname !== "/" && toPathname.endsWith("/") ? toPathname.length - 1 : toPathname.length;
    let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(endSlashPosition) === "/";
    let isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === "/");
    let renderProps = {
      isActive,
      isPending,
      isTransitioning
    };
    let ariaCurrent = isActive ? ariaCurrentProp : void 0;
    let className;
    if (typeof classNameProp === "function") {
      className = classNameProp(renderProps);
    } else {
      className = [classNameProp, isActive ? "active" : null, isPending ? "pending" : null, isTransitioning ? "transitioning" : null].filter(Boolean).join(" ");
    }
    let style = typeof styleProp === "function" ? styleProp(renderProps) : styleProp;
    return /* @__PURE__ */ React2.createElement(Link, _extends3({}, rest, {
      "aria-current": ariaCurrent,
      className,
      ref: ref2,
      style,
      to,
      viewTransition
    }), typeof children === "function" ? children(renderProps) : children);
  });
  if (true) {
    NavLink.displayName = "NavLink";
  }
  var Form = /* @__PURE__ */ React2.forwardRef((_ref9, forwardedRef) => {
    let {
      fetcherKey,
      navigate,
      reloadDocument,
      replace: replace2,
      state,
      method = defaultMethod,
      action,
      onSubmit,
      relative,
      preventScrollReset,
      viewTransition
    } = _ref9, props = _objectWithoutPropertiesLoose(_ref9, _excluded3);
    let submit = useSubmit();
    let formAction = useFormAction(action, {
      relative
    });
    let formMethod = method.toLowerCase() === "get" ? "get" : "post";
    let submitHandler = (event) => {
      onSubmit && onSubmit(event);
      if (event.defaultPrevented) return;
      event.preventDefault();
      let submitter = event.nativeEvent.submitter;
      let submitMethod = (submitter == null ? void 0 : submitter.getAttribute("formmethod")) || method;
      submit(submitter || event.currentTarget, {
        fetcherKey,
        method: submitMethod,
        navigate,
        replace: replace2,
        state,
        relative,
        preventScrollReset,
        viewTransition
      });
    };
    return /* @__PURE__ */ React2.createElement("form", _extends3({
      ref: forwardedRef,
      method: formMethod,
      action: formAction,
      onSubmit: reloadDocument ? onSubmit : submitHandler
    }, props));
  });
  if (true) {
    Form.displayName = "Form";
  }
  function ScrollRestoration(_ref10) {
    let {
      getKey,
      storageKey
    } = _ref10;
    useScrollRestoration({
      getKey,
      storageKey
    });
    return null;
  }
  if (true) {
    ScrollRestoration.displayName = "ScrollRestoration";
  }
  var DataRouterHook2;
  (function(DataRouterHook3) {
    DataRouterHook3["UseScrollRestoration"] = "useScrollRestoration";
    DataRouterHook3["UseSubmit"] = "useSubmit";
    DataRouterHook3["UseSubmitFetcher"] = "useSubmitFetcher";
    DataRouterHook3["UseFetcher"] = "useFetcher";
    DataRouterHook3["useViewTransitionState"] = "useViewTransitionState";
  })(DataRouterHook2 || (DataRouterHook2 = {}));
  var DataRouterStateHook2;
  (function(DataRouterStateHook3) {
    DataRouterStateHook3["UseFetcher"] = "useFetcher";
    DataRouterStateHook3["UseFetchers"] = "useFetchers";
    DataRouterStateHook3["UseScrollRestoration"] = "useScrollRestoration";
  })(DataRouterStateHook2 || (DataRouterStateHook2 = {}));
  function getDataRouterConsoleError2(hookName) {
    return hookName + " must be used within a data router.  See https://reactrouter.com/v6/routers/picking-a-router.";
  }
  function useDataRouterContext2(hookName) {
    let ctx = React2.useContext(DataRouterContext);
    !ctx ? true ? invariant(false, getDataRouterConsoleError2(hookName)) : invariant(false) : void 0;
    return ctx;
  }
  function useDataRouterState2(hookName) {
    let state = React2.useContext(DataRouterStateContext);
    !state ? true ? invariant(false, getDataRouterConsoleError2(hookName)) : invariant(false) : void 0;
    return state;
  }
  function useLinkClickHandler(to, _temp) {
    let {
      target,
      replace: replaceProp,
      state,
      preventScrollReset,
      relative,
      viewTransition
    } = _temp === void 0 ? {} : _temp;
    let navigate = useNavigate();
    let location2 = useLocation();
    let path = useResolvedPath(to, {
      relative
    });
    return React2.useCallback((event) => {
      if (shouldProcessLinkClick(event, target)) {
        event.preventDefault();
        let replace2 = replaceProp !== void 0 ? replaceProp : createPath(location2) === createPath(path);
        navigate(to, {
          replace: replace2,
          state,
          preventScrollReset,
          relative,
          viewTransition
        });
      }
    }, [location2, navigate, path, replaceProp, state, target, to, preventScrollReset, relative, viewTransition]);
  }
  function validateClientSideSubmission() {
    if (typeof document === "undefined") {
      throw new Error("You are calling submit during the server render. Try calling submit within a `useEffect` or callback instead.");
    }
  }
  var fetcherId = 0;
  var getUniqueFetcherId = () => "__" + String(++fetcherId) + "__";
  function useSubmit() {
    let {
      router
    } = useDataRouterContext2(DataRouterHook2.UseSubmit);
    let {
      basename
    } = React2.useContext(NavigationContext);
    let currentRouteId = useRouteId();
    return React2.useCallback(function(target, options) {
      if (options === void 0) {
        options = {};
      }
      validateClientSideSubmission();
      let {
        action,
        method,
        encType,
        formData,
        body
      } = getFormSubmissionInfo(target, basename);
      if (options.navigate === false) {
        let key = options.fetcherKey || getUniqueFetcherId();
        router.fetch(key, currentRouteId, options.action || action, {
          preventScrollReset: options.preventScrollReset,
          formData,
          body,
          formMethod: options.method || method,
          formEncType: options.encType || encType,
          flushSync: options.flushSync
        });
      } else {
        router.navigate(options.action || action, {
          preventScrollReset: options.preventScrollReset,
          formData,
          body,
          formMethod: options.method || method,
          formEncType: options.encType || encType,
          replace: options.replace,
          state: options.state,
          fromRouteId: currentRouteId,
          flushSync: options.flushSync,
          viewTransition: options.viewTransition
        });
      }
    }, [router, basename, currentRouteId]);
  }
  function useFormAction(action, _temp2) {
    let {
      relative
    } = _temp2 === void 0 ? {} : _temp2;
    let {
      basename
    } = React2.useContext(NavigationContext);
    let routeContext = React2.useContext(RouteContext);
    !routeContext ? true ? invariant(false, "useFormAction must be used inside a RouteContext") : invariant(false) : void 0;
    let [match] = routeContext.matches.slice(-1);
    let path = _extends3({}, useResolvedPath(action ? action : ".", {
      relative
    }));
    let location2 = useLocation();
    if (action == null) {
      path.search = location2.search;
      let params = new URLSearchParams(path.search);
      let indexValues = params.getAll("index");
      let hasNakedIndexParam = indexValues.some((v) => v === "");
      if (hasNakedIndexParam) {
        params.delete("index");
        indexValues.filter((v) => v).forEach((v) => params.append("index", v));
        let qs = params.toString();
        path.search = qs ? "?" + qs : "";
      }
    }
    if ((!action || action === ".") && match.route.index) {
      path.search = path.search ? path.search.replace(/^\?/, "?index&") : "?index";
    }
    if (basename !== "/") {
      path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
    }
    return createPath(path);
  }
  var SCROLL_RESTORATION_STORAGE_KEY = "react-router-scroll-positions";
  var savedScrollPositions = {};
  function useScrollRestoration(_temp4) {
    let {
      getKey,
      storageKey
    } = _temp4 === void 0 ? {} : _temp4;
    let {
      router
    } = useDataRouterContext2(DataRouterHook2.UseScrollRestoration);
    let {
      restoreScrollPosition,
      preventScrollReset
    } = useDataRouterState2(DataRouterStateHook2.UseScrollRestoration);
    let {
      basename
    } = React2.useContext(NavigationContext);
    let location2 = useLocation();
    let matches = useMatches();
    let navigation = useNavigation();
    React2.useEffect(() => {
      window.history.scrollRestoration = "manual";
      return () => {
        window.history.scrollRestoration = "auto";
      };
    }, []);
    usePageHide(React2.useCallback(() => {
      if (navigation.state === "idle") {
        let key = (getKey ? getKey(location2, matches) : null) || location2.key;
        savedScrollPositions[key] = window.scrollY;
      }
      try {
        sessionStorage.setItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY, JSON.stringify(savedScrollPositions));
      } catch (error) {
        true ? warning(false, "Failed to save scroll positions in sessionStorage, <ScrollRestoration /> will not work properly (" + error + ").") : void 0;
      }
      window.history.scrollRestoration = "auto";
    }, [storageKey, getKey, navigation.state, location2, matches]));
    if (typeof document !== "undefined") {
      React2.useLayoutEffect(() => {
        try {
          let sessionPositions = sessionStorage.getItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY);
          if (sessionPositions) {
            savedScrollPositions = JSON.parse(sessionPositions);
          }
        } catch (e) {
        }
      }, [storageKey]);
      React2.useLayoutEffect(() => {
        let getKeyWithoutBasename = getKey && basename !== "/" ? (location3, matches2) => getKey(
          // Strip the basename to match useLocation()
          _extends3({}, location3, {
            pathname: stripBasename(location3.pathname, basename) || location3.pathname
          }),
          matches2
        ) : getKey;
        let disableScrollRestoration = router == null ? void 0 : router.enableScrollRestoration(savedScrollPositions, () => window.scrollY, getKeyWithoutBasename);
        return () => disableScrollRestoration && disableScrollRestoration();
      }, [router, basename, getKey]);
      React2.useLayoutEffect(() => {
        if (restoreScrollPosition === false) {
          return;
        }
        if (typeof restoreScrollPosition === "number") {
          window.scrollTo(0, restoreScrollPosition);
          return;
        }
        if (location2.hash) {
          let el = document.getElementById(decodeURIComponent(location2.hash.slice(1)));
          if (el) {
            el.scrollIntoView();
            return;
          }
        }
        if (preventScrollReset === true) {
          return;
        }
        window.scrollTo(0, 0);
      }, [location2, restoreScrollPosition, preventScrollReset]);
    }
  }
  function usePageHide(callback, options) {
    let {
      capture
    } = options || {};
    React2.useEffect(() => {
      let opts = capture != null ? {
        capture
      } : void 0;
      window.addEventListener("pagehide", callback, opts);
      return () => {
        window.removeEventListener("pagehide", callback, opts);
      };
    }, [callback, capture]);
  }
  function useViewTransitionState(to, opts) {
    if (opts === void 0) {
      opts = {};
    }
    let vtContext = React2.useContext(ViewTransitionContext);
    !(vtContext != null) ? true ? invariant(false, "`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?") : invariant(false) : void 0;
    let {
      basename
    } = useDataRouterContext2(DataRouterHook2.useViewTransitionState);
    let path = useResolvedPath(to, {
      relative: opts.relative
    });
    if (!vtContext.isTransitioning) {
      return false;
    }
    let currentPath = stripBasename(vtContext.currentLocation.pathname, basename) || vtContext.currentLocation.pathname;
    let nextPath = stripBasename(vtContext.nextLocation.pathname, basename) || vtContext.nextLocation.pathname;
    return matchPath(path.pathname, nextPath) != null || matchPath(path.pathname, currentPath) != null;
  }

  // node_modules/hls.js/dist/hls.mjs
  var isFiniteNumber = Number.isFinite || function(value) {
    return typeof value === "number" && isFinite(value);
  };
  var isSafeInteger = Number.isSafeInteger || function(value) {
    return typeof value === "number" && Math.abs(value) <= MAX_SAFE_INTEGER;
  };
  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
  var ErrorTypes = /* @__PURE__ */ (function(ErrorTypes2) {
    ErrorTypes2["NETWORK_ERROR"] = "networkError";
    ErrorTypes2["MEDIA_ERROR"] = "mediaError";
    ErrorTypes2["KEY_SYSTEM_ERROR"] = "keySystemError";
    ErrorTypes2["MUX_ERROR"] = "muxError";
    ErrorTypes2["OTHER_ERROR"] = "otherError";
    return ErrorTypes2;
  })({});
  var ErrorDetails = /* @__PURE__ */ (function(ErrorDetails2) {
    ErrorDetails2["KEY_SYSTEM_NO_KEYS"] = "keySystemNoKeys";
    ErrorDetails2["KEY_SYSTEM_NO_ACCESS"] = "keySystemNoAccess";
    ErrorDetails2["KEY_SYSTEM_NO_SESSION"] = "keySystemNoSession";
    ErrorDetails2["KEY_SYSTEM_NO_CONFIGURED_LICENSE"] = "keySystemNoConfiguredLicense";
    ErrorDetails2["KEY_SYSTEM_LICENSE_REQUEST_FAILED"] = "keySystemLicenseRequestFailed";
    ErrorDetails2["KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED"] = "keySystemServerCertificateRequestFailed";
    ErrorDetails2["KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED"] = "keySystemServerCertificateUpdateFailed";
    ErrorDetails2["KEY_SYSTEM_SESSION_UPDATE_FAILED"] = "keySystemSessionUpdateFailed";
    ErrorDetails2["KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED"] = "keySystemStatusOutputRestricted";
    ErrorDetails2["KEY_SYSTEM_STATUS_INTERNAL_ERROR"] = "keySystemStatusInternalError";
    ErrorDetails2["KEY_SYSTEM_DESTROY_MEDIA_KEYS_ERROR"] = "keySystemDestroyMediaKeysError";
    ErrorDetails2["KEY_SYSTEM_DESTROY_CLOSE_SESSION_ERROR"] = "keySystemDestroyCloseSessionError";
    ErrorDetails2["KEY_SYSTEM_DESTROY_REMOVE_SESSION_ERROR"] = "keySystemDestroyRemoveSessionError";
    ErrorDetails2["MANIFEST_LOAD_ERROR"] = "manifestLoadError";
    ErrorDetails2["MANIFEST_LOAD_TIMEOUT"] = "manifestLoadTimeOut";
    ErrorDetails2["MANIFEST_PARSING_ERROR"] = "manifestParsingError";
    ErrorDetails2["MANIFEST_INCOMPATIBLE_CODECS_ERROR"] = "manifestIncompatibleCodecsError";
    ErrorDetails2["LEVEL_EMPTY_ERROR"] = "levelEmptyError";
    ErrorDetails2["LEVEL_LOAD_ERROR"] = "levelLoadError";
    ErrorDetails2["LEVEL_LOAD_TIMEOUT"] = "levelLoadTimeOut";
    ErrorDetails2["LEVEL_PARSING_ERROR"] = "levelParsingError";
    ErrorDetails2["LEVEL_SWITCH_ERROR"] = "levelSwitchError";
    ErrorDetails2["AUDIO_TRACK_LOAD_ERROR"] = "audioTrackLoadError";
    ErrorDetails2["AUDIO_TRACK_LOAD_TIMEOUT"] = "audioTrackLoadTimeOut";
    ErrorDetails2["SUBTITLE_LOAD_ERROR"] = "subtitleTrackLoadError";
    ErrorDetails2["SUBTITLE_TRACK_LOAD_TIMEOUT"] = "subtitleTrackLoadTimeOut";
    ErrorDetails2["FRAG_LOAD_ERROR"] = "fragLoadError";
    ErrorDetails2["FRAG_LOAD_TIMEOUT"] = "fragLoadTimeOut";
    ErrorDetails2["FRAG_DECRYPT_ERROR"] = "fragDecryptError";
    ErrorDetails2["FRAG_PARSING_ERROR"] = "fragParsingError";
    ErrorDetails2["FRAG_GAP"] = "fragGap";
    ErrorDetails2["REMUX_ALLOC_ERROR"] = "remuxAllocError";
    ErrorDetails2["KEY_LOAD_ERROR"] = "keyLoadError";
    ErrorDetails2["KEY_LOAD_TIMEOUT"] = "keyLoadTimeOut";
    ErrorDetails2["BUFFER_ADD_CODEC_ERROR"] = "bufferAddCodecError";
    ErrorDetails2["BUFFER_INCOMPATIBLE_CODECS_ERROR"] = "bufferIncompatibleCodecsError";
    ErrorDetails2["BUFFER_APPEND_ERROR"] = "bufferAppendError";
    ErrorDetails2["BUFFER_APPENDING_ERROR"] = "bufferAppendingError";
    ErrorDetails2["BUFFER_STALLED_ERROR"] = "bufferStalledError";
    ErrorDetails2["BUFFER_FULL_ERROR"] = "bufferFullError";
    ErrorDetails2["BUFFER_SEEK_OVER_HOLE"] = "bufferSeekOverHole";
    ErrorDetails2["BUFFER_NUDGE_ON_STALL"] = "bufferNudgeOnStall";
    ErrorDetails2["ASSET_LIST_LOAD_ERROR"] = "assetListLoadError";
    ErrorDetails2["ASSET_LIST_LOAD_TIMEOUT"] = "assetListLoadTimeout";
    ErrorDetails2["ASSET_LIST_PARSING_ERROR"] = "assetListParsingError";
    ErrorDetails2["INTERSTITIAL_ASSET_ITEM_ERROR"] = "interstitialAssetItemError";
    ErrorDetails2["INTERNAL_EXCEPTION"] = "internalException";
    ErrorDetails2["INTERNAL_ABORTED"] = "aborted";
    ErrorDetails2["ATTACH_MEDIA_ERROR"] = "attachMediaError";
    ErrorDetails2["UNKNOWN"] = "unknown";
    return ErrorDetails2;
  })({});
  var Events = /* @__PURE__ */ (function(Events2) {
    Events2["MEDIA_ATTACHING"] = "hlsMediaAttaching";
    Events2["MEDIA_ATTACHED"] = "hlsMediaAttached";
    Events2["MEDIA_DETACHING"] = "hlsMediaDetaching";
    Events2["MEDIA_DETACHED"] = "hlsMediaDetached";
    Events2["MEDIA_ENDED"] = "hlsMediaEnded";
    Events2["STALL_RESOLVED"] = "hlsStallResolved";
    Events2["BUFFER_RESET"] = "hlsBufferReset";
    Events2["BUFFER_CODECS"] = "hlsBufferCodecs";
    Events2["BUFFER_CREATED"] = "hlsBufferCreated";
    Events2["BUFFER_APPENDING"] = "hlsBufferAppending";
    Events2["BUFFER_APPENDED"] = "hlsBufferAppended";
    Events2["BUFFER_EOS"] = "hlsBufferEos";
    Events2["BUFFERED_TO_END"] = "hlsBufferedToEnd";
    Events2["BUFFER_FLUSHING"] = "hlsBufferFlushing";
    Events2["BUFFER_FLUSHED"] = "hlsBufferFlushed";
    Events2["MANIFEST_LOADING"] = "hlsManifestLoading";
    Events2["MANIFEST_LOADED"] = "hlsManifestLoaded";
    Events2["MANIFEST_PARSED"] = "hlsManifestParsed";
    Events2["LEVEL_SWITCHING"] = "hlsLevelSwitching";
    Events2["LEVEL_SWITCHED"] = "hlsLevelSwitched";
    Events2["LEVEL_LOADING"] = "hlsLevelLoading";
    Events2["LEVEL_LOADED"] = "hlsLevelLoaded";
    Events2["LEVEL_UPDATED"] = "hlsLevelUpdated";
    Events2["LEVEL_PTS_UPDATED"] = "hlsLevelPtsUpdated";
    Events2["LEVELS_UPDATED"] = "hlsLevelsUpdated";
    Events2["AUDIO_TRACKS_UPDATED"] = "hlsAudioTracksUpdated";
    Events2["AUDIO_TRACK_SWITCHING"] = "hlsAudioTrackSwitching";
    Events2["AUDIO_TRACK_SWITCHED"] = "hlsAudioTrackSwitched";
    Events2["AUDIO_TRACK_LOADING"] = "hlsAudioTrackLoading";
    Events2["AUDIO_TRACK_LOADED"] = "hlsAudioTrackLoaded";
    Events2["AUDIO_TRACK_UPDATED"] = "hlsAudioTrackUpdated";
    Events2["SUBTITLE_TRACKS_UPDATED"] = "hlsSubtitleTracksUpdated";
    Events2["SUBTITLE_TRACKS_CLEARED"] = "hlsSubtitleTracksCleared";
    Events2["SUBTITLE_TRACK_SWITCH"] = "hlsSubtitleTrackSwitch";
    Events2["SUBTITLE_TRACK_LOADING"] = "hlsSubtitleTrackLoading";
    Events2["SUBTITLE_TRACK_LOADED"] = "hlsSubtitleTrackLoaded";
    Events2["SUBTITLE_TRACK_UPDATED"] = "hlsSubtitleTrackUpdated";
    Events2["SUBTITLE_FRAG_PROCESSED"] = "hlsSubtitleFragProcessed";
    Events2["CUES_PARSED"] = "hlsCuesParsed";
    Events2["NON_NATIVE_TEXT_TRACKS_FOUND"] = "hlsNonNativeTextTracksFound";
    Events2["INIT_PTS_FOUND"] = "hlsInitPtsFound";
    Events2["FRAG_LOADING"] = "hlsFragLoading";
    Events2["FRAG_LOAD_EMERGENCY_ABORTED"] = "hlsFragLoadEmergencyAborted";
    Events2["FRAG_LOADED"] = "hlsFragLoaded";
    Events2["FRAG_DECRYPTED"] = "hlsFragDecrypted";
    Events2["FRAG_PARSING_INIT_SEGMENT"] = "hlsFragParsingInitSegment";
    Events2["FRAG_PARSING_USERDATA"] = "hlsFragParsingUserdata";
    Events2["FRAG_PARSING_METADATA"] = "hlsFragParsingMetadata";
    Events2["FRAG_PARSED"] = "hlsFragParsed";
    Events2["FRAG_BUFFERED"] = "hlsFragBuffered";
    Events2["FRAG_CHANGED"] = "hlsFragChanged";
    Events2["FPS_DROP"] = "hlsFpsDrop";
    Events2["FPS_DROP_LEVEL_CAPPING"] = "hlsFpsDropLevelCapping";
    Events2["MAX_AUTO_LEVEL_UPDATED"] = "hlsMaxAutoLevelUpdated";
    Events2["ERROR"] = "hlsError";
    Events2["DESTROYING"] = "hlsDestroying";
    Events2["KEY_LOADING"] = "hlsKeyLoading";
    Events2["KEY_LOADED"] = "hlsKeyLoaded";
    Events2["LIVE_BACK_BUFFER_REACHED"] = "hlsLiveBackBufferReached";
    Events2["BACK_BUFFER_REACHED"] = "hlsBackBufferReached";
    Events2["STEERING_MANIFEST_LOADED"] = "hlsSteeringManifestLoaded";
    Events2["ASSET_LIST_LOADING"] = "hlsAssetListLoading";
    Events2["ASSET_LIST_LOADED"] = "hlsAssetListLoaded";
    Events2["INTERSTITIALS_UPDATED"] = "hlsInterstitialsUpdated";
    Events2["INTERSTITIALS_BUFFERED_TO_BOUNDARY"] = "hlsInterstitialsBufferedToBoundary";
    Events2["INTERSTITIAL_ASSET_PLAYER_CREATED"] = "hlsInterstitialAssetPlayerCreated";
    Events2["INTERSTITIAL_STARTED"] = "hlsInterstitialStarted";
    Events2["INTERSTITIAL_ASSET_STARTED"] = "hlsInterstitialAssetStarted";
    Events2["INTERSTITIAL_ASSET_ENDED"] = "hlsInterstitialAssetEnded";
    Events2["INTERSTITIAL_ASSET_ERROR"] = "hlsInterstitialAssetError";
    Events2["INTERSTITIAL_ENDED"] = "hlsInterstitialEnded";
    Events2["INTERSTITIALS_PRIMARY_RESUMED"] = "hlsInterstitialsPrimaryResumed";
    Events2["PLAYOUT_LIMIT_REACHED"] = "hlsPlayoutLimitReached";
    Events2["EVENT_CUE_ENTER"] = "hlsEventCueEnter";
    return Events2;
  })({});
  var PlaylistContextType = {
    MANIFEST: "manifest",
    LEVEL: "level",
    AUDIO_TRACK: "audioTrack",
    SUBTITLE_TRACK: "subtitleTrack"
  };
  var PlaylistLevelType = {
    MAIN: "main",
    AUDIO: "audio",
    SUBTITLE: "subtitle"
  };
  var EWMA = class {
    //  About half of the estimated value will be from the last |halfLife| samples by weight.
    constructor(halfLife, estimate = 0, weight = 0) {
      this.halfLife = void 0;
      this.alpha_ = void 0;
      this.estimate_ = void 0;
      this.totalWeight_ = void 0;
      this.halfLife = halfLife;
      this.alpha_ = halfLife ? Math.exp(Math.log(0.5) / halfLife) : 0;
      this.estimate_ = estimate;
      this.totalWeight_ = weight;
    }
    sample(weight, value) {
      const adjAlpha = Math.pow(this.alpha_, weight);
      this.estimate_ = value * (1 - adjAlpha) + adjAlpha * this.estimate_;
      this.totalWeight_ += weight;
    }
    getTotalWeight() {
      return this.totalWeight_;
    }
    getEstimate() {
      if (this.alpha_) {
        const zeroFactor = 1 - Math.pow(this.alpha_, this.totalWeight_);
        if (zeroFactor) {
          return this.estimate_ / zeroFactor;
        }
      }
      return this.estimate_;
    }
  };
  var EwmaBandWidthEstimator = class {
    constructor(slow, fast, defaultEstimate, defaultTTFB = 100) {
      this.defaultEstimate_ = void 0;
      this.minWeight_ = void 0;
      this.minDelayMs_ = void 0;
      this.slow_ = void 0;
      this.fast_ = void 0;
      this.defaultTTFB_ = void 0;
      this.ttfb_ = void 0;
      this.defaultEstimate_ = defaultEstimate;
      this.minWeight_ = 1e-3;
      this.minDelayMs_ = 50;
      this.slow_ = new EWMA(slow);
      this.fast_ = new EWMA(fast);
      this.defaultTTFB_ = defaultTTFB;
      this.ttfb_ = new EWMA(slow);
    }
    update(slow, fast) {
      const {
        slow_,
        fast_,
        ttfb_
      } = this;
      if (slow_.halfLife !== slow) {
        this.slow_ = new EWMA(slow, slow_.getEstimate(), slow_.getTotalWeight());
      }
      if (fast_.halfLife !== fast) {
        this.fast_ = new EWMA(fast, fast_.getEstimate(), fast_.getTotalWeight());
      }
      if (ttfb_.halfLife !== slow) {
        this.ttfb_ = new EWMA(slow, ttfb_.getEstimate(), ttfb_.getTotalWeight());
      }
    }
    sample(durationMs, numBytes) {
      durationMs = Math.max(durationMs, this.minDelayMs_);
      const numBits = 8 * numBytes;
      const durationS = durationMs / 1e3;
      const bandwidthInBps = numBits / durationS;
      this.fast_.sample(durationS, bandwidthInBps);
      this.slow_.sample(durationS, bandwidthInBps);
    }
    sampleTTFB(ttfb) {
      const seconds = ttfb / 1e3;
      const weight = Math.sqrt(2) * Math.exp(-Math.pow(seconds, 2) / 2);
      this.ttfb_.sample(weight, Math.max(ttfb, 5));
    }
    canEstimate() {
      return this.fast_.getTotalWeight() >= this.minWeight_;
    }
    getEstimate() {
      if (this.canEstimate()) {
        return Math.min(this.fast_.getEstimate(), this.slow_.getEstimate());
      } else {
        return this.defaultEstimate_;
      }
    }
    getEstimateTTFB() {
      if (this.ttfb_.getTotalWeight() >= this.minWeight_) {
        return this.ttfb_.getEstimate();
      } else {
        return this.defaultTTFB_;
      }
    }
    get defaultEstimate() {
      return this.defaultEstimate_;
    }
    destroy() {
    }
  };
  function _defineProperty(e, r, t) {
    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
      value: t,
      enumerable: true,
      configurable: true,
      writable: true
    }) : e[r] = t, e;
  }
  function _extends4() {
    return _extends4 = Object.assign ? Object.assign.bind() : function(n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
      }
      return n;
    }, _extends4.apply(null, arguments);
  }
  function ownKeys(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r && (o = o.filter(function(r2) {
        return Object.getOwnPropertyDescriptor(e, r2).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread2(e) {
    for (var r = 1; r < arguments.length; r++) {
      var t = null != arguments[r] ? arguments[r] : {};
      r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
        _defineProperty(e, r2, t[r2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
        Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
      });
    }
    return e;
  }
  function _toPrimitive(t, r) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r);
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
  }
  function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  var Logger = class {
    constructor(label, logger2) {
      this.trace = void 0;
      this.debug = void 0;
      this.log = void 0;
      this.warn = void 0;
      this.info = void 0;
      this.error = void 0;
      const lb = `[${label}]:`;
      this.trace = noop;
      this.debug = logger2.debug.bind(null, lb);
      this.log = logger2.log.bind(null, lb);
      this.warn = logger2.warn.bind(null, lb);
      this.info = logger2.info.bind(null, lb);
      this.error = logger2.error.bind(null, lb);
    }
  };
  var noop = function noop2() {
  };
  var fakeLogger = {
    trace: noop,
    debug: noop,
    log: noop,
    warn: noop,
    info: noop,
    error: noop
  };
  function createLogger() {
    return _extends4({}, fakeLogger);
  }
  function consolePrintFn(type, id3) {
    const func = self.console[type];
    return func ? func.bind(self.console, `${id3 ? "[" + id3 + "] " : ""}[${type}] >`) : noop;
  }
  function getLoggerFn(key, debugConfig, id3) {
    return debugConfig[key] ? debugConfig[key].bind(debugConfig) : consolePrintFn(key, id3);
  }
  var exportedLogger = createLogger();
  function enableLogs(debugConfig, context3, id3) {
    const newLogger = createLogger();
    if (typeof console === "object" && debugConfig === true || typeof debugConfig === "object") {
      const keys2 = [
        // Remove out from list here to hard-disable a log-level
        // 'trace',
        "debug",
        "log",
        "info",
        "warn",
        "error"
      ];
      keys2.forEach((key) => {
        newLogger[key] = getLoggerFn(key, debugConfig, id3);
      });
      try {
        newLogger.log(`Debug logs enabled for "${context3}" in hls.js version ${"1.6.13"}`);
      } catch (e) {
        return createLogger();
      }
      keys2.forEach((key) => {
        exportedLogger[key] = getLoggerFn(key, debugConfig);
      });
    } else {
      _extends4(exportedLogger, newLogger);
    }
    return newLogger;
  }
  var logger = exportedLogger;
  function getMediaSource(preferManagedMediaSource = true) {
    if (typeof self === "undefined") return void 0;
    const mms = (preferManagedMediaSource || !self.MediaSource) && self.ManagedMediaSource;
    return mms || self.MediaSource || self.WebKitMediaSource;
  }
  function isManagedMediaSource(source) {
    return typeof self !== "undefined" && source === self.ManagedMediaSource;
  }
  function isCompatibleTrackChange(currentTracks, requiredTracks) {
    const trackNames = Object.keys(currentTracks);
    const requiredTrackNames = Object.keys(requiredTracks);
    const trackCount = trackNames.length;
    const requiredTrackCount = requiredTrackNames.length;
    return !trackCount || !requiredTrackCount || trackCount === requiredTrackCount && !trackNames.some((name) => requiredTrackNames.indexOf(name) === -1);
  }
  function utf8ArrayToStr(array, exitOnNull = false) {
    if (typeof TextDecoder !== "undefined") {
      const decoder = new TextDecoder("utf-8");
      const decoded = decoder.decode(array);
      if (exitOnNull) {
        const idx = decoded.indexOf("\0");
        return idx !== -1 ? decoded.substring(0, idx) : decoded;
      }
      return decoded.replace(/\0/g, "");
    }
    const len = array.length;
    let c;
    let char2;
    let char3;
    let out = "";
    let i = 0;
    while (i < len) {
      c = array[i++];
      if (c === 0 && exitOnNull) {
        return out;
      } else if (c === 0 || c === 3) {
        continue;
      }
      switch (c >> 4) {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
          out += String.fromCharCode(c);
          break;
        case 12:
        case 13:
          char2 = array[i++];
          out += String.fromCharCode((c & 31) << 6 | char2 & 63);
          break;
        case 14:
          char2 = array[i++];
          char3 = array[i++];
          out += String.fromCharCode((c & 15) << 12 | (char2 & 63) << 6 | (char3 & 63) << 0);
          break;
      }
    }
    return out;
  }
  function arrayToHex(array) {
    let str = "";
    for (let i = 0; i < array.length; i++) {
      let h = array[i].toString(16);
      if (h.length < 2) {
        h = "0" + h;
      }
      str += h;
    }
    return str;
  }
  function hexToArrayBuffer(str) {
    return Uint8Array.from(str.replace(/^0x/, "").replace(/([\da-fA-F]{2}) ?/g, "0x$1 ").replace(/ +$/, "").split(" ")).buffer;
  }
  function getDefaultExportFromCjs(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
  }
  var urlToolkit = { exports: {} };
  var hasRequiredUrlToolkit;
  function requireUrlToolkit() {
    if (hasRequiredUrlToolkit) return urlToolkit.exports;
    hasRequiredUrlToolkit = 1;
    (function(module, exports) {
      (function(root2) {
        var URL_REGEX = /^(?=((?:[a-zA-Z0-9+\-.]+:)?))\1(?=((?:\/\/[^\/?#]*)?))\2(?=((?:(?:[^?#\/]*\/)*[^;?#\/]*)?))\3((?:;[^?#]*)?)(\?[^#]*)?(#[^]*)?$/;
        var FIRST_SEGMENT_REGEX = /^(?=([^\/?#]*))\1([^]*)$/;
        var SLASH_DOT_REGEX = /(?:\/|^)\.(?=\/)/g;
        var SLASH_DOT_DOT_REGEX = /(?:\/|^)\.\.\/(?!\.\.\/)[^\/]*(?=\/)/g;
        var URLToolkit = {
          // If opts.alwaysNormalize is true then the path will always be normalized even when it starts with / or //
          // E.g
          // With opts.alwaysNormalize = false (default, spec compliant)
          // http://a.com/b/cd + /e/f/../g => http://a.com/e/f/../g
          // With opts.alwaysNormalize = true (not spec compliant)
          // http://a.com/b/cd + /e/f/../g => http://a.com/e/g
          buildAbsoluteURL: function(baseURL, relativeURL, opts) {
            opts = opts || {};
            baseURL = baseURL.trim();
            relativeURL = relativeURL.trim();
            if (!relativeURL) {
              if (!opts.alwaysNormalize) {
                return baseURL;
              }
              var basePartsForNormalise = URLToolkit.parseURL(baseURL);
              if (!basePartsForNormalise) {
                throw new Error("Error trying to parse base URL.");
              }
              basePartsForNormalise.path = URLToolkit.normalizePath(
                basePartsForNormalise.path
              );
              return URLToolkit.buildURLFromParts(basePartsForNormalise);
            }
            var relativeParts = URLToolkit.parseURL(relativeURL);
            if (!relativeParts) {
              throw new Error("Error trying to parse relative URL.");
            }
            if (relativeParts.scheme) {
              if (!opts.alwaysNormalize) {
                return relativeURL;
              }
              relativeParts.path = URLToolkit.normalizePath(relativeParts.path);
              return URLToolkit.buildURLFromParts(relativeParts);
            }
            var baseParts = URLToolkit.parseURL(baseURL);
            if (!baseParts) {
              throw new Error("Error trying to parse base URL.");
            }
            if (!baseParts.netLoc && baseParts.path && baseParts.path[0] !== "/") {
              var pathParts = FIRST_SEGMENT_REGEX.exec(baseParts.path);
              baseParts.netLoc = pathParts[1];
              baseParts.path = pathParts[2];
            }
            if (baseParts.netLoc && !baseParts.path) {
              baseParts.path = "/";
            }
            var builtParts = {
              // 2c) Otherwise, the embedded URL inherits the scheme of
              // the base URL.
              scheme: baseParts.scheme,
              netLoc: relativeParts.netLoc,
              path: null,
              params: relativeParts.params,
              query: relativeParts.query,
              fragment: relativeParts.fragment
            };
            if (!relativeParts.netLoc) {
              builtParts.netLoc = baseParts.netLoc;
              if (relativeParts.path[0] !== "/") {
                if (!relativeParts.path) {
                  builtParts.path = baseParts.path;
                  if (!relativeParts.params) {
                    builtParts.params = baseParts.params;
                    if (!relativeParts.query) {
                      builtParts.query = baseParts.query;
                    }
                  }
                } else {
                  var baseURLPath = baseParts.path;
                  var newPath = baseURLPath.substring(0, baseURLPath.lastIndexOf("/") + 1) + relativeParts.path;
                  builtParts.path = URLToolkit.normalizePath(newPath);
                }
              }
            }
            if (builtParts.path === null) {
              builtParts.path = opts.alwaysNormalize ? URLToolkit.normalizePath(relativeParts.path) : relativeParts.path;
            }
            return URLToolkit.buildURLFromParts(builtParts);
          },
          parseURL: function(url) {
            var parts = URL_REGEX.exec(url);
            if (!parts) {
              return null;
            }
            return {
              scheme: parts[1] || "",
              netLoc: parts[2] || "",
              path: parts[3] || "",
              params: parts[4] || "",
              query: parts[5] || "",
              fragment: parts[6] || ""
            };
          },
          normalizePath: function(path) {
            path = path.split("").reverse().join("").replace(SLASH_DOT_REGEX, "");
            while (path.length !== (path = path.replace(SLASH_DOT_DOT_REGEX, "")).length) {
            }
            return path.split("").reverse().join("");
          },
          buildURLFromParts: function(parts) {
            return parts.scheme + parts.netLoc + parts.path + parts.params + parts.query + parts.fragment;
          }
        };
        module.exports = URLToolkit;
      })();
    })(urlToolkit);
    return urlToolkit.exports;
  }
  var urlToolkitExports = requireUrlToolkit();
  var LoadStats = class {
    constructor() {
      this.aborted = false;
      this.loaded = 0;
      this.retry = 0;
      this.total = 0;
      this.chunkCount = 0;
      this.bwEstimate = 0;
      this.loading = {
        start: 0,
        first: 0,
        end: 0
      };
      this.parsing = {
        start: 0,
        end: 0
      };
      this.buffering = {
        start: 0,
        first: 0,
        end: 0
      };
    }
  };
  var ElementaryStreamTypes = {
    AUDIO: "audio",
    VIDEO: "video",
    AUDIOVIDEO: "audiovideo"
  };
  var BaseSegment = class {
    constructor(base) {
      this._byteRange = null;
      this._url = null;
      this._stats = null;
      this._streams = null;
      this.base = void 0;
      this.relurl = void 0;
      if (typeof base === "string") {
        base = {
          url: base
        };
      }
      this.base = base;
      makeEnumerable(this, "stats");
    }
    // setByteRange converts a EXT-X-BYTERANGE attribute into a two element array
    setByteRange(value, previous) {
      const params = value.split("@", 2);
      let start;
      if (params.length === 1) {
        start = (previous == null ? void 0 : previous.byteRangeEndOffset) || 0;
      } else {
        start = parseInt(params[1]);
      }
      this._byteRange = [start, parseInt(params[0]) + start];
    }
    get baseurl() {
      return this.base.url;
    }
    get byteRange() {
      if (this._byteRange === null) {
        return [];
      }
      return this._byteRange;
    }
    get byteRangeStartOffset() {
      return this.byteRange[0];
    }
    get byteRangeEndOffset() {
      return this.byteRange[1];
    }
    get elementaryStreams() {
      if (this._streams === null) {
        this._streams = {
          [ElementaryStreamTypes.AUDIO]: null,
          [ElementaryStreamTypes.VIDEO]: null,
          [ElementaryStreamTypes.AUDIOVIDEO]: null
        };
      }
      return this._streams;
    }
    set elementaryStreams(value) {
      this._streams = value;
    }
    get hasStats() {
      return this._stats !== null;
    }
    get hasStreams() {
      return this._streams !== null;
    }
    get stats() {
      if (this._stats === null) {
        this._stats = new LoadStats();
      }
      return this._stats;
    }
    set stats(value) {
      this._stats = value;
    }
    get url() {
      if (!this._url && this.baseurl && this.relurl) {
        this._url = urlToolkitExports.buildAbsoluteURL(this.baseurl, this.relurl, {
          alwaysNormalize: true
        });
      }
      return this._url || "";
    }
    set url(value) {
      this._url = value;
    }
    clearElementaryStreamInfo() {
      const {
        elementaryStreams
      } = this;
      elementaryStreams[ElementaryStreamTypes.AUDIO] = null;
      elementaryStreams[ElementaryStreamTypes.VIDEO] = null;
      elementaryStreams[ElementaryStreamTypes.AUDIOVIDEO] = null;
    }
  };
  function isMediaFragment(frag) {
    return frag.sn !== "initSegment";
  }
  var Fragment3 = class extends BaseSegment {
    constructor(type, base) {
      super(base);
      this._decryptdata = null;
      this._programDateTime = null;
      this._ref = null;
      this._bitrate = void 0;
      this.rawProgramDateTime = null;
      this.tagList = [];
      this.duration = 0;
      this.sn = 0;
      this.levelkeys = void 0;
      this.type = void 0;
      this.loader = null;
      this.keyLoader = null;
      this.level = -1;
      this.cc = 0;
      this.startPTS = void 0;
      this.endPTS = void 0;
      this.startDTS = void 0;
      this.endDTS = void 0;
      this.start = 0;
      this.playlistOffset = 0;
      this.deltaPTS = void 0;
      this.maxStartPTS = void 0;
      this.minEndPTS = void 0;
      this.data = void 0;
      this.bitrateTest = false;
      this.title = null;
      this.initSegment = null;
      this.endList = void 0;
      this.gap = void 0;
      this.urlId = 0;
      this.type = type;
    }
    get byteLength() {
      if (this.hasStats) {
        const total = this.stats.total;
        if (total) {
          return total;
        }
      }
      if (this.byteRange.length) {
        const start = this.byteRange[0];
        const end = this.byteRange[1];
        if (isFiniteNumber(start) && isFiniteNumber(end)) {
          return end - start;
        }
      }
      return null;
    }
    get bitrate() {
      if (this.byteLength) {
        return this.byteLength * 8 / this.duration;
      }
      if (this._bitrate) {
        return this._bitrate;
      }
      return null;
    }
    set bitrate(value) {
      this._bitrate = value;
    }
    get decryptdata() {
      var _this$_decryptdata;
      const {
        levelkeys
      } = this;
      if (!levelkeys || levelkeys.NONE) {
        return null;
      }
      if (levelkeys.identity) {
        if (!this._decryptdata) {
          this._decryptdata = levelkeys.identity.getDecryptData(this.sn);
        }
      } else if (!((_this$_decryptdata = this._decryptdata) != null && _this$_decryptdata.keyId)) {
        const keyFormats = Object.keys(levelkeys);
        if (keyFormats.length === 1) {
          const levelKey = this._decryptdata = levelkeys[keyFormats[0]] || null;
          if (levelKey) {
            this._decryptdata = levelKey.getDecryptData(this.sn, levelkeys);
          }
        }
      }
      return this._decryptdata;
    }
    get end() {
      return this.start + this.duration;
    }
    get endProgramDateTime() {
      if (this.programDateTime === null) {
        return null;
      }
      const duration = !isFiniteNumber(this.duration) ? 0 : this.duration;
      return this.programDateTime + duration * 1e3;
    }
    get encrypted() {
      var _this$_decryptdata2;
      if ((_this$_decryptdata2 = this._decryptdata) != null && _this$_decryptdata2.encrypted) {
        return true;
      } else if (this.levelkeys) {
        var _this$levelkeys$keyFo;
        const keyFormats = Object.keys(this.levelkeys);
        const len = keyFormats.length;
        if (len > 1 || len === 1 && (_this$levelkeys$keyFo = this.levelkeys[keyFormats[0]]) != null && _this$levelkeys$keyFo.encrypted) {
          return true;
        }
      }
      return false;
    }
    get programDateTime() {
      if (this._programDateTime === null && this.rawProgramDateTime) {
        this.programDateTime = Date.parse(this.rawProgramDateTime);
      }
      return this._programDateTime;
    }
    set programDateTime(value) {
      if (!isFiniteNumber(value)) {
        this._programDateTime = this.rawProgramDateTime = null;
        return;
      }
      this._programDateTime = value;
    }
    get ref() {
      if (!isMediaFragment(this)) {
        return null;
      }
      if (!this._ref) {
        this._ref = {
          base: this.base,
          start: this.start,
          duration: this.duration,
          sn: this.sn,
          programDateTime: this.programDateTime
        };
      }
      return this._ref;
    }
    addStart(value) {
      this.setStart(this.start + value);
    }
    setStart(value) {
      this.start = value;
      if (this._ref) {
        this._ref.start = value;
      }
    }
    setDuration(value) {
      this.duration = value;
      if (this._ref) {
        this._ref.duration = value;
      }
    }
    setKeyFormat(keyFormat) {
      const levelkeys = this.levelkeys;
      if (levelkeys) {
        var _this$_decryptdata3;
        const key = levelkeys[keyFormat];
        if (key && !((_this$_decryptdata3 = this._decryptdata) != null && _this$_decryptdata3.keyId)) {
          this._decryptdata = key.getDecryptData(this.sn, levelkeys);
        }
      }
    }
    abortRequests() {
      var _this$loader, _this$keyLoader;
      (_this$loader = this.loader) == null || _this$loader.abort();
      (_this$keyLoader = this.keyLoader) == null || _this$keyLoader.abort();
    }
    setElementaryStreamInfo(type, startPTS, endPTS, startDTS, endDTS, partial = false) {
      const {
        elementaryStreams
      } = this;
      const info = elementaryStreams[type];
      if (!info) {
        elementaryStreams[type] = {
          startPTS,
          endPTS,
          startDTS,
          endDTS,
          partial
        };
        return;
      }
      info.startPTS = Math.min(info.startPTS, startPTS);
      info.endPTS = Math.max(info.endPTS, endPTS);
      info.startDTS = Math.min(info.startDTS, startDTS);
      info.endDTS = Math.max(info.endDTS, endDTS);
    }
  };
  var Part = class extends BaseSegment {
    constructor(partAttrs, frag, base, index, previous) {
      super(base);
      this.fragOffset = 0;
      this.duration = 0;
      this.gap = false;
      this.independent = false;
      this.relurl = void 0;
      this.fragment = void 0;
      this.index = void 0;
      this.duration = partAttrs.decimalFloatingPoint("DURATION");
      this.gap = partAttrs.bool("GAP");
      this.independent = partAttrs.bool("INDEPENDENT");
      this.relurl = partAttrs.enumeratedString("URI");
      this.fragment = frag;
      this.index = index;
      const byteRange = partAttrs.enumeratedString("BYTERANGE");
      if (byteRange) {
        this.setByteRange(byteRange, previous);
      }
      if (previous) {
        this.fragOffset = previous.fragOffset + previous.duration;
      }
    }
    get start() {
      return this.fragment.start + this.fragOffset;
    }
    get end() {
      return this.start + this.duration;
    }
    get loaded() {
      const {
        elementaryStreams
      } = this;
      return !!(elementaryStreams.audio || elementaryStreams.video || elementaryStreams.audiovideo);
    }
  };
  function getOwnPropertyDescriptorFromPrototypeChain(object, property) {
    const prototype = Object.getPrototypeOf(object);
    if (prototype) {
      const propertyDescriptor = Object.getOwnPropertyDescriptor(prototype, property);
      if (propertyDescriptor) {
        return propertyDescriptor;
      }
      return getOwnPropertyDescriptorFromPrototypeChain(prototype, property);
    }
  }
  function makeEnumerable(object, property) {
    const d = getOwnPropertyDescriptorFromPrototypeChain(object, property);
    if (d) {
      d.enumerable = true;
      Object.defineProperty(object, property, d);
    }
  }
  var UINT32_MAX$1 = Math.pow(2, 32) - 1;
  var push = [].push;
  var RemuxerTrackIdConfig = {
    video: 1,
    audio: 2,
    id3: 3,
    text: 4
  };
  function bin2str(data) {
    return String.fromCharCode.apply(null, data);
  }
  function readUint16(buffer, offset) {
    const val = buffer[offset] << 8 | buffer[offset + 1];
    return val < 0 ? 65536 + val : val;
  }
  function readUint32(buffer, offset) {
    const val = readSint32(buffer, offset);
    return val < 0 ? 4294967296 + val : val;
  }
  function readUint64(buffer, offset) {
    let result = readUint32(buffer, offset);
    result *= Math.pow(2, 32);
    result += readUint32(buffer, offset + 4);
    return result;
  }
  function readSint32(buffer, offset) {
    return buffer[offset] << 24 | buffer[offset + 1] << 16 | buffer[offset + 2] << 8 | buffer[offset + 3];
  }
  function hasMoofData(data) {
    const end = data.byteLength;
    for (let i = 0; i < end; ) {
      const size = readUint32(data, i);
      if (size > 8 && data[i + 4] === 109 && data[i + 5] === 111 && data[i + 6] === 111 && data[i + 7] === 102) {
        return true;
      }
      i = size > 1 ? i + size : end;
    }
    return false;
  }
  function findBox(data, path) {
    const results = [];
    if (!path.length) {
      return results;
    }
    const end = data.byteLength;
    for (let i = 0; i < end; ) {
      const size = readUint32(data, i);
      const type = bin2str(data.subarray(i + 4, i + 8));
      const endbox = size > 1 ? i + size : end;
      if (type === path[0]) {
        if (path.length === 1) {
          results.push(data.subarray(i + 8, endbox));
        } else {
          const subresults = findBox(data.subarray(i + 8, endbox), path.slice(1));
          if (subresults.length) {
            push.apply(results, subresults);
          }
        }
      }
      i = endbox;
    }
    return results;
  }
  function parseSegmentIndex(sidx) {
    const references = [];
    const version2 = sidx[0];
    let index = 8;
    const timescale = readUint32(sidx, index);
    index += 4;
    let earliestPresentationTime = 0;
    let firstOffset = 0;
    if (version2 === 0) {
      earliestPresentationTime = readUint32(sidx, index);
      firstOffset = readUint32(sidx, index + 4);
      index += 8;
    } else {
      earliestPresentationTime = readUint64(sidx, index);
      firstOffset = readUint64(sidx, index + 8);
      index += 16;
    }
    index += 2;
    let startByte = sidx.length + firstOffset;
    const referencesCount = readUint16(sidx, index);
    index += 2;
    for (let i = 0; i < referencesCount; i++) {
      let referenceIndex = index;
      const referenceInfo = readUint32(sidx, referenceIndex);
      referenceIndex += 4;
      const referenceSize = referenceInfo & 2147483647;
      const referenceType = (referenceInfo & 2147483648) >>> 31;
      if (referenceType === 1) {
        logger.warn("SIDX has hierarchical references (not supported)");
        return null;
      }
      const subsegmentDuration = readUint32(sidx, referenceIndex);
      referenceIndex += 4;
      references.push({
        referenceSize,
        subsegmentDuration,
        // unscaled
        info: {
          duration: subsegmentDuration / timescale,
          start: startByte,
          end: startByte + referenceSize - 1
        }
      });
      startByte += referenceSize;
      referenceIndex += 4;
      index = referenceIndex;
    }
    return {
      earliestPresentationTime,
      timescale,
      version: version2,
      referencesCount,
      references
    };
  }
  function parseInitSegment(initSegment) {
    const result = [];
    const traks = findBox(initSegment, ["moov", "trak"]);
    for (let i = 0; i < traks.length; i++) {
      const trak = traks[i];
      const tkhd = findBox(trak, ["tkhd"])[0];
      if (tkhd) {
        let version2 = tkhd[0];
        const trackId = readUint32(tkhd, version2 === 0 ? 12 : 20);
        const mdhd = findBox(trak, ["mdia", "mdhd"])[0];
        if (mdhd) {
          version2 = mdhd[0];
          const timescale = readUint32(mdhd, version2 === 0 ? 12 : 20);
          const hdlr = findBox(trak, ["mdia", "hdlr"])[0];
          if (hdlr) {
            const hdlrType = bin2str(hdlr.subarray(8, 12));
            const type = {
              soun: ElementaryStreamTypes.AUDIO,
              vide: ElementaryStreamTypes.VIDEO
            }[hdlrType];
            const stsdBox = findBox(trak, ["mdia", "minf", "stbl", "stsd"])[0];
            const stsd = parseStsd(stsdBox);
            if (type) {
              result[trackId] = {
                timescale,
                type,
                stsd
              };
              result[type] = _objectSpread2({
                timescale,
                id: trackId
              }, stsd);
            } else {
              result[trackId] = {
                timescale,
                type: hdlrType,
                stsd
              };
            }
          }
        }
      }
    }
    const trex = findBox(initSegment, ["moov", "mvex", "trex"]);
    trex.forEach((trex2) => {
      const trackId = readUint32(trex2, 4);
      const track = result[trackId];
      if (track) {
        track.default = {
          duration: readUint32(trex2, 12),
          flags: readUint32(trex2, 20)
        };
      }
    });
    return result;
  }
  function parseStsd(stsd) {
    const sampleEntries = stsd.subarray(8);
    const sampleEntriesEnd = sampleEntries.subarray(8 + 78);
    const fourCC = bin2str(sampleEntries.subarray(4, 8));
    let codec = fourCC;
    let supplemental;
    const encrypted = fourCC === "enca" || fourCC === "encv";
    if (encrypted) {
      const encBox = findBox(sampleEntries, [fourCC])[0];
      const encBoxChildren = encBox.subarray(fourCC === "enca" ? 28 : 78);
      const sinfs = findBox(encBoxChildren, ["sinf"]);
      sinfs.forEach((sinf) => {
        const schm = findBox(sinf, ["schm"])[0];
        if (schm) {
          const scheme = bin2str(schm.subarray(4, 8));
          if (scheme === "cbcs" || scheme === "cenc") {
            const frma = findBox(sinf, ["frma"])[0];
            if (frma) {
              codec = bin2str(frma);
            }
          }
        }
      });
    }
    const codecFourCC = codec;
    switch (codec) {
      case "avc1":
      case "avc2":
      case "avc3":
      case "avc4": {
        const avcCBox = findBox(sampleEntriesEnd, ["avcC"])[0];
        if (avcCBox && avcCBox.length > 3) {
          codec += "." + toHex(avcCBox[1]) + toHex(avcCBox[2]) + toHex(avcCBox[3]);
          supplemental = parseSupplementalDoViCodec(codecFourCC === "avc1" ? "dva1" : "dvav", sampleEntriesEnd);
        }
        break;
      }
      case "mp4a": {
        const codecBox = findBox(sampleEntries, [fourCC])[0];
        const esdsBox = findBox(codecBox.subarray(28), ["esds"])[0];
        if (esdsBox && esdsBox.length > 7) {
          let i = 4;
          if (esdsBox[i++] !== 3) {
            break;
          }
          i = skipBERInteger(esdsBox, i);
          i += 2;
          const flags = esdsBox[i++];
          if (flags & 128) {
            i += 2;
          }
          if (flags & 64) {
            i += esdsBox[i++];
          }
          if (esdsBox[i++] !== 4) {
            break;
          }
          i = skipBERInteger(esdsBox, i);
          const objectType = esdsBox[i++];
          if (objectType === 64) {
            codec += "." + toHex(objectType);
          } else {
            break;
          }
          i += 12;
          if (esdsBox[i++] !== 5) {
            break;
          }
          i = skipBERInteger(esdsBox, i);
          const firstByte = esdsBox[i++];
          let audioObjectType = (firstByte & 248) >> 3;
          if (audioObjectType === 31) {
            audioObjectType += 1 + ((firstByte & 7) << 3) + ((esdsBox[i] & 224) >> 5);
          }
          codec += "." + audioObjectType;
        }
        break;
      }
      case "hvc1":
      case "hev1": {
        const hvcCBox = findBox(sampleEntriesEnd, ["hvcC"])[0];
        if (hvcCBox && hvcCBox.length > 12) {
          const profileByte = hvcCBox[1];
          const profileSpace = ["", "A", "B", "C"][profileByte >> 6];
          const generalProfileIdc = profileByte & 31;
          const profileCompat = readUint32(hvcCBox, 2);
          const tierFlag = (profileByte & 32) >> 5 ? "H" : "L";
          const levelIDC = hvcCBox[12];
          const constraintIndicator = hvcCBox.subarray(6, 12);
          codec += "." + profileSpace + generalProfileIdc;
          codec += "." + reverse32BitInt(profileCompat).toString(16).toUpperCase();
          codec += "." + tierFlag + levelIDC;
          let constraintString = "";
          for (let i = constraintIndicator.length; i--; ) {
            const byte = constraintIndicator[i];
            if (byte || constraintString) {
              const encodedByte = byte.toString(16).toUpperCase();
              constraintString = "." + encodedByte + constraintString;
            }
          }
          codec += constraintString;
        }
        supplemental = parseSupplementalDoViCodec(codecFourCC == "hev1" ? "dvhe" : "dvh1", sampleEntriesEnd);
        break;
      }
      case "dvh1":
      case "dvhe":
      case "dvav":
      case "dva1":
      case "dav1": {
        codec = parseSupplementalDoViCodec(codec, sampleEntriesEnd) || codec;
        break;
      }
      case "vp09": {
        const vpcCBox = findBox(sampleEntriesEnd, ["vpcC"])[0];
        if (vpcCBox && vpcCBox.length > 6) {
          const profile = vpcCBox[4];
          const level = vpcCBox[5];
          const bitDepth = vpcCBox[6] >> 4 & 15;
          codec += "." + addLeadingZero(profile) + "." + addLeadingZero(level) + "." + addLeadingZero(bitDepth);
        }
        break;
      }
      case "av01": {
        const av1CBox = findBox(sampleEntriesEnd, ["av1C"])[0];
        if (av1CBox && av1CBox.length > 2) {
          const profile = av1CBox[1] >>> 5;
          const level = av1CBox[1] & 31;
          const tierFlag = av1CBox[2] >>> 7 ? "H" : "M";
          const highBitDepth = (av1CBox[2] & 64) >> 6;
          const twelveBit = (av1CBox[2] & 32) >> 5;
          const bitDepth = profile === 2 && highBitDepth ? twelveBit ? 12 : 10 : highBitDepth ? 10 : 8;
          const monochrome = (av1CBox[2] & 16) >> 4;
          const chromaSubsamplingX = (av1CBox[2] & 8) >> 3;
          const chromaSubsamplingY = (av1CBox[2] & 4) >> 2;
          const chromaSamplePosition = av1CBox[2] & 3;
          const colorPrimaries = 1;
          const transferCharacteristics = 1;
          const matrixCoefficients = 1;
          const videoFullRangeFlag = 0;
          codec += "." + profile + "." + addLeadingZero(level) + tierFlag + "." + addLeadingZero(bitDepth) + "." + monochrome + "." + chromaSubsamplingX + chromaSubsamplingY + chromaSamplePosition + "." + addLeadingZero(colorPrimaries) + "." + addLeadingZero(transferCharacteristics) + "." + addLeadingZero(matrixCoefficients) + "." + videoFullRangeFlag;
          supplemental = parseSupplementalDoViCodec("dav1", sampleEntriesEnd);
        }
        break;
      }
    }
    return {
      codec,
      encrypted,
      supplemental
    };
  }
  function parseSupplementalDoViCodec(fourCC, sampleEntriesEnd) {
    const dvvCResult = findBox(sampleEntriesEnd, ["dvvC"]);
    const dvXCBox = dvvCResult.length ? dvvCResult[0] : findBox(sampleEntriesEnd, ["dvcC"])[0];
    if (dvXCBox) {
      const doViProfile = dvXCBox[2] >> 1 & 127;
      const doViLevel = dvXCBox[2] << 5 & 32 | dvXCBox[3] >> 3 & 31;
      return fourCC + "." + addLeadingZero(doViProfile) + "." + addLeadingZero(doViLevel);
    }
  }
  function reverse32BitInt(val) {
    let result = 0;
    for (let i = 0; i < 32; i++) {
      result |= (val >> i & 1) << 32 - 1 - i;
    }
    return result >>> 0;
  }
  function skipBERInteger(bytes, i) {
    const limit = i + 5;
    while (bytes[i++] & 128 && i < limit) {
    }
    return i;
  }
  function toHex(x) {
    return ("0" + x.toString(16).toUpperCase()).slice(-2);
  }
  function addLeadingZero(num) {
    return (num < 10 ? "0" : "") + num;
  }
  function patchEncyptionData(initSegment, decryptdata) {
    if (!initSegment || !decryptdata) {
      return;
    }
    const keyId = decryptdata.keyId;
    if (keyId && decryptdata.isCommonEncryption) {
      applyToTencBoxes(initSegment, (tenc, isAudio) => {
        const tencKeyId = tenc.subarray(8, 24);
        if (!tencKeyId.some((b) => b !== 0)) {
          logger.log(`[eme] Patching keyId in 'enc${isAudio ? "a" : "v"}>sinf>>tenc' box: ${arrayToHex(tencKeyId)} -> ${arrayToHex(keyId)}`);
          tenc.set(keyId, 8);
        }
      });
    }
  }
  function parseKeyIdsFromTenc(initSegment) {
    const keyIds = [];
    applyToTencBoxes(initSegment, (tenc) => keyIds.push(tenc.subarray(8, 24)));
    return keyIds;
  }
  function applyToTencBoxes(initSegment, predicate) {
    const traks = findBox(initSegment, ["moov", "trak"]);
    traks.forEach((trak) => {
      const stsd = findBox(trak, ["mdia", "minf", "stbl", "stsd"])[0];
      if (!stsd) return;
      const sampleEntries = stsd.subarray(8);
      let encBoxes = findBox(sampleEntries, ["enca"]);
      const isAudio = encBoxes.length > 0;
      if (!isAudio) {
        encBoxes = findBox(sampleEntries, ["encv"]);
      }
      encBoxes.forEach((enc) => {
        const encBoxChildren = isAudio ? enc.subarray(28) : enc.subarray(78);
        const sinfBoxes = findBox(encBoxChildren, ["sinf"]);
        sinfBoxes.forEach((sinf) => {
          const tenc = parseSinf(sinf);
          if (tenc) {
            predicate(tenc, isAudio);
          }
        });
      });
    });
  }
  function parseSinf(sinf) {
    const schm = findBox(sinf, ["schm"])[0];
    if (schm) {
      const scheme = bin2str(schm.subarray(4, 8));
      if (scheme === "cbcs" || scheme === "cenc") {
        const tenc = findBox(sinf, ["schi", "tenc"])[0];
        if (tenc) {
          return tenc;
        }
      }
    }
  }
  function getSampleData(data, initData, logger2) {
    const tracks = {};
    const trafs = findBox(data, ["moof", "traf"]);
    for (let i = 0; i < trafs.length; i++) {
      const traf = trafs[i];
      const tfhd = findBox(traf, ["tfhd"])[0];
      const id3 = readUint32(tfhd, 4);
      const track = initData[id3];
      if (!track) {
        continue;
      }
      tracks[id3] || (tracks[id3] = {
        start: NaN,
        duration: 0,
        sampleCount: 0,
        timescale: track.timescale,
        type: track.type
      });
      const trackTimes = tracks[id3];
      const tfdt = findBox(traf, ["tfdt"])[0];
      if (tfdt) {
        const version2 = tfdt[0];
        let baseTime = readUint32(tfdt, 4);
        if (version2 === 1) {
          if (baseTime === UINT32_MAX$1) {
            logger2.warn(`[mp4-demuxer]: Ignoring assumed invalid signed 64-bit track fragment decode time`);
          } else {
            baseTime *= UINT32_MAX$1 + 1;
            baseTime += readUint32(tfdt, 8);
          }
        }
        if (isFiniteNumber(baseTime) && (!isFiniteNumber(trackTimes.start) || baseTime < trackTimes.start)) {
          trackTimes.start = baseTime;
        }
      }
      const trackDefault = track.default;
      const tfhdFlags = readUint32(tfhd, 0) | (trackDefault == null ? void 0 : trackDefault.flags);
      let defaultSampleDuration = (trackDefault == null ? void 0 : trackDefault.duration) || 0;
      if (tfhdFlags & 8) {
        if (tfhdFlags & 2) {
          defaultSampleDuration = readUint32(tfhd, 12);
        } else {
          defaultSampleDuration = readUint32(tfhd, 8);
        }
      }
      const truns = findBox(traf, ["trun"]);
      let sampleDTS = trackTimes.start || 0;
      let rawDuration = 0;
      let sampleDuration = defaultSampleDuration;
      for (let j = 0; j < truns.length; j++) {
        const trun = truns[j];
        const sampleCount = readUint32(trun, 4);
        const sampleIndex = trackTimes.sampleCount;
        trackTimes.sampleCount += sampleCount;
        const dataOffsetPresent = trun[3] & 1;
        const firstSampleFlagsPresent = trun[3] & 4;
        const sampleDurationPresent = trun[2] & 1;
        const sampleSizePresent = trun[2] & 2;
        const sampleFlagsPresent = trun[2] & 4;
        const sampleCompositionTimeOffsetPresent = trun[2] & 8;
        let offset = 8;
        let remaining = sampleCount;
        if (dataOffsetPresent) {
          offset += 4;
        }
        if (firstSampleFlagsPresent && sampleCount) {
          const isNonSyncSample = trun[offset + 1] & 1;
          if (!isNonSyncSample && trackTimes.keyFrameIndex === void 0) {
            trackTimes.keyFrameIndex = sampleIndex;
          }
          offset += 4;
          if (sampleDurationPresent) {
            sampleDuration = readUint32(trun, offset);
            offset += 4;
          } else {
            sampleDuration = defaultSampleDuration;
          }
          if (sampleSizePresent) {
            offset += 4;
          }
          if (sampleCompositionTimeOffsetPresent) {
            offset += 4;
          }
          sampleDTS += sampleDuration;
          rawDuration += sampleDuration;
          remaining--;
        }
        while (remaining--) {
          if (sampleDurationPresent) {
            sampleDuration = readUint32(trun, offset);
            offset += 4;
          } else {
            sampleDuration = defaultSampleDuration;
          }
          if (sampleSizePresent) {
            offset += 4;
          }
          if (sampleFlagsPresent) {
            const isNonSyncSample = trun[offset + 1] & 1;
            if (!isNonSyncSample) {
              if (trackTimes.keyFrameIndex === void 0) {
                trackTimes.keyFrameIndex = trackTimes.sampleCount - (remaining + 1);
                trackTimes.keyFrameStart = sampleDTS;
              }
            }
            offset += 4;
          }
          if (sampleCompositionTimeOffsetPresent) {
            offset += 4;
          }
          sampleDTS += sampleDuration;
          rawDuration += sampleDuration;
        }
        if (!rawDuration && defaultSampleDuration) {
          rawDuration += defaultSampleDuration * sampleCount;
        }
      }
      trackTimes.duration += rawDuration;
    }
    if (!Object.keys(tracks).some((trackId) => tracks[trackId].duration)) {
      let sidxMinStart = Infinity;
      let sidxMaxEnd = 0;
      const sidxs = findBox(data, ["sidx"]);
      for (let i = 0; i < sidxs.length; i++) {
        const sidx = parseSegmentIndex(sidxs[i]);
        if (sidx != null && sidx.references) {
          sidxMinStart = Math.min(sidxMinStart, sidx.earliestPresentationTime / sidx.timescale);
          const subSegmentDuration = sidx.references.reduce((dur, ref2) => dur + ref2.info.duration || 0, 0);
          sidxMaxEnd = Math.max(sidxMaxEnd, subSegmentDuration + sidx.earliestPresentationTime / sidx.timescale);
        }
      }
      if (sidxMaxEnd && isFiniteNumber(sidxMaxEnd)) {
        Object.keys(tracks).forEach((trackId) => {
          if (!tracks[trackId].duration) {
            tracks[trackId].duration = sidxMaxEnd * tracks[trackId].timescale - tracks[trackId].start;
          }
        });
      }
    }
    return tracks;
  }
  function segmentValidRange(data) {
    const segmentedRange = {
      valid: null,
      remainder: null
    };
    const moofs = findBox(data, ["moof"]);
    if (moofs.length < 2) {
      segmentedRange.remainder = data;
      return segmentedRange;
    }
    const last = moofs[moofs.length - 1];
    segmentedRange.valid = data.slice(0, last.byteOffset - 8);
    segmentedRange.remainder = data.slice(last.byteOffset - 8);
    return segmentedRange;
  }
  function appendUint8Array(data1, data2) {
    const temp = new Uint8Array(data1.length + data2.length);
    temp.set(data1);
    temp.set(data2, data1.length);
    return temp;
  }
  function parseSamples(timeOffset, track) {
    const seiSamples = [];
    const videoData = track.samples;
    const timescale = track.timescale;
    const trackId = track.id;
    let isHEVCFlavor = false;
    const moofs = findBox(videoData, ["moof"]);
    moofs.map((moof) => {
      const moofOffset = moof.byteOffset - 8;
      const trafs = findBox(moof, ["traf"]);
      trafs.map((traf) => {
        const baseTime = findBox(traf, ["tfdt"]).map((tfdt) => {
          const version2 = tfdt[0];
          let result = readUint32(tfdt, 4);
          if (version2 === 1) {
            result *= Math.pow(2, 32);
            result += readUint32(tfdt, 8);
          }
          return result / timescale;
        })[0];
        if (baseTime !== void 0) {
          timeOffset = baseTime;
        }
        return findBox(traf, ["tfhd"]).map((tfhd) => {
          const id3 = readUint32(tfhd, 4);
          const tfhdFlags = readUint32(tfhd, 0) & 16777215;
          const baseDataOffsetPresent = (tfhdFlags & 1) !== 0;
          const sampleDescriptionIndexPresent = (tfhdFlags & 2) !== 0;
          const defaultSampleDurationPresent = (tfhdFlags & 8) !== 0;
          let defaultSampleDuration = 0;
          const defaultSampleSizePresent = (tfhdFlags & 16) !== 0;
          let defaultSampleSize = 0;
          const defaultSampleFlagsPresent = (tfhdFlags & 32) !== 0;
          let tfhdOffset = 8;
          if (id3 === trackId) {
            if (baseDataOffsetPresent) {
              tfhdOffset += 8;
            }
            if (sampleDescriptionIndexPresent) {
              tfhdOffset += 4;
            }
            if (defaultSampleDurationPresent) {
              defaultSampleDuration = readUint32(tfhd, tfhdOffset);
              tfhdOffset += 4;
            }
            if (defaultSampleSizePresent) {
              defaultSampleSize = readUint32(tfhd, tfhdOffset);
              tfhdOffset += 4;
            }
            if (defaultSampleFlagsPresent) {
              tfhdOffset += 4;
            }
            if (track.type === "video") {
              isHEVCFlavor = isHEVC(track.codec);
            }
            findBox(traf, ["trun"]).map((trun) => {
              const version2 = trun[0];
              const flags = readUint32(trun, 0) & 16777215;
              const dataOffsetPresent = (flags & 1) !== 0;
              let dataOffset = 0;
              const firstSampleFlagsPresent = (flags & 4) !== 0;
              const sampleDurationPresent = (flags & 256) !== 0;
              let sampleDuration = 0;
              const sampleSizePresent = (flags & 512) !== 0;
              let sampleSize = 0;
              const sampleFlagsPresent = (flags & 1024) !== 0;
              const sampleCompositionOffsetsPresent = (flags & 2048) !== 0;
              let compositionOffset = 0;
              const sampleCount = readUint32(trun, 4);
              let trunOffset = 8;
              if (dataOffsetPresent) {
                dataOffset = readUint32(trun, trunOffset);
                trunOffset += 4;
              }
              if (firstSampleFlagsPresent) {
                trunOffset += 4;
              }
              let sampleOffset = dataOffset + moofOffset;
              for (let ix = 0; ix < sampleCount; ix++) {
                if (sampleDurationPresent) {
                  sampleDuration = readUint32(trun, trunOffset);
                  trunOffset += 4;
                } else {
                  sampleDuration = defaultSampleDuration;
                }
                if (sampleSizePresent) {
                  sampleSize = readUint32(trun, trunOffset);
                  trunOffset += 4;
                } else {
                  sampleSize = defaultSampleSize;
                }
                if (sampleFlagsPresent) {
                  trunOffset += 4;
                }
                if (sampleCompositionOffsetsPresent) {
                  if (version2 === 0) {
                    compositionOffset = readUint32(trun, trunOffset);
                  } else {
                    compositionOffset = readSint32(trun, trunOffset);
                  }
                  trunOffset += 4;
                }
                if (track.type === ElementaryStreamTypes.VIDEO) {
                  let naluTotalSize = 0;
                  while (naluTotalSize < sampleSize) {
                    const naluSize = readUint32(videoData, sampleOffset);
                    sampleOffset += 4;
                    if (isSEIMessage(isHEVCFlavor, videoData[sampleOffset])) {
                      const data = videoData.subarray(sampleOffset, sampleOffset + naluSize);
                      parseSEIMessageFromNALu(data, isHEVCFlavor ? 2 : 1, timeOffset + compositionOffset / timescale, seiSamples);
                    }
                    sampleOffset += naluSize;
                    naluTotalSize += naluSize + 4;
                  }
                }
                timeOffset += sampleDuration / timescale;
              }
            });
          }
        });
      });
    });
    return seiSamples;
  }
  function isHEVC(codec) {
    if (!codec) {
      return false;
    }
    const baseCodec = codec.substring(0, 4);
    return baseCodec === "hvc1" || baseCodec === "hev1" || // Dolby Vision
    baseCodec === "dvh1" || baseCodec === "dvhe";
  }
  function isSEIMessage(isHEVCFlavor, naluHeader) {
    if (isHEVCFlavor) {
      const naluType = naluHeader >> 1 & 63;
      return naluType === 39 || naluType === 40;
    } else {
      const naluType = naluHeader & 31;
      return naluType === 6;
    }
  }
  function parseSEIMessageFromNALu(unescapedData, headerSize, pts, samples) {
    const data = discardEPB(unescapedData);
    let seiPtr = 0;
    seiPtr += headerSize;
    let payloadType = 0;
    let payloadSize = 0;
    let b = 0;
    while (seiPtr < data.length) {
      payloadType = 0;
      do {
        if (seiPtr >= data.length) {
          break;
        }
        b = data[seiPtr++];
        payloadType += b;
      } while (b === 255);
      payloadSize = 0;
      do {
        if (seiPtr >= data.length) {
          break;
        }
        b = data[seiPtr++];
        payloadSize += b;
      } while (b === 255);
      const leftOver = data.length - seiPtr;
      let payPtr = seiPtr;
      if (payloadSize < leftOver) {
        seiPtr += payloadSize;
      } else if (payloadSize > leftOver) {
        logger.error(`Malformed SEI payload. ${payloadSize} is too small, only ${leftOver} bytes left to parse.`);
        break;
      }
      if (payloadType === 4) {
        const countryCode = data[payPtr++];
        if (countryCode === 181) {
          const providerCode = readUint16(data, payPtr);
          payPtr += 2;
          if (providerCode === 49) {
            const userStructure = readUint32(data, payPtr);
            payPtr += 4;
            if (userStructure === 1195456820) {
              const userDataType = data[payPtr++];
              if (userDataType === 3) {
                const firstByte = data[payPtr++];
                const totalCCs = 31 & firstByte;
                const enabled = 64 & firstByte;
                const totalBytes = enabled ? 2 + totalCCs * 3 : 0;
                const byteArray = new Uint8Array(totalBytes);
                if (enabled) {
                  byteArray[0] = firstByte;
                  for (let i = 1; i < totalBytes; i++) {
                    byteArray[i] = data[payPtr++];
                  }
                }
                samples.push({
                  type: userDataType,
                  payloadType,
                  pts,
                  bytes: byteArray
                });
              }
            }
          }
        }
      } else if (payloadType === 5) {
        if (payloadSize > 16) {
          const uuidStrArray = [];
          for (let i = 0; i < 16; i++) {
            const _b = data[payPtr++].toString(16);
            uuidStrArray.push(_b.length == 1 ? "0" + _b : _b);
            if (i === 3 || i === 5 || i === 7 || i === 9) {
              uuidStrArray.push("-");
            }
          }
          const length = payloadSize - 16;
          const userDataBytes = new Uint8Array(length);
          for (let i = 0; i < length; i++) {
            userDataBytes[i] = data[payPtr++];
          }
          samples.push({
            payloadType,
            pts,
            uuid: uuidStrArray.join(""),
            userData: utf8ArrayToStr(userDataBytes),
            userDataBytes
          });
        }
      }
    }
  }
  function discardEPB(data) {
    const length = data.byteLength;
    const EPBPositions = [];
    let i = 1;
    while (i < length - 2) {
      if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 3) {
        EPBPositions.push(i + 2);
        i += 2;
      } else {
        i++;
      }
    }
    if (EPBPositions.length === 0) {
      return data;
    }
    const newLength = length - EPBPositions.length;
    const newData = new Uint8Array(newLength);
    let sourceIndex = 0;
    for (i = 0; i < newLength; sourceIndex++, i++) {
      if (sourceIndex === EPBPositions[0]) {
        sourceIndex++;
        EPBPositions.shift();
      }
      newData[i] = data[sourceIndex];
    }
    return newData;
  }
  function parseEmsg(data) {
    const version2 = data[0];
    let schemeIdUri = "";
    let value = "";
    let timeScale = 0;
    let presentationTimeDelta = 0;
    let presentationTime = 0;
    let eventDuration = 0;
    let id3 = 0;
    let offset = 0;
    if (version2 === 0) {
      while (bin2str(data.subarray(offset, offset + 1)) !== "\0") {
        schemeIdUri += bin2str(data.subarray(offset, offset + 1));
        offset += 1;
      }
      schemeIdUri += bin2str(data.subarray(offset, offset + 1));
      offset += 1;
      while (bin2str(data.subarray(offset, offset + 1)) !== "\0") {
        value += bin2str(data.subarray(offset, offset + 1));
        offset += 1;
      }
      value += bin2str(data.subarray(offset, offset + 1));
      offset += 1;
      timeScale = readUint32(data, 12);
      presentationTimeDelta = readUint32(data, 16);
      eventDuration = readUint32(data, 20);
      id3 = readUint32(data, 24);
      offset = 28;
    } else if (version2 === 1) {
      offset += 4;
      timeScale = readUint32(data, offset);
      offset += 4;
      const leftPresentationTime = readUint32(data, offset);
      offset += 4;
      const rightPresentationTime = readUint32(data, offset);
      offset += 4;
      presentationTime = 2 ** 32 * leftPresentationTime + rightPresentationTime;
      if (!isSafeInteger(presentationTime)) {
        presentationTime = Number.MAX_SAFE_INTEGER;
        logger.warn("Presentation time exceeds safe integer limit and wrapped to max safe integer in parsing emsg box");
      }
      eventDuration = readUint32(data, offset);
      offset += 4;
      id3 = readUint32(data, offset);
      offset += 4;
      while (bin2str(data.subarray(offset, offset + 1)) !== "\0") {
        schemeIdUri += bin2str(data.subarray(offset, offset + 1));
        offset += 1;
      }
      schemeIdUri += bin2str(data.subarray(offset, offset + 1));
      offset += 1;
      while (bin2str(data.subarray(offset, offset + 1)) !== "\0") {
        value += bin2str(data.subarray(offset, offset + 1));
        offset += 1;
      }
      value += bin2str(data.subarray(offset, offset + 1));
      offset += 1;
    }
    const payload = data.subarray(offset, data.byteLength);
    return {
      schemeIdUri,
      value,
      timeScale,
      presentationTime,
      presentationTimeDelta,
      eventDuration,
      id: id3,
      payload
    };
  }
  function mp4Box(type, ...payload) {
    const len = payload.length;
    let size = 8;
    let i = len;
    while (i--) {
      size += payload[i].byteLength;
    }
    const result = new Uint8Array(size);
    result[0] = size >> 24 & 255;
    result[1] = size >> 16 & 255;
    result[2] = size >> 8 & 255;
    result[3] = size & 255;
    result.set(type, 4);
    for (i = 0, size = 8; i < len; i++) {
      result.set(payload[i], size);
      size += payload[i].byteLength;
    }
    return result;
  }
  function mp4pssh(systemId, keyids, data) {
    if (systemId.byteLength !== 16) {
      throw new RangeError("Invalid system id");
    }
    let version2;
    let kids;
    {
      version2 = 0;
      kids = new Uint8Array();
    }
    let kidCount;
    if (version2 > 0) {
      kidCount = new Uint8Array(4);
      if (keyids.length > 0) {
        new DataView(kidCount.buffer).setUint32(0, keyids.length, false);
      }
    } else {
      kidCount = new Uint8Array();
    }
    const dataSize = new Uint8Array(4);
    if (data.byteLength > 0) {
      new DataView(dataSize.buffer).setUint32(0, data.byteLength, false);
    }
    return mp4Box(
      [112, 115, 115, 104],
      new Uint8Array([
        version2,
        0,
        0,
        0
        // Flags
      ]),
      systemId,
      // 16 bytes
      kidCount,
      kids,
      dataSize,
      data
    );
  }
  function parseMultiPssh(initData) {
    const results = [];
    if (initData instanceof ArrayBuffer) {
      const length = initData.byteLength;
      let offset = 0;
      while (offset + 32 < length) {
        const view2 = new DataView(initData, offset);
        const pssh = parsePssh(view2);
        results.push(pssh);
        offset += pssh.size;
      }
    }
    return results;
  }
  function parsePssh(view2) {
    const size = view2.getUint32(0);
    const offset = view2.byteOffset;
    const length = view2.byteLength;
    if (length < size) {
      return {
        offset,
        size: length
      };
    }
    const type = view2.getUint32(4);
    if (type !== 1886614376) {
      return {
        offset,
        size
      };
    }
    const version2 = view2.getUint32(8) >>> 24;
    if (version2 !== 0 && version2 !== 1) {
      return {
        offset,
        size
      };
    }
    const buffer = view2.buffer;
    const systemId = arrayToHex(new Uint8Array(buffer, offset + 12, 16));
    let kids = null;
    let data = null;
    let dataSizeOffset = 0;
    if (version2 === 0) {
      dataSizeOffset = 28;
    } else {
      const kidCounts = view2.getUint32(28);
      if (!kidCounts || length < 32 + kidCounts * 16) {
        return {
          offset,
          size
        };
      }
      kids = [];
      for (let i = 0; i < kidCounts; i++) {
        kids.push(new Uint8Array(buffer, offset + 32 + i * 16, 16));
      }
      dataSizeOffset = 32 + kidCounts * 16;
    }
    if (!dataSizeOffset) {
      return {
        offset,
        size
      };
    }
    const dataSizeOrKidCount = view2.getUint32(dataSizeOffset);
    if (size - 32 < dataSizeOrKidCount) {
      return {
        offset,
        size
      };
    }
    data = new Uint8Array(buffer, offset + dataSizeOffset + 4, dataSizeOrKidCount);
    return {
      version: version2,
      systemId,
      kids,
      data,
      offset,
      size
    };
  }
  var userAgentHevcSupportIsInaccurate = () => {
    return /\(Windows.+Firefox\//i.test(navigator.userAgent);
  };
  var sampleEntryCodesISO = {
    audio: {
      a3ds: 1,
      "ac-3": 0.95,
      "ac-4": 1,
      alac: 0.9,
      alaw: 1,
      dra1: 1,
      "dts+": 1,
      "dts-": 1,
      dtsc: 1,
      dtse: 1,
      dtsh: 1,
      "ec-3": 0.9,
      enca: 1,
      fLaC: 0.9,
      // MP4-RA listed codec entry for FLAC
      flac: 0.9,
      // legacy browser codec name for FLAC
      FLAC: 0.9,
      // some manifests may list "FLAC" with Apple's tools
      g719: 1,
      g726: 1,
      m4ae: 1,
      mha1: 1,
      mha2: 1,
      mhm1: 1,
      mhm2: 1,
      mlpa: 1,
      mp4a: 1,
      "raw ": 1,
      Opus: 1,
      opus: 1,
      // browsers expect this to be lowercase despite MP4RA says 'Opus'
      samr: 1,
      sawb: 1,
      sawp: 1,
      sevc: 1,
      sqcp: 1,
      ssmv: 1,
      twos: 1,
      ulaw: 1
    },
    video: {
      avc1: 1,
      avc2: 1,
      avc3: 1,
      avc4: 1,
      avcp: 1,
      av01: 0.8,
      dav1: 0.8,
      drac: 1,
      dva1: 1,
      dvav: 1,
      dvh1: 0.7,
      dvhe: 0.7,
      encv: 1,
      hev1: 0.75,
      hvc1: 0.75,
      mjp2: 1,
      mp4v: 1,
      mvc1: 1,
      mvc2: 1,
      mvc3: 1,
      mvc4: 1,
      resv: 1,
      rv60: 1,
      s263: 1,
      svc1: 1,
      svc2: 1,
      "vc-1": 1,
      vp08: 1,
      vp09: 0.9
    },
    text: {
      stpp: 1,
      wvtt: 1
    }
  };
  function isCodecType(codec, type) {
    const typeCodes = sampleEntryCodesISO[type];
    return !!typeCodes && !!typeCodes[codec.slice(0, 4)];
  }
  function areCodecsMediaSourceSupported(codecs, type, preferManagedMediaSource = true) {
    return !codecs.split(",").some((codec) => !isCodecMediaSourceSupported(codec, type, preferManagedMediaSource));
  }
  function isCodecMediaSourceSupported(codec, type, preferManagedMediaSource = true) {
    var _MediaSource$isTypeSu;
    const MediaSource = getMediaSource(preferManagedMediaSource);
    return (_MediaSource$isTypeSu = MediaSource == null ? void 0 : MediaSource.isTypeSupported(mimeTypeForCodec(codec, type))) != null ? _MediaSource$isTypeSu : false;
  }
  function mimeTypeForCodec(codec, type) {
    return `${type}/mp4;codecs=${codec}`;
  }
  function videoCodecPreferenceValue(videoCodec) {
    if (videoCodec) {
      const fourCC = videoCodec.substring(0, 4);
      return sampleEntryCodesISO.video[fourCC];
    }
    return 2;
  }
  function codecsSetSelectionPreferenceValue(codecSet) {
    const limitedHevcSupport = userAgentHevcSupportIsInaccurate();
    return codecSet.split(",").reduce((num, fourCC) => {
      const lowerPriority = limitedHevcSupport && isHEVC(fourCC);
      const preferenceValue = lowerPriority ? 9 : sampleEntryCodesISO.video[fourCC];
      if (preferenceValue) {
        return (preferenceValue * 2 + num) / (num ? 3 : 2);
      }
      return (sampleEntryCodesISO.audio[fourCC] + num) / (num ? 2 : 1);
    }, 0);
  }
  var CODEC_COMPATIBLE_NAMES = {};
  function getCodecCompatibleNameLower(lowerCaseCodec, preferManagedMediaSource = true) {
    if (CODEC_COMPATIBLE_NAMES[lowerCaseCodec]) {
      return CODEC_COMPATIBLE_NAMES[lowerCaseCodec];
    }
    const codecsToCheck = {
      // Idealy fLaC and Opus would be first (spec-compliant) but
      // some browsers will report that fLaC is supported then fail.
      // see: https://bugs.chromium.org/p/chromium/issues/detail?id=1422728
      flac: ["flac", "fLaC", "FLAC"],
      opus: ["opus", "Opus"],
      // Replace audio codec info if browser does not support mp4a.40.34,
      // and demuxer can fallback to 'audio/mpeg' or 'audio/mp4;codecs="mp3"'
      "mp4a.40.34": ["mp3"]
    }[lowerCaseCodec];
    for (let i = 0; i < codecsToCheck.length; i++) {
      var _getMediaSource;
      if (isCodecMediaSourceSupported(codecsToCheck[i], "audio", preferManagedMediaSource)) {
        CODEC_COMPATIBLE_NAMES[lowerCaseCodec] = codecsToCheck[i];
        return codecsToCheck[i];
      } else if (codecsToCheck[i] === "mp3" && (_getMediaSource = getMediaSource(preferManagedMediaSource)) != null && _getMediaSource.isTypeSupported("audio/mpeg")) {
        return "";
      }
    }
    return lowerCaseCodec;
  }
  var AUDIO_CODEC_REGEXP = /flac|opus|mp4a\.40\.34/i;
  function getCodecCompatibleName(codec, preferManagedMediaSource = true) {
    return codec.replace(AUDIO_CODEC_REGEXP, (m) => getCodecCompatibleNameLower(m.toLowerCase(), preferManagedMediaSource));
  }
  function replaceVideoCodec(originalCodecs, newVideoCodec) {
    const codecs = [];
    if (originalCodecs) {
      const allCodecs = originalCodecs.split(",");
      for (let i = 0; i < allCodecs.length; i++) {
        if (!isCodecType(allCodecs[i], "video")) {
          codecs.push(allCodecs[i]);
        }
      }
    }
    if (newVideoCodec) {
      codecs.push(newVideoCodec);
    }
    return codecs.join(",");
  }
  function pickMostCompleteCodecName(parsedCodec, levelCodec) {
    if (parsedCodec && (parsedCodec.length > 4 || ["ac-3", "ec-3", "alac", "fLaC", "Opus"].indexOf(parsedCodec) !== -1)) {
      if (isCodecSupportedAsType(parsedCodec, "audio") || isCodecSupportedAsType(parsedCodec, "video")) {
        return parsedCodec;
      }
    }
    if (levelCodec) {
      const levelCodecs = levelCodec.split(",");
      if (levelCodecs.length > 1) {
        if (parsedCodec) {
          for (let i = levelCodecs.length; i--; ) {
            if (levelCodecs[i].substring(0, 4) === parsedCodec.substring(0, 4)) {
              return levelCodecs[i];
            }
          }
        }
        return levelCodecs[0];
      }
    }
    return levelCodec || parsedCodec;
  }
  function isCodecSupportedAsType(codec, type) {
    return isCodecType(codec, type) && isCodecMediaSourceSupported(codec, type);
  }
  function convertAVC1ToAVCOTI(videoCodecs) {
    const codecs = videoCodecs.split(",");
    for (let i = 0; i < codecs.length; i++) {
      const avcdata = codecs[i].split(".");
      if (avcdata.length > 2 && avcdata[0] === "avc1") {
        codecs[i] = `avc1.${parseInt(avcdata[1]).toString(16)}${("000" + parseInt(avcdata[2]).toString(16)).slice(-4)}`;
      }
    }
    return codecs.join(",");
  }
  function fillInMissingAV01Params(videoCodec) {
    if (videoCodec.startsWith("av01.")) {
      const av1params = videoCodec.split(".");
      const placeholders = ["0", "111", "01", "01", "01", "0"];
      for (let i = av1params.length; i > 4 && i < 10; i++) {
        av1params[i] = placeholders[i - 4];
      }
      return av1params.join(".");
    }
    return videoCodec;
  }
  function getM2TSSupportedAudioTypes(preferManagedMediaSource) {
    const MediaSource = getMediaSource(preferManagedMediaSource) || {
      isTypeSupported: () => false
    };
    return {
      mpeg: MediaSource.isTypeSupported("audio/mpeg"),
      mp3: MediaSource.isTypeSupported('audio/mp4; codecs="mp3"'),
      ac3: MediaSource.isTypeSupported('audio/mp4; codecs="ac-3"')
    };
  }
  function getCodecsForMimeType(mimeType) {
    return mimeType.replace(/^.+codecs=["']?([^"']+).*$/, "$1");
  }
  var supportedResult = {
    supported: true,
    powerEfficient: true,
    smooth: true
    // keySystemAccess: null,
  };
  var unsupportedResult = {
    supported: false,
    smooth: false,
    powerEfficient: false
    // keySystemAccess: null,
  };
  var SUPPORTED_INFO_DEFAULT = {
    supported: true,
    configurations: [],
    decodingInfoResults: [supportedResult]
  };
  function getUnsupportedResult(error, configurations) {
    return {
      supported: false,
      configurations,
      decodingInfoResults: [unsupportedResult],
      error
    };
  }
  function requiresMediaCapabilitiesDecodingInfo(level, audioTracksByGroup, currentVideoRange, currentFrameRate, currentBw, audioPreference) {
    const videoCodecs = level.videoCodec;
    const audioGroups = level.audioCodec ? level.audioGroups : null;
    const audioCodecPreference = audioPreference == null ? void 0 : audioPreference.audioCodec;
    const channelsPreference = audioPreference == null ? void 0 : audioPreference.channels;
    const maxChannels = channelsPreference ? parseInt(channelsPreference) : audioCodecPreference ? Infinity : 2;
    let audioChannels = null;
    if (audioGroups != null && audioGroups.length) {
      try {
        if (audioGroups.length === 1 && audioGroups[0]) {
          audioChannels = audioTracksByGroup.groups[audioGroups[0]].channels;
        } else {
          audioChannels = audioGroups.reduce((acc, groupId) => {
            if (groupId) {
              const audioTrackGroup = audioTracksByGroup.groups[groupId];
              if (!audioTrackGroup) {
                throw new Error(`Audio track group ${groupId} not found`);
              }
              Object.keys(audioTrackGroup.channels).forEach((key) => {
                acc[key] = (acc[key] || 0) + audioTrackGroup.channels[key];
              });
            }
            return acc;
          }, {
            2: 0
          });
        }
      } catch (error) {
        return true;
      }
    }
    return videoCodecs !== void 0 && // Force media capabilities check for HEVC to avoid failure on Windows
    (videoCodecs.split(",").some((videoCodec) => isHEVC(videoCodec)) || level.width > 1920 && level.height > 1088 || level.height > 1920 && level.width > 1088 || level.frameRate > Math.max(currentFrameRate, 30) || level.videoRange !== "SDR" && level.videoRange !== currentVideoRange || level.bitrate > Math.max(currentBw, 8e6)) || !!audioChannels && isFiniteNumber(maxChannels) && Object.keys(audioChannels).some((channels) => parseInt(channels) > maxChannels);
  }
  function getMediaDecodingInfoPromise(level, audioTracksByGroup, mediaCapabilities, cache = {}) {
    const videoCodecs = level.videoCodec;
    if (!videoCodecs && !level.audioCodec || !mediaCapabilities) {
      return Promise.resolve(SUPPORTED_INFO_DEFAULT);
    }
    const configurations = [];
    const videoDecodeList = makeVideoConfigurations(level);
    const videoCount = videoDecodeList.length;
    const audioDecodeList = makeAudioConfigurations(level, audioTracksByGroup, videoCount > 0);
    const audioCount = audioDecodeList.length;
    for (let i = videoCount || 1 * audioCount || 1; i--; ) {
      const configuration = {
        type: "media-source"
      };
      if (videoCount) {
        configuration.video = videoDecodeList[i % videoCount];
      }
      if (audioCount) {
        configuration.audio = audioDecodeList[i % audioCount];
        const audioBitrate = configuration.audio.bitrate;
        if (configuration.video && audioBitrate) {
          configuration.video.bitrate -= audioBitrate;
        }
      }
      configurations.push(configuration);
    }
    if (videoCodecs) {
      const ua = navigator.userAgent;
      if (videoCodecs.split(",").some((videoCodec) => isHEVC(videoCodec)) && userAgentHevcSupportIsInaccurate()) {
        return Promise.resolve(getUnsupportedResult(new Error(`Overriding Windows Firefox HEVC MediaCapabilities result based on user-agent string: (${ua})`), configurations));
      }
    }
    return Promise.all(configurations.map((configuration) => {
      const decodingInfoKey = getMediaDecodingInfoKey(configuration);
      return cache[decodingInfoKey] || (cache[decodingInfoKey] = mediaCapabilities.decodingInfo(configuration));
    })).then((decodingInfoResults) => ({
      supported: !decodingInfoResults.some((info) => !info.supported),
      configurations,
      decodingInfoResults
    })).catch((error) => ({
      supported: false,
      configurations,
      decodingInfoResults: [],
      error
    }));
  }
  function makeVideoConfigurations(level) {
    var _level$videoCodec;
    const videoCodecs = (_level$videoCodec = level.videoCodec) == null ? void 0 : _level$videoCodec.split(",");
    const bitrate = getVariantDecodingBitrate(level);
    const width = level.width || 640;
    const height = level.height || 480;
    const framerate = level.frameRate || 30;
    const videoRange = level.videoRange.toLowerCase();
    return videoCodecs ? videoCodecs.map((videoCodec) => {
      const videoConfiguration = {
        contentType: mimeTypeForCodec(fillInMissingAV01Params(videoCodec), "video"),
        width,
        height,
        bitrate,
        framerate
      };
      if (videoRange !== "sdr") {
        videoConfiguration.transferFunction = videoRange;
      }
      return videoConfiguration;
    }) : [];
  }
  function makeAudioConfigurations(level, audioTracksByGroup, hasVideo) {
    var _level$audioCodec;
    const audioCodecs = (_level$audioCodec = level.audioCodec) == null ? void 0 : _level$audioCodec.split(",");
    const combinedBitrate = getVariantDecodingBitrate(level);
    if (audioCodecs && level.audioGroups) {
      return level.audioGroups.reduce((configurations, audioGroupId) => {
        var _audioTracksByGroup$g;
        const tracks = audioGroupId ? (_audioTracksByGroup$g = audioTracksByGroup.groups[audioGroupId]) == null ? void 0 : _audioTracksByGroup$g.tracks : null;
        if (tracks) {
          return tracks.reduce((configs, audioTrack) => {
            if (audioTrack.groupId === audioGroupId) {
              const channelsNumber = parseFloat(audioTrack.channels || "");
              audioCodecs.forEach((audioCodec) => {
                const audioConfiguration = {
                  contentType: mimeTypeForCodec(audioCodec, "audio"),
                  bitrate: hasVideo ? estimatedAudioBitrate(audioCodec, combinedBitrate) : combinedBitrate
                };
                if (channelsNumber) {
                  audioConfiguration.channels = "" + channelsNumber;
                }
                configs.push(audioConfiguration);
              });
            }
            return configs;
          }, configurations);
        }
        return configurations;
      }, []);
    }
    return [];
  }
  function estimatedAudioBitrate(audioCodec, levelBitrate) {
    if (levelBitrate <= 1) {
      return 1;
    }
    let audioBitrate = 128e3;
    if (audioCodec === "ec-3") {
      audioBitrate = 768e3;
    } else if (audioCodec === "ac-3") {
      audioBitrate = 64e4;
    }
    return Math.min(levelBitrate / 2, audioBitrate);
  }
  function getVariantDecodingBitrate(level) {
    return Math.ceil(Math.max(level.bitrate * 0.9, level.averageBitrate) / 1e3) * 1e3 || 1;
  }
  function getMediaDecodingInfoKey(config3) {
    let key = "";
    const {
      audio,
      video
    } = config3;
    if (video) {
      const codec = getCodecsForMimeType(video.contentType);
      key += `${codec}_r${video.height}x${video.width}f${Math.ceil(video.framerate)}${video.transferFunction || "sd"}_${Math.ceil(video.bitrate / 1e5)}`;
    }
    if (audio) {
      const codec = getCodecsForMimeType(audio.contentType);
      key += `${video ? "_" : ""}${codec}_c${audio.channels}`;
    }
    return key;
  }
  var HdcpLevels = ["NONE", "TYPE-0", "TYPE-1", null];
  function isHdcpLevel(value) {
    return HdcpLevels.indexOf(value) > -1;
  }
  var VideoRangeValues = ["SDR", "PQ", "HLG"];
  function isVideoRange(value) {
    return !!value && VideoRangeValues.indexOf(value) > -1;
  }
  var HlsSkip = {
    No: "",
    Yes: "YES",
    v2: "v2"
  };
  function getSkipValue(details) {
    const {
      canSkipUntil,
      canSkipDateRanges,
      age
    } = details;
    const playlistRecentEnough = age < canSkipUntil / 2;
    if (canSkipUntil && playlistRecentEnough) {
      if (canSkipDateRanges) {
        return HlsSkip.v2;
      }
      return HlsSkip.Yes;
    }
    return HlsSkip.No;
  }
  var HlsUrlParameters = class {
    constructor(msn, part, skip) {
      this.msn = void 0;
      this.part = void 0;
      this.skip = void 0;
      this.msn = msn;
      this.part = part;
      this.skip = skip;
    }
    addDirectives(uri) {
      const url = new self.URL(uri);
      if (this.msn !== void 0) {
        url.searchParams.set("_HLS_msn", this.msn.toString());
      }
      if (this.part !== void 0) {
        url.searchParams.set("_HLS_part", this.part.toString());
      }
      if (this.skip) {
        url.searchParams.set("_HLS_skip", this.skip);
      }
      return url.href;
    }
  };
  var Level = class {
    constructor(data) {
      this._attrs = void 0;
      this.audioCodec = void 0;
      this.bitrate = void 0;
      this.codecSet = void 0;
      this.url = void 0;
      this.frameRate = void 0;
      this.height = void 0;
      this.id = void 0;
      this.name = void 0;
      this.supplemental = void 0;
      this.videoCodec = void 0;
      this.width = void 0;
      this.details = void 0;
      this.fragmentError = 0;
      this.loadError = 0;
      this.loaded = void 0;
      this.realBitrate = 0;
      this.supportedPromise = void 0;
      this.supportedResult = void 0;
      this._avgBitrate = 0;
      this._audioGroups = void 0;
      this._subtitleGroups = void 0;
      this._urlId = 0;
      this.url = [data.url];
      this._attrs = [data.attrs];
      this.bitrate = data.bitrate;
      if (data.details) {
        this.details = data.details;
      }
      this.id = data.id || 0;
      this.name = data.name;
      this.width = data.width || 0;
      this.height = data.height || 0;
      this.frameRate = data.attrs.optionalFloat("FRAME-RATE", 0);
      this._avgBitrate = data.attrs.decimalInteger("AVERAGE-BANDWIDTH");
      this.audioCodec = data.audioCodec;
      this.videoCodec = data.videoCodec;
      this.codecSet = [data.videoCodec, data.audioCodec].filter((c) => !!c).map((s) => s.substring(0, 4)).join(",");
      if ("supplemental" in data) {
        var _data$supplemental;
        this.supplemental = data.supplemental;
        const supplementalVideo = (_data$supplemental = data.supplemental) == null ? void 0 : _data$supplemental.videoCodec;
        if (supplementalVideo && supplementalVideo !== data.videoCodec) {
          this.codecSet += `,${supplementalVideo.substring(0, 4)}`;
        }
      }
      this.addGroupId("audio", data.attrs.AUDIO);
      this.addGroupId("text", data.attrs.SUBTITLES);
    }
    get maxBitrate() {
      return Math.max(this.realBitrate, this.bitrate);
    }
    get averageBitrate() {
      return this._avgBitrate || this.realBitrate || this.bitrate;
    }
    get attrs() {
      return this._attrs[0];
    }
    get codecs() {
      return this.attrs.CODECS || "";
    }
    get pathwayId() {
      return this.attrs["PATHWAY-ID"] || ".";
    }
    get videoRange() {
      return this.attrs["VIDEO-RANGE"] || "SDR";
    }
    get score() {
      return this.attrs.optionalFloat("SCORE", 0);
    }
    get uri() {
      return this.url[0] || "";
    }
    hasAudioGroup(groupId) {
      return hasGroup(this._audioGroups, groupId);
    }
    hasSubtitleGroup(groupId) {
      return hasGroup(this._subtitleGroups, groupId);
    }
    get audioGroups() {
      return this._audioGroups;
    }
    get subtitleGroups() {
      return this._subtitleGroups;
    }
    addGroupId(type, groupId) {
      if (!groupId) {
        return;
      }
      if (type === "audio") {
        let audioGroups = this._audioGroups;
        if (!audioGroups) {
          audioGroups = this._audioGroups = [];
        }
        if (audioGroups.indexOf(groupId) === -1) {
          audioGroups.push(groupId);
        }
      } else if (type === "text") {
        let subtitleGroups = this._subtitleGroups;
        if (!subtitleGroups) {
          subtitleGroups = this._subtitleGroups = [];
        }
        if (subtitleGroups.indexOf(groupId) === -1) {
          subtitleGroups.push(groupId);
        }
      }
    }
    // Deprecated methods (retained for backwards compatibility)
    get urlId() {
      return 0;
    }
    set urlId(value) {
    }
    get audioGroupIds() {
      return this.audioGroups ? [this.audioGroupId] : void 0;
    }
    get textGroupIds() {
      return this.subtitleGroups ? [this.textGroupId] : void 0;
    }
    get audioGroupId() {
      var _this$audioGroups;
      return (_this$audioGroups = this.audioGroups) == null ? void 0 : _this$audioGroups[0];
    }
    get textGroupId() {
      var _this$subtitleGroups;
      return (_this$subtitleGroups = this.subtitleGroups) == null ? void 0 : _this$subtitleGroups[0];
    }
    addFallback() {
    }
  };
  function hasGroup(groups, groupId) {
    if (!groupId || !groups) {
      return false;
    }
    return groups.indexOf(groupId) !== -1;
  }
  function isHdrSupported() {
    if (typeof matchMedia === "function") {
      const mediaQueryList = matchMedia("(dynamic-range: high)");
      const badQuery = matchMedia("bad query");
      if (mediaQueryList.media !== badQuery.media) {
        return mediaQueryList.matches === true;
      }
    }
    return false;
  }
  function getVideoSelectionOptions(currentVideoRange, videoPreference) {
    let preferHDR = false;
    let allowedVideoRanges = [];
    if (currentVideoRange) {
      preferHDR = currentVideoRange !== "SDR";
      allowedVideoRanges = [currentVideoRange];
    }
    if (videoPreference) {
      allowedVideoRanges = videoPreference.allowedVideoRanges || VideoRangeValues.slice(0);
      const allowAutoPreferHDR = allowedVideoRanges.join("") !== "SDR" && !videoPreference.videoCodec;
      preferHDR = videoPreference.preferHDR !== void 0 ? videoPreference.preferHDR : allowAutoPreferHDR && isHdrSupported();
      if (!preferHDR) {
        allowedVideoRanges = ["SDR"];
      }
    }
    return {
      preferHDR,
      allowedVideoRanges
    };
  }
  var omitCircularRefsReplacer = (replacer) => {
    const known = /* @__PURE__ */ new WeakSet();
    return (_, value) => {
      if (replacer) {
        value = replacer(_, value);
      }
      if (typeof value === "object" && value !== null) {
        if (known.has(value)) {
          return;
        }
        known.add(value);
      }
      return value;
    };
  };
  var stringify = (object, replacer) => JSON.stringify(object, omitCircularRefsReplacer(replacer));
  function getStartCodecTier(codecTiers, currentVideoRange, currentBw, audioPreference, videoPreference) {
    const codecSets = Object.keys(codecTiers);
    const channelsPreference = audioPreference == null ? void 0 : audioPreference.channels;
    const audioCodecPreference = audioPreference == null ? void 0 : audioPreference.audioCodec;
    const videoCodecPreference = videoPreference == null ? void 0 : videoPreference.videoCodec;
    const preferStereo = channelsPreference && parseInt(channelsPreference) === 2;
    let hasStereo = false;
    let hasCurrentVideoRange = false;
    let minHeight = Infinity;
    let minFramerate = Infinity;
    let minBitrate = Infinity;
    let minIndex = Infinity;
    let selectedScore = 0;
    let videoRanges = [];
    const {
      preferHDR,
      allowedVideoRanges
    } = getVideoSelectionOptions(currentVideoRange, videoPreference);
    for (let i = codecSets.length; i--; ) {
      const tier = codecTiers[codecSets[i]];
      hasStereo || (hasStereo = tier.channels[2] > 0);
      minHeight = Math.min(minHeight, tier.minHeight);
      minFramerate = Math.min(minFramerate, tier.minFramerate);
      minBitrate = Math.min(minBitrate, tier.minBitrate);
      const matchingVideoRanges = allowedVideoRanges.filter((range) => tier.videoRanges[range] > 0);
      if (matchingVideoRanges.length > 0) {
        hasCurrentVideoRange = true;
      }
    }
    minHeight = isFiniteNumber(minHeight) ? minHeight : 0;
    minFramerate = isFiniteNumber(minFramerate) ? minFramerate : 0;
    const maxHeight = Math.max(1080, minHeight);
    const maxFramerate = Math.max(30, minFramerate);
    minBitrate = isFiniteNumber(minBitrate) ? minBitrate : currentBw;
    currentBw = Math.max(minBitrate, currentBw);
    if (!hasCurrentVideoRange) {
      currentVideoRange = void 0;
    }
    const hasMultipleSets = codecSets.length > 1;
    const codecSet = codecSets.reduce((selected, candidate) => {
      const candidateTier = codecTiers[candidate];
      if (candidate === selected) {
        return selected;
      }
      videoRanges = hasCurrentVideoRange ? allowedVideoRanges.filter((range) => candidateTier.videoRanges[range] > 0) : [];
      if (hasMultipleSets) {
        if (candidateTier.minBitrate > currentBw) {
          logStartCodecCandidateIgnored(candidate, `min bitrate of ${candidateTier.minBitrate} > current estimate of ${currentBw}`);
          return selected;
        }
        if (!candidateTier.hasDefaultAudio) {
          logStartCodecCandidateIgnored(candidate, `no renditions with default or auto-select sound found`);
          return selected;
        }
        if (audioCodecPreference && candidate.indexOf(audioCodecPreference.substring(0, 4)) % 5 !== 0) {
          logStartCodecCandidateIgnored(candidate, `audio codec preference "${audioCodecPreference}" not found`);
          return selected;
        }
        if (channelsPreference && !preferStereo) {
          if (!candidateTier.channels[channelsPreference]) {
            logStartCodecCandidateIgnored(candidate, `no renditions with ${channelsPreference} channel sound found (channels options: ${Object.keys(candidateTier.channels)})`);
            return selected;
          }
        } else if ((!audioCodecPreference || preferStereo) && hasStereo && candidateTier.channels["2"] === 0) {
          logStartCodecCandidateIgnored(candidate, `no renditions with stereo sound found`);
          return selected;
        }
        if (candidateTier.minHeight > maxHeight) {
          logStartCodecCandidateIgnored(candidate, `min resolution of ${candidateTier.minHeight} > maximum of ${maxHeight}`);
          return selected;
        }
        if (candidateTier.minFramerate > maxFramerate) {
          logStartCodecCandidateIgnored(candidate, `min framerate of ${candidateTier.minFramerate} > maximum of ${maxFramerate}`);
          return selected;
        }
        if (!videoRanges.some((range) => candidateTier.videoRanges[range] > 0)) {
          logStartCodecCandidateIgnored(candidate, `no variants with VIDEO-RANGE of ${stringify(videoRanges)} found`);
          return selected;
        }
        if (videoCodecPreference && candidate.indexOf(videoCodecPreference.substring(0, 4)) % 5 !== 0) {
          logStartCodecCandidateIgnored(candidate, `video codec preference "${videoCodecPreference}" not found`);
          return selected;
        }
        if (candidateTier.maxScore < selectedScore) {
          logStartCodecCandidateIgnored(candidate, `max score of ${candidateTier.maxScore} < selected max of ${selectedScore}`);
          return selected;
        }
      }
      if (selected && (codecsSetSelectionPreferenceValue(candidate) >= codecsSetSelectionPreferenceValue(selected) || candidateTier.fragmentError > codecTiers[selected].fragmentError)) {
        return selected;
      }
      minIndex = candidateTier.minIndex;
      selectedScore = candidateTier.maxScore;
      return candidate;
    }, void 0);
    return {
      codecSet,
      videoRanges,
      preferHDR,
      minFramerate,
      minBitrate,
      minIndex
    };
  }
  function logStartCodecCandidateIgnored(codeSet, reason) {
    logger.log(`[abr] start candidates with "${codeSet}" ignored because ${reason}`);
  }
  function getAudioTracksByGroup(allAudioTracks) {
    return allAudioTracks.reduce((audioTracksByGroup, track) => {
      let trackGroup = audioTracksByGroup.groups[track.groupId];
      if (!trackGroup) {
        trackGroup = audioTracksByGroup.groups[track.groupId] = {
          tracks: [],
          channels: {
            2: 0
          },
          hasDefault: false,
          hasAutoSelect: false
        };
      }
      trackGroup.tracks.push(track);
      const channelsKey = track.channels || "2";
      trackGroup.channels[channelsKey] = (trackGroup.channels[channelsKey] || 0) + 1;
      trackGroup.hasDefault = trackGroup.hasDefault || track.default;
      trackGroup.hasAutoSelect = trackGroup.hasAutoSelect || track.autoselect;
      if (trackGroup.hasDefault) {
        audioTracksByGroup.hasDefaultAudio = true;
      }
      if (trackGroup.hasAutoSelect) {
        audioTracksByGroup.hasAutoSelectAudio = true;
      }
      return audioTracksByGroup;
    }, {
      hasDefaultAudio: false,
      hasAutoSelectAudio: false,
      groups: {}
    });
  }
  function getCodecTiers(levels, audioTracksByGroup, minAutoLevel, maxAutoLevel) {
    return levels.slice(minAutoLevel, maxAutoLevel + 1).reduce((tiers, level, index) => {
      if (!level.codecSet) {
        return tiers;
      }
      const audioGroups = level.audioGroups;
      let tier = tiers[level.codecSet];
      if (!tier) {
        tiers[level.codecSet] = tier = {
          minBitrate: Infinity,
          minHeight: Infinity,
          minFramerate: Infinity,
          minIndex: index,
          maxScore: 0,
          videoRanges: {
            SDR: 0
          },
          channels: {
            "2": 0
          },
          hasDefaultAudio: !audioGroups,
          fragmentError: 0
        };
      }
      tier.minBitrate = Math.min(tier.minBitrate, level.bitrate);
      const lesserWidthOrHeight = Math.min(level.height, level.width);
      tier.minHeight = Math.min(tier.minHeight, lesserWidthOrHeight);
      tier.minFramerate = Math.min(tier.minFramerate, level.frameRate);
      tier.minIndex = Math.min(tier.minIndex, index);
      tier.maxScore = Math.max(tier.maxScore, level.score);
      tier.fragmentError += level.fragmentError;
      tier.videoRanges[level.videoRange] = (tier.videoRanges[level.videoRange] || 0) + 1;
      if (audioGroups) {
        audioGroups.forEach((audioGroupId) => {
          if (!audioGroupId) {
            return;
          }
          const audioGroup = audioTracksByGroup.groups[audioGroupId];
          if (!audioGroup) {
            return;
          }
          tier.hasDefaultAudio = tier.hasDefaultAudio || audioTracksByGroup.hasDefaultAudio ? audioGroup.hasDefault : audioGroup.hasAutoSelect || !audioTracksByGroup.hasDefaultAudio && !audioTracksByGroup.hasAutoSelectAudio;
          Object.keys(audioGroup.channels).forEach((channels) => {
            tier.channels[channels] = (tier.channels[channels] || 0) + audioGroup.channels[channels];
          });
        });
      }
      return tiers;
    }, {});
  }
  function getBasicSelectionOption(option) {
    if (!option) {
      return option;
    }
    const {
      lang,
      assocLang,
      characteristics,
      channels,
      audioCodec
    } = option;
    return {
      lang,
      assocLang,
      characteristics,
      channels,
      audioCodec
    };
  }
  function findMatchingOption(option, tracks, matchPredicate) {
    if ("attrs" in option) {
      const index = tracks.indexOf(option);
      if (index !== -1) {
        return index;
      }
    }
    for (let i = 0; i < tracks.length; i++) {
      const track = tracks[i];
      if (matchesOption(option, track, matchPredicate)) {
        return i;
      }
    }
    return -1;
  }
  function matchesOption(option, track, matchPredicate) {
    const {
      groupId,
      name,
      lang,
      assocLang,
      default: isDefault
    } = option;
    const forced = option.forced;
    return (groupId === void 0 || track.groupId === groupId) && (name === void 0 || track.name === name) && (lang === void 0 || languagesMatch(lang, track.lang)) && (lang === void 0 || track.assocLang === assocLang) && (isDefault === void 0 || track.default === isDefault) && (forced === void 0 || track.forced === forced) && (!("characteristics" in option) || characteristicsMatch(option.characteristics || "", track.characteristics)) && (matchPredicate === void 0 || matchPredicate(option, track));
  }
  function languagesMatch(languageA, languageB = "--") {
    if (languageA.length === languageB.length) {
      return languageA === languageB;
    }
    return languageA.startsWith(languageB) || languageB.startsWith(languageA);
  }
  function characteristicsMatch(characteristicsA, characteristicsB = "") {
    const arrA = characteristicsA.split(",");
    const arrB = characteristicsB.split(",");
    return arrA.length === arrB.length && !arrA.some((el) => arrB.indexOf(el) === -1);
  }
  function audioMatchPredicate(option, track) {
    const {
      audioCodec,
      channels
    } = option;
    return (audioCodec === void 0 || (track.audioCodec || "").substring(0, 4) === audioCodec.substring(0, 4)) && (channels === void 0 || channels === (track.channels || "2"));
  }
  function findClosestLevelWithAudioGroup(option, levels, allAudioTracks, searchIndex, matchPredicate) {
    const currentLevel = levels[searchIndex];
    const variants = levels.reduce((variantMap, level, index) => {
      const uri = level.uri;
      const renditions2 = variantMap[uri] || (variantMap[uri] = []);
      renditions2.push(index);
      return variantMap;
    }, {});
    const renditions = variants[currentLevel.uri];
    if (renditions.length > 1) {
      searchIndex = Math.max.apply(Math, renditions);
    }
    const currentVideoRange = currentLevel.videoRange;
    const currentFrameRate = currentLevel.frameRate;
    const currentVideoCodec = currentLevel.codecSet.substring(0, 4);
    const matchingVideo = searchDownAndUpList(levels, searchIndex, (level) => {
      if (level.videoRange !== currentVideoRange || level.frameRate !== currentFrameRate || level.codecSet.substring(0, 4) !== currentVideoCodec) {
        return false;
      }
      const audioGroups = level.audioGroups;
      const tracks = allAudioTracks.filter((track) => !audioGroups || audioGroups.indexOf(track.groupId) !== -1);
      return findMatchingOption(option, tracks, matchPredicate) > -1;
    });
    if (matchingVideo > -1) {
      return matchingVideo;
    }
    return searchDownAndUpList(levels, searchIndex, (level) => {
      const audioGroups = level.audioGroups;
      const tracks = allAudioTracks.filter((track) => !audioGroups || audioGroups.indexOf(track.groupId) !== -1);
      return findMatchingOption(option, tracks, matchPredicate) > -1;
    });
  }
  function searchDownAndUpList(arr, searchIndex, predicate) {
    for (let i = searchIndex; i > -1; i--) {
      if (predicate(arr[i])) {
        return i;
      }
    }
    for (let i = searchIndex + 1; i < arr.length; i++) {
      if (predicate(arr[i])) {
        return i;
      }
    }
    return -1;
  }
  function useAlternateAudio(audioTrackUrl, hls) {
    var _hls$loadLevelObj;
    return !!audioTrackUrl && audioTrackUrl !== ((_hls$loadLevelObj = hls.loadLevelObj) == null ? void 0 : _hls$loadLevelObj.uri);
  }
  var AbrController = class extends Logger {
    constructor(_hls) {
      super("abr", _hls.logger);
      this.hls = void 0;
      this.lastLevelLoadSec = 0;
      this.lastLoadedFragLevel = -1;
      this.firstSelection = -1;
      this._nextAutoLevel = -1;
      this.nextAutoLevelKey = "";
      this.audioTracksByGroup = null;
      this.codecTiers = null;
      this.timer = -1;
      this.fragCurrent = null;
      this.partCurrent = null;
      this.bitrateTestDelay = 0;
      this.rebufferNotice = -1;
      this.supportedCache = {};
      this.bwEstimator = void 0;
      this._abandonRulesCheck = (levelLoaded) => {
        var _ref;
        const {
          fragCurrent: frag,
          partCurrent: part,
          hls
        } = this;
        const {
          autoLevelEnabled,
          media
        } = hls;
        if (!frag || !media) {
          return;
        }
        const now3 = performance.now();
        const stats = part ? part.stats : frag.stats;
        const duration = part ? part.duration : frag.duration;
        const timeLoading = now3 - stats.loading.start;
        const minAutoLevel = hls.minAutoLevel;
        const loadingFragForLevel = frag.level;
        const currentAutoLevel = this._nextAutoLevel;
        if (stats.aborted || stats.loaded && stats.loaded === stats.total || loadingFragForLevel <= minAutoLevel) {
          this.clearTimer();
          this._nextAutoLevel = -1;
          return;
        }
        if (!autoLevelEnabled) {
          return;
        }
        const fragBlockingSwitch = currentAutoLevel > -1 && currentAutoLevel !== loadingFragForLevel;
        const levelChange = !!levelLoaded || fragBlockingSwitch;
        if (!levelChange && (media.paused || !media.playbackRate || !media.readyState)) {
          return;
        }
        const bufferInfo = hls.mainForwardBufferInfo;
        if (!levelChange && bufferInfo === null) {
          return;
        }
        const ttfbEstimate = this.bwEstimator.getEstimateTTFB();
        const playbackRate = Math.abs(media.playbackRate);
        if (timeLoading <= Math.max(ttfbEstimate, 1e3 * (duration / (playbackRate * 2)))) {
          return;
        }
        const bufferStarvationDelay = bufferInfo ? bufferInfo.len / playbackRate : 0;
        const ttfb = stats.loading.first ? stats.loading.first - stats.loading.start : -1;
        const loadedFirstByte = stats.loaded && ttfb > -1;
        const bwEstimate = this.getBwEstimate();
        const levels = hls.levels;
        const level = levels[loadingFragForLevel];
        const expectedLen = Math.max(stats.loaded, Math.round(duration * (frag.bitrate || level.averageBitrate) / 8));
        let timeStreaming = loadedFirstByte ? timeLoading - ttfb : timeLoading;
        if (timeStreaming < 1 && loadedFirstByte) {
          timeStreaming = Math.min(timeLoading, stats.loaded * 8 / bwEstimate);
        }
        const loadRate = loadedFirstByte ? stats.loaded * 1e3 / timeStreaming : 0;
        const ttfbSeconds = ttfbEstimate / 1e3;
        const fragLoadedDelay = loadRate ? (expectedLen - stats.loaded) / loadRate : expectedLen * 8 / bwEstimate + ttfbSeconds;
        if (fragLoadedDelay <= bufferStarvationDelay) {
          return;
        }
        const bwe = loadRate ? loadRate * 8 : bwEstimate;
        const live = ((_ref = (levelLoaded == null ? void 0 : levelLoaded.details) || this.hls.latestLevelDetails) == null ? void 0 : _ref.live) === true;
        const abrBandWidthUpFactor = this.hls.config.abrBandWidthUpFactor;
        let fragLevelNextLoadedDelay = Number.POSITIVE_INFINITY;
        let nextLoadLevel;
        for (nextLoadLevel = loadingFragForLevel - 1; nextLoadLevel > minAutoLevel; nextLoadLevel--) {
          const levelNextBitrate = levels[nextLoadLevel].maxBitrate;
          const requiresLevelLoad = !levels[nextLoadLevel].details || live;
          fragLevelNextLoadedDelay = this.getTimeToLoadFrag(ttfbSeconds, bwe, duration * levelNextBitrate, requiresLevelLoad);
          if (fragLevelNextLoadedDelay < Math.min(bufferStarvationDelay, duration + ttfbSeconds)) {
            break;
          }
        }
        if (fragLevelNextLoadedDelay >= fragLoadedDelay) {
          return;
        }
        if (fragLevelNextLoadedDelay > duration * 10) {
          return;
        }
        if (loadedFirstByte) {
          this.bwEstimator.sample(timeLoading - Math.min(ttfbEstimate, ttfb), stats.loaded);
        } else {
          this.bwEstimator.sampleTTFB(timeLoading);
        }
        const nextLoadLevelBitrate = levels[nextLoadLevel].maxBitrate;
        if (this.getBwEstimate() * abrBandWidthUpFactor > nextLoadLevelBitrate) {
          this.resetEstimator(nextLoadLevelBitrate);
        }
        const bestSwitchLevel = this.findBestLevel(nextLoadLevelBitrate, minAutoLevel, nextLoadLevel, 0, bufferStarvationDelay, 1, 1);
        if (bestSwitchLevel > -1) {
          nextLoadLevel = bestSwitchLevel;
        }
        this.warn(`Fragment ${frag.sn}${part ? " part " + part.index : ""} of level ${loadingFragForLevel} is loading too slowly;
      Fragment duration: ${frag.duration.toFixed(3)}
      Time to underbuffer: ${bufferStarvationDelay.toFixed(3)} s
      Estimated load time for current fragment: ${fragLoadedDelay.toFixed(3)} s
      Estimated load time for down switch fragment: ${fragLevelNextLoadedDelay.toFixed(3)} s
      TTFB estimate: ${ttfb | 0} ms
      Current BW estimate: ${isFiniteNumber(bwEstimate) ? bwEstimate | 0 : "Unknown"} bps
      New BW estimate: ${this.getBwEstimate() | 0} bps
      Switching to level ${nextLoadLevel} @ ${nextLoadLevelBitrate | 0} bps`);
        hls.nextLoadLevel = hls.nextAutoLevel = nextLoadLevel;
        this.clearTimer();
        const abortAndSwitch = () => {
          this.clearTimer();
          if (this.fragCurrent === frag && this.hls.loadLevel === nextLoadLevel && nextLoadLevel > 0) {
            const bufferStarvationDelay2 = this.getStarvationDelay();
            this.warn(`Aborting inflight request ${nextLoadLevel > 0 ? "and switching down" : ""}
      Fragment duration: ${frag.duration.toFixed(3)} s
      Time to underbuffer: ${bufferStarvationDelay2.toFixed(3)} s`);
            frag.abortRequests();
            this.fragCurrent = this.partCurrent = null;
            if (nextLoadLevel > minAutoLevel) {
              let lowestSwitchLevel = this.findBestLevel(this.hls.levels[minAutoLevel].bitrate, minAutoLevel, nextLoadLevel, 0, bufferStarvationDelay2, 1, 1);
              if (lowestSwitchLevel === -1) {
                lowestSwitchLevel = minAutoLevel;
              }
              this.hls.nextLoadLevel = this.hls.nextAutoLevel = lowestSwitchLevel;
              this.resetEstimator(this.hls.levels[lowestSwitchLevel].bitrate);
            }
          }
        };
        if (fragBlockingSwitch || fragLoadedDelay > fragLevelNextLoadedDelay * 2) {
          abortAndSwitch();
        } else {
          this.timer = self.setInterval(abortAndSwitch, fragLevelNextLoadedDelay * 1e3);
        }
        hls.trigger(Events.FRAG_LOAD_EMERGENCY_ABORTED, {
          frag,
          part,
          stats
        });
      };
      this.hls = _hls;
      this.bwEstimator = this.initEstimator();
      this.registerListeners();
    }
    resetEstimator(abrEwmaDefaultEstimate) {
      if (abrEwmaDefaultEstimate) {
        this.log(`setting initial bwe to ${abrEwmaDefaultEstimate}`);
        this.hls.config.abrEwmaDefaultEstimate = abrEwmaDefaultEstimate;
      }
      this.firstSelection = -1;
      this.bwEstimator = this.initEstimator();
    }
    initEstimator() {
      const config3 = this.hls.config;
      return new EwmaBandWidthEstimator(config3.abrEwmaSlowVoD, config3.abrEwmaFastVoD, config3.abrEwmaDefaultEstimate);
    }
    registerListeners() {
      const {
        hls
      } = this;
      hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.on(Events.FRAG_LOADING, this.onFragLoading, this);
      hls.on(Events.FRAG_LOADED, this.onFragLoaded, this);
      hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);
      hls.on(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);
      hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);
      hls.on(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);
      hls.on(Events.MAX_AUTO_LEVEL_UPDATED, this.onMaxAutoLevelUpdated, this);
      hls.on(Events.ERROR, this.onError, this);
    }
    unregisterListeners() {
      const {
        hls
      } = this;
      if (!hls) {
        return;
      }
      hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.off(Events.FRAG_LOADING, this.onFragLoading, this);
      hls.off(Events.FRAG_LOADED, this.onFragLoaded, this);
      hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);
      hls.off(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);
      hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);
      hls.off(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);
      hls.off(Events.MAX_AUTO_LEVEL_UPDATED, this.onMaxAutoLevelUpdated, this);
      hls.off(Events.ERROR, this.onError, this);
    }
    destroy() {
      this.unregisterListeners();
      this.clearTimer();
      this.hls = this._abandonRulesCheck = this.supportedCache = null;
      this.fragCurrent = this.partCurrent = null;
    }
    onManifestLoading(event, data) {
      this.lastLoadedFragLevel = -1;
      this.firstSelection = -1;
      this.lastLevelLoadSec = 0;
      this.supportedCache = {};
      this.fragCurrent = this.partCurrent = null;
      this.onLevelsUpdated();
      this.clearTimer();
    }
    onLevelsUpdated() {
      if (this.lastLoadedFragLevel > -1 && this.fragCurrent) {
        this.lastLoadedFragLevel = this.fragCurrent.level;
      }
      this._nextAutoLevel = -1;
      this.onMaxAutoLevelUpdated();
      this.codecTiers = null;
      this.audioTracksByGroup = null;
    }
    onMaxAutoLevelUpdated() {
      this.firstSelection = -1;
      this.nextAutoLevelKey = "";
    }
    onFragLoading(event, data) {
      const frag = data.frag;
      if (this.ignoreFragment(frag)) {
        return;
      }
      if (!frag.bitrateTest) {
        var _data$part;
        this.fragCurrent = frag;
        this.partCurrent = (_data$part = data.part) != null ? _data$part : null;
      }
      this.clearTimer();
      this.timer = self.setInterval(this._abandonRulesCheck, 100);
    }
    onLevelSwitching(event, data) {
      this.clearTimer();
    }
    onError(event, data) {
      if (data.fatal) {
        return;
      }
      switch (data.details) {
        case ErrorDetails.BUFFER_ADD_CODEC_ERROR:
        case ErrorDetails.BUFFER_APPEND_ERROR:
          this.lastLoadedFragLevel = -1;
          this.firstSelection = -1;
          break;
        case ErrorDetails.FRAG_LOAD_TIMEOUT: {
          const frag = data.frag;
          const {
            fragCurrent,
            partCurrent: part
          } = this;
          if (frag && fragCurrent && frag.sn === fragCurrent.sn && frag.level === fragCurrent.level) {
            const now3 = performance.now();
            const stats = part ? part.stats : frag.stats;
            const timeLoading = now3 - stats.loading.start;
            const ttfb = stats.loading.first ? stats.loading.first - stats.loading.start : -1;
            const loadedFirstByte = stats.loaded && ttfb > -1;
            if (loadedFirstByte) {
              const ttfbEstimate = this.bwEstimator.getEstimateTTFB();
              this.bwEstimator.sample(timeLoading - Math.min(ttfbEstimate, ttfb), stats.loaded);
            } else {
              this.bwEstimator.sampleTTFB(timeLoading);
            }
          }
          break;
        }
      }
    }
    getTimeToLoadFrag(timeToFirstByteSec, bandwidth, fragSizeBits, isSwitch) {
      const fragLoadSec = timeToFirstByteSec + fragSizeBits / bandwidth;
      const playlistLoadSec = isSwitch ? timeToFirstByteSec + this.lastLevelLoadSec : 0;
      return fragLoadSec + playlistLoadSec;
    }
    onLevelLoaded(event, data) {
      const config3 = this.hls.config;
      const {
        loading
      } = data.stats;
      const timeLoadingMs = loading.end - loading.first;
      if (isFiniteNumber(timeLoadingMs)) {
        this.lastLevelLoadSec = timeLoadingMs / 1e3;
      }
      if (data.details.live) {
        this.bwEstimator.update(config3.abrEwmaSlowLive, config3.abrEwmaFastLive);
      } else {
        this.bwEstimator.update(config3.abrEwmaSlowVoD, config3.abrEwmaFastVoD);
      }
      if (this.timer > -1) {
        this._abandonRulesCheck(data.levelInfo);
      }
    }
    onFragLoaded(event, {
      frag,
      part
    }) {
      const stats = part ? part.stats : frag.stats;
      if (frag.type === PlaylistLevelType.MAIN) {
        this.bwEstimator.sampleTTFB(stats.loading.first - stats.loading.start);
      }
      if (this.ignoreFragment(frag)) {
        return;
      }
      this.clearTimer();
      if (frag.level === this._nextAutoLevel) {
        this._nextAutoLevel = -1;
      }
      this.firstSelection = -1;
      if (this.hls.config.abrMaxWithRealBitrate) {
        const duration = part ? part.duration : frag.duration;
        const level = this.hls.levels[frag.level];
        const loadedBytes = (level.loaded ? level.loaded.bytes : 0) + stats.loaded;
        const loadedDuration = (level.loaded ? level.loaded.duration : 0) + duration;
        level.loaded = {
          bytes: loadedBytes,
          duration: loadedDuration
        };
        level.realBitrate = Math.round(8 * loadedBytes / loadedDuration);
      }
      if (frag.bitrateTest) {
        const fragBufferedData = {
          stats,
          frag,
          part,
          id: frag.type
        };
        this.onFragBuffered(Events.FRAG_BUFFERED, fragBufferedData);
        frag.bitrateTest = false;
      } else {
        this.lastLoadedFragLevel = frag.level;
      }
    }
    onFragBuffered(event, data) {
      const {
        frag,
        part
      } = data;
      const stats = part != null && part.stats.loaded ? part.stats : frag.stats;
      if (stats.aborted) {
        return;
      }
      if (this.ignoreFragment(frag)) {
        return;
      }
      const processingMs = stats.parsing.end - stats.loading.start - Math.min(stats.loading.first - stats.loading.start, this.bwEstimator.getEstimateTTFB());
      this.bwEstimator.sample(processingMs, stats.loaded);
      stats.bwEstimate = this.getBwEstimate();
      if (frag.bitrateTest) {
        this.bitrateTestDelay = processingMs / 1e3;
      } else {
        this.bitrateTestDelay = 0;
      }
    }
    ignoreFragment(frag) {
      return frag.type !== PlaylistLevelType.MAIN || frag.sn === "initSegment";
    }
    clearTimer() {
      if (this.timer > -1) {
        self.clearInterval(this.timer);
        this.timer = -1;
      }
    }
    get firstAutoLevel() {
      const {
        maxAutoLevel,
        minAutoLevel
      } = this.hls;
      const bwEstimate = this.getBwEstimate();
      const maxStartDelay = this.hls.config.maxStarvationDelay;
      const abrAutoLevel = this.findBestLevel(bwEstimate, minAutoLevel, maxAutoLevel, 0, maxStartDelay, 1, 1);
      if (abrAutoLevel > -1) {
        return abrAutoLevel;
      }
      const firstLevel = this.hls.firstLevel;
      const clamped = Math.min(Math.max(firstLevel, minAutoLevel), maxAutoLevel);
      this.warn(`Could not find best starting auto level. Defaulting to first in playlist ${firstLevel} clamped to ${clamped}`);
      return clamped;
    }
    get forcedAutoLevel() {
      if (this.nextAutoLevelKey) {
        return -1;
      }
      return this._nextAutoLevel;
    }
    // return next auto level
    get nextAutoLevel() {
      const forcedAutoLevel = this.forcedAutoLevel;
      const bwEstimator = this.bwEstimator;
      const useEstimate = bwEstimator.canEstimate();
      const loadedFirstFrag = this.lastLoadedFragLevel > -1;
      if (forcedAutoLevel !== -1 && (!useEstimate || !loadedFirstFrag || this.nextAutoLevelKey === this.getAutoLevelKey())) {
        return forcedAutoLevel;
      }
      const nextABRAutoLevel = useEstimate && loadedFirstFrag ? this.getNextABRAutoLevel() : this.firstAutoLevel;
      if (forcedAutoLevel !== -1) {
        const levels = this.hls.levels;
        if (levels.length > Math.max(forcedAutoLevel, nextABRAutoLevel) && levels[forcedAutoLevel].loadError <= levels[nextABRAutoLevel].loadError) {
          return forcedAutoLevel;
        }
      }
      this._nextAutoLevel = nextABRAutoLevel;
      this.nextAutoLevelKey = this.getAutoLevelKey();
      return nextABRAutoLevel;
    }
    getAutoLevelKey() {
      return `${this.getBwEstimate()}_${this.getStarvationDelay().toFixed(2)}`;
    }
    getNextABRAutoLevel() {
      const {
        fragCurrent,
        partCurrent,
        hls
      } = this;
      if (hls.levels.length <= 1) {
        return hls.loadLevel;
      }
      const {
        maxAutoLevel,
        config: config3,
        minAutoLevel
      } = hls;
      const currentFragDuration = partCurrent ? partCurrent.duration : fragCurrent ? fragCurrent.duration : 0;
      const avgbw = this.getBwEstimate();
      const bufferStarvationDelay = this.getStarvationDelay();
      let bwFactor = config3.abrBandWidthFactor;
      let bwUpFactor = config3.abrBandWidthUpFactor;
      if (bufferStarvationDelay) {
        const _bestLevel = this.findBestLevel(avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay, 0, bwFactor, bwUpFactor);
        if (_bestLevel >= 0) {
          this.rebufferNotice = -1;
          return _bestLevel;
        }
      }
      let maxStarvationDelay = currentFragDuration ? Math.min(currentFragDuration, config3.maxStarvationDelay) : config3.maxStarvationDelay;
      if (!bufferStarvationDelay) {
        const bitrateTestDelay = this.bitrateTestDelay;
        if (bitrateTestDelay) {
          const maxLoadingDelay = currentFragDuration ? Math.min(currentFragDuration, config3.maxLoadingDelay) : config3.maxLoadingDelay;
          maxStarvationDelay = maxLoadingDelay - bitrateTestDelay;
          this.info(`bitrate test took ${Math.round(1e3 * bitrateTestDelay)}ms, set first fragment max fetchDuration to ${Math.round(1e3 * maxStarvationDelay)} ms`);
          bwFactor = bwUpFactor = 1;
        }
      }
      const bestLevel = this.findBestLevel(avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay, maxStarvationDelay, bwFactor, bwUpFactor);
      if (this.rebufferNotice !== bestLevel) {
        this.rebufferNotice = bestLevel;
        this.info(`${bufferStarvationDelay ? "rebuffering expected" : "buffer is empty"}, optimal quality level ${bestLevel}`);
      }
      if (bestLevel > -1) {
        return bestLevel;
      }
      const minLevel = hls.levels[minAutoLevel];
      const autoLevel = hls.loadLevelObj;
      if (autoLevel && (minLevel == null ? void 0 : minLevel.bitrate) < autoLevel.bitrate) {
        return minAutoLevel;
      }
      return hls.loadLevel;
    }
    getStarvationDelay() {
      const hls = this.hls;
      const media = hls.media;
      if (!media) {
        return Infinity;
      }
      const playbackRate = media && media.playbackRate !== 0 ? Math.abs(media.playbackRate) : 1;
      const bufferInfo = hls.mainForwardBufferInfo;
      return (bufferInfo ? bufferInfo.len : 0) / playbackRate;
    }
    getBwEstimate() {
      return this.bwEstimator.canEstimate() ? this.bwEstimator.getEstimate() : this.hls.config.abrEwmaDefaultEstimate;
    }
    findBestLevel(currentBw, minAutoLevel, maxAutoLevel, bufferStarvationDelay, maxStarvationDelay, bwFactor, bwUpFactor) {
      var _this$hls$latestLevel;
      const maxFetchDuration = bufferStarvationDelay + maxStarvationDelay;
      const lastLoadedFragLevel = this.lastLoadedFragLevel;
      const selectionBaseLevel = lastLoadedFragLevel === -1 ? this.hls.firstLevel : lastLoadedFragLevel;
      const {
        fragCurrent,
        partCurrent
      } = this;
      const {
        levels,
        allAudioTracks,
        loadLevel,
        config: config3
      } = this.hls;
      if (levels.length === 1) {
        return 0;
      }
      const level = levels[selectionBaseLevel];
      const live = !!((_this$hls$latestLevel = this.hls.latestLevelDetails) != null && _this$hls$latestLevel.live);
      const firstSelection = loadLevel === -1 || lastLoadedFragLevel === -1;
      let currentCodecSet;
      let currentVideoRange = "SDR";
      let currentFrameRate = (level == null ? void 0 : level.frameRate) || 0;
      const {
        audioPreference,
        videoPreference
      } = config3;
      const audioTracksByGroup = this.audioTracksByGroup || (this.audioTracksByGroup = getAudioTracksByGroup(allAudioTracks));
      let minStartIndex = -1;
      if (firstSelection) {
        if (this.firstSelection !== -1) {
          return this.firstSelection;
        }
        const codecTiers = this.codecTiers || (this.codecTiers = getCodecTiers(levels, audioTracksByGroup, minAutoLevel, maxAutoLevel));
        const startTier = getStartCodecTier(codecTiers, currentVideoRange, currentBw, audioPreference, videoPreference);
        const {
          codecSet,
          videoRanges,
          minFramerate,
          minBitrate,
          minIndex,
          preferHDR
        } = startTier;
        minStartIndex = minIndex;
        currentCodecSet = codecSet;
        currentVideoRange = preferHDR ? videoRanges[videoRanges.length - 1] : videoRanges[0];
        currentFrameRate = minFramerate;
        currentBw = Math.max(currentBw, minBitrate);
        this.log(`picked start tier ${stringify(startTier)}`);
      } else {
        currentCodecSet = level == null ? void 0 : level.codecSet;
        currentVideoRange = level == null ? void 0 : level.videoRange;
      }
      const currentFragDuration = partCurrent ? partCurrent.duration : fragCurrent ? fragCurrent.duration : 0;
      const ttfbEstimateSec = this.bwEstimator.getEstimateTTFB() / 1e3;
      const levelsSkipped = [];
      for (let i = maxAutoLevel; i >= minAutoLevel; i--) {
        var _levelInfo$supportedR;
        const levelInfo = levels[i];
        const upSwitch = i > selectionBaseLevel;
        if (!levelInfo) {
          continue;
        }
        if (config3.useMediaCapabilities && !levelInfo.supportedResult && !levelInfo.supportedPromise) {
          const mediaCapabilities = navigator.mediaCapabilities;
          if (typeof (mediaCapabilities == null ? void 0 : mediaCapabilities.decodingInfo) === "function" && requiresMediaCapabilitiesDecodingInfo(levelInfo, audioTracksByGroup, currentVideoRange, currentFrameRate, currentBw, audioPreference)) {
            levelInfo.supportedPromise = getMediaDecodingInfoPromise(levelInfo, audioTracksByGroup, mediaCapabilities, this.supportedCache);
            levelInfo.supportedPromise.then((decodingInfo) => {
              if (!this.hls) {
                return;
              }
              levelInfo.supportedResult = decodingInfo;
              const levels2 = this.hls.levels;
              const index = levels2.indexOf(levelInfo);
              if (decodingInfo.error) {
                this.warn(`MediaCapabilities decodingInfo error: "${decodingInfo.error}" for level ${index} ${stringify(decodingInfo)}`);
              } else if (!decodingInfo.supported) {
                this.warn(`Unsupported MediaCapabilities decodingInfo result for level ${index} ${stringify(decodingInfo)}`);
                if (index > -1 && levels2.length > 1) {
                  this.log(`Removing unsupported level ${index}`);
                  this.hls.removeLevel(index);
                  if (this.hls.loadLevel === -1) {
                    this.hls.nextLoadLevel = 0;
                  }
                }
              } else if (decodingInfo.decodingInfoResults.some((info) => info.smooth === false || info.powerEfficient === false)) {
                this.log(`MediaCapabilities decodingInfo for level ${index} not smooth or powerEfficient: ${stringify(decodingInfo)}`);
              }
            }).catch((error) => {
              this.warn(`Error handling MediaCapabilities decodingInfo: ${error}`);
            });
          } else {
            levelInfo.supportedResult = SUPPORTED_INFO_DEFAULT;
          }
        }
        if (currentCodecSet && levelInfo.codecSet !== currentCodecSet || currentVideoRange && levelInfo.videoRange !== currentVideoRange || upSwitch && currentFrameRate > levelInfo.frameRate || !upSwitch && currentFrameRate > 0 && currentFrameRate < levelInfo.frameRate || (_levelInfo$supportedR = levelInfo.supportedResult) != null && (_levelInfo$supportedR = _levelInfo$supportedR.decodingInfoResults) != null && _levelInfo$supportedR.some((info) => info.smooth === false)) {
          if (!firstSelection || i !== minStartIndex) {
            levelsSkipped.push(i);
            continue;
          }
        }
        const levelDetails = levelInfo.details;
        const avgDuration = (partCurrent ? levelDetails == null ? void 0 : levelDetails.partTarget : levelDetails == null ? void 0 : levelDetails.averagetargetduration) || currentFragDuration;
        let adjustedbw;
        if (!upSwitch) {
          adjustedbw = bwFactor * currentBw;
        } else {
          adjustedbw = bwUpFactor * currentBw;
        }
        const bitrate = currentFragDuration && bufferStarvationDelay >= currentFragDuration * 2 && maxStarvationDelay === 0 ? levelInfo.averageBitrate : levelInfo.maxBitrate;
        const fetchDuration = this.getTimeToLoadFrag(ttfbEstimateSec, adjustedbw, bitrate * avgDuration, levelDetails === void 0);
        const canSwitchWithinTolerance = (
          // if adjusted bw is greater than level bitrate AND
          adjustedbw >= bitrate && // no level change, or new level has no error history
          (i === lastLoadedFragLevel || levelInfo.loadError === 0 && levelInfo.fragmentError === 0) && // fragment fetchDuration unknown OR live stream OR fragment fetchDuration less than max allowed fetch duration, then this level matches
          // we don't account for max Fetch Duration for live streams, this is to avoid switching down when near the edge of live sliding window ...
          // special case to support startLevel = -1 (bitrateTest) on live streams : in that case we should not exit loop so that findBestLevel will return -1
          (fetchDuration <= ttfbEstimateSec || !isFiniteNumber(fetchDuration) || live && !this.bitrateTestDelay || fetchDuration < maxFetchDuration)
        );
        if (canSwitchWithinTolerance) {
          const forcedAutoLevel = this.forcedAutoLevel;
          if (i !== loadLevel && (forcedAutoLevel === -1 || forcedAutoLevel !== loadLevel)) {
            if (levelsSkipped.length) {
              this.trace(`Skipped level(s) ${levelsSkipped.join(",")} of ${maxAutoLevel} max with CODECS and VIDEO-RANGE:"${levels[levelsSkipped[0]].codecs}" ${levels[levelsSkipped[0]].videoRange}; not compatible with "${currentCodecSet}" ${currentVideoRange}`);
            }
            this.info(`switch candidate:${selectionBaseLevel}->${i} adjustedbw(${Math.round(adjustedbw)})-bitrate=${Math.round(adjustedbw - bitrate)} ttfb:${ttfbEstimateSec.toFixed(1)} avgDuration:${avgDuration.toFixed(1)} maxFetchDuration:${maxFetchDuration.toFixed(1)} fetchDuration:${fetchDuration.toFixed(1)} firstSelection:${firstSelection} codecSet:${levelInfo.codecSet} videoRange:${levelInfo.videoRange} hls.loadLevel:${loadLevel}`);
          }
          if (firstSelection) {
            this.firstSelection = i;
          }
          return i;
        }
      }
      return -1;
    }
    set nextAutoLevel(nextLevel) {
      const value = this.deriveNextAutoLevel(nextLevel);
      if (this._nextAutoLevel !== value) {
        this.nextAutoLevelKey = "";
        this._nextAutoLevel = value;
      }
    }
    deriveNextAutoLevel(nextLevel) {
      const {
        maxAutoLevel,
        minAutoLevel
      } = this.hls;
      return Math.min(Math.max(nextLevel, minAutoLevel), maxAutoLevel);
    }
  };
  var BinarySearch = {
    /**
     * Searches for an item in an array which matches a certain condition.
     * This requires the condition to only match one item in the array,
     * and for the array to be ordered.
     *
     * @param list The array to search.
     * @param comparisonFn
     *      Called and provided a candidate item as the first argument.
     *      Should return:
     *          > -1 if the item should be located at a lower index than the provided item.
     *          > 1 if the item should be located at a higher index than the provided item.
     *          > 0 if the item is the item you're looking for.
     *
     * @returns the object if found, otherwise returns null
     */
    search: function(list, comparisonFn) {
      let minIndex = 0;
      let maxIndex = list.length - 1;
      let currentIndex = null;
      let currentElement = null;
      while (minIndex <= maxIndex) {
        currentIndex = (minIndex + maxIndex) / 2 | 0;
        currentElement = list[currentIndex];
        const comparisonResult = comparisonFn(currentElement);
        if (comparisonResult > 0) {
          minIndex = currentIndex + 1;
        } else if (comparisonResult < 0) {
          maxIndex = currentIndex - 1;
        } else {
          return currentElement;
        }
      }
      return null;
    }
  };
  function findFragmentByPDT(fragments, PDTValue, maxFragLookUpTolerance) {
    if (PDTValue === null || !Array.isArray(fragments) || !fragments.length || !isFiniteNumber(PDTValue)) {
      return null;
    }
    const startPDT = fragments[0].programDateTime;
    if (PDTValue < (startPDT || 0)) {
      return null;
    }
    const endPDT = fragments[fragments.length - 1].endProgramDateTime;
    if (PDTValue >= (endPDT || 0)) {
      return null;
    }
    for (let seg = 0; seg < fragments.length; ++seg) {
      const frag = fragments[seg];
      if (pdtWithinToleranceTest(PDTValue, maxFragLookUpTolerance, frag)) {
        return frag;
      }
    }
    return null;
  }
  function findFragmentByPTS(fragPrevious, fragments, bufferEnd = 0, maxFragLookUpTolerance = 0, nextFragLookupTolerance = 5e-3) {
    let fragNext = null;
    if (fragPrevious) {
      fragNext = fragments[1 + fragPrevious.sn - fragments[0].sn] || null;
      const bufferEdgeError = fragPrevious.endDTS - bufferEnd;
      if (bufferEdgeError > 0 && bufferEdgeError < 15e-7) {
        bufferEnd += 15e-7;
      }
      if (fragNext && fragPrevious.level !== fragNext.level && fragNext.end <= fragPrevious.end) {
        fragNext = fragments[2 + fragPrevious.sn - fragments[0].sn] || null;
      }
    } else if (bufferEnd === 0 && fragments[0].start === 0) {
      fragNext = fragments[0];
    }
    if (fragNext && ((!fragPrevious || fragPrevious.level === fragNext.level) && fragmentWithinToleranceTest(bufferEnd, maxFragLookUpTolerance, fragNext) === 0 || fragmentWithinFastStartSwitch(fragNext, fragPrevious, Math.min(nextFragLookupTolerance, maxFragLookUpTolerance)))) {
      return fragNext;
    }
    const foundFragment = BinarySearch.search(fragments, fragmentWithinToleranceTest.bind(null, bufferEnd, maxFragLookUpTolerance));
    if (foundFragment && (foundFragment !== fragPrevious || !fragNext)) {
      return foundFragment;
    }
    return fragNext;
  }
  function fragmentWithinFastStartSwitch(fragNext, fragPrevious, nextFragLookupTolerance) {
    if (fragPrevious && fragPrevious.start === 0 && fragPrevious.level < fragNext.level && (fragPrevious.endPTS || 0) > 0) {
      const firstDuration = fragPrevious.tagList.reduce((duration, tag) => {
        if (tag[0] === "INF") {
          duration += parseFloat(tag[1]);
        }
        return duration;
      }, nextFragLookupTolerance);
      return fragNext.start <= firstDuration;
    }
    return false;
  }
  function fragmentWithinToleranceTest(bufferEnd = 0, maxFragLookUpTolerance = 0, candidate) {
    if (candidate.start <= bufferEnd && candidate.start + candidate.duration > bufferEnd) {
      return 0;
    }
    const candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration + (candidate.deltaPTS ? candidate.deltaPTS : 0));
    if (candidate.start + candidate.duration - candidateLookupTolerance <= bufferEnd) {
      return 1;
    } else if (candidate.start - candidateLookupTolerance > bufferEnd && candidate.start) {
      return -1;
    }
    return 0;
  }
  function pdtWithinToleranceTest(pdtBufferEnd, maxFragLookUpTolerance, candidate) {
    const candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration + (candidate.deltaPTS ? candidate.deltaPTS : 0)) * 1e3;
    const endProgramDateTime = candidate.endProgramDateTime || 0;
    return endProgramDateTime - candidateLookupTolerance > pdtBufferEnd;
  }
  function findNearestWithCC(details, cc, pos) {
    if (details) {
      if (details.startCC <= cc && details.endCC >= cc) {
        let fragments = details.fragments;
        const {
          fragmentHint
        } = details;
        if (fragmentHint) {
          fragments = fragments.concat(fragmentHint);
        }
        let closest;
        BinarySearch.search(fragments, (candidate) => {
          if (candidate.cc < cc) {
            return 1;
          }
          if (candidate.cc > cc) {
            return -1;
          }
          closest = candidate;
          if (candidate.end <= pos) {
            return 1;
          }
          if (candidate.start > pos) {
            return -1;
          }
          return 0;
        });
        return closest || null;
      }
    }
    return null;
  }
  function isTimeoutError(error) {
    switch (error.details) {
      case ErrorDetails.FRAG_LOAD_TIMEOUT:
      case ErrorDetails.KEY_LOAD_TIMEOUT:
      case ErrorDetails.LEVEL_LOAD_TIMEOUT:
      case ErrorDetails.MANIFEST_LOAD_TIMEOUT:
        return true;
    }
    return false;
  }
  function isKeyError(error) {
    return error.details.startsWith("key");
  }
  function isUnusableKeyError(error) {
    return isKeyError(error) && !!error.frag && !error.frag.decryptdata;
  }
  function getRetryConfig(loadPolicy, error) {
    const isTimeout = isTimeoutError(error);
    return loadPolicy.default[`${isTimeout ? "timeout" : "error"}Retry`];
  }
  function getRetryDelay(retryConfig, retryCount) {
    const backoffFactor = retryConfig.backoff === "linear" ? 1 : Math.pow(2, retryCount);
    return Math.min(backoffFactor * retryConfig.retryDelayMs, retryConfig.maxRetryDelayMs);
  }
  function getLoaderConfigWithoutReties(loderConfig) {
    return _objectSpread2(_objectSpread2({}, loderConfig), {
      errorRetry: null,
      timeoutRetry: null
    });
  }
  function shouldRetry(retryConfig, retryCount, isTimeout, loaderResponse) {
    if (!retryConfig) {
      return false;
    }
    const httpStatus = loaderResponse == null ? void 0 : loaderResponse.code;
    const retry = retryCount < retryConfig.maxNumRetry && (retryForHttpStatus(httpStatus) || !!isTimeout);
    return retryConfig.shouldRetry ? retryConfig.shouldRetry(retryConfig, retryCount, isTimeout, loaderResponse, retry) : retry;
  }
  function retryForHttpStatus(httpStatus) {
    return offlineHttpStatus(httpStatus) || !!httpStatus && (httpStatus < 400 || httpStatus > 499);
  }
  function offlineHttpStatus(httpStatus) {
    return httpStatus === 0 && navigator.onLine === false;
  }
  var NetworkErrorAction = {
    DoNothing: 0,
    SendEndCallback: 1,
    SendAlternateToPenaltyBox: 2,
    RemoveAlternatePermanently: 3,
    InsertDiscontinuity: 4,
    RetryRequest: 5
  };
  var ErrorActionFlags = {
    None: 0,
    MoveAllAlternatesMatchingHost: 1,
    MoveAllAlternatesMatchingHDCP: 2,
    MoveAllAlternatesMatchingKey: 4,
    SwitchToSDR: 8
  };
  var ErrorController = class extends Logger {
    constructor(hls) {
      super("error-controller", hls.logger);
      this.hls = void 0;
      this.playlistError = 0;
      this.hls = hls;
      this.registerListeners();
    }
    registerListeners() {
      const hls = this.hls;
      hls.on(Events.ERROR, this.onError, this);
      hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);
    }
    unregisterListeners() {
      const hls = this.hls;
      if (!hls) {
        return;
      }
      hls.off(Events.ERROR, this.onError, this);
      hls.off(Events.ERROR, this.onErrorOut, this);
      hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);
    }
    destroy() {
      this.unregisterListeners();
      this.hls = null;
    }
    startLoad(startPosition) {
    }
    stopLoad() {
      this.playlistError = 0;
    }
    getVariantLevelIndex(frag) {
      if ((frag == null ? void 0 : frag.type) === PlaylistLevelType.MAIN) {
        return frag.level;
      }
      return this.getVariantIndex();
    }
    getVariantIndex() {
      var _hls$loadLevelObj;
      const hls = this.hls;
      const currentLevel = hls.currentLevel;
      if ((_hls$loadLevelObj = hls.loadLevelObj) != null && _hls$loadLevelObj.details || currentLevel === -1) {
        return hls.loadLevel;
      }
      return currentLevel;
    }
    variantHasKey(level, keyInError) {
      if (level) {
        var _level$details;
        if ((_level$details = level.details) != null && _level$details.hasKey(keyInError)) {
          return true;
        }
        const audioGroupsIds = level.audioGroups;
        if (audioGroupsIds) {
          const audioTracks = this.hls.allAudioTracks.filter((track) => audioGroupsIds.indexOf(track.groupId) >= 0);
          return audioTracks.some((track) => {
            var _track$details;
            return (_track$details = track.details) == null ? void 0 : _track$details.hasKey(keyInError);
          });
        }
      }
      return false;
    }
    onManifestLoading() {
      this.playlistError = 0;
    }
    onLevelUpdated() {
      this.playlistError = 0;
    }
    onError(event, data) {
      var _data$frag;
      if (data.fatal) {
        return;
      }
      const hls = this.hls;
      const context3 = data.context;
      switch (data.details) {
        case ErrorDetails.FRAG_LOAD_ERROR:
        case ErrorDetails.FRAG_LOAD_TIMEOUT:
        case ErrorDetails.KEY_LOAD_ERROR:
        case ErrorDetails.KEY_LOAD_TIMEOUT:
          data.errorAction = this.getFragRetryOrSwitchAction(data);
          return;
        case ErrorDetails.FRAG_PARSING_ERROR:
          if ((_data$frag = data.frag) != null && _data$frag.gap) {
            data.errorAction = createDoNothingErrorAction();
            return;
          }
        // falls through
        case ErrorDetails.FRAG_GAP:
        case ErrorDetails.FRAG_DECRYPT_ERROR: {
          data.errorAction = this.getFragRetryOrSwitchAction(data);
          data.errorAction.action = NetworkErrorAction.SendAlternateToPenaltyBox;
          return;
        }
        case ErrorDetails.LEVEL_EMPTY_ERROR:
        case ErrorDetails.LEVEL_PARSING_ERROR:
          {
            var _data$context;
            const levelIndex = data.parent === PlaylistLevelType.MAIN ? data.level : hls.loadLevel;
            if (data.details === ErrorDetails.LEVEL_EMPTY_ERROR && !!((_data$context = data.context) != null && (_data$context = _data$context.levelDetails) != null && _data$context.live)) {
              data.errorAction = this.getPlaylistRetryOrSwitchAction(data, levelIndex);
            } else {
              data.levelRetry = false;
              data.errorAction = this.getLevelSwitchAction(data, levelIndex);
            }
          }
          return;
        case ErrorDetails.LEVEL_LOAD_ERROR:
        case ErrorDetails.LEVEL_LOAD_TIMEOUT:
          if (typeof (context3 == null ? void 0 : context3.level) === "number") {
            data.errorAction = this.getPlaylistRetryOrSwitchAction(data, context3.level);
          }
          return;
        case ErrorDetails.AUDIO_TRACK_LOAD_ERROR:
        case ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT:
        case ErrorDetails.SUBTITLE_LOAD_ERROR:
        case ErrorDetails.SUBTITLE_TRACK_LOAD_TIMEOUT:
          if (context3) {
            const level = hls.loadLevelObj;
            if (level && (context3.type === PlaylistContextType.AUDIO_TRACK && level.hasAudioGroup(context3.groupId) || context3.type === PlaylistContextType.SUBTITLE_TRACK && level.hasSubtitleGroup(context3.groupId))) {
              data.errorAction = this.getPlaylistRetryOrSwitchAction(data, hls.loadLevel);
              data.errorAction.action = NetworkErrorAction.SendAlternateToPenaltyBox;
              data.errorAction.flags = ErrorActionFlags.MoveAllAlternatesMatchingHost;
              return;
            }
          }
          return;
        case ErrorDetails.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED:
          {
            data.errorAction = {
              action: NetworkErrorAction.SendAlternateToPenaltyBox,
              flags: ErrorActionFlags.MoveAllAlternatesMatchingHDCP
            };
          }
          return;
        case ErrorDetails.KEY_SYSTEM_SESSION_UPDATE_FAILED:
        case ErrorDetails.KEY_SYSTEM_STATUS_INTERNAL_ERROR:
        case ErrorDetails.KEY_SYSTEM_NO_SESSION:
          {
            data.errorAction = {
              action: NetworkErrorAction.SendAlternateToPenaltyBox,
              flags: ErrorActionFlags.MoveAllAlternatesMatchingKey
            };
          }
          return;
        case ErrorDetails.BUFFER_ADD_CODEC_ERROR:
        case ErrorDetails.REMUX_ALLOC_ERROR:
        case ErrorDetails.BUFFER_APPEND_ERROR:
          if (!data.errorAction) {
            var _data$level;
            data.errorAction = this.getLevelSwitchAction(data, (_data$level = data.level) != null ? _data$level : hls.loadLevel);
          }
          return;
        case ErrorDetails.INTERNAL_EXCEPTION:
        case ErrorDetails.BUFFER_APPENDING_ERROR:
        case ErrorDetails.BUFFER_FULL_ERROR:
        case ErrorDetails.LEVEL_SWITCH_ERROR:
        case ErrorDetails.BUFFER_STALLED_ERROR:
        case ErrorDetails.BUFFER_SEEK_OVER_HOLE:
        case ErrorDetails.BUFFER_NUDGE_ON_STALL:
          data.errorAction = createDoNothingErrorAction();
          return;
      }
      if (data.type === ErrorTypes.KEY_SYSTEM_ERROR) {
        data.levelRetry = false;
        data.errorAction = createDoNothingErrorAction();
      }
    }
    getPlaylistRetryOrSwitchAction(data, levelIndex) {
      const hls = this.hls;
      const retryConfig = getRetryConfig(hls.config.playlistLoadPolicy, data);
      const retryCount = this.playlistError++;
      const retry = shouldRetry(retryConfig, retryCount, isTimeoutError(data), data.response);
      if (retry) {
        return {
          action: NetworkErrorAction.RetryRequest,
          flags: ErrorActionFlags.None,
          retryConfig,
          retryCount
        };
      }
      const errorAction = this.getLevelSwitchAction(data, levelIndex);
      if (retryConfig) {
        errorAction.retryConfig = retryConfig;
        errorAction.retryCount = retryCount;
      }
      return errorAction;
    }
    getFragRetryOrSwitchAction(data) {
      const hls = this.hls;
      const variantLevelIndex = this.getVariantLevelIndex(data.frag);
      const level = hls.levels[variantLevelIndex];
      const {
        fragLoadPolicy,
        keyLoadPolicy
      } = hls.config;
      const retryConfig = getRetryConfig(isKeyError(data) ? keyLoadPolicy : fragLoadPolicy, data);
      const fragmentErrors = hls.levels.reduce((acc, level2) => acc + level2.fragmentError, 0);
      if (level) {
        if (data.details !== ErrorDetails.FRAG_GAP) {
          level.fragmentError++;
        }
        if (!isUnusableKeyError(data)) {
          const retry = shouldRetry(retryConfig, fragmentErrors, isTimeoutError(data), data.response);
          if (retry) {
            return {
              action: NetworkErrorAction.RetryRequest,
              flags: ErrorActionFlags.None,
              retryConfig,
              retryCount: fragmentErrors
            };
          }
        }
      }
      const errorAction = this.getLevelSwitchAction(data, variantLevelIndex);
      if (retryConfig) {
        errorAction.retryConfig = retryConfig;
        errorAction.retryCount = fragmentErrors;
      }
      return errorAction;
    }
    getLevelSwitchAction(data, levelIndex) {
      const hls = this.hls;
      if (levelIndex === null || levelIndex === void 0) {
        levelIndex = hls.loadLevel;
      }
      const level = this.hls.levels[levelIndex];
      if (level) {
        var _data$frag2, _data$context2;
        const errorDetails = data.details;
        level.loadError++;
        if (errorDetails === ErrorDetails.BUFFER_APPEND_ERROR) {
          level.fragmentError++;
        }
        let nextLevel = -1;
        const {
          levels,
          loadLevel,
          minAutoLevel,
          maxAutoLevel
        } = hls;
        if (!hls.autoLevelEnabled && !hls.config.preserveManualLevelOnError) {
          hls.loadLevel = -1;
        }
        const fragErrorType = (_data$frag2 = data.frag) == null ? void 0 : _data$frag2.type;
        const isAudioCodecError = fragErrorType === PlaylistLevelType.AUDIO && errorDetails === ErrorDetails.FRAG_PARSING_ERROR || data.sourceBufferName === "audio" && (errorDetails === ErrorDetails.BUFFER_ADD_CODEC_ERROR || errorDetails === ErrorDetails.BUFFER_APPEND_ERROR);
        const findAudioCodecAlternate = isAudioCodecError && levels.some(({
          audioCodec
        }) => level.audioCodec !== audioCodec);
        const isVideoCodecError = data.sourceBufferName === "video" && (errorDetails === ErrorDetails.BUFFER_ADD_CODEC_ERROR || errorDetails === ErrorDetails.BUFFER_APPEND_ERROR);
        const findVideoCodecAlternate = isVideoCodecError && levels.some(({
          codecSet,
          audioCodec
        }) => level.codecSet !== codecSet && level.audioCodec === audioCodec);
        const {
          type: playlistErrorType,
          groupId: playlistErrorGroupId
        } = (_data$context2 = data.context) != null ? _data$context2 : {};
        for (let i = levels.length; i--; ) {
          const candidate = (i + loadLevel) % levels.length;
          if (candidate !== loadLevel && candidate >= minAutoLevel && candidate <= maxAutoLevel && levels[candidate].loadError === 0) {
            var _level$audioGroups, _level$subtitleGroups;
            const levelCandidate = levels[candidate];
            if (errorDetails === ErrorDetails.FRAG_GAP && fragErrorType === PlaylistLevelType.MAIN && data.frag) {
              const levelDetails = levels[candidate].details;
              if (levelDetails) {
                const fragCandidate = findFragmentByPTS(data.frag, levelDetails.fragments, data.frag.start);
                if (fragCandidate != null && fragCandidate.gap) {
                  continue;
                }
              }
            } else if (playlistErrorType === PlaylistContextType.AUDIO_TRACK && levelCandidate.hasAudioGroup(playlistErrorGroupId) || playlistErrorType === PlaylistContextType.SUBTITLE_TRACK && levelCandidate.hasSubtitleGroup(playlistErrorGroupId)) {
              continue;
            } else if (fragErrorType === PlaylistLevelType.AUDIO && (_level$audioGroups = level.audioGroups) != null && _level$audioGroups.some((groupId) => levelCandidate.hasAudioGroup(groupId)) || fragErrorType === PlaylistLevelType.SUBTITLE && (_level$subtitleGroups = level.subtitleGroups) != null && _level$subtitleGroups.some((groupId) => levelCandidate.hasSubtitleGroup(groupId)) || findAudioCodecAlternate && level.audioCodec === levelCandidate.audioCodec || findVideoCodecAlternate && level.codecSet === levelCandidate.codecSet || !findAudioCodecAlternate && level.codecSet !== levelCandidate.codecSet) {
              continue;
            }
            nextLevel = candidate;
            break;
          }
        }
        if (nextLevel > -1 && hls.loadLevel !== nextLevel) {
          data.levelRetry = true;
          this.playlistError = 0;
          return {
            action: NetworkErrorAction.SendAlternateToPenaltyBox,
            flags: ErrorActionFlags.None,
            nextAutoLevel: nextLevel
          };
        }
      }
      return {
        action: NetworkErrorAction.SendAlternateToPenaltyBox,
        flags: ErrorActionFlags.MoveAllAlternatesMatchingHost
      };
    }
    onErrorOut(event, data) {
      var _data$errorAction;
      switch ((_data$errorAction = data.errorAction) == null ? void 0 : _data$errorAction.action) {
        case NetworkErrorAction.DoNothing:
          break;
        case NetworkErrorAction.SendAlternateToPenaltyBox:
          this.sendAlternateToPenaltyBox(data);
          if (!data.errorAction.resolved && data.details !== ErrorDetails.FRAG_GAP) {
            data.fatal = true;
          } else if (/MediaSource readyState: ended/.test(data.error.message)) {
            this.warn(`MediaSource ended after "${data.sourceBufferName}" sourceBuffer append error. Attempting to recover from media error.`);
            this.hls.recoverMediaError();
          }
          break;
        case NetworkErrorAction.RetryRequest:
          break;
      }
      if (data.fatal) {
        this.hls.stopLoad();
        return;
      }
    }
    sendAlternateToPenaltyBox(data) {
      const hls = this.hls;
      const errorAction = data.errorAction;
      if (!errorAction) {
        return;
      }
      const {
        flags
      } = errorAction;
      const nextAutoLevel = errorAction.nextAutoLevel;
      switch (flags) {
        case ErrorActionFlags.None:
          this.switchLevel(data, nextAutoLevel);
          break;
        case ErrorActionFlags.MoveAllAlternatesMatchingHDCP: {
          const levelIndex = this.getVariantLevelIndex(data.frag);
          const level = hls.levels[levelIndex];
          const restrictedHdcpLevel = level == null ? void 0 : level.attrs["HDCP-LEVEL"];
          errorAction.hdcpLevel = restrictedHdcpLevel;
          if (restrictedHdcpLevel === "NONE") {
            this.warn(`HDCP policy resticted output with HDCP-LEVEL=NONE`);
          } else if (restrictedHdcpLevel) {
            hls.maxHdcpLevel = HdcpLevels[HdcpLevels.indexOf(restrictedHdcpLevel) - 1];
            errorAction.resolved = true;
            this.warn(`Restricting playback to HDCP-LEVEL of "${hls.maxHdcpLevel}" or lower`);
            break;
          }
        }
        // eslint-disable-next-line no-fallthrough
        case ErrorActionFlags.MoveAllAlternatesMatchingKey: {
          const levelKey = data.decryptdata;
          if (levelKey) {
            const levels = this.hls.levels;
            const levelCountWithError = levels.length;
            for (let i = levelCountWithError; i--; ) {
              if (this.variantHasKey(levels[i], levelKey)) {
                var _levels$i$audioGroups, _data$frag3;
                this.log(`Banned key found in level ${i} (${levels[i].bitrate}bps) or audio group "${(_levels$i$audioGroups = levels[i].audioGroups) == null ? void 0 : _levels$i$audioGroups.join(",")}" (${(_data$frag3 = data.frag) == null ? void 0 : _data$frag3.type} fragment) ${arrayToHex(levelKey.keyId || [])}`);
                levels[i].fragmentError++;
                levels[i].loadError++;
                this.log(`Removing level ${i} with key error (${data.error})`);
                this.hls.removeLevel(i);
              }
            }
            const frag = data.frag;
            if (this.hls.levels.length < levelCountWithError) {
              errorAction.resolved = true;
            } else if (frag && frag.type !== PlaylistLevelType.MAIN) {
              const fragLevelKey = frag.decryptdata;
              if (fragLevelKey && !levelKey.matches(fragLevelKey)) {
                errorAction.resolved = true;
              }
            }
          }
          break;
        }
      }
      if (!errorAction.resolved) {
        this.switchLevel(data, nextAutoLevel);
      }
    }
    switchLevel(data, levelIndex) {
      if (levelIndex !== void 0 && data.errorAction) {
        this.warn(`switching to level ${levelIndex} after ${data.details}`);
        this.hls.nextAutoLevel = levelIndex;
        data.errorAction.resolved = true;
        this.hls.nextLoadLevel = this.hls.nextAutoLevel;
        if (data.details === ErrorDetails.BUFFER_ADD_CODEC_ERROR && data.mimeType && data.sourceBufferName !== "audiovideo") {
          const codec = getCodecsForMimeType(data.mimeType);
          const levels = this.hls.levels;
          for (let i = levels.length; i--; ) {
            if (levels[i][`${data.sourceBufferName}Codec`] === codec) {
              this.log(`Removing level ${i} for ${data.details} ("${codec}" not supported)`);
              this.hls.removeLevel(i);
            }
          }
        }
      }
    }
  };
  function createDoNothingErrorAction(resolved) {
    const errorAction = {
      action: NetworkErrorAction.DoNothing,
      flags: ErrorActionFlags.None
    };
    if (resolved) {
      errorAction.resolved = true;
    }
    return errorAction;
  }
  var FragmentState = {
    NOT_LOADED: "NOT_LOADED",
    APPENDING: "APPENDING",
    PARTIAL: "PARTIAL",
    OK: "OK"
  };
  var FragmentTracker = class {
    constructor(hls) {
      this.activePartLists = /* @__PURE__ */ Object.create(null);
      this.endListFragments = /* @__PURE__ */ Object.create(null);
      this.fragments = /* @__PURE__ */ Object.create(null);
      this.timeRanges = /* @__PURE__ */ Object.create(null);
      this.bufferPadding = 0.2;
      this.hls = void 0;
      this.hasGaps = false;
      this.hls = hls;
      this._registerListeners();
    }
    _registerListeners() {
      const {
        hls
      } = this;
      if (hls) {
        hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
        hls.on(Events.BUFFER_APPENDED, this.onBufferAppended, this);
        hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);
        hls.on(Events.FRAG_LOADED, this.onFragLoaded, this);
      }
    }
    _unregisterListeners() {
      const {
        hls
      } = this;
      if (hls) {
        hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
        hls.off(Events.BUFFER_APPENDED, this.onBufferAppended, this);
        hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);
        hls.off(Events.FRAG_LOADED, this.onFragLoaded, this);
      }
    }
    destroy() {
      this._unregisterListeners();
      this.hls = // @ts-ignore
      this.fragments = // @ts-ignore
      this.activePartLists = // @ts-ignore
      this.endListFragments = this.timeRanges = null;
    }
    /**
     * Return a Fragment or Part with an appended range that matches the position and levelType
     * Otherwise, return null
     */
    getAppendedFrag(position, levelType) {
      const activeParts = this.activePartLists[levelType];
      if (activeParts) {
        for (let i = activeParts.length; i--; ) {
          const activePart = activeParts[i];
          if (!activePart) {
            break;
          }
          if (activePart.start <= position && position <= activePart.end && activePart.loaded) {
            return activePart;
          }
        }
      }
      return this.getBufferedFrag(position, levelType);
    }
    /**
     * Return a buffered Fragment that matches the position and levelType.
     * A buffered Fragment is one whose loading, parsing and appending is done (completed or "partial" meaning aborted).
     * If not found any Fragment, return null
     */
    getBufferedFrag(position, levelType) {
      return this.getFragAtPos(position, levelType, true);
    }
    getFragAtPos(position, levelType, buffered) {
      const {
        fragments
      } = this;
      const keys2 = Object.keys(fragments);
      for (let i = keys2.length; i--; ) {
        const fragmentEntity = fragments[keys2[i]];
        if ((fragmentEntity == null ? void 0 : fragmentEntity.body.type) === levelType && (!buffered || fragmentEntity.buffered)) {
          const frag = fragmentEntity.body;
          if (frag.start <= position && position <= frag.end) {
            return frag;
          }
        }
      }
      return null;
    }
    /**
     * Partial fragments effected by coded frame eviction will be removed
     * The browser will unload parts of the buffer to free up memory for new buffer data
     * Fragments will need to be reloaded when the buffer is freed up, removing partial fragments will allow them to reload(since there might be parts that are still playable)
     */
    detectEvictedFragments(elementaryStream, timeRange, playlistType, appendedPart, removeAppending) {
      if (this.timeRanges) {
        this.timeRanges[elementaryStream] = timeRange;
      }
      const appendedPartSn = (appendedPart == null ? void 0 : appendedPart.fragment.sn) || -1;
      Object.keys(this.fragments).forEach((key) => {
        const fragmentEntity = this.fragments[key];
        if (!fragmentEntity) {
          return;
        }
        if (appendedPartSn >= fragmentEntity.body.sn) {
          return;
        }
        if (!fragmentEntity.buffered && (!fragmentEntity.loaded || removeAppending)) {
          if (fragmentEntity.body.type === playlistType) {
            this.removeFragment(fragmentEntity.body);
          }
          return;
        }
        const esData = fragmentEntity.range[elementaryStream];
        if (!esData) {
          return;
        }
        if (esData.time.length === 0) {
          this.removeFragment(fragmentEntity.body);
          return;
        }
        esData.time.some((time2) => {
          const isNotBuffered = !this.isTimeBuffered(time2.startPTS, time2.endPTS, timeRange);
          if (isNotBuffered) {
            this.removeFragment(fragmentEntity.body);
          }
          return isNotBuffered;
        });
      });
    }
    /**
     * Checks if the fragment passed in is loaded in the buffer properly
     * Partially loaded fragments will be registered as a partial fragment
     */
    detectPartialFragments(data) {
      const timeRanges = this.timeRanges;
      if (!timeRanges || data.frag.sn === "initSegment") {
        return;
      }
      const frag = data.frag;
      const fragKey = getFragmentKey(frag);
      const fragmentEntity = this.fragments[fragKey];
      if (!fragmentEntity || fragmentEntity.buffered && frag.gap) {
        return;
      }
      const isFragHint = !frag.relurl;
      Object.keys(timeRanges).forEach((elementaryStream) => {
        const streamInfo = frag.elementaryStreams[elementaryStream];
        if (!streamInfo) {
          return;
        }
        const timeRange = timeRanges[elementaryStream];
        const partial = isFragHint || streamInfo.partial === true;
        fragmentEntity.range[elementaryStream] = this.getBufferedTimes(frag, data.part, partial, timeRange);
      });
      fragmentEntity.loaded = null;
      if (Object.keys(fragmentEntity.range).length) {
        fragmentEntity.buffered = true;
        const endList = fragmentEntity.body.endList = frag.endList || fragmentEntity.body.endList;
        if (endList) {
          this.endListFragments[fragmentEntity.body.type] = fragmentEntity;
        }
        if (!isPartial(fragmentEntity)) {
          this.removeParts(frag.sn - 1, frag.type);
        }
      } else {
        this.removeFragment(fragmentEntity.body);
      }
    }
    removeParts(snToKeep, levelType) {
      const activeParts = this.activePartLists[levelType];
      if (!activeParts) {
        return;
      }
      this.activePartLists[levelType] = filterParts(activeParts, (part) => part.fragment.sn >= snToKeep);
    }
    fragBuffered(frag, force) {
      const fragKey = getFragmentKey(frag);
      let fragmentEntity = this.fragments[fragKey];
      if (!fragmentEntity && force) {
        fragmentEntity = this.fragments[fragKey] = {
          body: frag,
          appendedPTS: null,
          loaded: null,
          buffered: false,
          range: /* @__PURE__ */ Object.create(null)
        };
        if (frag.gap) {
          this.hasGaps = true;
        }
      }
      if (fragmentEntity) {
        fragmentEntity.loaded = null;
        fragmentEntity.buffered = true;
      }
    }
    getBufferedTimes(fragment, part, partial, timeRange) {
      const buffered = {
        time: [],
        partial
      };
      const startPTS = fragment.start;
      const endPTS = fragment.end;
      const minEndPTS = fragment.minEndPTS || endPTS;
      const maxStartPTS = fragment.maxStartPTS || startPTS;
      for (let i = 0; i < timeRange.length; i++) {
        const startTime = timeRange.start(i) - this.bufferPadding;
        const endTime = timeRange.end(i) + this.bufferPadding;
        if (maxStartPTS >= startTime && minEndPTS <= endTime) {
          buffered.time.push({
            startPTS: Math.max(startPTS, timeRange.start(i)),
            endPTS: Math.min(endPTS, timeRange.end(i))
          });
          break;
        } else if (startPTS < endTime && endPTS > startTime) {
          const start = Math.max(startPTS, timeRange.start(i));
          const end = Math.min(endPTS, timeRange.end(i));
          if (end > start) {
            buffered.partial = true;
            buffered.time.push({
              startPTS: start,
              endPTS: end
            });
          }
        } else if (endPTS <= startTime) {
          break;
        }
      }
      return buffered;
    }
    /**
     * Gets the partial fragment for a certain time
     */
    getPartialFragment(time2) {
      let bestFragment = null;
      let timePadding;
      let startTime;
      let endTime;
      let bestOverlap = 0;
      const {
        bufferPadding,
        fragments
      } = this;
      Object.keys(fragments).forEach((key) => {
        const fragmentEntity = fragments[key];
        if (!fragmentEntity) {
          return;
        }
        if (isPartial(fragmentEntity)) {
          startTime = fragmentEntity.body.start - bufferPadding;
          endTime = fragmentEntity.body.end + bufferPadding;
          if (time2 >= startTime && time2 <= endTime) {
            timePadding = Math.min(time2 - startTime, endTime - time2);
            if (bestOverlap <= timePadding) {
              bestFragment = fragmentEntity.body;
              bestOverlap = timePadding;
            }
          }
        }
      });
      return bestFragment;
    }
    isEndListAppended(type) {
      const lastFragmentEntity = this.endListFragments[type];
      return lastFragmentEntity !== void 0 && (lastFragmentEntity.buffered || isPartial(lastFragmentEntity));
    }
    getState(fragment) {
      const fragKey = getFragmentKey(fragment);
      const fragmentEntity = this.fragments[fragKey];
      if (fragmentEntity) {
        if (!fragmentEntity.buffered) {
          return FragmentState.APPENDING;
        } else if (isPartial(fragmentEntity)) {
          return FragmentState.PARTIAL;
        } else {
          return FragmentState.OK;
        }
      }
      return FragmentState.NOT_LOADED;
    }
    isTimeBuffered(startPTS, endPTS, timeRange) {
      let startTime;
      let endTime;
      for (let i = 0; i < timeRange.length; i++) {
        startTime = timeRange.start(i) - this.bufferPadding;
        endTime = timeRange.end(i) + this.bufferPadding;
        if (startPTS >= startTime && endPTS <= endTime) {
          return true;
        }
        if (endPTS <= startTime) {
          return false;
        }
      }
      return false;
    }
    onManifestLoading() {
      this.removeAllFragments();
    }
    onFragLoaded(event, data) {
      if (data.frag.sn === "initSegment" || data.frag.bitrateTest) {
        return;
      }
      const frag = data.frag;
      const loaded = data.part ? null : data;
      const fragKey = getFragmentKey(frag);
      this.fragments[fragKey] = {
        body: frag,
        appendedPTS: null,
        loaded,
        buffered: false,
        range: /* @__PURE__ */ Object.create(null)
      };
    }
    onBufferAppended(event, data) {
      const {
        frag,
        part,
        timeRanges,
        type
      } = data;
      if (frag.sn === "initSegment") {
        return;
      }
      const playlistType = frag.type;
      if (part) {
        let activeParts = this.activePartLists[playlistType];
        if (!activeParts) {
          this.activePartLists[playlistType] = activeParts = [];
        }
        activeParts.push(part);
      }
      this.timeRanges = timeRanges;
      const timeRange = timeRanges[type];
      this.detectEvictedFragments(type, timeRange, playlistType, part);
    }
    onFragBuffered(event, data) {
      this.detectPartialFragments(data);
    }
    hasFragment(fragment) {
      const fragKey = getFragmentKey(fragment);
      return !!this.fragments[fragKey];
    }
    hasFragments(type) {
      const {
        fragments
      } = this;
      const keys2 = Object.keys(fragments);
      if (!type) {
        return keys2.length > 0;
      }
      for (let i = keys2.length; i--; ) {
        const fragmentEntity = fragments[keys2[i]];
        if ((fragmentEntity == null ? void 0 : fragmentEntity.body.type) === type) {
          return true;
        }
      }
      return false;
    }
    hasParts(type) {
      var _this$activePartLists;
      return !!((_this$activePartLists = this.activePartLists[type]) != null && _this$activePartLists.length);
    }
    removeFragmentsInRange(start, end, playlistType, withGapOnly, unbufferedOnly) {
      if (withGapOnly && !this.hasGaps) {
        return;
      }
      Object.keys(this.fragments).forEach((key) => {
        const fragmentEntity = this.fragments[key];
        if (!fragmentEntity) {
          return;
        }
        const frag = fragmentEntity.body;
        if (frag.type !== playlistType || withGapOnly && !frag.gap) {
          return;
        }
        if (frag.start < end && frag.end > start && (fragmentEntity.buffered || unbufferedOnly)) {
          this.removeFragment(frag);
        }
      });
    }
    removeFragment(fragment) {
      const fragKey = getFragmentKey(fragment);
      fragment.clearElementaryStreamInfo();
      const activeParts = this.activePartLists[fragment.type];
      if (activeParts) {
        const snToRemove = fragment.sn;
        this.activePartLists[fragment.type] = filterParts(activeParts, (part) => part.fragment.sn !== snToRemove);
      }
      delete this.fragments[fragKey];
      if (fragment.endList) {
        delete this.endListFragments[fragment.type];
      }
    }
    removeAllFragments() {
      var _this$hls;
      this.fragments = /* @__PURE__ */ Object.create(null);
      this.endListFragments = /* @__PURE__ */ Object.create(null);
      this.activePartLists = /* @__PURE__ */ Object.create(null);
      this.hasGaps = false;
      const partlist = (_this$hls = this.hls) == null || (_this$hls = _this$hls.latestLevelDetails) == null ? void 0 : _this$hls.partList;
      if (partlist) {
        partlist.forEach((part) => part.clearElementaryStreamInfo());
      }
    }
  };
  function isPartial(fragmentEntity) {
    var _fragmentEntity$range, _fragmentEntity$range2, _fragmentEntity$range3;
    return fragmentEntity.buffered && !!(fragmentEntity.body.gap || (_fragmentEntity$range = fragmentEntity.range.video) != null && _fragmentEntity$range.partial || (_fragmentEntity$range2 = fragmentEntity.range.audio) != null && _fragmentEntity$range2.partial || (_fragmentEntity$range3 = fragmentEntity.range.audiovideo) != null && _fragmentEntity$range3.partial);
  }
  function getFragmentKey(fragment) {
    return `${fragment.type}_${fragment.level}_${fragment.sn}`;
  }
  function filterParts(partList, predicate) {
    return partList.filter((part) => {
      const keep = predicate(part);
      if (!keep) {
        part.clearElementaryStreamInfo();
      }
      return keep;
    });
  }
  var DecrypterAesMode = {
    cbc: 0,
    ctr: 1
  };
  var AESCrypto = class {
    constructor(subtle, iv, aesMode) {
      this.subtle = void 0;
      this.aesIV = void 0;
      this.aesMode = void 0;
      this.subtle = subtle;
      this.aesIV = iv;
      this.aesMode = aesMode;
    }
    decrypt(data, key) {
      switch (this.aesMode) {
        case DecrypterAesMode.cbc:
          return this.subtle.decrypt({
            name: "AES-CBC",
            iv: this.aesIV
          }, key, data);
        case DecrypterAesMode.ctr:
          return this.subtle.decrypt(
            {
              name: "AES-CTR",
              counter: this.aesIV,
              length: 64
            },
            //64 : NIST SP800-38A standard suggests that the counter should occupy half of the counter block
            key,
            data
          );
        default:
          throw new Error(`[AESCrypto] invalid aes mode ${this.aesMode}`);
      }
    }
  };
  function removePadding(array) {
    const outputBytes = array.byteLength;
    const paddingBytes = outputBytes && new DataView(array.buffer).getUint8(outputBytes - 1);
    if (paddingBytes) {
      return array.slice(0, outputBytes - paddingBytes);
    }
    return array;
  }
  var AESDecryptor = class {
    constructor() {
      this.rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
      this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];
      this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];
      this.sBox = new Uint32Array(256);
      this.invSBox = new Uint32Array(256);
      this.key = new Uint32Array(0);
      this.ksRows = 0;
      this.keySize = 0;
      this.keySchedule = void 0;
      this.invKeySchedule = void 0;
      this.initTable();
    }
    // Using view.getUint32() also swaps the byte order.
    uint8ArrayToUint32Array_(arrayBuffer) {
      const view2 = new DataView(arrayBuffer);
      const newArray = new Uint32Array(4);
      for (let i = 0; i < 4; i++) {
        newArray[i] = view2.getUint32(i * 4);
      }
      return newArray;
    }
    initTable() {
      const sBox = this.sBox;
      const invSBox = this.invSBox;
      const subMix = this.subMix;
      const subMix0 = subMix[0];
      const subMix1 = subMix[1];
      const subMix2 = subMix[2];
      const subMix3 = subMix[3];
      const invSubMix = this.invSubMix;
      const invSubMix0 = invSubMix[0];
      const invSubMix1 = invSubMix[1];
      const invSubMix2 = invSubMix[2];
      const invSubMix3 = invSubMix[3];
      const d = new Uint32Array(256);
      let x = 0;
      let xi = 0;
      let i = 0;
      for (i = 0; i < 256; i++) {
        if (i < 128) {
          d[i] = i << 1;
        } else {
          d[i] = i << 1 ^ 283;
        }
      }
      for (i = 0; i < 256; i++) {
        let sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
        sx = sx >>> 8 ^ sx & 255 ^ 99;
        sBox[x] = sx;
        invSBox[sx] = x;
        const x2 = d[x];
        const x4 = d[x2];
        const x8 = d[x4];
        let t = d[sx] * 257 ^ sx * 16843008;
        subMix0[x] = t << 24 | t >>> 8;
        subMix1[x] = t << 16 | t >>> 16;
        subMix2[x] = t << 8 | t >>> 24;
        subMix3[x] = t;
        t = x8 * 16843009 ^ x4 * 65537 ^ x2 * 257 ^ x * 16843008;
        invSubMix0[sx] = t << 24 | t >>> 8;
        invSubMix1[sx] = t << 16 | t >>> 16;
        invSubMix2[sx] = t << 8 | t >>> 24;
        invSubMix3[sx] = t;
        if (!x) {
          x = xi = 1;
        } else {
          x = x2 ^ d[d[d[x8 ^ x2]]];
          xi ^= d[d[xi]];
        }
      }
    }
    expandKey(keyBuffer) {
      const key = this.uint8ArrayToUint32Array_(keyBuffer);
      let sameKey = true;
      let offset = 0;
      while (offset < key.length && sameKey) {
        sameKey = key[offset] === this.key[offset];
        offset++;
      }
      if (sameKey) {
        return;
      }
      this.key = key;
      const keySize = this.keySize = key.length;
      if (keySize !== 4 && keySize !== 6 && keySize !== 8) {
        throw new Error("Invalid aes key size=" + keySize);
      }
      const ksRows = this.ksRows = (keySize + 6 + 1) * 4;
      let ksRow;
      let invKsRow;
      const keySchedule = this.keySchedule = new Uint32Array(ksRows);
      const invKeySchedule = this.invKeySchedule = new Uint32Array(ksRows);
      const sbox = this.sBox;
      const rcon = this.rcon;
      const invSubMix = this.invSubMix;
      const invSubMix0 = invSubMix[0];
      const invSubMix1 = invSubMix[1];
      const invSubMix2 = invSubMix[2];
      const invSubMix3 = invSubMix[3];
      let prev;
      let t;
      for (ksRow = 0; ksRow < ksRows; ksRow++) {
        if (ksRow < keySize) {
          prev = keySchedule[ksRow] = key[ksRow];
          continue;
        }
        t = prev;
        if (ksRow % keySize === 0) {
          t = t << 8 | t >>> 24;
          t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 255] << 16 | sbox[t >>> 8 & 255] << 8 | sbox[t & 255];
          t ^= rcon[ksRow / keySize | 0] << 24;
        } else if (keySize > 6 && ksRow % keySize === 4) {
          t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 255] << 16 | sbox[t >>> 8 & 255] << 8 | sbox[t & 255];
        }
        keySchedule[ksRow] = prev = (keySchedule[ksRow - keySize] ^ t) >>> 0;
      }
      for (invKsRow = 0; invKsRow < ksRows; invKsRow++) {
        ksRow = ksRows - invKsRow;
        if (invKsRow & 3) {
          t = keySchedule[ksRow];
        } else {
          t = keySchedule[ksRow - 4];
        }
        if (invKsRow < 4 || ksRow <= 4) {
          invKeySchedule[invKsRow] = t;
        } else {
          invKeySchedule[invKsRow] = invSubMix0[sbox[t >>> 24]] ^ invSubMix1[sbox[t >>> 16 & 255]] ^ invSubMix2[sbox[t >>> 8 & 255]] ^ invSubMix3[sbox[t & 255]];
        }
        invKeySchedule[invKsRow] = invKeySchedule[invKsRow] >>> 0;
      }
    }
    // Adding this as a method greatly improves performance.
    networkToHostOrderSwap(word) {
      return word << 24 | (word & 65280) << 8 | (word & 16711680) >> 8 | word >>> 24;
    }
    decrypt(inputArrayBuffer, offset, aesIV) {
      const nRounds = this.keySize + 6;
      const invKeySchedule = this.invKeySchedule;
      const invSBOX = this.invSBox;
      const invSubMix = this.invSubMix;
      const invSubMix0 = invSubMix[0];
      const invSubMix1 = invSubMix[1];
      const invSubMix2 = invSubMix[2];
      const invSubMix3 = invSubMix[3];
      const initVector = this.uint8ArrayToUint32Array_(aesIV);
      let initVector0 = initVector[0];
      let initVector1 = initVector[1];
      let initVector2 = initVector[2];
      let initVector3 = initVector[3];
      const inputInt32 = new Int32Array(inputArrayBuffer);
      const outputInt32 = new Int32Array(inputInt32.length);
      let t0, t1, t2, t3;
      let s0, s1, s2, s3;
      let inputWords0, inputWords1, inputWords2, inputWords3;
      let ksRow, i;
      const swapWord = this.networkToHostOrderSwap;
      while (offset < inputInt32.length) {
        inputWords0 = swapWord(inputInt32[offset]);
        inputWords1 = swapWord(inputInt32[offset + 1]);
        inputWords2 = swapWord(inputInt32[offset + 2]);
        inputWords3 = swapWord(inputInt32[offset + 3]);
        s0 = inputWords0 ^ invKeySchedule[0];
        s1 = inputWords3 ^ invKeySchedule[1];
        s2 = inputWords2 ^ invKeySchedule[2];
        s3 = inputWords1 ^ invKeySchedule[3];
        ksRow = 4;
        for (i = 1; i < nRounds; i++) {
          t0 = invSubMix0[s0 >>> 24] ^ invSubMix1[s1 >> 16 & 255] ^ invSubMix2[s2 >> 8 & 255] ^ invSubMix3[s3 & 255] ^ invKeySchedule[ksRow];
          t1 = invSubMix0[s1 >>> 24] ^ invSubMix1[s2 >> 16 & 255] ^ invSubMix2[s3 >> 8 & 255] ^ invSubMix3[s0 & 255] ^ invKeySchedule[ksRow + 1];
          t2 = invSubMix0[s2 >>> 24] ^ invSubMix1[s3 >> 16 & 255] ^ invSubMix2[s0 >> 8 & 255] ^ invSubMix3[s1 & 255] ^ invKeySchedule[ksRow + 2];
          t3 = invSubMix0[s3 >>> 24] ^ invSubMix1[s0 >> 16 & 255] ^ invSubMix2[s1 >> 8 & 255] ^ invSubMix3[s2 & 255] ^ invKeySchedule[ksRow + 3];
          s0 = t0;
          s1 = t1;
          s2 = t2;
          s3 = t3;
          ksRow = ksRow + 4;
        }
        t0 = invSBOX[s0 >>> 24] << 24 ^ invSBOX[s1 >> 16 & 255] << 16 ^ invSBOX[s2 >> 8 & 255] << 8 ^ invSBOX[s3 & 255] ^ invKeySchedule[ksRow];
        t1 = invSBOX[s1 >>> 24] << 24 ^ invSBOX[s2 >> 16 & 255] << 16 ^ invSBOX[s3 >> 8 & 255] << 8 ^ invSBOX[s0 & 255] ^ invKeySchedule[ksRow + 1];
        t2 = invSBOX[s2 >>> 24] << 24 ^ invSBOX[s3 >> 16 & 255] << 16 ^ invSBOX[s0 >> 8 & 255] << 8 ^ invSBOX[s1 & 255] ^ invKeySchedule[ksRow + 2];
        t3 = invSBOX[s3 >>> 24] << 24 ^ invSBOX[s0 >> 16 & 255] << 16 ^ invSBOX[s1 >> 8 & 255] << 8 ^ invSBOX[s2 & 255] ^ invKeySchedule[ksRow + 3];
        outputInt32[offset] = swapWord(t0 ^ initVector0);
        outputInt32[offset + 1] = swapWord(t3 ^ initVector1);
        outputInt32[offset + 2] = swapWord(t2 ^ initVector2);
        outputInt32[offset + 3] = swapWord(t1 ^ initVector3);
        initVector0 = inputWords0;
        initVector1 = inputWords1;
        initVector2 = inputWords2;
        initVector3 = inputWords3;
        offset = offset + 4;
      }
      return outputInt32.buffer;
    }
  };
  var FastAESKey = class {
    constructor(subtle, key, aesMode) {
      this.subtle = void 0;
      this.key = void 0;
      this.aesMode = void 0;
      this.subtle = subtle;
      this.key = key;
      this.aesMode = aesMode;
    }
    expandKey() {
      const subtleAlgoName = getSubtleAlgoName(this.aesMode);
      return this.subtle.importKey("raw", this.key, {
        name: subtleAlgoName
      }, false, ["encrypt", "decrypt"]);
    }
  };
  function getSubtleAlgoName(aesMode) {
    switch (aesMode) {
      case DecrypterAesMode.cbc:
        return "AES-CBC";
      case DecrypterAesMode.ctr:
        return "AES-CTR";
      default:
        throw new Error(`[FastAESKey] invalid aes mode ${aesMode}`);
    }
  }
  var CHUNK_SIZE = 16;
  var Decrypter = class {
    constructor(config3, {
      removePKCS7Padding = true
    } = {}) {
      this.logEnabled = true;
      this.removePKCS7Padding = void 0;
      this.subtle = null;
      this.softwareDecrypter = null;
      this.key = null;
      this.fastAesKey = null;
      this.remainderData = null;
      this.currentIV = null;
      this.currentResult = null;
      this.useSoftware = void 0;
      this.enableSoftwareAES = void 0;
      this.enableSoftwareAES = config3.enableSoftwareAES;
      this.removePKCS7Padding = removePKCS7Padding;
      if (removePKCS7Padding) {
        try {
          const browserCrypto = self.crypto;
          if (browserCrypto) {
            this.subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;
          }
        } catch (e) {
        }
      }
      this.useSoftware = !this.subtle;
    }
    destroy() {
      this.subtle = null;
      this.softwareDecrypter = null;
      this.key = null;
      this.fastAesKey = null;
      this.remainderData = null;
      this.currentIV = null;
      this.currentResult = null;
    }
    isSync() {
      return this.useSoftware;
    }
    flush() {
      const {
        currentResult,
        remainderData
      } = this;
      if (!currentResult || remainderData) {
        this.reset();
        return null;
      }
      const data = new Uint8Array(currentResult);
      this.reset();
      if (this.removePKCS7Padding) {
        return removePadding(data);
      }
      return data;
    }
    reset() {
      this.currentResult = null;
      this.currentIV = null;
      this.remainderData = null;
      if (this.softwareDecrypter) {
        this.softwareDecrypter = null;
      }
    }
    decrypt(data, key, iv, aesMode) {
      if (this.useSoftware) {
        return new Promise((resolve, reject) => {
          const dataView = ArrayBuffer.isView(data) ? data : new Uint8Array(data);
          this.softwareDecrypt(dataView, key, iv, aesMode);
          const decryptResult = this.flush();
          if (decryptResult) {
            resolve(decryptResult.buffer);
          } else {
            reject(new Error("[softwareDecrypt] Failed to decrypt data"));
          }
        });
      }
      return this.webCryptoDecrypt(new Uint8Array(data), key, iv, aesMode);
    }
    // Software decryption is progressive. Progressive decryption may not return a result on each call. Any cached
    // data is handled in the flush() call
    softwareDecrypt(data, key, iv, aesMode) {
      const {
        currentIV,
        currentResult,
        remainderData
      } = this;
      if (aesMode !== DecrypterAesMode.cbc || key.byteLength !== 16) {
        logger.warn("SoftwareDecrypt: can only handle AES-128-CBC");
        return null;
      }
      this.logOnce("JS AES decrypt");
      if (remainderData) {
        data = appendUint8Array(remainderData, data);
        this.remainderData = null;
      }
      const currentChunk = this.getValidChunk(data);
      if (!currentChunk.length) {
        return null;
      }
      if (currentIV) {
        iv = currentIV;
      }
      let softwareDecrypter = this.softwareDecrypter;
      if (!softwareDecrypter) {
        softwareDecrypter = this.softwareDecrypter = new AESDecryptor();
      }
      softwareDecrypter.expandKey(key);
      const result = currentResult;
      this.currentResult = softwareDecrypter.decrypt(currentChunk.buffer, 0, iv);
      this.currentIV = currentChunk.slice(-16).buffer;
      if (!result) {
        return null;
      }
      return result;
    }
    webCryptoDecrypt(data, key, iv, aesMode) {
      if (this.key !== key || !this.fastAesKey) {
        if (!this.subtle) {
          return Promise.resolve(this.onWebCryptoError(data, key, iv, aesMode));
        }
        this.key = key;
        this.fastAesKey = new FastAESKey(this.subtle, key, aesMode);
      }
      return this.fastAesKey.expandKey().then((aesKey) => {
        if (!this.subtle) {
          return Promise.reject(new Error("web crypto not initialized"));
        }
        this.logOnce("WebCrypto AES decrypt");
        const crypto2 = new AESCrypto(this.subtle, new Uint8Array(iv), aesMode);
        return crypto2.decrypt(data.buffer, aesKey);
      }).catch((err) => {
        logger.warn(`[decrypter]: WebCrypto Error, disable WebCrypto API, ${err.name}: ${err.message}`);
        return this.onWebCryptoError(data, key, iv, aesMode);
      });
    }
    onWebCryptoError(data, key, iv, aesMode) {
      const enableSoftwareAES = this.enableSoftwareAES;
      if (enableSoftwareAES) {
        this.useSoftware = true;
        this.logEnabled = true;
        this.softwareDecrypt(data, key, iv, aesMode);
        const decryptResult = this.flush();
        if (decryptResult) {
          return decryptResult.buffer;
        }
      }
      throw new Error("WebCrypto" + (enableSoftwareAES ? " and softwareDecrypt" : "") + ": failed to decrypt data");
    }
    getValidChunk(data) {
      let currentChunk = data;
      const splitPoint = data.length - data.length % CHUNK_SIZE;
      if (splitPoint !== data.length) {
        currentChunk = data.slice(0, splitPoint);
        this.remainderData = data.slice(splitPoint);
      }
      return currentChunk;
    }
    logOnce(msg) {
      if (!this.logEnabled) {
        return;
      }
      logger.log(`[decrypter]: ${msg}`);
      this.logEnabled = false;
    }
  };
  var MIN_CHUNK_SIZE = Math.pow(2, 17);
  var FragmentLoader = class {
    constructor(config3) {
      this.config = void 0;
      this.loader = null;
      this.partLoadTimeout = -1;
      this.config = config3;
    }
    destroy() {
      if (this.loader) {
        this.loader.destroy();
        this.loader = null;
      }
    }
    abort() {
      if (this.loader) {
        this.loader.abort();
      }
    }
    load(frag, onProgress) {
      const url = frag.url;
      if (!url) {
        return Promise.reject(new LoadError({
          type: ErrorTypes.NETWORK_ERROR,
          details: ErrorDetails.FRAG_LOAD_ERROR,
          fatal: false,
          frag,
          error: new Error(`Fragment does not have a ${url ? "part list" : "url"}`),
          networkDetails: null
        }));
      }
      this.abort();
      const config3 = this.config;
      const FragmentILoader = config3.fLoader;
      const DefaultILoader = config3.loader;
      return new Promise((resolve, reject) => {
        if (this.loader) {
          this.loader.destroy();
        }
        if (frag.gap) {
          if (frag.tagList.some((tags) => tags[0] === "GAP")) {
            reject(createGapLoadError(frag));
            return;
          } else {
            frag.gap = false;
          }
        }
        const loader = this.loader = FragmentILoader ? new FragmentILoader(config3) : new DefaultILoader(config3);
        const loaderContext = createLoaderContext(frag);
        frag.loader = loader;
        const loadPolicy = getLoaderConfigWithoutReties(config3.fragLoadPolicy.default);
        const loaderConfig = {
          loadPolicy,
          timeout: loadPolicy.maxLoadTimeMs,
          maxRetry: 0,
          retryDelay: 0,
          maxRetryDelay: 0,
          highWaterMark: frag.sn === "initSegment" ? Infinity : MIN_CHUNK_SIZE
        };
        frag.stats = loader.stats;
        const callbacks = {
          onSuccess: (response, stats, context3, networkDetails) => {
            this.resetLoader(frag, loader);
            let payload = response.data;
            if (context3.resetIV && frag.decryptdata) {
              frag.decryptdata.iv = new Uint8Array(payload.slice(0, 16));
              payload = payload.slice(16);
            }
            resolve({
              frag,
              part: null,
              payload,
              networkDetails
            });
          },
          onError: (response, context3, networkDetails, stats) => {
            this.resetLoader(frag, loader);
            reject(new LoadError({
              type: ErrorTypes.NETWORK_ERROR,
              details: ErrorDetails.FRAG_LOAD_ERROR,
              fatal: false,
              frag,
              response: _objectSpread2({
                url,
                data: void 0
              }, response),
              error: new Error(`HTTP Error ${response.code} ${response.text}`),
              networkDetails,
              stats
            }));
          },
          onAbort: (stats, context3, networkDetails) => {
            this.resetLoader(frag, loader);
            reject(new LoadError({
              type: ErrorTypes.NETWORK_ERROR,
              details: ErrorDetails.INTERNAL_ABORTED,
              fatal: false,
              frag,
              error: new Error("Aborted"),
              networkDetails,
              stats
            }));
          },
          onTimeout: (stats, context3, networkDetails) => {
            this.resetLoader(frag, loader);
            reject(new LoadError({
              type: ErrorTypes.NETWORK_ERROR,
              details: ErrorDetails.FRAG_LOAD_TIMEOUT,
              fatal: false,
              frag,
              error: new Error(`Timeout after ${loaderConfig.timeout}ms`),
              networkDetails,
              stats
            }));
          }
        };
        if (onProgress) {
          callbacks.onProgress = (stats, context3, data, networkDetails) => onProgress({
            frag,
            part: null,
            payload: data,
            networkDetails
          });
        }
        loader.load(loaderContext, loaderConfig, callbacks);
      });
    }
    loadPart(frag, part, onProgress) {
      this.abort();
      const config3 = this.config;
      const FragmentILoader = config3.fLoader;
      const DefaultILoader = config3.loader;
      return new Promise((resolve, reject) => {
        if (this.loader) {
          this.loader.destroy();
        }
        if (frag.gap || part.gap) {
          reject(createGapLoadError(frag, part));
          return;
        }
        const loader = this.loader = FragmentILoader ? new FragmentILoader(config3) : new DefaultILoader(config3);
        const loaderContext = createLoaderContext(frag, part);
        frag.loader = loader;
        const loadPolicy = getLoaderConfigWithoutReties(config3.fragLoadPolicy.default);
        const loaderConfig = {
          loadPolicy,
          timeout: loadPolicy.maxLoadTimeMs,
          maxRetry: 0,
          retryDelay: 0,
          maxRetryDelay: 0,
          highWaterMark: MIN_CHUNK_SIZE
        };
        part.stats = loader.stats;
        loader.load(loaderContext, loaderConfig, {
          onSuccess: (response, stats, context3, networkDetails) => {
            this.resetLoader(frag, loader);
            this.updateStatsFromPart(frag, part);
            const partLoadedData = {
              frag,
              part,
              payload: response.data,
              networkDetails
            };
            onProgress(partLoadedData);
            resolve(partLoadedData);
          },
          onError: (response, context3, networkDetails, stats) => {
            this.resetLoader(frag, loader);
            reject(new LoadError({
              type: ErrorTypes.NETWORK_ERROR,
              details: ErrorDetails.FRAG_LOAD_ERROR,
              fatal: false,
              frag,
              part,
              response: _objectSpread2({
                url: loaderContext.url,
                data: void 0
              }, response),
              error: new Error(`HTTP Error ${response.code} ${response.text}`),
              networkDetails,
              stats
            }));
          },
          onAbort: (stats, context3, networkDetails) => {
            frag.stats.aborted = part.stats.aborted;
            this.resetLoader(frag, loader);
            reject(new LoadError({
              type: ErrorTypes.NETWORK_ERROR,
              details: ErrorDetails.INTERNAL_ABORTED,
              fatal: false,
              frag,
              part,
              error: new Error("Aborted"),
              networkDetails,
              stats
            }));
          },
          onTimeout: (stats, context3, networkDetails) => {
            this.resetLoader(frag, loader);
            reject(new LoadError({
              type: ErrorTypes.NETWORK_ERROR,
              details: ErrorDetails.FRAG_LOAD_TIMEOUT,
              fatal: false,
              frag,
              part,
              error: new Error(`Timeout after ${loaderConfig.timeout}ms`),
              networkDetails,
              stats
            }));
          }
        });
      });
    }
    updateStatsFromPart(frag, part) {
      const fragStats = frag.stats;
      const partStats = part.stats;
      const partTotal = partStats.total;
      fragStats.loaded += partStats.loaded;
      if (partTotal) {
        const estTotalParts = Math.round(frag.duration / part.duration);
        const estLoadedParts = Math.min(Math.round(fragStats.loaded / partTotal), estTotalParts);
        const estRemainingParts = estTotalParts - estLoadedParts;
        const estRemainingBytes = estRemainingParts * Math.round(fragStats.loaded / estLoadedParts);
        fragStats.total = fragStats.loaded + estRemainingBytes;
      } else {
        fragStats.total = Math.max(fragStats.loaded, fragStats.total);
      }
      const fragLoading = fragStats.loading;
      const partLoading = partStats.loading;
      if (fragLoading.start) {
        fragLoading.first += partLoading.first - partLoading.start;
      } else {
        fragLoading.start = partLoading.start;
        fragLoading.first = partLoading.first;
      }
      fragLoading.end = partLoading.end;
    }
    resetLoader(frag, loader) {
      frag.loader = null;
      if (this.loader === loader) {
        self.clearTimeout(this.partLoadTimeout);
        this.loader = null;
      }
      loader.destroy();
    }
  };
  function createLoaderContext(frag, part = null) {
    const segment = part || frag;
    const loaderContext = {
      frag,
      part,
      responseType: "arraybuffer",
      url: segment.url,
      headers: {},
      rangeStart: 0,
      rangeEnd: 0
    };
    const start = segment.byteRangeStartOffset;
    const end = segment.byteRangeEndOffset;
    if (isFiniteNumber(start) && isFiniteNumber(end)) {
      var _frag$decryptdata;
      let byteRangeStart = start;
      let byteRangeEnd = end;
      if (frag.sn === "initSegment" && isMethodFullSegmentAesCbc((_frag$decryptdata = frag.decryptdata) == null ? void 0 : _frag$decryptdata.method)) {
        const fragmentLen = end - start;
        if (fragmentLen % 16) {
          byteRangeEnd = end + (16 - fragmentLen % 16);
        }
        if (start !== 0) {
          loaderContext.resetIV = true;
          byteRangeStart = start - 16;
        }
      }
      loaderContext.rangeStart = byteRangeStart;
      loaderContext.rangeEnd = byteRangeEnd;
    }
    return loaderContext;
  }
  function createGapLoadError(frag, part) {
    const error = new Error(`GAP ${frag.gap ? "tag" : "attribute"} found`);
    const errorData = {
      type: ErrorTypes.MEDIA_ERROR,
      details: ErrorDetails.FRAG_GAP,
      fatal: false,
      frag,
      error,
      networkDetails: null
    };
    if (part) {
      errorData.part = part;
    }
    (part ? part : frag).stats.aborted = true;
    return new LoadError(errorData);
  }
  function isMethodFullSegmentAesCbc(method) {
    return method === "AES-128" || method === "AES-256";
  }
  var LoadError = class extends Error {
    constructor(data) {
      super(data.error.message);
      this.data = void 0;
      this.data = data;
    }
  };
  var TaskLoop = class extends Logger {
    constructor(label, logger2) {
      super(label, logger2);
      this._boundTick = void 0;
      this._tickTimer = null;
      this._tickInterval = null;
      this._tickCallCount = 0;
      this._boundTick = this.tick.bind(this);
    }
    destroy() {
      this.onHandlerDestroying();
      this.onHandlerDestroyed();
    }
    onHandlerDestroying() {
      this.clearNextTick();
      this.clearInterval();
    }
    onHandlerDestroyed() {
    }
    hasInterval() {
      return !!this._tickInterval;
    }
    hasNextTick() {
      return !!this._tickTimer;
    }
    /**
     * @param millis - Interval time (ms)
     * @eturns True when interval has been scheduled, false when already scheduled (no effect)
     */
    setInterval(millis) {
      if (!this._tickInterval) {
        this._tickCallCount = 0;
        this._tickInterval = self.setInterval(this._boundTick, millis);
        return true;
      }
      return false;
    }
    /**
     * @returns True when interval was cleared, false when none was set (no effect)
     */
    clearInterval() {
      if (this._tickInterval) {
        self.clearInterval(this._tickInterval);
        this._tickInterval = null;
        return true;
      }
      return false;
    }
    /**
     * @returns True when timeout was cleared, false when none was set (no effect)
     */
    clearNextTick() {
      if (this._tickTimer) {
        self.clearTimeout(this._tickTimer);
        this._tickTimer = null;
        return true;
      }
      return false;
    }
    /**
     * Will call the subclass doTick implementation in this main loop tick
     * or in the next one (via setTimeout(,0)) in case it has already been called
     * in this tick (in case this is a re-entrant call).
     */
    tick() {
      this._tickCallCount++;
      if (this._tickCallCount === 1) {
        this.doTick();
        if (this._tickCallCount > 1) {
          this.tickImmediate();
        }
        this._tickCallCount = 0;
      }
    }
    tickImmediate() {
      this.clearNextTick();
      this._tickTimer = self.setTimeout(this._boundTick, 0);
    }
    /**
     * For subclass to implement task logic
     * @abstract
     */
    doTick() {
    }
  };
  var ChunkMetadata = class {
    constructor(level, sn, id3, size = 0, part = -1, partial = false) {
      this.level = void 0;
      this.sn = void 0;
      this.part = void 0;
      this.id = void 0;
      this.size = void 0;
      this.partial = void 0;
      this.transmuxing = getNewPerformanceTiming();
      this.buffering = {
        audio: getNewPerformanceTiming(),
        video: getNewPerformanceTiming(),
        audiovideo: getNewPerformanceTiming()
      };
      this.level = level;
      this.sn = sn;
      this.id = id3;
      this.size = size;
      this.part = part;
      this.partial = partial;
    }
  };
  function getNewPerformanceTiming() {
    return {
      start: 0,
      executeStart: 0,
      executeEnd: 0,
      end: 0
    };
  }
  var noopBuffered = {
    length: 0,
    start: () => 0,
    end: () => 0
  };
  var BufferHelper = class _BufferHelper {
    /**
     * Return true if `media`'s buffered include `position`
     */
    static isBuffered(media, position) {
      if (media) {
        const buffered = _BufferHelper.getBuffered(media);
        for (let i = buffered.length; i--; ) {
          if (position >= buffered.start(i) && position <= buffered.end(i)) {
            return true;
          }
        }
      }
      return false;
    }
    static bufferedRanges(media) {
      if (media) {
        const timeRanges = _BufferHelper.getBuffered(media);
        return _BufferHelper.timeRangesToArray(timeRanges);
      }
      return [];
    }
    static timeRangesToArray(timeRanges) {
      const buffered = [];
      for (let i = 0; i < timeRanges.length; i++) {
        buffered.push({
          start: timeRanges.start(i),
          end: timeRanges.end(i)
        });
      }
      return buffered;
    }
    static bufferInfo(media, pos, maxHoleDuration) {
      if (media) {
        const buffered = _BufferHelper.bufferedRanges(media);
        if (buffered.length) {
          return _BufferHelper.bufferedInfo(buffered, pos, maxHoleDuration);
        }
      }
      return {
        len: 0,
        start: pos,
        end: pos,
        bufferedIndex: -1
      };
    }
    static bufferedInfo(buffered, pos, maxHoleDuration) {
      pos = Math.max(0, pos);
      if (buffered.length > 1) {
        buffered.sort((a, b) => a.start - b.start || b.end - a.end);
      }
      let bufferedIndex = -1;
      let buffered2 = [];
      if (maxHoleDuration) {
        for (let i = 0; i < buffered.length; i++) {
          if (pos >= buffered[i].start && pos <= buffered[i].end) {
            bufferedIndex = i;
          }
          const buf2len = buffered2.length;
          if (buf2len) {
            const buf2end = buffered2[buf2len - 1].end;
            if (buffered[i].start - buf2end < maxHoleDuration) {
              if (buffered[i].end > buf2end) {
                buffered2[buf2len - 1].end = buffered[i].end;
              }
            } else {
              buffered2.push(buffered[i]);
            }
          } else {
            buffered2.push(buffered[i]);
          }
        }
      } else {
        buffered2 = buffered;
      }
      let bufferLen = 0;
      let nextStart;
      let bufferStart = pos;
      let bufferEnd = pos;
      for (let i = 0; i < buffered2.length; i++) {
        const start = buffered2[i].start;
        const end = buffered2[i].end;
        if (bufferedIndex === -1 && pos >= start && pos <= end) {
          bufferedIndex = i;
        }
        if (pos + maxHoleDuration >= start && pos < end) {
          bufferStart = start;
          bufferEnd = end;
          bufferLen = bufferEnd - pos;
        } else if (pos + maxHoleDuration < start) {
          nextStart = start;
          break;
        }
      }
      return {
        len: bufferLen,
        start: bufferStart || 0,
        end: bufferEnd || 0,
        nextStart,
        buffered,
        bufferedIndex
      };
    }
    /**
     * Safe method to get buffered property.
     * SourceBuffer.buffered may throw if SourceBuffer is removed from it's MediaSource
     */
    static getBuffered(media) {
      try {
        return media.buffered || noopBuffered;
      } catch (e) {
        logger.log("failed to get media.buffered", e);
        return noopBuffered;
      }
    }
  };
  var VARIABLE_REPLACEMENT_REGEX = /\{\$([a-zA-Z0-9-_]+)\}/g;
  function hasVariableReferences(str) {
    return VARIABLE_REPLACEMENT_REGEX.test(str);
  }
  function substituteVariables(parsed, value) {
    if (parsed.variableList !== null || parsed.hasVariableRefs) {
      const variableList = parsed.variableList;
      return value.replace(VARIABLE_REPLACEMENT_REGEX, (variableReference) => {
        const variableName = variableReference.substring(2, variableReference.length - 1);
        const variableValue = variableList == null ? void 0 : variableList[variableName];
        if (variableValue === void 0) {
          parsed.playlistParsingError || (parsed.playlistParsingError = new Error(`Missing preceding EXT-X-DEFINE tag for Variable Reference: "${variableName}"`));
          return variableReference;
        }
        return variableValue;
      });
    }
    return value;
  }
  function addVariableDefinition(parsed, attr, parentUrl) {
    let variableList = parsed.variableList;
    if (!variableList) {
      parsed.variableList = variableList = {};
    }
    let NAME;
    let VALUE;
    if ("QUERYPARAM" in attr) {
      NAME = attr.QUERYPARAM;
      try {
        const searchParams = new self.URL(parentUrl).searchParams;
        if (searchParams.has(NAME)) {
          VALUE = searchParams.get(NAME);
        } else {
          throw new Error(`"${NAME}" does not match any query parameter in URI: "${parentUrl}"`);
        }
      } catch (error) {
        parsed.playlistParsingError || (parsed.playlistParsingError = new Error(`EXT-X-DEFINE QUERYPARAM: ${error.message}`));
      }
    } else {
      NAME = attr.NAME;
      VALUE = attr.VALUE;
    }
    if (NAME in variableList) {
      parsed.playlistParsingError || (parsed.playlistParsingError = new Error(`EXT-X-DEFINE duplicate Variable Name declarations: "${NAME}"`));
    } else {
      variableList[NAME] = VALUE || "";
    }
  }
  function importVariableDefinition(parsed, attr, sourceVariableList) {
    const IMPORT = attr.IMPORT;
    if (sourceVariableList && IMPORT in sourceVariableList) {
      let variableList = parsed.variableList;
      if (!variableList) {
        parsed.variableList = variableList = {};
      }
      variableList[IMPORT] = sourceVariableList[IMPORT];
    } else {
      parsed.playlistParsingError || (parsed.playlistParsingError = new Error(`EXT-X-DEFINE IMPORT attribute not found in Multivariant Playlist: "${IMPORT}"`));
    }
  }
  var DECIMAL_RESOLUTION_REGEX = /^(\d+)x(\d+)$/;
  var ATTR_LIST_REGEX = /(.+?)=(".*?"|.*?)(?:,|$)/g;
  var AttrList = class _AttrList {
    constructor(attrs, parsed) {
      if (typeof attrs === "string") {
        attrs = _AttrList.parseAttrList(attrs, parsed);
      }
      _extends4(this, attrs);
    }
    get clientAttrs() {
      return Object.keys(this).filter((attr) => attr.substring(0, 2) === "X-");
    }
    decimalInteger(attrName) {
      const intValue = parseInt(this[attrName], 10);
      if (intValue > Number.MAX_SAFE_INTEGER) {
        return Infinity;
      }
      return intValue;
    }
    hexadecimalInteger(attrName) {
      if (this[attrName]) {
        let stringValue = (this[attrName] || "0x").slice(2);
        stringValue = (stringValue.length & 1 ? "0" : "") + stringValue;
        const value = new Uint8Array(stringValue.length / 2);
        for (let i = 0; i < stringValue.length / 2; i++) {
          value[i] = parseInt(stringValue.slice(i * 2, i * 2 + 2), 16);
        }
        return value;
      }
      return null;
    }
    hexadecimalIntegerAsNumber(attrName) {
      const intValue = parseInt(this[attrName], 16);
      if (intValue > Number.MAX_SAFE_INTEGER) {
        return Infinity;
      }
      return intValue;
    }
    decimalFloatingPoint(attrName) {
      return parseFloat(this[attrName]);
    }
    optionalFloat(attrName, defaultValue) {
      const value = this[attrName];
      return value ? parseFloat(value) : defaultValue;
    }
    enumeratedString(attrName) {
      return this[attrName];
    }
    enumeratedStringList(attrName, dict) {
      const attrValue = this[attrName];
      return (attrValue ? attrValue.split(/[ ,]+/) : []).reduce((result, identifier) => {
        result[identifier.toLowerCase()] = true;
        return result;
      }, dict);
    }
    bool(attrName) {
      return this[attrName] === "YES";
    }
    decimalResolution(attrName) {
      const res = DECIMAL_RESOLUTION_REGEX.exec(this[attrName]);
      if (res === null) {
        return void 0;
      }
      return {
        width: parseInt(res[1], 10),
        height: parseInt(res[2], 10)
      };
    }
    static parseAttrList(input, parsed) {
      let match;
      const attrs = {};
      const quote = '"';
      ATTR_LIST_REGEX.lastIndex = 0;
      while ((match = ATTR_LIST_REGEX.exec(input)) !== null) {
        const name = match[1].trim();
        let value = match[2];
        const quotedString = value.indexOf(quote) === 0 && value.lastIndexOf(quote) === value.length - 1;
        let hexadecimalSequence = false;
        if (quotedString) {
          value = value.slice(1, -1);
        } else {
          switch (name) {
            case "IV":
            case "SCTE35-CMD":
            case "SCTE35-IN":
            case "SCTE35-OUT":
              hexadecimalSequence = true;
          }
        }
        if (parsed && (quotedString || hexadecimalSequence)) {
          {
            value = substituteVariables(parsed, value);
          }
        } else if (!hexadecimalSequence && !quotedString) {
          switch (name) {
            case "CLOSED-CAPTIONS":
              if (value === "NONE") {
                break;
              }
            // falls through
            case "ALLOWED-CPC":
            case "CLASS":
            case "ASSOC-LANGUAGE":
            case "AUDIO":
            case "BYTERANGE":
            case "CHANNELS":
            case "CHARACTERISTICS":
            case "CODECS":
            case "DATA-ID":
            case "END-DATE":
            case "GROUP-ID":
            case "ID":
            case "IMPORT":
            case "INSTREAM-ID":
            case "KEYFORMAT":
            case "KEYFORMATVERSIONS":
            case "LANGUAGE":
            case "NAME":
            case "PATHWAY-ID":
            case "QUERYPARAM":
            case "RECENTLY-REMOVED-DATERANGES":
            case "SERVER-URI":
            case "STABLE-RENDITION-ID":
            case "STABLE-VARIANT-ID":
            case "START-DATE":
            case "SUBTITLES":
            case "SUPPLEMENTAL-CODECS":
            case "URI":
            case "VALUE":
            case "VIDEO":
            case "X-ASSET-LIST":
            case "X-ASSET-URI":
              logger.warn(`${input}: attribute ${name} is missing quotes`);
          }
        }
        attrs[name] = value;
      }
      return attrs;
    }
  };
  var CLASS_INTERSTITIAL = "com.apple.hls.interstitial";
  function isDateRangeCueAttribute(attrName) {
    return attrName !== "ID" && attrName !== "CLASS" && attrName !== "CUE" && attrName !== "START-DATE" && attrName !== "DURATION" && attrName !== "END-DATE" && attrName !== "END-ON-NEXT";
  }
  function isSCTE35Attribute(attrName) {
    return attrName === "SCTE35-OUT" || attrName === "SCTE35-IN" || attrName === "SCTE35-CMD";
  }
  var DateRange = class {
    constructor(dateRangeAttr, dateRangeWithSameId, tagCount = 0) {
      var _dateRangeWithSameId$;
      this.attr = void 0;
      this.tagAnchor = void 0;
      this.tagOrder = void 0;
      this._startDate = void 0;
      this._endDate = void 0;
      this._dateAtEnd = void 0;
      this._cue = void 0;
      this._badValueForSameId = void 0;
      this.tagAnchor = (dateRangeWithSameId == null ? void 0 : dateRangeWithSameId.tagAnchor) || null;
      this.tagOrder = (_dateRangeWithSameId$ = dateRangeWithSameId == null ? void 0 : dateRangeWithSameId.tagOrder) != null ? _dateRangeWithSameId$ : tagCount;
      if (dateRangeWithSameId) {
        const previousAttr = dateRangeWithSameId.attr;
        for (const key in previousAttr) {
          if (Object.prototype.hasOwnProperty.call(dateRangeAttr, key) && dateRangeAttr[key] !== previousAttr[key]) {
            logger.warn(`DATERANGE tag attribute: "${key}" does not match for tags with ID: "${dateRangeAttr.ID}"`);
            this._badValueForSameId = key;
            break;
          }
        }
        dateRangeAttr = _extends4(new AttrList({}), previousAttr, dateRangeAttr);
      }
      this.attr = dateRangeAttr;
      if (dateRangeWithSameId) {
        this._startDate = dateRangeWithSameId._startDate;
        this._cue = dateRangeWithSameId._cue;
        this._endDate = dateRangeWithSameId._endDate;
        this._dateAtEnd = dateRangeWithSameId._dateAtEnd;
      } else {
        this._startDate = new Date(dateRangeAttr["START-DATE"]);
      }
      if ("END-DATE" in this.attr) {
        const endDate = (dateRangeWithSameId == null ? void 0 : dateRangeWithSameId.endDate) || new Date(this.attr["END-DATE"]);
        if (isFiniteNumber(endDate.getTime())) {
          this._endDate = endDate;
        }
      }
    }
    get id() {
      return this.attr.ID;
    }
    get class() {
      return this.attr.CLASS;
    }
    get cue() {
      const _cue = this._cue;
      if (_cue === void 0) {
        return this._cue = this.attr.enumeratedStringList(this.attr.CUE ? "CUE" : "X-CUE", {
          pre: false,
          post: false,
          once: false
        });
      }
      return _cue;
    }
    get startTime() {
      const {
        tagAnchor
      } = this;
      if (tagAnchor === null || tagAnchor.programDateTime === null) {
        logger.warn(`Expected tagAnchor Fragment with PDT set for DateRange "${this.id}": ${tagAnchor}`);
        return NaN;
      }
      return tagAnchor.start + (this.startDate.getTime() - tagAnchor.programDateTime) / 1e3;
    }
    get startDate() {
      return this._startDate;
    }
    get endDate() {
      const dateAtEnd = this._endDate || this._dateAtEnd;
      if (dateAtEnd) {
        return dateAtEnd;
      }
      const duration = this.duration;
      if (duration !== null) {
        return this._dateAtEnd = new Date(this._startDate.getTime() + duration * 1e3);
      }
      return null;
    }
    get duration() {
      if ("DURATION" in this.attr) {
        const duration = this.attr.decimalFloatingPoint("DURATION");
        if (isFiniteNumber(duration)) {
          return duration;
        }
      } else if (this._endDate) {
        return (this._endDate.getTime() - this._startDate.getTime()) / 1e3;
      }
      return null;
    }
    get plannedDuration() {
      if ("PLANNED-DURATION" in this.attr) {
        return this.attr.decimalFloatingPoint("PLANNED-DURATION");
      }
      return null;
    }
    get endOnNext() {
      return this.attr.bool("END-ON-NEXT");
    }
    get isInterstitial() {
      return this.class === CLASS_INTERSTITIAL;
    }
    get isValid() {
      return !!this.id && !this._badValueForSameId && isFiniteNumber(this.startDate.getTime()) && (this.duration === null || this.duration >= 0) && (!this.endOnNext || !!this.class) && (!this.attr.CUE || !this.cue.pre && !this.cue.post || this.cue.pre !== this.cue.post) && (!this.isInterstitial || "X-ASSET-URI" in this.attr || "X-ASSET-LIST" in this.attr);
    }
  };
  var DEFAULT_TARGET_DURATION = 10;
  var LevelDetails = class {
    constructor(baseUrl) {
      this.PTSKnown = false;
      this.alignedSliding = false;
      this.averagetargetduration = void 0;
      this.endCC = 0;
      this.endSN = 0;
      this.fragments = void 0;
      this.fragmentHint = void 0;
      this.partList = null;
      this.dateRanges = void 0;
      this.dateRangeTagCount = 0;
      this.live = true;
      this.requestScheduled = -1;
      this.ageHeader = 0;
      this.advancedDateTime = void 0;
      this.updated = true;
      this.advanced = true;
      this.misses = 0;
      this.startCC = 0;
      this.startSN = 0;
      this.startTimeOffset = null;
      this.targetduration = 0;
      this.totalduration = 0;
      this.type = null;
      this.url = void 0;
      this.m3u8 = "";
      this.version = null;
      this.canBlockReload = false;
      this.canSkipUntil = 0;
      this.canSkipDateRanges = false;
      this.skippedSegments = 0;
      this.recentlyRemovedDateranges = void 0;
      this.partHoldBack = 0;
      this.holdBack = 0;
      this.partTarget = 0;
      this.preloadHint = void 0;
      this.renditionReports = void 0;
      this.tuneInGoal = 0;
      this.deltaUpdateFailed = void 0;
      this.driftStartTime = 0;
      this.driftEndTime = 0;
      this.driftStart = 0;
      this.driftEnd = 0;
      this.encryptedFragments = void 0;
      this.playlistParsingError = null;
      this.variableList = null;
      this.hasVariableRefs = false;
      this.appliedTimelineOffset = void 0;
      this.fragments = [];
      this.encryptedFragments = [];
      this.dateRanges = {};
      this.url = baseUrl;
    }
    reloaded(previous) {
      if (!previous) {
        this.advanced = true;
        this.updated = true;
        return;
      }
      const partSnDiff = this.lastPartSn - previous.lastPartSn;
      const partIndexDiff = this.lastPartIndex - previous.lastPartIndex;
      this.updated = this.endSN !== previous.endSN || !!partIndexDiff || !!partSnDiff || !this.live;
      this.advanced = this.endSN > previous.endSN || partSnDiff > 0 || partSnDiff === 0 && partIndexDiff > 0;
      if (this.updated || this.advanced) {
        this.misses = Math.floor(previous.misses * 0.6);
      } else {
        this.misses = previous.misses + 1;
      }
    }
    hasKey(levelKey) {
      return this.encryptedFragments.some((frag) => {
        let decryptdata = frag.decryptdata;
        if (!decryptdata) {
          frag.setKeyFormat(levelKey.keyFormat);
          decryptdata = frag.decryptdata;
        }
        return !!decryptdata && levelKey.matches(decryptdata);
      });
    }
    get hasProgramDateTime() {
      if (this.fragments.length) {
        return isFiniteNumber(this.fragments[this.fragments.length - 1].programDateTime);
      }
      return false;
    }
    get levelTargetDuration() {
      return this.averagetargetduration || this.targetduration || DEFAULT_TARGET_DURATION;
    }
    get drift() {
      const runTime = this.driftEndTime - this.driftStartTime;
      if (runTime > 0) {
        const runDuration = this.driftEnd - this.driftStart;
        return runDuration * 1e3 / runTime;
      }
      return 1;
    }
    get edge() {
      return this.partEnd || this.fragmentEnd;
    }
    get partEnd() {
      var _this$partList;
      if ((_this$partList = this.partList) != null && _this$partList.length) {
        return this.partList[this.partList.length - 1].end;
      }
      return this.fragmentEnd;
    }
    get fragmentEnd() {
      if (this.fragments.length) {
        return this.fragments[this.fragments.length - 1].end;
      }
      return 0;
    }
    get fragmentStart() {
      if (this.fragments.length) {
        return this.fragments[0].start;
      }
      return 0;
    }
    get age() {
      if (this.advancedDateTime) {
        return Math.max(Date.now() - this.advancedDateTime, 0) / 1e3;
      }
      return 0;
    }
    get lastPartIndex() {
      var _this$partList2;
      if ((_this$partList2 = this.partList) != null && _this$partList2.length) {
        return this.partList[this.partList.length - 1].index;
      }
      return -1;
    }
    get maxPartIndex() {
      const partList = this.partList;
      if (partList) {
        const lastIndex = this.lastPartIndex;
        if (lastIndex !== -1) {
          for (let i = partList.length; i--; ) {
            if (partList[i].index > lastIndex) {
              return partList[i].index;
            }
          }
          return lastIndex;
        }
      }
      return 0;
    }
    get lastPartSn() {
      var _this$partList3;
      if ((_this$partList3 = this.partList) != null && _this$partList3.length) {
        return this.partList[this.partList.length - 1].fragment.sn;
      }
      return this.endSN;
    }
    get expired() {
      if (this.live && this.age && this.misses < 3) {
        const playlistWindowDuration = this.partEnd - this.fragmentStart;
        return this.age > Math.max(playlistWindowDuration, this.totalduration) + this.levelTargetDuration;
      }
      return false;
    }
  };
  function arrayValuesMatch(a, b) {
    if (a.length === b.length) {
      return !a.some((value, i) => value !== b[i]);
    }
    return false;
  }
  function optionalArrayValuesMatch(a, b) {
    if (!a && !b) {
      return true;
    }
    if (!a || !b) {
      return false;
    }
    return arrayValuesMatch(a, b);
  }
  function isFullSegmentEncryption(method) {
    return method === "AES-128" || method === "AES-256" || method === "AES-256-CTR";
  }
  function getAesModeFromFullSegmentMethod(method) {
    switch (method) {
      case "AES-128":
      case "AES-256":
        return DecrypterAesMode.cbc;
      case "AES-256-CTR":
        return DecrypterAesMode.ctr;
      default:
        throw new Error(`invalid full segment method ${method}`);
    }
  }
  function base64Decode(base64encodedStr) {
    return Uint8Array.from(atob(base64encodedStr), (c) => c.charCodeAt(0));
  }
  function strToUtf8array(str) {
    return Uint8Array.from(unescape(encodeURIComponent(str)), (c) => c.charCodeAt(0));
  }
  function getKeyIdBytes(str) {
    const keyIdbytes = strToUtf8array(str).subarray(0, 16);
    const paddedkeyIdbytes = new Uint8Array(16);
    paddedkeyIdbytes.set(keyIdbytes, 16 - keyIdbytes.length);
    return paddedkeyIdbytes;
  }
  function changeEndianness(keyId) {
    const swap = function swap2(array, from, to) {
      const cur = array[from];
      array[from] = array[to];
      array[to] = cur;
    };
    swap(keyId, 0, 3);
    swap(keyId, 1, 2);
    swap(keyId, 4, 5);
    swap(keyId, 6, 7);
  }
  function convertDataUriToArrayBytes(uri) {
    const colonsplit = uri.split(":");
    let keydata = null;
    if (colonsplit[0] === "data" && colonsplit.length === 2) {
      const semicolonsplit = colonsplit[1].split(";");
      const commasplit = semicolonsplit[semicolonsplit.length - 1].split(",");
      if (commasplit.length === 2) {
        const isbase64 = commasplit[0] === "base64";
        const data = commasplit[1];
        if (isbase64) {
          semicolonsplit.splice(-1, 1);
          keydata = base64Decode(data);
        } else {
          keydata = getKeyIdBytes(data);
        }
      }
    }
    return keydata;
  }
  var optionalSelf = typeof self !== "undefined" ? self : void 0;
  var KeySystems = {
    CLEARKEY: "org.w3.clearkey",
    FAIRPLAY: "com.apple.fps",
    PLAYREADY: "com.microsoft.playready",
    WIDEVINE: "com.widevine.alpha"
  };
  var KeySystemFormats = {
    CLEARKEY: "org.w3.clearkey",
    FAIRPLAY: "com.apple.streamingkeydelivery",
    PLAYREADY: "com.microsoft.playready",
    WIDEVINE: "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed"
  };
  function keySystemFormatToKeySystemDomain(format2) {
    switch (format2) {
      case KeySystemFormats.FAIRPLAY:
        return KeySystems.FAIRPLAY;
      case KeySystemFormats.PLAYREADY:
        return KeySystems.PLAYREADY;
      case KeySystemFormats.WIDEVINE:
        return KeySystems.WIDEVINE;
      case KeySystemFormats.CLEARKEY:
        return KeySystems.CLEARKEY;
    }
  }
  function keySystemDomainToKeySystemFormat(keySystem) {
    switch (keySystem) {
      case KeySystems.FAIRPLAY:
        return KeySystemFormats.FAIRPLAY;
      case KeySystems.PLAYREADY:
        return KeySystemFormats.PLAYREADY;
      case KeySystems.WIDEVINE:
        return KeySystemFormats.WIDEVINE;
      case KeySystems.CLEARKEY:
        return KeySystemFormats.CLEARKEY;
    }
  }
  function getKeySystemsForConfig(config3) {
    const {
      drmSystems,
      widevineLicenseUrl
    } = config3;
    const keySystemsToAttempt = drmSystems ? [KeySystems.FAIRPLAY, KeySystems.WIDEVINE, KeySystems.PLAYREADY, KeySystems.CLEARKEY].filter((keySystem) => !!drmSystems[keySystem]) : [];
    if (!keySystemsToAttempt[KeySystems.WIDEVINE] && widevineLicenseUrl) {
      keySystemsToAttempt.push(KeySystems.WIDEVINE);
    }
    return keySystemsToAttempt;
  }
  var requestMediaKeySystemAccess = (function(_optionalSelf$navigat) {
    if (optionalSelf != null && (_optionalSelf$navigat = optionalSelf.navigator) != null && _optionalSelf$navigat.requestMediaKeySystemAccess) {
      return self.navigator.requestMediaKeySystemAccess.bind(self.navigator);
    } else {
      return null;
    }
  })();
  function getSupportedMediaKeySystemConfigurations(keySystem, audioCodecs, videoCodecs, drmSystemOptions) {
    let initDataTypes;
    switch (keySystem) {
      case KeySystems.FAIRPLAY:
        initDataTypes = ["cenc", "sinf"];
        break;
      case KeySystems.WIDEVINE:
      case KeySystems.PLAYREADY:
        initDataTypes = ["cenc"];
        break;
      case KeySystems.CLEARKEY:
        initDataTypes = ["cenc", "keyids"];
        break;
      default:
        throw new Error(`Unknown key-system: ${keySystem}`);
    }
    return createMediaKeySystemConfigurations(initDataTypes, audioCodecs, videoCodecs, drmSystemOptions);
  }
  function createMediaKeySystemConfigurations(initDataTypes, audioCodecs, videoCodecs, drmSystemOptions) {
    const baseConfig = {
      initDataTypes,
      persistentState: drmSystemOptions.persistentState || "optional",
      distinctiveIdentifier: drmSystemOptions.distinctiveIdentifier || "optional",
      sessionTypes: drmSystemOptions.sessionTypes || [drmSystemOptions.sessionType || "temporary"],
      audioCapabilities: audioCodecs.map((codec) => ({
        contentType: `audio/mp4; codecs=${codec}`,
        robustness: drmSystemOptions.audioRobustness || "",
        encryptionScheme: drmSystemOptions.audioEncryptionScheme || null
      })),
      videoCapabilities: videoCodecs.map((codec) => ({
        contentType: `video/mp4; codecs=${codec}`,
        robustness: drmSystemOptions.videoRobustness || "",
        encryptionScheme: drmSystemOptions.videoEncryptionScheme || null
      }))
    };
    return [baseConfig];
  }
  function isPersistentSessionType(drmSystemOptions) {
    var _drmSystemOptions$ses;
    return !!drmSystemOptions && (drmSystemOptions.sessionType === "persistent-license" || !!((_drmSystemOptions$ses = drmSystemOptions.sessionTypes) != null && _drmSystemOptions$ses.some((type) => type === "persistent-license")));
  }
  function parsePlayReadyWRM(keyBytes) {
    const keyBytesUtf16 = new Uint16Array(keyBytes.buffer, keyBytes.byteOffset, keyBytes.byteLength / 2);
    const keyByteStr = String.fromCharCode.apply(null, Array.from(keyBytesUtf16));
    const xmlKeyBytes = keyByteStr.substring(keyByteStr.indexOf("<"), keyByteStr.length);
    const parser = new DOMParser();
    const xmlDoc = parser.parseFromString(xmlKeyBytes, "text/xml");
    const keyData = xmlDoc.getElementsByTagName("KID")[0];
    if (keyData) {
      const keyId = keyData.childNodes[0] ? keyData.childNodes[0].nodeValue : keyData.getAttribute("VALUE");
      if (keyId) {
        const keyIdArray = base64Decode(keyId).subarray(0, 16);
        changeEndianness(keyIdArray);
        return keyIdArray;
      }
    }
    return null;
  }
  var keyUriToKeyIdMap = {};
  var LevelKey = class _LevelKey {
    static clearKeyUriToKeyIdMap() {
      keyUriToKeyIdMap = {};
    }
    static setKeyIdForUri(uri, keyId) {
      keyUriToKeyIdMap[uri] = keyId;
    }
    constructor(method, uri, format2, formatversions = [1], iv = null, keyId) {
      this.uri = void 0;
      this.method = void 0;
      this.keyFormat = void 0;
      this.keyFormatVersions = void 0;
      this.encrypted = void 0;
      this.isCommonEncryption = void 0;
      this.iv = null;
      this.key = null;
      this.keyId = null;
      this.pssh = null;
      this.method = method;
      this.uri = uri;
      this.keyFormat = format2;
      this.keyFormatVersions = formatversions;
      this.iv = iv;
      this.encrypted = method ? method !== "NONE" : false;
      this.isCommonEncryption = this.encrypted && !isFullSegmentEncryption(method);
      if (keyId != null && keyId.startsWith("0x")) {
        this.keyId = new Uint8Array(hexToArrayBuffer(keyId));
      }
    }
    matches(key) {
      return key.uri === this.uri && key.method === this.method && key.encrypted === this.encrypted && key.keyFormat === this.keyFormat && arrayValuesMatch(key.keyFormatVersions, this.keyFormatVersions) && optionalArrayValuesMatch(key.iv, this.iv) && optionalArrayValuesMatch(key.keyId, this.keyId);
    }
    isSupported() {
      if (this.method) {
        if (isFullSegmentEncryption(this.method) || this.method === "NONE") {
          return true;
        }
        if (this.keyFormat === "identity") {
          return this.method === "SAMPLE-AES";
        } else {
          switch (this.keyFormat) {
            case KeySystemFormats.FAIRPLAY:
            case KeySystemFormats.WIDEVINE:
            case KeySystemFormats.PLAYREADY:
            case KeySystemFormats.CLEARKEY:
              return ["SAMPLE-AES", "SAMPLE-AES-CENC", "SAMPLE-AES-CTR"].indexOf(this.method) !== -1;
          }
        }
      }
      return false;
    }
    getDecryptData(sn, levelKeys) {
      if (!this.encrypted || !this.uri) {
        return null;
      }
      if (isFullSegmentEncryption(this.method)) {
        let iv = this.iv;
        if (!iv) {
          if (typeof sn !== "number") {
            logger.warn(`missing IV for initialization segment with method="${this.method}" - compliance issue`);
            sn = 0;
          }
          iv = createInitializationVector(sn);
        }
        const decryptdata = new _LevelKey(this.method, this.uri, "identity", this.keyFormatVersions, iv);
        return decryptdata;
      }
      if (this.keyId) {
        const assignedKeyId = keyUriToKeyIdMap[this.uri];
        if (assignedKeyId && !arrayValuesMatch(this.keyId, assignedKeyId)) {
          _LevelKey.setKeyIdForUri(this.uri, this.keyId);
        }
        if (this.pssh) {
          return this;
        }
      }
      const keyBytes = convertDataUriToArrayBytes(this.uri);
      if (keyBytes) {
        switch (this.keyFormat) {
          case KeySystemFormats.WIDEVINE:
            this.pssh = keyBytes;
            if (!this.keyId) {
              const results = parseMultiPssh(keyBytes.buffer);
              if (results.length) {
                var _psshData$kids;
                const psshData = results[0];
                this.keyId = (_psshData$kids = psshData.kids) != null && _psshData$kids.length ? psshData.kids[0] : null;
              }
            }
            if (!this.keyId) {
              this.keyId = getKeyIdFromPlayReadyKey(levelKeys);
            }
            break;
          case KeySystemFormats.PLAYREADY: {
            const PlayReadyKeySystemUUID = new Uint8Array([154, 4, 240, 121, 152, 64, 66, 134, 171, 146, 230, 91, 224, 136, 95, 149]);
            this.pssh = mp4pssh(PlayReadyKeySystemUUID, null, keyBytes);
            this.keyId = parsePlayReadyWRM(keyBytes);
            break;
          }
          default: {
            let keydata = keyBytes.subarray(0, 16);
            if (keydata.length !== 16) {
              const padded = new Uint8Array(16);
              padded.set(keydata, 16 - keydata.length);
              keydata = padded;
            }
            this.keyId = keydata;
            break;
          }
        }
      }
      if (!this.keyId || this.keyId.byteLength !== 16) {
        let keyId;
        keyId = getKeyIdFromWidevineKey(levelKeys);
        if (!keyId) {
          keyId = getKeyIdFromPlayReadyKey(levelKeys);
          if (!keyId) {
            keyId = keyUriToKeyIdMap[this.uri];
          }
        }
        if (keyId) {
          this.keyId = keyId;
          _LevelKey.setKeyIdForUri(this.uri, keyId);
        }
      }
      return this;
    }
  };
  function getKeyIdFromWidevineKey(levelKeys) {
    const widevineKey = levelKeys == null ? void 0 : levelKeys[KeySystemFormats.WIDEVINE];
    if (widevineKey) {
      return widevineKey.keyId;
    }
    return null;
  }
  function getKeyIdFromPlayReadyKey(levelKeys) {
    const playReadyKey = levelKeys == null ? void 0 : levelKeys[KeySystemFormats.PLAYREADY];
    if (playReadyKey) {
      const playReadyKeyBytes = convertDataUriToArrayBytes(playReadyKey.uri);
      if (playReadyKeyBytes) {
        return parsePlayReadyWRM(playReadyKeyBytes);
      }
    }
    return null;
  }
  function createInitializationVector(segmentNumber) {
    const uint8View = new Uint8Array(16);
    for (let i = 12; i < 16; i++) {
      uint8View[i] = segmentNumber >> 8 * (15 - i) & 255;
    }
    return uint8View;
  }
  var MASTER_PLAYLIST_REGEX = /#EXT-X-STREAM-INF:([^\r\n]*)(?:[\r\n](?:#[^\r\n]*)?)*([^\r\n]+)|#EXT-X-(SESSION-DATA|SESSION-KEY|DEFINE|CONTENT-STEERING|START):([^\r\n]*)[\r\n]+/g;
  var MASTER_PLAYLIST_MEDIA_REGEX = /#EXT-X-MEDIA:(.*)/g;
  var IS_MEDIA_PLAYLIST = /^#EXT(?:INF|-X-TARGETDURATION):/m;
  var LEVEL_PLAYLIST_REGEX_FAST = new RegExp([
    /#EXTINF:\s*(\d*(?:\.\d+)?)(?:,(.*)\s+)?/.source,
    // duration (#EXTINF:<duration>,<title>), group 1 => duration, group 2 => title
    /(?!#) *(\S[^\r\n]*)/.source,
    // segment URI, group 3 => the URI (note newline is not eaten)
    /#.*/.source
    // All other non-segment oriented tags will match with all groups empty
  ].join("|"), "g");
  var LEVEL_PLAYLIST_REGEX_SLOW = new RegExp([/#EXT-X-(PROGRAM-DATE-TIME|BYTERANGE|DATERANGE|DEFINE|KEY|MAP|PART|PART-INF|PLAYLIST-TYPE|PRELOAD-HINT|RENDITION-REPORT|SERVER-CONTROL|SKIP|START):(.+)/.source, /#EXT-X-(BITRATE|DISCONTINUITY-SEQUENCE|MEDIA-SEQUENCE|TARGETDURATION|VERSION): *(\d+)/.source, /#EXT-X-(DISCONTINUITY|ENDLIST|GAP|INDEPENDENT-SEGMENTS)/.source, /(#)([^:]*):(.*)/.source, /(#)(.*)(?:.*)\r?\n?/.source].join("|"));
  var M3U8Parser = class _M3U8Parser {
    static findGroup(groups, mediaGroupId) {
      for (let i = 0; i < groups.length; i++) {
        const group = groups[i];
        if (group.id === mediaGroupId) {
          return group;
        }
      }
    }
    static resolve(url, baseUrl) {
      return urlToolkitExports.buildAbsoluteURL(baseUrl, url, {
        alwaysNormalize: true
      });
    }
    static isMediaPlaylist(str) {
      return IS_MEDIA_PLAYLIST.test(str);
    }
    static parseMasterPlaylist(string, baseurl) {
      const hasVariableRefs = hasVariableReferences(string);
      const parsed = {
        contentSteering: null,
        levels: [],
        playlistParsingError: null,
        sessionData: null,
        sessionKeys: null,
        startTimeOffset: null,
        variableList: null,
        hasVariableRefs
      };
      const levelsWithKnownCodecs = [];
      MASTER_PLAYLIST_REGEX.lastIndex = 0;
      if (!string.startsWith("#EXTM3U")) {
        parsed.playlistParsingError = new Error("no EXTM3U delimiter");
        return parsed;
      }
      let result;
      while ((result = MASTER_PLAYLIST_REGEX.exec(string)) != null) {
        if (result[1]) {
          var _level$unknownCodecs;
          const attrs = new AttrList(result[1], parsed);
          const uri = substituteVariables(parsed, result[2]);
          const level = {
            attrs,
            bitrate: attrs.decimalInteger("BANDWIDTH") || attrs.decimalInteger("AVERAGE-BANDWIDTH"),
            name: attrs.NAME,
            url: _M3U8Parser.resolve(uri, baseurl)
          };
          const resolution = attrs.decimalResolution("RESOLUTION");
          if (resolution) {
            level.width = resolution.width;
            level.height = resolution.height;
          }
          setCodecs(attrs.CODECS, level);
          const supplementalCodecs = attrs["SUPPLEMENTAL-CODECS"];
          if (supplementalCodecs) {
            level.supplemental = {};
            setCodecs(supplementalCodecs, level.supplemental);
          }
          if (!((_level$unknownCodecs = level.unknownCodecs) != null && _level$unknownCodecs.length)) {
            levelsWithKnownCodecs.push(level);
          }
          parsed.levels.push(level);
        } else if (result[3]) {
          const tag = result[3];
          const attributes = result[4];
          switch (tag) {
            case "SESSION-DATA": {
              const sessionAttrs = new AttrList(attributes, parsed);
              const dataId = sessionAttrs["DATA-ID"];
              if (dataId) {
                if (parsed.sessionData === null) {
                  parsed.sessionData = {};
                }
                parsed.sessionData[dataId] = sessionAttrs;
              }
              break;
            }
            case "SESSION-KEY": {
              const sessionKey = parseKey(attributes, baseurl, parsed);
              if (sessionKey.encrypted && sessionKey.isSupported()) {
                if (parsed.sessionKeys === null) {
                  parsed.sessionKeys = [];
                }
                parsed.sessionKeys.push(sessionKey);
              } else {
                logger.warn(`[Keys] Ignoring invalid EXT-X-SESSION-KEY tag: "${attributes}"`);
              }
              break;
            }
            case "DEFINE": {
              {
                const variableAttributes = new AttrList(attributes, parsed);
                addVariableDefinition(parsed, variableAttributes, baseurl);
              }
              break;
            }
            case "CONTENT-STEERING": {
              const contentSteeringAttributes = new AttrList(attributes, parsed);
              parsed.contentSteering = {
                uri: _M3U8Parser.resolve(contentSteeringAttributes["SERVER-URI"], baseurl),
                pathwayId: contentSteeringAttributes["PATHWAY-ID"] || "."
              };
              break;
            }
            case "START": {
              parsed.startTimeOffset = parseStartTimeOffset(attributes);
              break;
            }
          }
        }
      }
      const stripUnknownCodecLevels = levelsWithKnownCodecs.length > 0 && levelsWithKnownCodecs.length < parsed.levels.length;
      parsed.levels = stripUnknownCodecLevels ? levelsWithKnownCodecs : parsed.levels;
      if (parsed.levels.length === 0) {
        parsed.playlistParsingError = new Error("no levels found in manifest");
      }
      return parsed;
    }
    static parseMasterPlaylistMedia(string, baseurl, parsed) {
      let result;
      const results = {};
      const levels = parsed.levels;
      const groupsByType = {
        AUDIO: levels.map((level) => ({
          id: level.attrs.AUDIO,
          audioCodec: level.audioCodec
        })),
        SUBTITLES: levels.map((level) => ({
          id: level.attrs.SUBTITLES,
          textCodec: level.textCodec
        })),
        "CLOSED-CAPTIONS": []
      };
      let id3 = 0;
      MASTER_PLAYLIST_MEDIA_REGEX.lastIndex = 0;
      while ((result = MASTER_PLAYLIST_MEDIA_REGEX.exec(string)) !== null) {
        const attrs = new AttrList(result[1], parsed);
        const type = attrs.TYPE;
        if (type) {
          const groups = groupsByType[type];
          const medias = results[type] || [];
          results[type] = medias;
          const lang = attrs.LANGUAGE;
          const assocLang = attrs["ASSOC-LANGUAGE"];
          const channels = attrs.CHANNELS;
          const characteristics = attrs.CHARACTERISTICS;
          const instreamId = attrs["INSTREAM-ID"];
          const media = {
            attrs,
            bitrate: 0,
            id: id3++,
            groupId: attrs["GROUP-ID"] || "",
            name: attrs.NAME || lang || "",
            type,
            default: attrs.bool("DEFAULT"),
            autoselect: attrs.bool("AUTOSELECT"),
            forced: attrs.bool("FORCED"),
            lang,
            url: attrs.URI ? _M3U8Parser.resolve(attrs.URI, baseurl) : ""
          };
          if (assocLang) {
            media.assocLang = assocLang;
          }
          if (channels) {
            media.channels = channels;
          }
          if (characteristics) {
            media.characteristics = characteristics;
          }
          if (instreamId) {
            media.instreamId = instreamId;
          }
          if (groups != null && groups.length) {
            const groupCodec = _M3U8Parser.findGroup(groups, media.groupId) || groups[0];
            assignCodec(media, groupCodec, "audioCodec");
            assignCodec(media, groupCodec, "textCodec");
          }
          medias.push(media);
        }
      }
      return results;
    }
    static parseLevelPlaylist(string, baseurl, id3, type, levelUrlId, multivariantVariableList) {
      var _LEVEL_PLAYLIST_REGEX;
      const base = {
        url: baseurl
      };
      const level = new LevelDetails(baseurl);
      const fragments = level.fragments;
      const programDateTimes = [];
      let currentInitSegment = null;
      let currentSN = 0;
      let currentPart = 0;
      let totalduration = 0;
      let discontinuityCounter = 0;
      let currentBitrate = 0;
      let prevFrag = null;
      let frag = new Fragment3(type, base);
      let result;
      let i;
      let levelkeys;
      let firstPdtIndex = -1;
      let createNextFrag = false;
      let nextByteRange = null;
      let serverControlAttrs;
      LEVEL_PLAYLIST_REGEX_FAST.lastIndex = 0;
      level.m3u8 = string;
      level.hasVariableRefs = hasVariableReferences(string);
      if (((_LEVEL_PLAYLIST_REGEX = LEVEL_PLAYLIST_REGEX_FAST.exec(string)) == null ? void 0 : _LEVEL_PLAYLIST_REGEX[0]) !== "#EXTM3U") {
        level.playlistParsingError = new Error("Missing format identifier #EXTM3U");
        return level;
      }
      while ((result = LEVEL_PLAYLIST_REGEX_FAST.exec(string)) !== null) {
        if (createNextFrag) {
          createNextFrag = false;
          frag = new Fragment3(type, base);
          frag.playlistOffset = totalduration;
          frag.setStart(totalduration);
          frag.sn = currentSN;
          frag.cc = discontinuityCounter;
          if (currentBitrate) {
            frag.bitrate = currentBitrate;
          }
          frag.level = id3;
          if (currentInitSegment) {
            frag.initSegment = currentInitSegment;
            if (currentInitSegment.rawProgramDateTime) {
              frag.rawProgramDateTime = currentInitSegment.rawProgramDateTime;
              currentInitSegment.rawProgramDateTime = null;
            }
            if (nextByteRange) {
              frag.setByteRange(nextByteRange);
              nextByteRange = null;
            }
          }
        }
        const duration = result[1];
        if (duration) {
          frag.duration = parseFloat(duration);
          const title = (" " + result[2]).slice(1);
          frag.title = title || null;
          frag.tagList.push(title ? ["INF", duration, title] : ["INF", duration]);
        } else if (result[3]) {
          if (isFiniteNumber(frag.duration)) {
            frag.playlistOffset = totalduration;
            frag.setStart(totalduration);
            if (levelkeys) {
              setFragLevelKeys(frag, levelkeys, level);
            }
            frag.sn = currentSN;
            frag.level = id3;
            frag.cc = discontinuityCounter;
            fragments.push(frag);
            const uri = (" " + result[3]).slice(1);
            frag.relurl = substituteVariables(level, uri);
            assignProgramDateTime(frag, prevFrag, programDateTimes);
            prevFrag = frag;
            totalduration += frag.duration;
            currentSN++;
            currentPart = 0;
            createNextFrag = true;
          }
        } else {
          result = result[0].match(LEVEL_PLAYLIST_REGEX_SLOW);
          if (!result) {
            logger.warn("No matches on slow regex match for level playlist!");
            continue;
          }
          for (i = 1; i < result.length; i++) {
            if (result[i] !== void 0) {
              break;
            }
          }
          const tag = (" " + result[i]).slice(1);
          const value1 = (" " + result[i + 1]).slice(1);
          const value2 = result[i + 2] ? (" " + result[i + 2]).slice(1) : null;
          switch (tag) {
            case "BYTERANGE":
              if (prevFrag) {
                frag.setByteRange(value1, prevFrag);
              } else {
                frag.setByteRange(value1);
              }
              break;
            case "PROGRAM-DATE-TIME":
              frag.rawProgramDateTime = value1;
              frag.tagList.push(["PROGRAM-DATE-TIME", value1]);
              if (firstPdtIndex === -1) {
                firstPdtIndex = fragments.length;
              }
              break;
            case "PLAYLIST-TYPE":
              if (level.type) {
                assignMultipleMediaPlaylistTagOccuranceError(level, tag, result);
              }
              level.type = value1.toUpperCase();
              break;
            case "MEDIA-SEQUENCE":
              if (level.startSN !== 0) {
                assignMultipleMediaPlaylistTagOccuranceError(level, tag, result);
              } else if (fragments.length > 0) {
                assignMustAppearBeforeSegmentsError(level, tag, result);
              }
              currentSN = level.startSN = parseInt(value1);
              break;
            case "SKIP": {
              if (level.skippedSegments) {
                assignMultipleMediaPlaylistTagOccuranceError(level, tag, result);
              }
              const skipAttrs = new AttrList(value1, level);
              const skippedSegments = skipAttrs.decimalInteger("SKIPPED-SEGMENTS");
              if (isFiniteNumber(skippedSegments)) {
                level.skippedSegments += skippedSegments;
                for (let _i2 = skippedSegments; _i2--; ) {
                  fragments.push(null);
                }
                currentSN += skippedSegments;
              }
              const recentlyRemovedDateranges = skipAttrs.enumeratedString("RECENTLY-REMOVED-DATERANGES");
              if (recentlyRemovedDateranges) {
                level.recentlyRemovedDateranges = (level.recentlyRemovedDateranges || []).concat(recentlyRemovedDateranges.split("	"));
              }
              break;
            }
            case "TARGETDURATION":
              if (level.targetduration !== 0) {
                assignMultipleMediaPlaylistTagOccuranceError(level, tag, result);
              }
              level.targetduration = Math.max(parseInt(value1), 1);
              break;
            case "VERSION":
              if (level.version !== null) {
                assignMultipleMediaPlaylistTagOccuranceError(level, tag, result);
              }
              level.version = parseInt(value1);
              break;
            case "INDEPENDENT-SEGMENTS":
              break;
            case "ENDLIST":
              if (!level.live) {
                assignMultipleMediaPlaylistTagOccuranceError(level, tag, result);
              }
              level.live = false;
              break;
            case "#":
              if (value1 || value2) {
                frag.tagList.push(value2 ? [value1, value2] : [value1]);
              }
              break;
            case "DISCONTINUITY":
              discontinuityCounter++;
              frag.tagList.push(["DIS"]);
              break;
            case "GAP":
              frag.gap = true;
              frag.tagList.push([tag]);
              break;
            case "BITRATE":
              frag.tagList.push([tag, value1]);
              currentBitrate = parseInt(value1) * 1e3;
              if (isFiniteNumber(currentBitrate)) {
                frag.bitrate = currentBitrate;
              } else {
                currentBitrate = 0;
              }
              break;
            case "DATERANGE": {
              const dateRangeAttr = new AttrList(value1, level);
              const dateRange = new DateRange(dateRangeAttr, level.dateRanges[dateRangeAttr.ID], level.dateRangeTagCount);
              level.dateRangeTagCount++;
              if (dateRange.isValid || level.skippedSegments) {
                level.dateRanges[dateRange.id] = dateRange;
              } else {
                logger.warn(`Ignoring invalid DATERANGE tag: "${value1}"`);
              }
              frag.tagList.push(["EXT-X-DATERANGE", value1]);
              break;
            }
            case "DEFINE": {
              {
                const variableAttributes = new AttrList(value1, level);
                if ("IMPORT" in variableAttributes) {
                  importVariableDefinition(level, variableAttributes, multivariantVariableList);
                } else {
                  addVariableDefinition(level, variableAttributes, baseurl);
                }
              }
              break;
            }
            case "DISCONTINUITY-SEQUENCE":
              if (level.startCC !== 0) {
                assignMultipleMediaPlaylistTagOccuranceError(level, tag, result);
              } else if (fragments.length > 0) {
                assignMustAppearBeforeSegmentsError(level, tag, result);
              }
              level.startCC = discontinuityCounter = parseInt(value1);
              break;
            case "KEY": {
              const levelKey = parseKey(value1, baseurl, level);
              if (levelKey.isSupported()) {
                if (levelKey.method === "NONE") {
                  levelkeys = void 0;
                  break;
                }
                if (!levelkeys) {
                  levelkeys = {};
                }
                const currentKey = levelkeys[levelKey.keyFormat];
                if (!(currentKey != null && currentKey.matches(levelKey))) {
                  if (currentKey) {
                    levelkeys = _extends4({}, levelkeys);
                  }
                  levelkeys[levelKey.keyFormat] = levelKey;
                }
              } else {
                logger.warn(`[Keys] Ignoring unsupported EXT-X-KEY tag: "${value1}"${""}`);
              }
              break;
            }
            case "START":
              level.startTimeOffset = parseStartTimeOffset(value1);
              break;
            case "MAP": {
              const mapAttrs = new AttrList(value1, level);
              if (frag.duration) {
                const init5 = new Fragment3(type, base);
                setInitSegment(init5, mapAttrs, id3, levelkeys);
                currentInitSegment = init5;
                frag.initSegment = currentInitSegment;
                if (currentInitSegment.rawProgramDateTime && !frag.rawProgramDateTime) {
                  frag.rawProgramDateTime = currentInitSegment.rawProgramDateTime;
                }
              } else {
                const end = frag.byteRangeEndOffset;
                if (end) {
                  const start = frag.byteRangeStartOffset;
                  nextByteRange = `${end - start}@${start}`;
                } else {
                  nextByteRange = null;
                }
                setInitSegment(frag, mapAttrs, id3, levelkeys);
                currentInitSegment = frag;
                createNextFrag = true;
              }
              currentInitSegment.cc = discontinuityCounter;
              break;
            }
            case "SERVER-CONTROL": {
              if (serverControlAttrs) {
                assignMultipleMediaPlaylistTagOccuranceError(level, tag, result);
              }
              serverControlAttrs = new AttrList(value1);
              level.canBlockReload = serverControlAttrs.bool("CAN-BLOCK-RELOAD");
              level.canSkipUntil = serverControlAttrs.optionalFloat("CAN-SKIP-UNTIL", 0);
              level.canSkipDateRanges = level.canSkipUntil > 0 && serverControlAttrs.bool("CAN-SKIP-DATERANGES");
              level.partHoldBack = serverControlAttrs.optionalFloat("PART-HOLD-BACK", 0);
              level.holdBack = serverControlAttrs.optionalFloat("HOLD-BACK", 0);
              break;
            }
            case "PART-INF": {
              if (level.partTarget) {
                assignMultipleMediaPlaylistTagOccuranceError(level, tag, result);
              }
              const partInfAttrs = new AttrList(value1);
              level.partTarget = partInfAttrs.decimalFloatingPoint("PART-TARGET");
              break;
            }
            case "PART": {
              let partList = level.partList;
              if (!partList) {
                partList = level.partList = [];
              }
              const previousFragmentPart = currentPart > 0 ? partList[partList.length - 1] : void 0;
              const index = currentPart++;
              const partAttrs = new AttrList(value1, level);
              const part = new Part(partAttrs, frag, base, index, previousFragmentPart);
              partList.push(part);
              frag.duration += part.duration;
              break;
            }
            case "PRELOAD-HINT": {
              const preloadHintAttrs = new AttrList(value1, level);
              level.preloadHint = preloadHintAttrs;
              break;
            }
            case "RENDITION-REPORT": {
              const renditionReportAttrs = new AttrList(value1, level);
              level.renditionReports = level.renditionReports || [];
              level.renditionReports.push(renditionReportAttrs);
              break;
            }
            default:
              logger.warn(`line parsed but not handled: ${result}`);
              break;
          }
        }
      }
      if (prevFrag && !prevFrag.relurl) {
        fragments.pop();
        totalduration -= prevFrag.duration;
        if (level.partList) {
          level.fragmentHint = prevFrag;
        }
      } else if (level.partList) {
        assignProgramDateTime(frag, prevFrag, programDateTimes);
        frag.cc = discontinuityCounter;
        level.fragmentHint = frag;
        if (levelkeys) {
          setFragLevelKeys(frag, levelkeys, level);
        }
      }
      if (!level.targetduration) {
        level.playlistParsingError = new Error(`Missing Target Duration`);
      }
      const fragmentLength = fragments.length;
      const firstFragment = fragments[0];
      const lastFragment = fragments[fragmentLength - 1];
      totalduration += level.skippedSegments * level.targetduration;
      if (totalduration > 0 && fragmentLength && lastFragment) {
        level.averagetargetduration = totalduration / fragmentLength;
        const lastSn = lastFragment.sn;
        level.endSN = lastSn !== "initSegment" ? lastSn : 0;
        if (!level.live) {
          lastFragment.endList = true;
        }
        if (firstPdtIndex > 0) {
          backfillProgramDateTimes(fragments, firstPdtIndex);
          if (firstFragment) {
            programDateTimes.unshift(firstFragment);
          }
        }
      }
      if (level.fragmentHint) {
        totalduration += level.fragmentHint.duration;
      }
      level.totalduration = totalduration;
      if (programDateTimes.length && level.dateRangeTagCount && firstFragment) {
        mapDateRanges(programDateTimes, level);
      }
      level.endCC = discontinuityCounter;
      return level;
    }
  };
  function mapDateRanges(programDateTimes, details) {
    let programDateTimeCount = programDateTimes.length;
    if (!programDateTimeCount) {
      if (details.hasProgramDateTime) {
        const lastFragment = details.fragments[details.fragments.length - 1];
        programDateTimes.push(lastFragment);
        programDateTimeCount++;
      } else {
        return;
      }
    }
    const lastProgramDateTime = programDateTimes[programDateTimeCount - 1];
    const playlistEnd = details.live ? Infinity : details.totalduration;
    const dateRangeIds = Object.keys(details.dateRanges);
    for (let i = dateRangeIds.length; i--; ) {
      const dateRange = details.dateRanges[dateRangeIds[i]];
      const startDateTime = dateRange.startDate.getTime();
      dateRange.tagAnchor = lastProgramDateTime.ref;
      for (let j = programDateTimeCount; j--; ) {
        var _programDateTimes$j;
        if (((_programDateTimes$j = programDateTimes[j]) == null ? void 0 : _programDateTimes$j.sn) < details.startSN) {
          break;
        }
        const fragIndex = findFragmentWithStartDate(details, startDateTime, programDateTimes, j, playlistEnd);
        if (fragIndex !== -1) {
          dateRange.tagAnchor = details.fragments[fragIndex].ref;
          break;
        }
      }
    }
  }
  function findFragmentWithStartDate(details, startDateTime, programDateTimes, index, endTime) {
    const pdtFragment = programDateTimes[index];
    if (pdtFragment) {
      const pdtStart = pdtFragment.programDateTime;
      if (startDateTime >= pdtStart || index === 0) {
        var _programDateTimes;
        const durationBetweenPdt = (((_programDateTimes = programDateTimes[index + 1]) == null ? void 0 : _programDateTimes.start) || endTime) - pdtFragment.start;
        if (startDateTime <= pdtStart + durationBetweenPdt * 1e3) {
          const startIndex = programDateTimes[index].sn - details.startSN;
          if (startIndex < 0) {
            return -1;
          }
          const fragments = details.fragments;
          if (fragments.length > programDateTimes.length) {
            const endSegment = programDateTimes[index + 1] || fragments[fragments.length - 1];
            const endIndex = endSegment.sn - details.startSN;
            for (let i = endIndex; i > startIndex; i--) {
              const fragStartDateTime = fragments[i].programDateTime;
              if (startDateTime >= fragStartDateTime && startDateTime < fragStartDateTime + fragments[i].duration * 1e3) {
                return i;
              }
            }
          }
          return startIndex;
        }
      }
    }
    return -1;
  }
  function parseKey(keyTagAttributes, baseurl, parsed) {
    var _keyAttrs$METHOD, _keyAttrs$KEYFORMAT;
    const keyAttrs = new AttrList(keyTagAttributes, parsed);
    const decryptmethod = (_keyAttrs$METHOD = keyAttrs.METHOD) != null ? _keyAttrs$METHOD : "";
    const decrypturi = keyAttrs.URI;
    const decryptiv = keyAttrs.hexadecimalInteger("IV");
    const decryptkeyformatversions = keyAttrs.KEYFORMATVERSIONS;
    const decryptkeyformat = (_keyAttrs$KEYFORMAT = keyAttrs.KEYFORMAT) != null ? _keyAttrs$KEYFORMAT : "identity";
    if (decrypturi && keyAttrs.IV && !decryptiv) {
      logger.error(`Invalid IV: ${keyAttrs.IV}`);
    }
    const resolvedUri = decrypturi ? M3U8Parser.resolve(decrypturi, baseurl) : "";
    const keyFormatVersions = (decryptkeyformatversions ? decryptkeyformatversions : "1").split("/").map(Number).filter(Number.isFinite);
    return new LevelKey(decryptmethod, resolvedUri, decryptkeyformat, keyFormatVersions, decryptiv, keyAttrs.KEYID);
  }
  function parseStartTimeOffset(startAttributes) {
    const startAttrs = new AttrList(startAttributes);
    const startTimeOffset = startAttrs.decimalFloatingPoint("TIME-OFFSET");
    if (isFiniteNumber(startTimeOffset)) {
      return startTimeOffset;
    }
    return null;
  }
  function setCodecs(codecsAttributeValue, level) {
    let codecs = (codecsAttributeValue || "").split(/[ ,]+/).filter((c) => c);
    ["video", "audio", "text"].forEach((type) => {
      const filtered = codecs.filter((codec) => isCodecType(codec, type));
      if (filtered.length) {
        level[`${type}Codec`] = filtered.map((c) => c.split("/")[0]).join(",");
        codecs = codecs.filter((codec) => filtered.indexOf(codec) === -1);
      }
    });
    level.unknownCodecs = codecs;
  }
  function assignCodec(media, groupItem, codecProperty) {
    const codecValue = groupItem[codecProperty];
    if (codecValue) {
      media[codecProperty] = codecValue;
    }
  }
  function backfillProgramDateTimes(fragments, firstPdtIndex) {
    let fragPrev = fragments[firstPdtIndex];
    for (let i = firstPdtIndex; i--; ) {
      const frag = fragments[i];
      if (!frag) {
        return;
      }
      frag.programDateTime = fragPrev.programDateTime - frag.duration * 1e3;
      fragPrev = frag;
    }
  }
  function assignProgramDateTime(frag, prevFrag, programDateTimes) {
    if (frag.rawProgramDateTime) {
      programDateTimes.push(frag);
    } else if (prevFrag != null && prevFrag.programDateTime) {
      frag.programDateTime = prevFrag.endProgramDateTime;
    }
  }
  function setInitSegment(frag, mapAttrs, id3, levelkeys) {
    frag.relurl = mapAttrs.URI;
    if (mapAttrs.BYTERANGE) {
      frag.setByteRange(mapAttrs.BYTERANGE);
    }
    frag.level = id3;
    frag.sn = "initSegment";
    if (levelkeys) {
      frag.levelkeys = levelkeys;
    }
    frag.initSegment = null;
  }
  function setFragLevelKeys(frag, levelkeys, level) {
    frag.levelkeys = levelkeys;
    const {
      encryptedFragments
    } = level;
    if ((!encryptedFragments.length || encryptedFragments[encryptedFragments.length - 1].levelkeys !== levelkeys) && Object.keys(levelkeys).some((format2) => levelkeys[format2].isCommonEncryption)) {
      encryptedFragments.push(frag);
    }
  }
  function assignMultipleMediaPlaylistTagOccuranceError(level, tag, result) {
    level.playlistParsingError = new Error(`#EXT-X-${tag} must not appear more than once (${result[0]})`);
  }
  function assignMustAppearBeforeSegmentsError(level, tag, result) {
    level.playlistParsingError = new Error(`#EXT-X-${tag} must appear before the first Media Segment (${result[0]})`);
  }
  function updateFromToPTS(fragFrom, fragTo) {
    const fragToPTS = fragTo.startPTS;
    if (isFiniteNumber(fragToPTS)) {
      let duration = 0;
      let frag;
      if (fragTo.sn > fragFrom.sn) {
        duration = fragToPTS - fragFrom.start;
        frag = fragFrom;
      } else {
        duration = fragFrom.start - fragToPTS;
        frag = fragTo;
      }
      if (frag.duration !== duration) {
        frag.setDuration(duration);
      }
    } else if (fragTo.sn > fragFrom.sn) {
      const contiguous = fragFrom.cc === fragTo.cc;
      if (contiguous && fragFrom.minEndPTS) {
        fragTo.setStart(fragFrom.start + (fragFrom.minEndPTS - fragFrom.start));
      } else {
        fragTo.setStart(fragFrom.start + fragFrom.duration);
      }
    } else {
      fragTo.setStart(Math.max(fragFrom.start - fragTo.duration, 0));
    }
  }
  function updateFragPTSDTS(details, frag, startPTS, endPTS, startDTS, endDTS, logger2) {
    const parsedMediaDuration = endPTS - startPTS;
    if (parsedMediaDuration <= 0) {
      logger2.warn("Fragment should have a positive duration", frag);
      endPTS = startPTS + frag.duration;
      endDTS = startDTS + frag.duration;
    }
    let maxStartPTS = startPTS;
    let minEndPTS = endPTS;
    const fragStartPts = frag.startPTS;
    const fragEndPts = frag.endPTS;
    if (isFiniteNumber(fragStartPts)) {
      const deltaPTS = Math.abs(fragStartPts - startPTS);
      if (details && deltaPTS > details.totalduration) {
        logger2.warn(`media timestamps and playlist times differ by ${deltaPTS}s for level ${frag.level} ${details.url}`);
      } else if (!isFiniteNumber(frag.deltaPTS)) {
        frag.deltaPTS = deltaPTS;
      } else {
        frag.deltaPTS = Math.max(deltaPTS, frag.deltaPTS);
      }
      maxStartPTS = Math.max(startPTS, fragStartPts);
      startPTS = Math.min(startPTS, fragStartPts);
      startDTS = frag.startDTS !== void 0 ? Math.min(startDTS, frag.startDTS) : startDTS;
      minEndPTS = Math.min(endPTS, fragEndPts);
      endPTS = Math.max(endPTS, fragEndPts);
      endDTS = frag.endDTS !== void 0 ? Math.max(endDTS, frag.endDTS) : endDTS;
    }
    const drift = startPTS - frag.start;
    if (frag.start !== 0) {
      frag.setStart(startPTS);
    }
    frag.setDuration(endPTS - frag.start);
    frag.startPTS = startPTS;
    frag.maxStartPTS = maxStartPTS;
    frag.startDTS = startDTS;
    frag.endPTS = endPTS;
    frag.minEndPTS = minEndPTS;
    frag.endDTS = endDTS;
    const sn = frag.sn;
    if (!details || sn < details.startSN || sn > details.endSN) {
      return 0;
    }
    let i;
    const fragIdx = sn - details.startSN;
    const fragments = details.fragments;
    fragments[fragIdx] = frag;
    for (i = fragIdx; i > 0; i--) {
      updateFromToPTS(fragments[i], fragments[i - 1]);
    }
    for (i = fragIdx; i < fragments.length - 1; i++) {
      updateFromToPTS(fragments[i], fragments[i + 1]);
    }
    if (details.fragmentHint) {
      updateFromToPTS(fragments[fragments.length - 1], details.fragmentHint);
    }
    details.PTSKnown = details.alignedSliding = true;
    return drift;
  }
  function mergeDetails(oldDetails, newDetails, logger2) {
    if (oldDetails === newDetails) {
      return;
    }
    let currentInitSegment = null;
    const oldFragments = oldDetails.fragments;
    for (let i = oldFragments.length - 1; i >= 0; i--) {
      const oldInit = oldFragments[i].initSegment;
      if (oldInit) {
        currentInitSegment = oldInit;
        break;
      }
    }
    if (oldDetails.fragmentHint) {
      delete oldDetails.fragmentHint.endPTS;
    }
    let PTSFrag;
    mapFragmentIntersection(oldDetails, newDetails, (oldFrag, newFrag, newFragIndex, newFragments2) => {
      if ((!newDetails.startCC || newDetails.skippedSegments) && newFrag.cc !== oldFrag.cc) {
        const ccOffset = oldFrag.cc - newFrag.cc;
        for (let i = newFragIndex; i < newFragments2.length; i++) {
          newFragments2[i].cc += ccOffset;
        }
        newDetails.endCC = newFragments2[newFragments2.length - 1].cc;
      }
      if (isFiniteNumber(oldFrag.startPTS) && isFiniteNumber(oldFrag.endPTS)) {
        newFrag.setStart(newFrag.startPTS = oldFrag.startPTS);
        newFrag.startDTS = oldFrag.startDTS;
        newFrag.maxStartPTS = oldFrag.maxStartPTS;
        newFrag.endPTS = oldFrag.endPTS;
        newFrag.endDTS = oldFrag.endDTS;
        newFrag.minEndPTS = oldFrag.minEndPTS;
        newFrag.setDuration(oldFrag.endPTS - oldFrag.startPTS);
        if (newFrag.duration) {
          PTSFrag = newFrag;
        }
        newDetails.PTSKnown = newDetails.alignedSliding = true;
      }
      if (oldFrag.hasStreams) {
        newFrag.elementaryStreams = oldFrag.elementaryStreams;
      }
      newFrag.loader = oldFrag.loader;
      if (oldFrag.hasStats) {
        newFrag.stats = oldFrag.stats;
      }
      if (oldFrag.initSegment) {
        newFrag.initSegment = oldFrag.initSegment;
        currentInitSegment = oldFrag.initSegment;
      }
    });
    const newFragments = newDetails.fragments;
    const fragmentsToCheck = newDetails.fragmentHint ? newFragments.concat(newDetails.fragmentHint) : newFragments;
    if (currentInitSegment) {
      fragmentsToCheck.forEach((frag) => {
        var _currentInitSegment;
        if (frag && (!frag.initSegment || frag.initSegment.relurl === ((_currentInitSegment = currentInitSegment) == null ? void 0 : _currentInitSegment.relurl))) {
          frag.initSegment = currentInitSegment;
        }
      });
    }
    if (newDetails.skippedSegments) {
      newDetails.deltaUpdateFailed = newFragments.some((frag) => !frag);
      if (newDetails.deltaUpdateFailed) {
        logger2.warn("[level-helper] Previous playlist missing segments skipped in delta playlist");
        for (let i = newDetails.skippedSegments; i--; ) {
          newFragments.shift();
        }
        newDetails.startSN = newFragments[0].sn;
      } else {
        if (newDetails.canSkipDateRanges) {
          newDetails.dateRanges = mergeDateRanges(oldDetails.dateRanges, newDetails, logger2);
        }
        const programDateTimes = oldDetails.fragments.filter((frag) => frag.rawProgramDateTime);
        if (oldDetails.hasProgramDateTime && !newDetails.hasProgramDateTime) {
          for (let i = 1; i < fragmentsToCheck.length; i++) {
            if (fragmentsToCheck[i].programDateTime === null) {
              assignProgramDateTime(fragmentsToCheck[i], fragmentsToCheck[i - 1], programDateTimes);
            }
          }
        }
        mapDateRanges(programDateTimes, newDetails);
      }
      newDetails.endCC = newFragments[newFragments.length - 1].cc;
    }
    if (!newDetails.startCC) {
      var _fragPriorToNewStart$;
      const fragPriorToNewStart = getFragmentWithSN(oldDetails, newDetails.startSN - 1);
      newDetails.startCC = (_fragPriorToNewStart$ = fragPriorToNewStart == null ? void 0 : fragPriorToNewStart.cc) != null ? _fragPriorToNewStart$ : newFragments[0].cc;
    }
    mapPartIntersection(oldDetails.partList, newDetails.partList, (oldPart, newPart) => {
      newPart.elementaryStreams = oldPart.elementaryStreams;
      newPart.stats = oldPart.stats;
    });
    if (PTSFrag) {
      updateFragPTSDTS(newDetails, PTSFrag, PTSFrag.startPTS, PTSFrag.endPTS, PTSFrag.startDTS, PTSFrag.endDTS, logger2);
    } else {
      adjustSliding(oldDetails, newDetails);
    }
    if (newFragments.length) {
      newDetails.totalduration = newDetails.edge - newFragments[0].start;
    }
    newDetails.driftStartTime = oldDetails.driftStartTime;
    newDetails.driftStart = oldDetails.driftStart;
    const advancedDateTime = newDetails.advancedDateTime;
    if (newDetails.advanced && advancedDateTime) {
      const edge = newDetails.edge;
      if (!newDetails.driftStart) {
        newDetails.driftStartTime = advancedDateTime;
        newDetails.driftStart = edge;
      }
      newDetails.driftEndTime = advancedDateTime;
      newDetails.driftEnd = edge;
    } else {
      newDetails.driftEndTime = oldDetails.driftEndTime;
      newDetails.driftEnd = oldDetails.driftEnd;
      newDetails.advancedDateTime = oldDetails.advancedDateTime;
    }
    if (newDetails.requestScheduled === -1) {
      newDetails.requestScheduled = oldDetails.requestScheduled;
    }
  }
  function mergeDateRanges(oldDateRanges, newDetails, logger2) {
    const {
      dateRanges: deltaDateRanges,
      recentlyRemovedDateranges
    } = newDetails;
    const dateRanges = _extends4({}, oldDateRanges);
    if (recentlyRemovedDateranges) {
      recentlyRemovedDateranges.forEach((id3) => {
        delete dateRanges[id3];
      });
    }
    const mergeIds = Object.keys(dateRanges);
    const mergeCount = mergeIds.length;
    if (!mergeCount) {
      return deltaDateRanges;
    }
    Object.keys(deltaDateRanges).forEach((id3) => {
      const mergedDateRange = dateRanges[id3];
      const dateRange = new DateRange(deltaDateRanges[id3].attr, mergedDateRange);
      if (dateRange.isValid) {
        dateRanges[id3] = dateRange;
        if (!mergedDateRange) {
          dateRange.tagOrder += mergeCount;
        }
      } else {
        logger2.warn(`Ignoring invalid Playlist Delta Update DATERANGE tag: "${stringify(deltaDateRanges[id3].attr)}"`);
      }
    });
    return dateRanges;
  }
  function mapPartIntersection(oldParts, newParts, intersectionFn) {
    if (oldParts && newParts) {
      let delta = 0;
      for (let i = 0, len = oldParts.length; i <= len; i++) {
        const oldPart = oldParts[i];
        const newPart = newParts[i + delta];
        if (oldPart && newPart && oldPart.index === newPart.index && oldPart.fragment.sn === newPart.fragment.sn) {
          intersectionFn(oldPart, newPart);
        } else {
          delta--;
        }
      }
    }
  }
  function mapFragmentIntersection(oldDetails, newDetails, intersectionFn) {
    const skippedSegments = newDetails.skippedSegments;
    const start = Math.max(oldDetails.startSN, newDetails.startSN) - newDetails.startSN;
    const end = (oldDetails.fragmentHint ? 1 : 0) + (skippedSegments ? newDetails.endSN : Math.min(oldDetails.endSN, newDetails.endSN)) - newDetails.startSN;
    const delta = newDetails.startSN - oldDetails.startSN;
    const newFrags = newDetails.fragmentHint ? newDetails.fragments.concat(newDetails.fragmentHint) : newDetails.fragments;
    const oldFrags = oldDetails.fragmentHint ? oldDetails.fragments.concat(oldDetails.fragmentHint) : oldDetails.fragments;
    for (let i = start; i <= end; i++) {
      const oldFrag = oldFrags[delta + i];
      let newFrag = newFrags[i];
      if (skippedSegments && !newFrag && oldFrag) {
        newFrag = newDetails.fragments[i] = oldFrag;
      }
      if (oldFrag && newFrag) {
        intersectionFn(oldFrag, newFrag, i, newFrags);
        const uriBefore = oldFrag.relurl;
        const uriAfter = newFrag.relurl;
        if (uriBefore && notEqualAfterStrippingQueries(uriBefore, uriAfter)) {
          newDetails.playlistParsingError = getSequenceError(`media sequence mismatch ${newFrag.sn}:`, oldDetails, newDetails, oldFrag, newFrag);
          return;
        } else if (oldFrag.cc !== newFrag.cc) {
          newDetails.playlistParsingError = getSequenceError(`discontinuity sequence mismatch (${oldFrag.cc}!=${newFrag.cc})`, oldDetails, newDetails, oldFrag, newFrag);
          return;
        }
      }
    }
  }
  function getSequenceError(message, oldDetails, newDetails, oldFrag, newFrag) {
    return new Error(`${message} ${newFrag.url}
Playlist starting @${oldDetails.startSN}
${oldDetails.m3u8}

Playlist starting @${newDetails.startSN}
${newDetails.m3u8}`);
  }
  function adjustSliding(oldDetails, newDetails, matchingStableVariantOrRendition = true) {
    const delta = newDetails.startSN + newDetails.skippedSegments - oldDetails.startSN;
    const oldFragments = oldDetails.fragments;
    const advancedOrStable = delta >= 0;
    let sliding = 0;
    if (advancedOrStable && delta < oldFragments.length) {
      sliding = oldFragments[delta].start;
    } else if (advancedOrStable && newDetails.startSN === oldDetails.endSN + 1) {
      sliding = oldDetails.fragmentEnd;
    } else if (advancedOrStable && matchingStableVariantOrRendition) {
      sliding = oldDetails.fragmentStart + delta * newDetails.levelTargetDuration;
    } else if (!newDetails.skippedSegments && newDetails.fragmentStart === 0) {
      sliding = oldDetails.fragmentStart;
    } else {
      return;
    }
    addSliding(newDetails, sliding);
  }
  function addSliding(details, sliding) {
    if (sliding) {
      const fragments = details.fragments;
      for (let i = details.skippedSegments; i < fragments.length; i++) {
        fragments[i].addStart(sliding);
      }
      if (details.fragmentHint) {
        details.fragmentHint.addStart(sliding);
      }
    }
  }
  function computeReloadInterval(newDetails, distanceToLiveEdgeMs = Infinity) {
    let reloadInterval = 1e3 * newDetails.targetduration;
    if (newDetails.updated) {
      const fragments = newDetails.fragments;
      const liveEdgeMaxTargetDurations = 4;
      if (fragments.length && reloadInterval * liveEdgeMaxTargetDurations > distanceToLiveEdgeMs) {
        const lastSegmentDuration = fragments[fragments.length - 1].duration * 1e3;
        if (lastSegmentDuration < reloadInterval) {
          reloadInterval = lastSegmentDuration;
        }
      }
    } else {
      reloadInterval /= 2;
    }
    return Math.round(reloadInterval);
  }
  function getFragmentWithSN(details, sn, fragCurrent) {
    if (!details) {
      return null;
    }
    let fragment = details.fragments[sn - details.startSN];
    if (fragment) {
      return fragment;
    }
    fragment = details.fragmentHint;
    if (fragment && fragment.sn === sn) {
      return fragment;
    }
    if (sn < details.startSN && fragCurrent && fragCurrent.sn === sn) {
      return fragCurrent;
    }
    return null;
  }
  function getPartWith(details, sn, partIndex) {
    if (!details) {
      return null;
    }
    return findPart(details.partList, sn, partIndex);
  }
  function findPart(partList, sn, partIndex) {
    if (partList) {
      for (let i = partList.length; i--; ) {
        const part = partList[i];
        if (part.index === partIndex && part.fragment.sn === sn) {
          return part;
        }
      }
    }
    return null;
  }
  function reassignFragmentLevelIndexes(levels) {
    levels.forEach((level, index) => {
      var _level$details;
      (_level$details = level.details) == null || _level$details.fragments.forEach((fragment) => {
        fragment.level = index;
        if (fragment.initSegment) {
          fragment.initSegment.level = index;
        }
      });
    });
  }
  function notEqualAfterStrippingQueries(uriBefore, uriAfter) {
    if (uriBefore !== uriAfter && uriAfter) {
      return stripQuery(uriBefore) !== stripQuery(uriAfter);
    }
    return false;
  }
  function stripQuery(uri) {
    return uri.replace(/\?[^?]*$/, "");
  }
  function findFirstFragWithCC(fragments, cc) {
    for (let i = 0, len = fragments.length; i < len; i++) {
      var _fragments$i;
      if (((_fragments$i = fragments[i]) == null ? void 0 : _fragments$i.cc) === cc) {
        return fragments[i];
      }
    }
    return null;
  }
  function shouldAlignOnDiscontinuities(refDetails, details) {
    if (refDetails) {
      if (details.startCC < refDetails.endCC && details.endCC > refDetails.startCC) {
        return true;
      }
    }
    return false;
  }
  function adjustFragmentStart(frag, sliding) {
    const start = frag.start + sliding;
    frag.startPTS = start;
    frag.setStart(start);
    frag.endPTS = start + frag.duration;
  }
  function adjustSlidingStart(sliding, details) {
    const fragments = details.fragments;
    for (let i = 0, len = fragments.length; i < len; i++) {
      adjustFragmentStart(fragments[i], sliding);
    }
    if (details.fragmentHint) {
      adjustFragmentStart(details.fragmentHint, sliding);
    }
    details.alignedSliding = true;
  }
  function alignStream(switchDetails, details) {
    if (!switchDetails) {
      return;
    }
    alignDiscontinuities(details, switchDetails);
    if (!details.alignedSliding) {
      alignMediaPlaylistByPDT(details, switchDetails);
    }
    if (!details.alignedSliding && !details.skippedSegments) {
      adjustSliding(switchDetails, details, false);
    }
  }
  function alignDiscontinuities(details, refDetails) {
    if (!shouldAlignOnDiscontinuities(refDetails, details)) {
      return;
    }
    const targetCC = Math.min(refDetails.endCC, details.endCC);
    const refFrag = findFirstFragWithCC(refDetails.fragments, targetCC);
    const frag = findFirstFragWithCC(details.fragments, targetCC);
    if (!refFrag || !frag) {
      return;
    }
    logger.log(`Aligning playlist at start of dicontinuity sequence ${targetCC}`);
    const delta = refFrag.start - frag.start;
    adjustSlidingStart(delta, details);
  }
  function alignMediaPlaylistByPDT(details, refDetails) {
    if (!details.hasProgramDateTime || !refDetails.hasProgramDateTime) {
      return;
    }
    const fragments = details.fragments;
    const refFragments = refDetails.fragments;
    if (!fragments.length || !refFragments.length) {
      return;
    }
    let refFrag;
    let frag;
    const targetCC = Math.min(refDetails.endCC, details.endCC);
    if (refDetails.startCC < targetCC && details.startCC < targetCC) {
      refFrag = findFirstFragWithCC(refFragments, targetCC);
      frag = findFirstFragWithCC(fragments, targetCC);
    }
    if (!refFrag || !frag) {
      refFrag = refFragments[Math.floor(refFragments.length / 2)];
      frag = findFirstFragWithCC(fragments, refFrag.cc) || fragments[Math.floor(fragments.length / 2)];
    }
    const refPDT = refFrag.programDateTime;
    const targetPDT = frag.programDateTime;
    if (!refPDT || !targetPDT) {
      return;
    }
    const delta = (targetPDT - refPDT) / 1e3 - (frag.start - refFrag.start);
    adjustSlidingStart(delta, details);
  }
  function addEventListener(el, type, listener) {
    removeEventListener(el, type, listener);
    el.addEventListener(type, listener);
  }
  function removeEventListener(el, type, listener) {
    el.removeEventListener(type, listener);
  }
  var TimeRanges = {
    toString: function(r) {
      let log = "";
      const len = r.length;
      for (let i = 0; i < len; i++) {
        log += `[${r.start(i).toFixed(3)}-${r.end(i).toFixed(3)}]`;
      }
      return log;
    }
  };
  var State = {
    STOPPED: "STOPPED",
    IDLE: "IDLE",
    KEY_LOADING: "KEY_LOADING",
    FRAG_LOADING: "FRAG_LOADING",
    FRAG_LOADING_WAITING_RETRY: "FRAG_LOADING_WAITING_RETRY",
    WAITING_TRACK: "WAITING_TRACK",
    PARSING: "PARSING",
    PARSED: "PARSED",
    ENDED: "ENDED",
    ERROR: "ERROR",
    WAITING_INIT_PTS: "WAITING_INIT_PTS",
    WAITING_LEVEL: "WAITING_LEVEL"
  };
  var BaseStreamController = class extends TaskLoop {
    constructor(hls, fragmentTracker, keyLoader, logPrefix, playlistType) {
      super(logPrefix, hls.logger);
      this.hls = void 0;
      this.fragPrevious = null;
      this.fragCurrent = null;
      this.fragmentTracker = void 0;
      this.transmuxer = null;
      this._state = State.STOPPED;
      this.playlistType = void 0;
      this.media = null;
      this.mediaBuffer = null;
      this.config = void 0;
      this.bitrateTest = false;
      this.lastCurrentTime = 0;
      this.nextLoadPosition = 0;
      this.startPosition = 0;
      this.startTimeOffset = null;
      this.retryDate = 0;
      this.levels = null;
      this.fragmentLoader = void 0;
      this.keyLoader = void 0;
      this.levelLastLoaded = null;
      this.startFragRequested = false;
      this.decrypter = void 0;
      this.initPTS = [];
      this.buffering = true;
      this.loadingParts = false;
      this.loopSn = void 0;
      this.onMediaSeeking = () => {
        const {
          config: config3,
          fragCurrent,
          media,
          mediaBuffer,
          state
        } = this;
        const currentTime = media ? media.currentTime : 0;
        const bufferInfo = BufferHelper.bufferInfo(mediaBuffer ? mediaBuffer : media, currentTime, config3.maxBufferHole);
        const noFowardBuffer = !bufferInfo.len;
        this.log(`Media seeking to ${isFiniteNumber(currentTime) ? currentTime.toFixed(3) : currentTime}, state: ${state}, ${noFowardBuffer ? "out of" : "in"} buffer`);
        if (this.state === State.ENDED) {
          this.resetLoadingState();
        } else if (fragCurrent) {
          const tolerance = config3.maxFragLookUpTolerance;
          const fragStartOffset = fragCurrent.start - tolerance;
          const fragEndOffset = fragCurrent.start + fragCurrent.duration + tolerance;
          if (noFowardBuffer || fragEndOffset < bufferInfo.start || fragStartOffset > bufferInfo.end) {
            const pastFragment = currentTime > fragEndOffset;
            if (currentTime < fragStartOffset || pastFragment) {
              if (pastFragment && fragCurrent.loader) {
                this.log(`Cancelling fragment load for seek (sn: ${fragCurrent.sn})`);
                fragCurrent.abortRequests();
                this.resetLoadingState();
              }
              this.fragPrevious = null;
            }
          }
        }
        if (media) {
          this.fragmentTracker.removeFragmentsInRange(currentTime, Infinity, this.playlistType, true);
          const lastCurrentTime = this.lastCurrentTime;
          if (currentTime > lastCurrentTime) {
            this.lastCurrentTime = currentTime;
          }
          if (!this.loadingParts) {
            const bufferEnd = Math.max(bufferInfo.end, currentTime);
            const shouldLoadParts = this.shouldLoadParts(this.getLevelDetails(), bufferEnd);
            if (shouldLoadParts) {
              this.log(`LL-Part loading ON after seeking to ${currentTime.toFixed(2)} with buffer @${bufferEnd.toFixed(2)}`);
              this.loadingParts = shouldLoadParts;
            }
          }
        }
        if (!this.hls.hasEnoughToStart) {
          this.log(`Setting ${noFowardBuffer ? "startPosition" : "nextLoadPosition"} to ${currentTime} for seek without enough to start`);
          this.nextLoadPosition = currentTime;
          if (noFowardBuffer) {
            this.startPosition = currentTime;
          }
        }
        if (noFowardBuffer && this.state === State.IDLE) {
          this.tickImmediate();
        }
      };
      this.onMediaEnded = () => {
        this.log(`setting startPosition to 0 because media ended`);
        this.startPosition = this.lastCurrentTime = 0;
      };
      this.playlistType = playlistType;
      this.hls = hls;
      this.fragmentLoader = new FragmentLoader(hls.config);
      this.keyLoader = keyLoader;
      this.fragmentTracker = fragmentTracker;
      this.config = hls.config;
      this.decrypter = new Decrypter(hls.config);
    }
    registerListeners() {
      const {
        hls
      } = this;
      hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
      hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
      hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);
      hls.on(Events.ERROR, this.onError, this);
    }
    unregisterListeners() {
      const {
        hls
      } = this;
      hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
      hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
      hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);
      hls.off(Events.ERROR, this.onError, this);
    }
    doTick() {
      this.onTickEnd();
    }
    onTickEnd() {
    }
    startLoad(startPosition) {
    }
    stopLoad() {
      if (this.state === State.STOPPED) {
        return;
      }
      this.fragmentLoader.abort();
      this.keyLoader.abort(this.playlistType);
      const frag = this.fragCurrent;
      if (frag != null && frag.loader) {
        frag.abortRequests();
        this.fragmentTracker.removeFragment(frag);
      }
      this.resetTransmuxer();
      this.fragCurrent = null;
      this.fragPrevious = null;
      this.clearInterval();
      this.clearNextTick();
      this.state = State.STOPPED;
    }
    get startPositionValue() {
      const {
        nextLoadPosition,
        startPosition
      } = this;
      if (startPosition === -1 && nextLoadPosition) {
        return nextLoadPosition;
      }
      return startPosition;
    }
    get bufferingEnabled() {
      return this.buffering;
    }
    pauseBuffering() {
      this.buffering = false;
    }
    resumeBuffering() {
      this.buffering = true;
    }
    get inFlightFrag() {
      return {
        frag: this.fragCurrent,
        state: this.state
      };
    }
    _streamEnded(bufferInfo, levelDetails) {
      if (levelDetails.live || !this.media) {
        return false;
      }
      const bufferEnd = bufferInfo.end || 0;
      const timelineStart = this.config.timelineOffset || 0;
      if (bufferEnd <= timelineStart) {
        return false;
      }
      const bufferedRanges = bufferInfo.buffered;
      if (this.config.maxBufferHole && bufferedRanges && bufferedRanges.length > 1) {
        bufferInfo = BufferHelper.bufferedInfo(bufferedRanges, bufferInfo.start, 0);
      }
      const nextStart = bufferInfo.nextStart;
      const hasSecondBufferedRange = nextStart && nextStart > timelineStart && nextStart < levelDetails.edge;
      if (hasSecondBufferedRange) {
        return false;
      }
      if (this.media.currentTime < bufferInfo.start) {
        return false;
      }
      const partList = levelDetails.partList;
      if (partList != null && partList.length) {
        const lastPart = partList[partList.length - 1];
        const lastPartBuffered = BufferHelper.isBuffered(this.media, lastPart.start + lastPart.duration / 2);
        return lastPartBuffered;
      }
      const playlistType = levelDetails.fragments[levelDetails.fragments.length - 1].type;
      return this.fragmentTracker.isEndListAppended(playlistType);
    }
    getLevelDetails() {
      if (this.levels && this.levelLastLoaded !== null) {
        return this.levelLastLoaded.details;
      }
    }
    get timelineOffset() {
      const configuredTimelineOffset = this.config.timelineOffset;
      if (configuredTimelineOffset) {
        var _this$getLevelDetails;
        return ((_this$getLevelDetails = this.getLevelDetails()) == null ? void 0 : _this$getLevelDetails.appliedTimelineOffset) || configuredTimelineOffset;
      }
      return 0;
    }
    onMediaAttached(event, data) {
      const media = this.media = this.mediaBuffer = data.media;
      addEventListener(media, "seeking", this.onMediaSeeking);
      addEventListener(media, "ended", this.onMediaEnded);
      const config3 = this.config;
      if (this.levels && config3.autoStartLoad && this.state === State.STOPPED) {
        this.startLoad(config3.startPosition);
      }
    }
    onMediaDetaching(event, data) {
      const transferringMedia = !!data.transferMedia;
      const media = this.media;
      if (media === null) {
        return;
      }
      if (media.ended) {
        this.log("MSE detaching and video ended, reset startPosition");
        this.startPosition = this.lastCurrentTime = 0;
      }
      removeEventListener(media, "seeking", this.onMediaSeeking);
      removeEventListener(media, "ended", this.onMediaEnded);
      if (this.keyLoader && !transferringMedia) {
        this.keyLoader.detach();
      }
      this.media = this.mediaBuffer = null;
      this.loopSn = void 0;
      if (transferringMedia) {
        this.resetLoadingState();
        this.resetTransmuxer();
        return;
      }
      this.loadingParts = false;
      this.fragmentTracker.removeAllFragments();
      this.stopLoad();
    }
    onManifestLoading() {
      this.initPTS = [];
      this.levels = this.levelLastLoaded = this.fragCurrent = null;
      this.lastCurrentTime = this.startPosition = 0;
      this.startFragRequested = false;
    }
    onError(event, data) {
    }
    onManifestLoaded(event, data) {
      this.startTimeOffset = data.startTimeOffset;
    }
    onHandlerDestroying() {
      this.stopLoad();
      if (this.transmuxer) {
        this.transmuxer.destroy();
        this.transmuxer = null;
      }
      super.onHandlerDestroying();
      this.hls = this.onMediaSeeking = this.onMediaEnded = null;
    }
    onHandlerDestroyed() {
      this.state = State.STOPPED;
      if (this.fragmentLoader) {
        this.fragmentLoader.destroy();
      }
      if (this.keyLoader) {
        this.keyLoader.destroy();
      }
      if (this.decrypter) {
        this.decrypter.destroy();
      }
      this.hls = this.log = this.warn = this.decrypter = this.keyLoader = this.fragmentLoader = this.fragmentTracker = null;
      super.onHandlerDestroyed();
    }
    loadFragment(frag, level, targetBufferTime) {
      this.startFragRequested = true;
      this._loadFragForPlayback(frag, level, targetBufferTime);
    }
    _loadFragForPlayback(fragment, level, targetBufferTime) {
      const progressCallback = (data) => {
        const frag = data.frag;
        if (this.fragContextChanged(frag)) {
          this.warn(`${frag.type} sn: ${frag.sn}${data.part ? " part: " + data.part.index : ""} of ${this.fragInfo(frag, false, data.part)}) was dropped during download.`);
          this.fragmentTracker.removeFragment(frag);
          return;
        }
        frag.stats.chunkCount++;
        this._handleFragmentLoadProgress(data);
      };
      this._doFragLoad(fragment, level, targetBufferTime, progressCallback).then((data) => {
        if (!data) {
          return;
        }
        const state = this.state;
        const frag = data.frag;
        if (this.fragContextChanged(frag)) {
          if (state === State.FRAG_LOADING || !this.fragCurrent && state === State.PARSING) {
            this.fragmentTracker.removeFragment(frag);
            this.state = State.IDLE;
          }
          return;
        }
        if ("payload" in data) {
          this.log(`Loaded ${frag.type} sn: ${frag.sn} of ${this.playlistLabel()} ${frag.level}`);
          this.hls.trigger(Events.FRAG_LOADED, data);
        }
        this._handleFragmentLoadComplete(data);
      }).catch((reason) => {
        if (this.state === State.STOPPED || this.state === State.ERROR) {
          return;
        }
        this.warn(`Frag error: ${(reason == null ? void 0 : reason.message) || reason}`);
        this.resetFragmentLoading(fragment);
      });
    }
    clearTrackerIfNeeded(frag) {
      var _this$mediaBuffer;
      const {
        fragmentTracker
      } = this;
      const fragState = fragmentTracker.getState(frag);
      if (fragState === FragmentState.APPENDING) {
        const playlistType = frag.type;
        const bufferedInfo = this.getFwdBufferInfo(this.mediaBuffer, playlistType);
        const minForwardBufferLength = Math.max(frag.duration, bufferedInfo ? bufferedInfo.len : this.config.maxBufferLength);
        const backtrackFragment = this.backtrackFragment;
        const backtracked = backtrackFragment ? frag.sn - backtrackFragment.sn : 0;
        if (backtracked === 1 || this.reduceMaxBufferLength(minForwardBufferLength, frag.duration)) {
          fragmentTracker.removeFragment(frag);
        }
      } else if (((_this$mediaBuffer = this.mediaBuffer) == null ? void 0 : _this$mediaBuffer.buffered.length) === 0) {
        fragmentTracker.removeAllFragments();
      } else if (fragmentTracker.hasParts(frag.type)) {
        fragmentTracker.detectPartialFragments({
          frag,
          part: null,
          stats: frag.stats,
          id: frag.type
        });
        if (fragmentTracker.getState(frag) === FragmentState.PARTIAL) {
          fragmentTracker.removeFragment(frag);
        }
      }
    }
    checkLiveUpdate(details) {
      if (details.updated && !details.live) {
        const lastFragment = details.fragments[details.fragments.length - 1];
        this.fragmentTracker.detectPartialFragments({
          frag: lastFragment,
          part: null,
          stats: lastFragment.stats,
          id: lastFragment.type
        });
      }
      if (!details.fragments[0]) {
        details.deltaUpdateFailed = true;
      }
    }
    waitForLive(levelInfo) {
      const details = levelInfo.details;
      return (details == null ? void 0 : details.live) && details.type !== "EVENT" && (this.levelLastLoaded !== levelInfo || details.expired);
    }
    flushMainBuffer(startOffset, endOffset, type = null) {
      if (!(startOffset - endOffset)) {
        return;
      }
      const flushScope = {
        startOffset,
        endOffset,
        type
      };
      this.hls.trigger(Events.BUFFER_FLUSHING, flushScope);
    }
    _loadInitSegment(fragment, level) {
      this._doFragLoad(fragment, level).then((data) => {
        const frag = data == null ? void 0 : data.frag;
        if (!frag || this.fragContextChanged(frag) || !this.levels) {
          throw new Error("init load aborted");
        }
        return data;
      }).then((data) => {
        const {
          hls
        } = this;
        const {
          frag,
          payload
        } = data;
        const decryptData = frag.decryptdata;
        if (payload && payload.byteLength > 0 && decryptData != null && decryptData.key && decryptData.iv && isFullSegmentEncryption(decryptData.method)) {
          const startTime = self.performance.now();
          return this.decrypter.decrypt(new Uint8Array(payload), decryptData.key.buffer, decryptData.iv.buffer, getAesModeFromFullSegmentMethod(decryptData.method)).catch((err) => {
            hls.trigger(Events.ERROR, {
              type: ErrorTypes.MEDIA_ERROR,
              details: ErrorDetails.FRAG_DECRYPT_ERROR,
              fatal: false,
              error: err,
              reason: err.message,
              frag
            });
            throw err;
          }).then((decryptedData) => {
            const endTime = self.performance.now();
            hls.trigger(Events.FRAG_DECRYPTED, {
              frag,
              payload: decryptedData,
              stats: {
                tstart: startTime,
                tdecrypt: endTime
              }
            });
            data.payload = decryptedData;
            return this.completeInitSegmentLoad(data);
          });
        }
        return this.completeInitSegmentLoad(data);
      }).catch((reason) => {
        if (this.state === State.STOPPED || this.state === State.ERROR) {
          return;
        }
        this.warn(reason);
        this.resetFragmentLoading(fragment);
      });
    }
    completeInitSegmentLoad(data) {
      const {
        levels
      } = this;
      if (!levels) {
        throw new Error("init load aborted, missing levels");
      }
      const stats = data.frag.stats;
      if (this.state !== State.STOPPED) {
        this.state = State.IDLE;
      }
      data.frag.data = new Uint8Array(data.payload);
      stats.parsing.start = stats.buffering.start = self.performance.now();
      stats.parsing.end = stats.buffering.end = self.performance.now();
      this.tick();
    }
    unhandledEncryptionError(initSegment, frag) {
      var _tracks$audio, _tracks$video;
      const tracks = initSegment.tracks;
      if (tracks && !frag.encrypted && ((_tracks$audio = tracks.audio) != null && _tracks$audio.encrypted || (_tracks$video = tracks.video) != null && _tracks$video.encrypted) && (!this.config.emeEnabled || !this.keyLoader.emeController)) {
        const media = this.media;
        const error = new Error(`Encrypted track with no key in ${this.fragInfo(frag)} (media ${media ? "attached mediaKeys: " + media.mediaKeys : "detached"})`);
        this.warn(error.message);
        if (!media || media.mediaKeys) {
          return false;
        }
        this.hls.trigger(Events.ERROR, {
          type: ErrorTypes.KEY_SYSTEM_ERROR,
          details: ErrorDetails.KEY_SYSTEM_NO_KEYS,
          fatal: false,
          error,
          frag
        });
        this.resetTransmuxer();
        return true;
      }
      return false;
    }
    fragContextChanged(frag) {
      const {
        fragCurrent
      } = this;
      return !frag || !fragCurrent || frag.sn !== fragCurrent.sn || frag.level !== fragCurrent.level;
    }
    fragBufferedComplete(frag, part) {
      const media = this.mediaBuffer ? this.mediaBuffer : this.media;
      this.log(`Buffered ${frag.type} sn: ${frag.sn}${part ? " part: " + part.index : ""} of ${this.fragInfo(frag, false, part)} > buffer:${media ? TimeRanges.toString(BufferHelper.getBuffered(media)) : "(detached)"})`);
      if (isMediaFragment(frag)) {
        var _this$levels;
        if (frag.type !== PlaylistLevelType.SUBTITLE) {
          const el = frag.elementaryStreams;
          if (!Object.keys(el).some((type) => !!el[type])) {
            this.state = State.IDLE;
            return;
          }
        }
        const level = (_this$levels = this.levels) == null ? void 0 : _this$levels[frag.level];
        if (level != null && level.fragmentError) {
          this.log(`Resetting level fragment error count of ${level.fragmentError} on frag buffered`);
          level.fragmentError = 0;
        }
      }
      this.state = State.IDLE;
    }
    _handleFragmentLoadComplete(fragLoadedEndData) {
      const {
        transmuxer
      } = this;
      if (!transmuxer) {
        return;
      }
      const {
        frag,
        part,
        partsLoaded
      } = fragLoadedEndData;
      const complete = !partsLoaded || partsLoaded.length === 0 || partsLoaded.some((fragLoaded) => !fragLoaded);
      const chunkMeta = new ChunkMetadata(frag.level, frag.sn, frag.stats.chunkCount + 1, 0, part ? part.index : -1, !complete);
      transmuxer.flush(chunkMeta);
    }
    _handleFragmentLoadProgress(frag) {
    }
    _doFragLoad(frag, level, targetBufferTime = null, progressCallback) {
      var _frag$decryptdata;
      this.fragCurrent = frag;
      const details = level.details;
      if (!this.levels || !details) {
        throw new Error(`frag load aborted, missing level${details ? "" : " detail"}s`);
      }
      let keyLoadingPromise = null;
      if (frag.encrypted && !((_frag$decryptdata = frag.decryptdata) != null && _frag$decryptdata.key)) {
        this.log(`Loading key for ${frag.sn} of [${details.startSN}-${details.endSN}], ${this.playlistLabel()} ${frag.level}`);
        this.state = State.KEY_LOADING;
        this.fragCurrent = frag;
        keyLoadingPromise = this.keyLoader.load(frag).then((keyLoadedData) => {
          if (!this.fragContextChanged(keyLoadedData.frag)) {
            this.hls.trigger(Events.KEY_LOADED, keyLoadedData);
            if (this.state === State.KEY_LOADING) {
              this.state = State.IDLE;
            }
            return keyLoadedData;
          }
        });
        this.hls.trigger(Events.KEY_LOADING, {
          frag
        });
        if (this.fragCurrent === null) {
          this.log(`context changed in KEY_LOADING`);
          return Promise.resolve(null);
        }
      } else if (!frag.encrypted) {
        keyLoadingPromise = this.keyLoader.loadClear(frag, details.encryptedFragments, this.startFragRequested);
        if (keyLoadingPromise) {
          this.log(`[eme] blocking frag load until media-keys acquired`);
        }
      }
      const fragPrevious = this.fragPrevious;
      if (isMediaFragment(frag) && (!fragPrevious || frag.sn !== fragPrevious.sn)) {
        const shouldLoadParts = this.shouldLoadParts(level.details, frag.end);
        if (shouldLoadParts !== this.loadingParts) {
          this.log(`LL-Part loading ${shouldLoadParts ? "ON" : "OFF"} loading sn ${fragPrevious == null ? void 0 : fragPrevious.sn}->${frag.sn}`);
          this.loadingParts = shouldLoadParts;
        }
      }
      targetBufferTime = Math.max(frag.start, targetBufferTime || 0);
      if (this.loadingParts && isMediaFragment(frag)) {
        const partList = details.partList;
        if (partList && progressCallback) {
          if (targetBufferTime > details.fragmentEnd && details.fragmentHint) {
            frag = details.fragmentHint;
          }
          const partIndex = this.getNextPart(partList, frag, targetBufferTime);
          if (partIndex > -1) {
            const part = partList[partIndex];
            frag = this.fragCurrent = part.fragment;
            this.log(`Loading ${frag.type} sn: ${frag.sn} part: ${part.index} (${partIndex}/${partList.length - 1}) of ${this.fragInfo(frag, false, part)}) cc: ${frag.cc} [${details.startSN}-${details.endSN}], target: ${parseFloat(targetBufferTime.toFixed(3))}`);
            this.nextLoadPosition = part.start + part.duration;
            this.state = State.FRAG_LOADING;
            let _result;
            if (keyLoadingPromise) {
              _result = keyLoadingPromise.then((keyLoadedData) => {
                if (!keyLoadedData || this.fragContextChanged(keyLoadedData.frag)) {
                  return null;
                }
                return this.doFragPartsLoad(frag, part, level, progressCallback);
              }).catch((error) => this.handleFragLoadError(error));
            } else {
              _result = this.doFragPartsLoad(frag, part, level, progressCallback).catch((error) => this.handleFragLoadError(error));
            }
            this.hls.trigger(Events.FRAG_LOADING, {
              frag,
              part,
              targetBufferTime
            });
            if (this.fragCurrent === null) {
              return Promise.reject(new Error(`frag load aborted, context changed in FRAG_LOADING parts`));
            }
            return _result;
          } else if (!frag.url || this.loadedEndOfParts(partList, targetBufferTime)) {
            return Promise.resolve(null);
          }
        }
      }
      if (isMediaFragment(frag) && this.loadingParts) {
        var _details$partList;
        this.log(`LL-Part loading OFF after next part miss @${targetBufferTime.toFixed(2)} Check buffer at sn: ${frag.sn} loaded parts: ${(_details$partList = details.partList) == null ? void 0 : _details$partList.filter((p) => p.loaded).map((p) => `[${p.start}-${p.end}]`)}`);
        this.loadingParts = false;
      } else if (!frag.url) {
        return Promise.resolve(null);
      }
      this.log(`Loading ${frag.type} sn: ${frag.sn} of ${this.fragInfo(frag, false)}) cc: ${frag.cc} ${"[" + details.startSN + "-" + details.endSN + "]"}, target: ${parseFloat(targetBufferTime.toFixed(3))}`);
      if (isFiniteNumber(frag.sn) && !this.bitrateTest) {
        this.nextLoadPosition = frag.start + frag.duration;
      }
      this.state = State.FRAG_LOADING;
      const dataOnProgress = this.config.progressive;
      let result;
      if (dataOnProgress && keyLoadingPromise) {
        result = keyLoadingPromise.then((keyLoadedData) => {
          if (!keyLoadedData || this.fragContextChanged(keyLoadedData.frag)) {
            return null;
          }
          return this.fragmentLoader.load(frag, progressCallback);
        }).catch((error) => this.handleFragLoadError(error));
      } else {
        result = Promise.all([this.fragmentLoader.load(frag, dataOnProgress ? progressCallback : void 0), keyLoadingPromise]).then(([fragLoadedData]) => {
          if (!dataOnProgress && progressCallback) {
            progressCallback(fragLoadedData);
          }
          return fragLoadedData;
        }).catch((error) => this.handleFragLoadError(error));
      }
      this.hls.trigger(Events.FRAG_LOADING, {
        frag,
        targetBufferTime
      });
      if (this.fragCurrent === null) {
        return Promise.reject(new Error(`frag load aborted, context changed in FRAG_LOADING`));
      }
      return result;
    }
    doFragPartsLoad(frag, fromPart, level, progressCallback) {
      return new Promise((resolve, reject) => {
        var _level$details;
        const partsLoaded = [];
        const initialPartList = (_level$details = level.details) == null ? void 0 : _level$details.partList;
        const loadPart = (part) => {
          this.fragmentLoader.loadPart(frag, part, progressCallback).then((partLoadedData) => {
            partsLoaded[part.index] = partLoadedData;
            const loadedPart = partLoadedData.part;
            this.hls.trigger(Events.FRAG_LOADED, partLoadedData);
            const nextPart = getPartWith(level.details, frag.sn, part.index + 1) || findPart(initialPartList, frag.sn, part.index + 1);
            if (nextPart) {
              loadPart(nextPart);
            } else {
              return resolve({
                frag,
                part: loadedPart,
                partsLoaded
              });
            }
          }).catch(reject);
        };
        loadPart(fromPart);
      });
    }
    handleFragLoadError(error) {
      if ("data" in error) {
        const data = error.data;
        if (data.frag && data.details === ErrorDetails.INTERNAL_ABORTED) {
          this.handleFragLoadAborted(data.frag, data.part);
        } else if (data.frag && data.type === ErrorTypes.KEY_SYSTEM_ERROR) {
          data.frag.abortRequests();
          this.resetStartWhenNotLoaded();
          this.resetFragmentLoading(data.frag);
        } else {
          this.hls.trigger(Events.ERROR, data);
        }
      } else {
        this.hls.trigger(Events.ERROR, {
          type: ErrorTypes.OTHER_ERROR,
          details: ErrorDetails.INTERNAL_EXCEPTION,
          err: error,
          error,
          fatal: true
        });
      }
      return null;
    }
    _handleTransmuxerFlush(chunkMeta) {
      const context3 = this.getCurrentContext(chunkMeta);
      if (!context3 || this.state !== State.PARSING) {
        if (!this.fragCurrent && this.state !== State.STOPPED && this.state !== State.ERROR) {
          this.state = State.IDLE;
        }
        return;
      }
      const {
        frag,
        part,
        level
      } = context3;
      const now3 = self.performance.now();
      frag.stats.parsing.end = now3;
      if (part) {
        part.stats.parsing.end = now3;
      }
      const levelDetails = this.getLevelDetails();
      const loadingPartsAtEdge = levelDetails && frag.sn > levelDetails.endSN;
      const shouldLoadParts = loadingPartsAtEdge || this.shouldLoadParts(levelDetails, frag.end);
      if (shouldLoadParts !== this.loadingParts) {
        this.log(`LL-Part loading ${shouldLoadParts ? "ON" : "OFF"} after parsing segment ending @${frag.end.toFixed(2)}`);
        this.loadingParts = shouldLoadParts;
      }
      this.updateLevelTiming(frag, part, level, chunkMeta.partial);
    }
    shouldLoadParts(details, bufferEnd) {
      if (this.config.lowLatencyMode) {
        if (!details) {
          return this.loadingParts;
        }
        if (details.partList) {
          var _details$fragmentHint;
          const firstPart = details.partList[0];
          if (firstPart.fragment.type === PlaylistLevelType.SUBTITLE) {
            return false;
          }
          const safePartStart = firstPart.end + (((_details$fragmentHint = details.fragmentHint) == null ? void 0 : _details$fragmentHint.duration) || 0);
          if (bufferEnd >= safePartStart) {
            var _this$media;
            const playhead = this.hls.hasEnoughToStart ? ((_this$media = this.media) == null ? void 0 : _this$media.currentTime) || this.lastCurrentTime : this.getLoadPosition();
            if (playhead > firstPart.start - firstPart.fragment.duration) {
              return true;
            }
          }
        }
      }
      return false;
    }
    getCurrentContext(chunkMeta) {
      const {
        levels,
        fragCurrent
      } = this;
      const {
        level: levelIndex,
        sn,
        part: partIndex
      } = chunkMeta;
      if (!(levels != null && levels[levelIndex])) {
        this.warn(`Levels object was unset while buffering fragment ${sn} of ${this.playlistLabel()} ${levelIndex}. The current chunk will not be buffered.`);
        return null;
      }
      const level = levels[levelIndex];
      const levelDetails = level.details;
      const part = partIndex > -1 ? getPartWith(levelDetails, sn, partIndex) : null;
      const frag = part ? part.fragment : getFragmentWithSN(levelDetails, sn, fragCurrent);
      if (!frag) {
        return null;
      }
      if (fragCurrent && fragCurrent !== frag) {
        frag.stats = fragCurrent.stats;
      }
      return {
        frag,
        part,
        level
      };
    }
    bufferFragmentData(data, frag, part, chunkMeta, noBacktracking) {
      if (this.state !== State.PARSING) {
        return;
      }
      const {
        data1,
        data2
      } = data;
      let buffer = data1;
      if (data2) {
        buffer = appendUint8Array(data1, data2);
      }
      if (!buffer.length) {
        return;
      }
      const offsetTimestamp = this.initPTS[frag.cc];
      const offset = offsetTimestamp ? -offsetTimestamp.baseTime / offsetTimestamp.timescale : void 0;
      const segment = {
        type: data.type,
        frag,
        part,
        chunkMeta,
        offset,
        parent: frag.type,
        data: buffer
      };
      this.hls.trigger(Events.BUFFER_APPENDING, segment);
      if (data.dropped && data.independent && !part) {
        if (noBacktracking) {
          return;
        }
        this.flushBufferGap(frag);
      }
    }
    flushBufferGap(frag) {
      const media = this.media;
      if (!media) {
        return;
      }
      if (!BufferHelper.isBuffered(media, media.currentTime)) {
        this.flushMainBuffer(0, frag.start);
        return;
      }
      const currentTime = media.currentTime;
      const bufferInfo = BufferHelper.bufferInfo(media, currentTime, 0);
      const fragDuration = frag.duration;
      const segmentFraction = Math.min(this.config.maxFragLookUpTolerance * 2, fragDuration * 0.25);
      const start = Math.max(Math.min(frag.start - segmentFraction, bufferInfo.end - segmentFraction), currentTime + segmentFraction);
      if (frag.start - start > segmentFraction) {
        this.flushMainBuffer(start, frag.start);
      }
    }
    getFwdBufferInfo(bufferable, type) {
      var _this$media2;
      const pos = this.getLoadPosition();
      if (!isFiniteNumber(pos)) {
        return null;
      }
      const backwardSeek = this.lastCurrentTime > pos;
      const maxBufferHole = backwardSeek || (_this$media2 = this.media) != null && _this$media2.paused ? 0 : this.config.maxBufferHole;
      return this.getFwdBufferInfoAtPos(bufferable, pos, type, maxBufferHole);
    }
    getFwdBufferInfoAtPos(bufferable, pos, type, maxBufferHole) {
      const bufferInfo = BufferHelper.bufferInfo(bufferable, pos, maxBufferHole);
      if (bufferInfo.len === 0 && bufferInfo.nextStart !== void 0) {
        const bufferedFragAtPos = this.fragmentTracker.getBufferedFrag(pos, type);
        if (bufferedFragAtPos && (bufferInfo.nextStart <= bufferedFragAtPos.end || bufferedFragAtPos.gap)) {
          const gapDuration = Math.max(Math.min(bufferInfo.nextStart, bufferedFragAtPos.end) - pos, maxBufferHole);
          return BufferHelper.bufferInfo(bufferable, pos, gapDuration);
        }
      }
      return bufferInfo;
    }
    getMaxBufferLength(levelBitrate) {
      const {
        config: config3
      } = this;
      let maxBufLen;
      if (levelBitrate) {
        maxBufLen = Math.max(8 * config3.maxBufferSize / levelBitrate, config3.maxBufferLength);
      } else {
        maxBufLen = config3.maxBufferLength;
      }
      return Math.min(maxBufLen, config3.maxMaxBufferLength);
    }
    reduceMaxBufferLength(threshold, fragDuration) {
      const config3 = this.config;
      const minLength = Math.max(Math.min(threshold - fragDuration, config3.maxBufferLength), fragDuration);
      const reducedLength = Math.max(threshold - fragDuration * 3, config3.maxMaxBufferLength / 2, minLength);
      if (reducedLength >= minLength) {
        config3.maxMaxBufferLength = reducedLength;
        this.warn(`Reduce max buffer length to ${reducedLength}s`);
        return true;
      }
      return false;
    }
    getAppendedFrag(position, playlistType = PlaylistLevelType.MAIN) {
      const fragOrPart = this.fragmentTracker ? this.fragmentTracker.getAppendedFrag(position, playlistType) : null;
      if (fragOrPart && "fragment" in fragOrPart) {
        return fragOrPart.fragment;
      }
      return fragOrPart;
    }
    getNextFragment(pos, levelDetails) {
      const fragments = levelDetails.fragments;
      const fragLen = fragments.length;
      if (!fragLen) {
        return null;
      }
      const {
        config: config3
      } = this;
      const start = fragments[0].start;
      const canLoadParts = config3.lowLatencyMode && !!levelDetails.partList;
      let frag = null;
      if (levelDetails.live) {
        const initialLiveManifestSize = config3.initialLiveManifestSize;
        if (fragLen < initialLiveManifestSize) {
          this.warn(`Not enough fragments to start playback (have: ${fragLen}, need: ${initialLiveManifestSize})`);
          return null;
        }
        if (!levelDetails.PTSKnown && !this.startFragRequested && this.startPosition === -1 || pos < start) {
          var _frag;
          if (canLoadParts && !this.loadingParts) {
            this.log(`LL-Part loading ON for initial live fragment`);
            this.loadingParts = true;
          }
          frag = this.getInitialLiveFragment(levelDetails);
          const mainStart = this.hls.startPosition;
          const liveSyncPosition = this.hls.liveSyncPosition;
          const startPosition = frag ? (mainStart !== -1 && mainStart >= start ? mainStart : liveSyncPosition) || frag.start : pos;
          this.log(`Setting startPosition to ${startPosition} to match start frag at live edge. mainStart: ${mainStart} liveSyncPosition: ${liveSyncPosition} frag.start: ${(_frag = frag) == null ? void 0 : _frag.start}`);
          this.startPosition = this.nextLoadPosition = startPosition;
        }
      } else if (pos <= start) {
        frag = fragments[0];
      }
      if (!frag) {
        const end = this.loadingParts ? levelDetails.partEnd : levelDetails.fragmentEnd;
        frag = this.getFragmentAtPosition(pos, end, levelDetails);
      }
      let programFrag = this.filterReplacedPrimary(frag, levelDetails);
      if (!programFrag && frag) {
        const curSNIdx = frag.sn - levelDetails.startSN;
        programFrag = this.filterReplacedPrimary(fragments[curSNIdx + 1] || null, levelDetails);
      }
      return this.mapToInitFragWhenRequired(programFrag);
    }
    isLoopLoading(frag, targetBufferTime) {
      const trackerState = this.fragmentTracker.getState(frag);
      return (trackerState === FragmentState.OK || trackerState === FragmentState.PARTIAL && !!frag.gap) && this.nextLoadPosition > targetBufferTime;
    }
    getNextFragmentLoopLoading(frag, levelDetails, bufferInfo, playlistType, maxBufLen) {
      let nextFragment = null;
      if (frag.gap) {
        nextFragment = this.getNextFragment(this.nextLoadPosition, levelDetails);
        if (nextFragment && !nextFragment.gap && bufferInfo.nextStart) {
          const nextbufferInfo = this.getFwdBufferInfoAtPos(this.mediaBuffer ? this.mediaBuffer : this.media, bufferInfo.nextStart, playlistType, 0);
          if (nextbufferInfo !== null && bufferInfo.len + nextbufferInfo.len >= maxBufLen) {
            const sn = nextFragment.sn;
            if (this.loopSn !== sn) {
              this.log(`buffer full after gaps in "${playlistType}" playlist starting at sn: ${sn}`);
              this.loopSn = sn;
            }
            return null;
          }
        }
      }
      this.loopSn = void 0;
      return nextFragment;
    }
    get primaryPrefetch() {
      if (interstitialsEnabled(this.config)) {
        var _this$hls$interstitia;
        const playingInterstitial = (_this$hls$interstitia = this.hls.interstitialsManager) == null || (_this$hls$interstitia = _this$hls$interstitia.playingItem) == null ? void 0 : _this$hls$interstitia.event;
        if (playingInterstitial) {
          return true;
        }
      }
      return false;
    }
    filterReplacedPrimary(frag, details) {
      if (!frag) {
        return frag;
      }
      if (interstitialsEnabled(this.config) && frag.type !== PlaylistLevelType.SUBTITLE) {
        const interstitials = this.hls.interstitialsManager;
        const bufferingItem = interstitials == null ? void 0 : interstitials.bufferingItem;
        if (bufferingItem) {
          const bufferingInterstitial = bufferingItem.event;
          if (bufferingInterstitial) {
            if (bufferingInterstitial.appendInPlace || Math.abs(frag.start - bufferingItem.start) > 1 || bufferingItem.start === 0) {
              return null;
            }
          } else {
            if (frag.end <= bufferingItem.start && (details == null ? void 0 : details.live) === false) {
              return null;
            }
            if (frag.start > bufferingItem.end && bufferingItem.nextEvent) {
              if (bufferingItem.nextEvent.appendInPlace || frag.start - bufferingItem.end > 1) {
                return null;
              }
            }
          }
        }
        const playerQueue = interstitials == null ? void 0 : interstitials.playerQueue;
        if (playerQueue) {
          for (let i = playerQueue.length; i--; ) {
            const interstitial = playerQueue[i].interstitial;
            if (interstitial.appendInPlace && frag.start >= interstitial.startTime && frag.end <= interstitial.resumeTime) {
              return null;
            }
          }
        }
      }
      return frag;
    }
    mapToInitFragWhenRequired(frag) {
      if (frag != null && frag.initSegment && !frag.initSegment.data && !this.bitrateTest) {
        return frag.initSegment;
      }
      return frag;
    }
    getNextPart(partList, frag, targetBufferTime) {
      let nextPart = -1;
      let contiguous = false;
      let independentAttrOmitted = true;
      for (let i = 0, len = partList.length; i < len; i++) {
        const part = partList[i];
        independentAttrOmitted = independentAttrOmitted && !part.independent;
        if (nextPart > -1 && targetBufferTime < part.start) {
          break;
        }
        const loaded = part.loaded;
        if (loaded) {
          nextPart = -1;
        } else if (contiguous || (part.independent || independentAttrOmitted) && part.fragment === frag) {
          if (part.fragment !== frag) {
            this.warn(`Need buffer at ${targetBufferTime} but next unloaded part starts at ${part.start}`);
          }
          nextPart = i;
        }
        contiguous = loaded;
      }
      return nextPart;
    }
    loadedEndOfParts(partList, targetBufferTime) {
      let part;
      for (let i = partList.length; i--; ) {
        part = partList[i];
        if (!part.loaded) {
          return false;
        }
        if (targetBufferTime > part.start) {
          return true;
        }
      }
      return false;
    }
    /*
     This method is used find the best matching first fragment for a live playlist. This fragment is used to calculate the
     "sliding" of the playlist, which is its offset from the start of playback. After sliding we can compute the real
     start and end times for each fragment in the playlist (after which this method will not need to be called).
    */
    getInitialLiveFragment(levelDetails) {
      const fragments = levelDetails.fragments;
      const fragPrevious = this.fragPrevious;
      let frag = null;
      if (fragPrevious) {
        if (levelDetails.hasProgramDateTime) {
          this.log(`Live playlist, switching playlist, load frag with same PDT: ${fragPrevious.programDateTime}`);
          frag = findFragmentByPDT(fragments, fragPrevious.endProgramDateTime, this.config.maxFragLookUpTolerance);
        }
        if (!frag) {
          const targetSN = fragPrevious.sn + 1;
          if (targetSN >= levelDetails.startSN && targetSN <= levelDetails.endSN) {
            const fragNext = fragments[targetSN - levelDetails.startSN];
            if (fragPrevious.cc === fragNext.cc) {
              frag = fragNext;
              this.log(`Live playlist, switching playlist, load frag with next SN: ${frag.sn}`);
            }
          }
          if (!frag) {
            frag = findNearestWithCC(levelDetails, fragPrevious.cc, fragPrevious.end);
            if (frag) {
              this.log(`Live playlist, switching playlist, load frag with same CC: ${frag.sn}`);
            }
          }
        }
      } else {
        const liveStart = this.hls.liveSyncPosition;
        if (liveStart !== null) {
          frag = this.getFragmentAtPosition(liveStart, this.bitrateTest ? levelDetails.fragmentEnd : levelDetails.edge, levelDetails);
        }
      }
      return frag;
    }
    /*
    This method finds the best matching fragment given the provided position.
     */
    getFragmentAtPosition(bufferEnd, end, levelDetails) {
      const {
        config: config3
      } = this;
      let {
        fragPrevious
      } = this;
      let {
        fragments,
        endSN
      } = levelDetails;
      const {
        fragmentHint
      } = levelDetails;
      const {
        maxFragLookUpTolerance
      } = config3;
      const partList = levelDetails.partList;
      const loadingParts = !!(this.loadingParts && partList != null && partList.length && fragmentHint);
      if (loadingParts && !this.bitrateTest && partList[partList.length - 1].fragment.sn === fragmentHint.sn) {
        fragments = fragments.concat(fragmentHint);
        endSN = fragmentHint.sn;
      }
      let frag;
      if (bufferEnd < end) {
        var _this$media3;
        const backwardSeek = bufferEnd < this.lastCurrentTime;
        const lookupTolerance = backwardSeek || bufferEnd > end - maxFragLookUpTolerance || (_this$media3 = this.media) != null && _this$media3.paused || !this.startFragRequested ? 0 : maxFragLookUpTolerance;
        frag = findFragmentByPTS(fragPrevious, fragments, bufferEnd, lookupTolerance);
      } else {
        frag = fragments[fragments.length - 1];
      }
      if (frag) {
        const curSNIdx = frag.sn - levelDetails.startSN;
        const fragState = this.fragmentTracker.getState(frag);
        if (fragState === FragmentState.OK || fragState === FragmentState.PARTIAL && frag.gap) {
          fragPrevious = frag;
        }
        if (fragPrevious && frag.sn === fragPrevious.sn && (!loadingParts || partList[0].fragment.sn > frag.sn || !levelDetails.live)) {
          const sameLevel = frag.level === fragPrevious.level;
          if (sameLevel) {
            const nextFrag = fragments[curSNIdx + 1];
            if (frag.sn < endSN && this.fragmentTracker.getState(nextFrag) !== FragmentState.OK) {
              frag = nextFrag;
            } else {
              frag = null;
            }
          }
        }
      }
      return frag;
    }
    alignPlaylists(details, previousDetails, switchDetails) {
      const length = details.fragments.length;
      if (!length) {
        this.warn(`No fragments in live playlist`);
        return 0;
      }
      const slidingStart = details.fragmentStart;
      const firstLevelLoad = !previousDetails;
      const aligned = details.alignedSliding && isFiniteNumber(slidingStart);
      if (firstLevelLoad || !aligned && !slidingStart) {
        alignStream(switchDetails, details);
        const alignedSlidingStart = details.fragmentStart;
        this.log(`Live playlist sliding: ${alignedSlidingStart.toFixed(2)} start-sn: ${previousDetails ? previousDetails.startSN : "na"}->${details.startSN} fragments: ${length}`);
        return alignedSlidingStart;
      }
      return slidingStart;
    }
    waitForCdnTuneIn(details) {
      const advancePartLimit = 3;
      return details.live && details.canBlockReload && details.partTarget && details.tuneInGoal > Math.max(details.partHoldBack, details.partTarget * advancePartLimit);
    }
    setStartPosition(details, sliding) {
      let startPosition = this.startPosition;
      if (startPosition < sliding) {
        startPosition = -1;
      }
      const timelineOffset = this.timelineOffset;
      if (startPosition === -1) {
        const offsetInMultivariantPlaylist = this.startTimeOffset !== null;
        const startTimeOffset = offsetInMultivariantPlaylist ? this.startTimeOffset : details.startTimeOffset;
        if (startTimeOffset !== null && isFiniteNumber(startTimeOffset)) {
          startPosition = sliding + startTimeOffset;
          if (startTimeOffset < 0) {
            startPosition += details.edge;
          }
          startPosition = Math.min(Math.max(sliding, startPosition), sliding + details.totalduration);
          this.log(`Setting startPosition to ${startPosition} for start time offset ${startTimeOffset} found in ${offsetInMultivariantPlaylist ? "multivariant" : "media"} playlist`);
          this.startPosition = startPosition;
        } else if (details.live) {
          startPosition = this.hls.liveSyncPosition || sliding;
          this.log(`Setting startPosition to -1 to start at live edge ${startPosition}`);
          this.startPosition = -1;
        } else {
          this.log(`setting startPosition to 0 by default`);
          this.startPosition = startPosition = 0;
        }
        this.lastCurrentTime = startPosition + timelineOffset;
      }
      this.nextLoadPosition = startPosition + timelineOffset;
    }
    getLoadPosition() {
      var _this$hls;
      const {
        media
      } = this;
      let pos = 0;
      if ((_this$hls = this.hls) != null && _this$hls.hasEnoughToStart && media) {
        pos = media.currentTime;
      } else if (this.nextLoadPosition >= 0) {
        pos = this.nextLoadPosition;
      }
      return pos;
    }
    handleFragLoadAborted(frag, part) {
      if (this.transmuxer && frag.type === this.playlistType && isMediaFragment(frag) && frag.stats.aborted) {
        this.log(`Fragment ${frag.sn}${part ? " part " + part.index : ""} of ${this.playlistLabel()} ${frag.level} was aborted`);
        this.resetFragmentLoading(frag);
      }
    }
    resetFragmentLoading(frag) {
      if (!this.fragCurrent || !this.fragContextChanged(frag) && this.state !== State.FRAG_LOADING_WAITING_RETRY) {
        this.state = State.IDLE;
      }
    }
    onFragmentOrKeyLoadError(filterType, data) {
      var _this$hls$latestLevel;
      if (data.chunkMeta && !data.frag) {
        const context3 = this.getCurrentContext(data.chunkMeta);
        if (context3) {
          data.frag = context3.frag;
        }
      }
      const frag = data.frag;
      if (!frag || frag.type !== filterType || !this.levels) {
        return;
      }
      if (this.fragContextChanged(frag)) {
        var _this$fragCurrent;
        this.warn(`Frag load error must match current frag to retry ${frag.url} > ${(_this$fragCurrent = this.fragCurrent) == null ? void 0 : _this$fragCurrent.url}`);
        return;
      }
      const gapTagEncountered = data.details === ErrorDetails.FRAG_GAP;
      if (gapTagEncountered) {
        this.fragmentTracker.fragBuffered(frag, true);
      }
      const errorAction = data.errorAction;
      if (!errorAction) {
        this.state = State.ERROR;
        return;
      }
      const {
        action,
        flags,
        retryCount = 0,
        retryConfig
      } = errorAction;
      const couldRetry = !!retryConfig;
      const retry = couldRetry && action === NetworkErrorAction.RetryRequest;
      const noAlternate = couldRetry && !errorAction.resolved && flags === ErrorActionFlags.MoveAllAlternatesMatchingHost;
      const live = (_this$hls$latestLevel = this.hls.latestLevelDetails) == null ? void 0 : _this$hls$latestLevel.live;
      if (!retry && noAlternate && isMediaFragment(frag) && !frag.endList && live && !isUnusableKeyError(data)) {
        this.resetFragmentErrors(filterType);
        this.treatAsGap(frag);
        errorAction.resolved = true;
      } else if ((retry || noAlternate) && retryCount < retryConfig.maxNumRetry) {
        var _data$response;
        const offlineStatus = offlineHttpStatus((_data$response = data.response) == null ? void 0 : _data$response.code);
        const delay2 = getRetryDelay(retryConfig, retryCount);
        this.resetStartWhenNotLoaded();
        this.retryDate = self.performance.now() + delay2;
        this.state = State.FRAG_LOADING_WAITING_RETRY;
        errorAction.resolved = true;
        if (offlineStatus) {
          this.log(`Waiting for connection (offline)`);
          this.retryDate = Infinity;
          data.reason = "offline";
          return;
        }
        this.warn(`Fragment ${frag.sn} of ${filterType} ${frag.level} errored with ${data.details}, retrying loading ${retryCount + 1}/${retryConfig.maxNumRetry} in ${delay2}ms`);
      } else if (retryConfig) {
        this.resetFragmentErrors(filterType);
        if (retryCount < retryConfig.maxNumRetry) {
          if (!gapTagEncountered && action !== NetworkErrorAction.RemoveAlternatePermanently) {
            errorAction.resolved = true;
          }
        } else {
          this.warn(`${data.details} reached or exceeded max retry (${retryCount})`);
          return;
        }
      } else if (action === NetworkErrorAction.SendAlternateToPenaltyBox) {
        this.state = State.WAITING_LEVEL;
      } else {
        this.state = State.ERROR;
      }
      this.tickImmediate();
    }
    checkRetryDate() {
      const now3 = self.performance.now();
      const retryDate = this.retryDate;
      const waitingForConnection = retryDate === Infinity;
      if (!retryDate || now3 >= retryDate || waitingForConnection && !offlineHttpStatus(0)) {
        if (waitingForConnection) {
          this.log(`Connection restored (online)`);
        }
        this.resetStartWhenNotLoaded();
        this.state = State.IDLE;
      }
    }
    reduceLengthAndFlushBuffer(data) {
      if (this.state === State.PARSING || this.state === State.PARSED) {
        const frag = data.frag;
        const playlistType = data.parent;
        const bufferedInfo = this.getFwdBufferInfo(this.mediaBuffer, playlistType);
        const buffered = bufferedInfo && bufferedInfo.len > 0.5;
        if (buffered) {
          this.reduceMaxBufferLength(bufferedInfo.len, (frag == null ? void 0 : frag.duration) || 10);
        }
        const flushBuffer = !buffered;
        if (flushBuffer) {
          this.warn(`Buffer full error while media.currentTime (${this.getLoadPosition()}) is not buffered, flush ${playlistType} buffer`);
        }
        if (frag) {
          this.fragmentTracker.removeFragment(frag);
          this.nextLoadPosition = frag.start;
        }
        this.resetLoadingState();
        return flushBuffer;
      }
      return false;
    }
    resetFragmentErrors(filterType) {
      if (filterType === PlaylistLevelType.AUDIO) {
        this.fragCurrent = null;
      }
      if (!this.hls.hasEnoughToStart) {
        this.startFragRequested = false;
      }
      if (this.state !== State.STOPPED) {
        this.state = State.IDLE;
      }
    }
    afterBufferFlushed(media, bufferType, playlistType) {
      if (!media) {
        return;
      }
      const bufferedTimeRanges = BufferHelper.getBuffered(media);
      this.fragmentTracker.detectEvictedFragments(bufferType, bufferedTimeRanges, playlistType);
      if (this.state === State.ENDED) {
        this.resetLoadingState();
      }
    }
    resetLoadingState() {
      this.log("Reset loading state");
      this.fragCurrent = null;
      this.fragPrevious = null;
      if (this.state !== State.STOPPED) {
        this.state = State.IDLE;
      }
    }
    resetStartWhenNotLoaded() {
      if (!this.hls.hasEnoughToStart) {
        this.startFragRequested = false;
        const level = this.levelLastLoaded;
        const details = level ? level.details : null;
        if (details != null && details.live) {
          this.log(`resetting startPosition for live start`);
          this.startPosition = -1;
          this.setStartPosition(details, details.fragmentStart);
          this.resetLoadingState();
        } else {
          this.nextLoadPosition = this.startPosition;
        }
      }
    }
    resetWhenMissingContext(chunkMeta) {
      this.log(`Loading context changed while buffering sn ${chunkMeta.sn} of ${this.playlistLabel()} ${chunkMeta.level === -1 ? "<removed>" : chunkMeta.level}. This chunk will not be buffered.`);
      this.removeUnbufferedFrags();
      this.resetStartWhenNotLoaded();
      this.resetLoadingState();
    }
    removeUnbufferedFrags(start = 0) {
      this.fragmentTracker.removeFragmentsInRange(start, Infinity, this.playlistType, false, true);
    }
    updateLevelTiming(frag, part, level, partial) {
      const details = level.details;
      if (!details) {
        this.warn("level.details undefined");
        return;
      }
      const parsed = Object.keys(frag.elementaryStreams).reduce((result, type) => {
        const info = frag.elementaryStreams[type];
        if (info) {
          const parsedDuration = info.endPTS - info.startPTS;
          if (parsedDuration <= 0) {
            this.warn(`Could not parse fragment ${frag.sn} ${type} duration reliably (${parsedDuration})`);
            return result || false;
          }
          const drift = partial ? 0 : updateFragPTSDTS(details, frag, info.startPTS, info.endPTS, info.startDTS, info.endDTS, this);
          this.hls.trigger(Events.LEVEL_PTS_UPDATED, {
            details,
            level,
            drift,
            type,
            frag,
            start: info.startPTS,
            end: info.endPTS
          });
          return true;
        }
        return result;
      }, false);
      if (!parsed) {
        var _this$transmuxer;
        if (level.fragmentError === 0) {
          this.treatAsGap(frag, level);
        }
        if (((_this$transmuxer = this.transmuxer) == null ? void 0 : _this$transmuxer.error) === null) {
          const error = new Error(`Found no media in fragment ${frag.sn} of ${this.playlistLabel()} ${frag.level} resetting transmuxer to fallback to playlist timing`);
          this.warn(error.message);
          this.hls.trigger(Events.ERROR, {
            type: ErrorTypes.MEDIA_ERROR,
            details: ErrorDetails.FRAG_PARSING_ERROR,
            fatal: false,
            error,
            frag,
            reason: `Found no media in msn ${frag.sn} of ${this.playlistLabel()} "${level.url}"`
          });
          if (!this.hls) {
            return;
          }
          this.resetTransmuxer();
        }
      }
      this.state = State.PARSED;
      this.log(`Parsed ${frag.type} sn: ${frag.sn}${part ? " part: " + part.index : ""} of ${this.fragInfo(frag, false, part)})`);
      this.hls.trigger(Events.FRAG_PARSED, {
        frag,
        part
      });
    }
    playlistLabel() {
      return this.playlistType === PlaylistLevelType.MAIN ? "level" : "track";
    }
    fragInfo(frag, pts = true, part) {
      var _ref, _ref2;
      return `${this.playlistLabel()} ${frag.level} (${part ? "part" : "frag"}:[${((_ref = pts && !part ? frag.startPTS : (part || frag).start) != null ? _ref : NaN).toFixed(3)}-${((_ref2 = pts && !part ? frag.endPTS : (part || frag).end) != null ? _ref2 : NaN).toFixed(3)}]${part && frag.type === "main" ? "INDEPENDENT=" + (part.independent ? "YES" : "NO") : ""}`;
    }
    treatAsGap(frag, level) {
      if (level) {
        level.fragmentError++;
      }
      frag.gap = true;
      this.fragmentTracker.removeFragment(frag);
      this.fragmentTracker.fragBuffered(frag, true);
    }
    resetTransmuxer() {
      var _this$transmuxer2;
      (_this$transmuxer2 = this.transmuxer) == null || _this$transmuxer2.reset();
    }
    recoverWorkerError(data) {
      if (data.event === "demuxerWorker") {
        this.fragmentTracker.removeAllFragments();
        if (this.transmuxer) {
          this.transmuxer.destroy();
          this.transmuxer = null;
        }
        this.resetStartWhenNotLoaded();
        this.resetLoadingState();
      }
    }
    set state(nextState) {
      const previousState = this._state;
      if (previousState !== nextState) {
        this._state = nextState;
        this.log(`${previousState}->${nextState}`);
      }
    }
    get state() {
      return this._state;
    }
  };
  function interstitialsEnabled(config3) {
    return !!config3.interstitialsController && config3.enableInterstitialPlayback !== false;
  }
  var ChunkCache = class {
    constructor() {
      this.chunks = [];
      this.dataLength = 0;
    }
    push(chunk) {
      this.chunks.push(chunk);
      this.dataLength += chunk.length;
    }
    flush() {
      const {
        chunks,
        dataLength
      } = this;
      let result;
      if (!chunks.length) {
        return new Uint8Array(0);
      } else if (chunks.length === 1) {
        result = chunks[0];
      } else {
        result = concatUint8Arrays(chunks, dataLength);
      }
      this.reset();
      return result;
    }
    reset() {
      this.chunks.length = 0;
      this.dataLength = 0;
    }
  };
  function concatUint8Arrays(chunks, dataLength) {
    const result = new Uint8Array(dataLength);
    let offset = 0;
    for (let i = 0; i < chunks.length; i++) {
      const chunk = chunks[i];
      result.set(chunk, offset);
      offset += chunk.length;
    }
    return result;
  }
  var eventemitter3 = { exports: {} };
  var hasRequiredEventemitter3;
  function requireEventemitter3() {
    if (hasRequiredEventemitter3) return eventemitter3.exports;
    hasRequiredEventemitter3 = 1;
    (function(module) {
      var has = Object.prototype.hasOwnProperty, prefix = "~";
      function Events2() {
      }
      if (Object.create) {
        Events2.prototype = /* @__PURE__ */ Object.create(null);
        if (!new Events2().__proto__) prefix = false;
      }
      function EE(fn, context3, once) {
        this.fn = fn;
        this.context = context3;
        this.once = once || false;
      }
      function addListener(emitter, event, fn, context3, once) {
        if (typeof fn !== "function") {
          throw new TypeError("The listener must be a function");
        }
        var listener = new EE(fn, context3 || emitter, once), evt = prefix ? prefix + event : event;
        if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
        else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
        else emitter._events[evt] = [emitter._events[evt], listener];
        return emitter;
      }
      function clearEvent(emitter, evt) {
        if (--emitter._eventsCount === 0) emitter._events = new Events2();
        else delete emitter._events[evt];
      }
      function EventEmitter2() {
        this._events = new Events2();
        this._eventsCount = 0;
      }
      EventEmitter2.prototype.eventNames = function eventNames() {
        var names = [], events, name;
        if (this._eventsCount === 0) return names;
        for (name in events = this._events) {
          if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
        }
        if (Object.getOwnPropertySymbols) {
          return names.concat(Object.getOwnPropertySymbols(events));
        }
        return names;
      };
      EventEmitter2.prototype.listeners = function listeners(event) {
        var evt = prefix ? prefix + event : event, handlers = this._events[evt];
        if (!handlers) return [];
        if (handlers.fn) return [handlers.fn];
        for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
          ee[i] = handlers[i].fn;
        }
        return ee;
      };
      EventEmitter2.prototype.listenerCount = function listenerCount(event) {
        var evt = prefix ? prefix + event : event, listeners = this._events[evt];
        if (!listeners) return 0;
        if (listeners.fn) return 1;
        return listeners.length;
      };
      EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt]) return false;
        var listeners = this._events[evt], len = arguments.length, args, i;
        if (listeners.fn) {
          if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
          switch (len) {
            case 1:
              return listeners.fn.call(listeners.context), true;
            case 2:
              return listeners.fn.call(listeners.context, a1), true;
            case 3:
              return listeners.fn.call(listeners.context, a1, a2), true;
            case 4:
              return listeners.fn.call(listeners.context, a1, a2, a3), true;
            case 5:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
            case 6:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
          }
          for (i = 1, args = new Array(len - 1); i < len; i++) {
            args[i - 1] = arguments[i];
          }
          listeners.fn.apply(listeners.context, args);
        } else {
          var length = listeners.length, j;
          for (i = 0; i < length; i++) {
            if (listeners[i].once) this.removeListener(event, listeners[i].fn, void 0, true);
            switch (len) {
              case 1:
                listeners[i].fn.call(listeners[i].context);
                break;
              case 2:
                listeners[i].fn.call(listeners[i].context, a1);
                break;
              case 3:
                listeners[i].fn.call(listeners[i].context, a1, a2);
                break;
              case 4:
                listeners[i].fn.call(listeners[i].context, a1, a2, a3);
                break;
              default:
                if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
                  args[j - 1] = arguments[j];
                }
                listeners[i].fn.apply(listeners[i].context, args);
            }
          }
        }
        return true;
      };
      EventEmitter2.prototype.on = function on(event, fn, context3) {
        return addListener(this, event, fn, context3, false);
      };
      EventEmitter2.prototype.once = function once(event, fn, context3) {
        return addListener(this, event, fn, context3, true);
      };
      EventEmitter2.prototype.removeListener = function removeListener(event, fn, context3, once) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt]) return this;
        if (!fn) {
          clearEvent(this, evt);
          return this;
        }
        var listeners = this._events[evt];
        if (listeners.fn) {
          if (listeners.fn === fn && (!once || listeners.once) && (!context3 || listeners.context === context3)) {
            clearEvent(this, evt);
          }
        } else {
          for (var i = 0, events = [], length = listeners.length; i < length; i++) {
            if (listeners[i].fn !== fn || once && !listeners[i].once || context3 && listeners[i].context !== context3) {
              events.push(listeners[i]);
            }
          }
          if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
          else clearEvent(this, evt);
        }
        return this;
      };
      EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
        var evt;
        if (event) {
          evt = prefix ? prefix + event : event;
          if (this._events[evt]) clearEvent(this, evt);
        } else {
          this._events = new Events2();
          this._eventsCount = 0;
        }
        return this;
      };
      EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
      EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
      EventEmitter2.prefixed = prefix;
      EventEmitter2.EventEmitter = EventEmitter2;
      {
        module.exports = EventEmitter2;
      }
    })(eventemitter3);
    return eventemitter3.exports;
  }
  var eventemitter3Exports = requireEventemitter3();
  var EventEmitter = /* @__PURE__ */ getDefaultExportFromCjs(eventemitter3Exports);
  var version = "1.6.13";
  var workerStore = {};
  function hasUMDWorker() {
    return typeof __HLS_WORKER_BUNDLE__ === "function";
  }
  function injectWorker() {
    const workerContext = workerStore[version];
    if (workerContext) {
      workerContext.clientCount++;
      return workerContext;
    }
    const blob = new self.Blob([`var exports={};var module={exports:exports};function define(f){f()};define.amd=true;(${__HLS_WORKER_BUNDLE__.toString()})(true);`], {
      type: "text/javascript"
    });
    const objectURL = self.URL.createObjectURL(blob);
    const worker = new self.Worker(objectURL);
    const result = {
      worker,
      objectURL,
      clientCount: 1
    };
    workerStore[version] = result;
    return result;
  }
  function loadWorker(path) {
    const workerContext = workerStore[path];
    if (workerContext) {
      workerContext.clientCount++;
      return workerContext;
    }
    const scriptURL = new self.URL(path, self.location.href).href;
    const worker = new self.Worker(scriptURL);
    const result = {
      worker,
      scriptURL,
      clientCount: 1
    };
    workerStore[path] = result;
    return result;
  }
  function removeWorkerFromStore(path) {
    const workerContext = workerStore[path || version];
    if (workerContext) {
      const clientCount = workerContext.clientCount--;
      if (clientCount === 1) {
        const {
          worker,
          objectURL
        } = workerContext;
        delete workerStore[path || version];
        if (objectURL) {
          self.URL.revokeObjectURL(objectURL);
        }
        worker.terminate();
      }
    }
  }
  function isId3Footer(data, offset) {
    if (offset + 10 <= data.length) {
      if (data[offset] === 51 && data[offset + 1] === 68 && data[offset + 2] === 73) {
        if (data[offset + 3] < 255 && data[offset + 4] < 255) {
          if (data[offset + 6] < 128 && data[offset + 7] < 128 && data[offset + 8] < 128 && data[offset + 9] < 128) {
            return true;
          }
        }
      }
    }
    return false;
  }
  function isId3Header(data, offset) {
    if (offset + 10 <= data.length) {
      if (data[offset] === 73 && data[offset + 1] === 68 && data[offset + 2] === 51) {
        if (data[offset + 3] < 255 && data[offset + 4] < 255) {
          if (data[offset + 6] < 128 && data[offset + 7] < 128 && data[offset + 8] < 128 && data[offset + 9] < 128) {
            return true;
          }
        }
      }
    }
    return false;
  }
  function readId3Size(data, offset) {
    let size = 0;
    size = (data[offset] & 127) << 21;
    size |= (data[offset + 1] & 127) << 14;
    size |= (data[offset + 2] & 127) << 7;
    size |= data[offset + 3] & 127;
    return size;
  }
  function getId3Data(data, offset) {
    const front = offset;
    let length = 0;
    while (isId3Header(data, offset)) {
      length += 10;
      const size = readId3Size(data, offset + 6);
      length += size;
      if (isId3Footer(data, offset + 10)) {
        length += 10;
      }
      offset += length;
    }
    if (length > 0) {
      return data.subarray(front, front + length);
    }
    return void 0;
  }
  function getAudioConfig(observer2, data, offset, manifestCodec) {
    const adtsSamplingRates = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350];
    const byte2 = data[offset + 2];
    const adtsSamplingIndex = byte2 >> 2 & 15;
    if (adtsSamplingIndex > 12) {
      const error = new Error(`invalid ADTS sampling index:${adtsSamplingIndex}`);
      observer2.emit(Events.ERROR, Events.ERROR, {
        type: ErrorTypes.MEDIA_ERROR,
        details: ErrorDetails.FRAG_PARSING_ERROR,
        fatal: true,
        error,
        reason: error.message
      });
      return;
    }
    const adtsObjectType = (byte2 >> 6 & 3) + 1;
    const channelCount = data[offset + 3] >> 6 & 3 | (byte2 & 1) << 2;
    const codec = "mp4a.40." + adtsObjectType;
    const samplerate = adtsSamplingRates[adtsSamplingIndex];
    let aacSampleIndex = adtsSamplingIndex;
    if (adtsObjectType === 5 || adtsObjectType === 29) {
      aacSampleIndex -= 3;
    }
    const config3 = [adtsObjectType << 3 | (aacSampleIndex & 14) >> 1, (aacSampleIndex & 1) << 7 | channelCount << 3];
    logger.log(`manifest codec:${manifestCodec}, parsed codec:${codec}, channels:${channelCount}, rate:${samplerate} (ADTS object type:${adtsObjectType} sampling index:${adtsSamplingIndex})`);
    return {
      config: config3,
      samplerate,
      channelCount,
      codec,
      parsedCodec: codec,
      manifestCodec
    };
  }
  function isHeaderPattern$1(data, offset) {
    return data[offset] === 255 && (data[offset + 1] & 246) === 240;
  }
  function getHeaderLength(data, offset) {
    return data[offset + 1] & 1 ? 7 : 9;
  }
  function getFullFrameLength(data, offset) {
    return (data[offset + 3] & 3) << 11 | data[offset + 4] << 3 | (data[offset + 5] & 224) >>> 5;
  }
  function canGetFrameLength(data, offset) {
    return offset + 5 < data.length;
  }
  function isHeader$1(data, offset) {
    return offset + 1 < data.length && isHeaderPattern$1(data, offset);
  }
  function canParse$1(data, offset) {
    return canGetFrameLength(data, offset) && isHeaderPattern$1(data, offset) && getFullFrameLength(data, offset) <= data.length - offset;
  }
  function probe$1(data, offset) {
    if (isHeader$1(data, offset)) {
      const headerLength = getHeaderLength(data, offset);
      if (offset + headerLength >= data.length) {
        return false;
      }
      const frameLength = getFullFrameLength(data, offset);
      if (frameLength <= headerLength) {
        return false;
      }
      const newOffset = offset + frameLength;
      return newOffset === data.length || isHeader$1(data, newOffset);
    }
    return false;
  }
  function initTrackConfig(track, observer2, data, offset, audioCodec) {
    if (!track.samplerate) {
      const config3 = getAudioConfig(observer2, data, offset, audioCodec);
      if (!config3) {
        return;
      }
      _extends4(track, config3);
    }
  }
  function getFrameDuration(samplerate) {
    return 1024 * 9e4 / samplerate;
  }
  function parseFrameHeader(data, offset) {
    const headerLength = getHeaderLength(data, offset);
    if (offset + headerLength <= data.length) {
      const frameLength = getFullFrameLength(data, offset) - headerLength;
      if (frameLength > 0) {
        return {
          headerLength,
          frameLength
        };
      }
    }
  }
  function appendFrame$2(track, data, offset, pts, frameIndex) {
    const frameDuration = getFrameDuration(track.samplerate);
    const stamp = pts + frameIndex * frameDuration;
    const header = parseFrameHeader(data, offset);
    let unit;
    if (header) {
      const {
        frameLength,
        headerLength
      } = header;
      const _length = headerLength + frameLength;
      const missing = Math.max(0, offset + _length - data.length);
      if (missing) {
        unit = new Uint8Array(_length - headerLength);
        unit.set(data.subarray(offset + headerLength, data.length), 0);
      } else {
        unit = data.subarray(offset + headerLength, offset + _length);
      }
      const _sample = {
        unit,
        pts: stamp
      };
      if (!missing) {
        track.samples.push(_sample);
      }
      return {
        sample: _sample,
        length: _length,
        missing
      };
    }
    const length = data.length - offset;
    unit = new Uint8Array(length);
    unit.set(data.subarray(offset, data.length), 0);
    const sample = {
      unit,
      pts: stamp
    };
    return {
      sample,
      length,
      missing: -1
    };
  }
  function canParseId3(data, offset) {
    return isId3Header(data, offset) && readId3Size(data, offset + 6) + 10 <= data.length - offset;
  }
  function toArrayBuffer(view2) {
    if (view2 instanceof ArrayBuffer) {
      return view2;
    } else {
      if (view2.byteOffset == 0 && view2.byteLength == view2.buffer.byteLength) {
        return view2.buffer;
      }
      return new Uint8Array(view2).buffer;
    }
  }
  function toUint8(data, offset = 0, length = Infinity) {
    return view(data, offset, length, Uint8Array);
  }
  function view(data, offset, length, Type) {
    const buffer = unsafeGetArrayBuffer(data);
    let bytesPerElement = 1;
    if ("BYTES_PER_ELEMENT" in Type) {
      bytesPerElement = Type.BYTES_PER_ELEMENT;
    }
    const dataOffset = isArrayBufferView(data) ? data.byteOffset : 0;
    const dataEnd = (dataOffset + data.byteLength) / bytesPerElement;
    const rawStart = (dataOffset + offset) / bytesPerElement;
    const start = Math.floor(Math.max(0, Math.min(rawStart, dataEnd)));
    const end = Math.floor(Math.min(start + Math.max(length, 0), dataEnd));
    return new Type(buffer, start, end - start);
  }
  function unsafeGetArrayBuffer(view2) {
    if (view2 instanceof ArrayBuffer) {
      return view2;
    } else {
      return view2.buffer;
    }
  }
  function isArrayBufferView(obj) {
    return obj && obj.buffer instanceof ArrayBuffer && obj.byteLength !== void 0 && obj.byteOffset !== void 0;
  }
  function decodeId3ImageFrame(frame2) {
    const metadataFrame = {
      key: frame2.type,
      description: "",
      data: "",
      mimeType: null,
      pictureType: null
    };
    const utf8Encoding = 3;
    if (frame2.size < 2) {
      return void 0;
    }
    if (frame2.data[0] !== utf8Encoding) {
      console.log("Ignore frame with unrecognized character encoding");
      return void 0;
    }
    const mimeTypeEndIndex = frame2.data.subarray(1).indexOf(0);
    if (mimeTypeEndIndex === -1) {
      return void 0;
    }
    const mimeType = utf8ArrayToStr(toUint8(frame2.data, 1, mimeTypeEndIndex));
    const pictureType = frame2.data[2 + mimeTypeEndIndex];
    const descriptionEndIndex = frame2.data.subarray(3 + mimeTypeEndIndex).indexOf(0);
    if (descriptionEndIndex === -1) {
      return void 0;
    }
    const description = utf8ArrayToStr(toUint8(frame2.data, 3 + mimeTypeEndIndex, descriptionEndIndex));
    let data;
    if (mimeType === "-->") {
      data = utf8ArrayToStr(toUint8(frame2.data, 4 + mimeTypeEndIndex + descriptionEndIndex));
    } else {
      data = toArrayBuffer(frame2.data.subarray(4 + mimeTypeEndIndex + descriptionEndIndex));
    }
    metadataFrame.mimeType = mimeType;
    metadataFrame.pictureType = pictureType;
    metadataFrame.description = description;
    metadataFrame.data = data;
    return metadataFrame;
  }
  function decodeId3PrivFrame(frame2) {
    if (frame2.size < 2) {
      return void 0;
    }
    const owner = utf8ArrayToStr(frame2.data, true);
    const privateData = new Uint8Array(frame2.data.subarray(owner.length + 1));
    return {
      key: frame2.type,
      info: owner,
      data: privateData.buffer
    };
  }
  function decodeId3TextFrame(frame2) {
    if (frame2.size < 2) {
      return void 0;
    }
    if (frame2.type === "TXXX") {
      let index = 1;
      const description = utf8ArrayToStr(frame2.data.subarray(index), true);
      index += description.length + 1;
      const value = utf8ArrayToStr(frame2.data.subarray(index));
      return {
        key: frame2.type,
        info: description,
        data: value
      };
    }
    const text = utf8ArrayToStr(frame2.data.subarray(1));
    return {
      key: frame2.type,
      info: "",
      data: text
    };
  }
  function decodeId3UrlFrame(frame2) {
    if (frame2.type === "WXXX") {
      if (frame2.size < 2) {
        return void 0;
      }
      let index = 1;
      const description = utf8ArrayToStr(frame2.data.subarray(index), true);
      index += description.length + 1;
      const value = utf8ArrayToStr(frame2.data.subarray(index));
      return {
        key: frame2.type,
        info: description,
        data: value
      };
    }
    const url = utf8ArrayToStr(frame2.data);
    return {
      key: frame2.type,
      info: "",
      data: url
    };
  }
  function decodeId3Frame(frame2) {
    if (frame2.type === "PRIV") {
      return decodeId3PrivFrame(frame2);
    } else if (frame2.type[0] === "W") {
      return decodeId3UrlFrame(frame2);
    } else if (frame2.type === "APIC") {
      return decodeId3ImageFrame(frame2);
    }
    return decodeId3TextFrame(frame2);
  }
  function getId3FrameData(data) {
    const type = String.fromCharCode(data[0], data[1], data[2], data[3]);
    const size = readId3Size(data, 4);
    const offset = 10;
    return {
      type,
      size,
      data: data.subarray(offset, offset + size)
    };
  }
  var HEADER_FOOTER_SIZE = 10;
  var FRAME_SIZE = 10;
  function getId3Frames(id3Data) {
    let offset = 0;
    const frames = [];
    while (isId3Header(id3Data, offset)) {
      const size = readId3Size(id3Data, offset + 6);
      if (id3Data[offset + 5] >> 6 & 1) {
        offset += HEADER_FOOTER_SIZE;
      }
      offset += HEADER_FOOTER_SIZE;
      const end = offset + size;
      while (offset + FRAME_SIZE < end) {
        const frameData2 = getId3FrameData(id3Data.subarray(offset));
        const frame2 = decodeId3Frame(frameData2);
        if (frame2) {
          frames.push(frame2);
        }
        offset += frameData2.size + HEADER_FOOTER_SIZE;
      }
      if (isId3Footer(id3Data, offset)) {
        offset += HEADER_FOOTER_SIZE;
      }
    }
    return frames;
  }
  function isId3TimestampFrame(frame2) {
    return frame2 && frame2.key === "PRIV" && frame2.info === "com.apple.streaming.transportStreamTimestamp";
  }
  function readId3Timestamp(timeStampFrame) {
    if (timeStampFrame.data.byteLength === 8) {
      const data = new Uint8Array(timeStampFrame.data);
      const pts33Bit = data[3] & 1;
      let timestamp = (data[4] << 23) + (data[5] << 15) + (data[6] << 7) + data[7];
      timestamp /= 45;
      if (pts33Bit) {
        timestamp += 4772185884e-2;
      }
      return Math.round(timestamp);
    }
    return void 0;
  }
  function getId3Timestamp(data) {
    const frames = getId3Frames(data);
    for (let i = 0; i < frames.length; i++) {
      const frame2 = frames[i];
      if (isId3TimestampFrame(frame2)) {
        return readId3Timestamp(frame2);
      }
    }
    return void 0;
  }
  var MetadataSchema = /* @__PURE__ */ (function(MetadataSchema2) {
    MetadataSchema2["audioId3"] = "org.id3";
    MetadataSchema2["dateRange"] = "com.apple.quicktime.HLS";
    MetadataSchema2["emsg"] = "https://aomedia.org/emsg/ID3";
    MetadataSchema2["misbklv"] = "urn:misb:KLV:bin:1910.1";
    return MetadataSchema2;
  })({});
  function dummyTrack(type = "", inputTimeScale = 9e4) {
    return {
      type,
      id: -1,
      pid: -1,
      inputTimeScale,
      sequenceNumber: -1,
      samples: [],
      dropped: 0
    };
  }
  var BaseAudioDemuxer = class {
    constructor() {
      this._audioTrack = void 0;
      this._id3Track = void 0;
      this.frameIndex = 0;
      this.cachedData = null;
      this.basePTS = null;
      this.initPTS = null;
      this.lastPTS = null;
    }
    resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {
      this._id3Track = {
        type: "id3",
        id: 3,
        pid: -1,
        inputTimeScale: 9e4,
        sequenceNumber: 0,
        samples: [],
        dropped: 0
      };
    }
    resetTimeStamp(deaultTimestamp) {
      this.initPTS = deaultTimestamp;
      this.resetContiguity();
    }
    resetContiguity() {
      this.basePTS = null;
      this.lastPTS = null;
      this.frameIndex = 0;
    }
    canParse(data, offset) {
      return false;
    }
    appendFrame(track, data, offset) {
    }
    // feed incoming data to the front of the parsing pipeline
    demux(data, timeOffset) {
      if (this.cachedData) {
        data = appendUint8Array(this.cachedData, data);
        this.cachedData = null;
      }
      let id3Data = getId3Data(data, 0);
      let offset = id3Data ? id3Data.length : 0;
      let lastDataIndex;
      const track = this._audioTrack;
      const id3Track = this._id3Track;
      const timestamp = id3Data ? getId3Timestamp(id3Data) : void 0;
      const length = data.length;
      if (this.basePTS === null || this.frameIndex === 0 && isFiniteNumber(timestamp)) {
        this.basePTS = initPTSFn(timestamp, timeOffset, this.initPTS);
        this.lastPTS = this.basePTS;
      }
      if (this.lastPTS === null) {
        this.lastPTS = this.basePTS;
      }
      if (id3Data && id3Data.length > 0) {
        id3Track.samples.push({
          pts: this.lastPTS,
          dts: this.lastPTS,
          data: id3Data,
          type: MetadataSchema.audioId3,
          duration: Number.POSITIVE_INFINITY
        });
      }
      while (offset < length) {
        if (this.canParse(data, offset)) {
          const frame2 = this.appendFrame(track, data, offset);
          if (frame2) {
            this.frameIndex++;
            this.lastPTS = frame2.sample.pts;
            offset += frame2.length;
            lastDataIndex = offset;
          } else {
            offset = length;
          }
        } else if (canParseId3(data, offset)) {
          id3Data = getId3Data(data, offset);
          id3Track.samples.push({
            pts: this.lastPTS,
            dts: this.lastPTS,
            data: id3Data,
            type: MetadataSchema.audioId3,
            duration: Number.POSITIVE_INFINITY
          });
          offset += id3Data.length;
          lastDataIndex = offset;
        } else {
          offset++;
        }
        if (offset === length && lastDataIndex !== length) {
          const partialData = data.slice(lastDataIndex);
          if (this.cachedData) {
            this.cachedData = appendUint8Array(this.cachedData, partialData);
          } else {
            this.cachedData = partialData;
          }
        }
      }
      return {
        audioTrack: track,
        videoTrack: dummyTrack(),
        id3Track,
        textTrack: dummyTrack()
      };
    }
    demuxSampleAes(data, keyData, timeOffset) {
      return Promise.reject(new Error(`[${this}] This demuxer does not support Sample-AES decryption`));
    }
    flush(timeOffset) {
      const cachedData = this.cachedData;
      if (cachedData) {
        this.cachedData = null;
        this.demux(cachedData, 0);
      }
      return {
        audioTrack: this._audioTrack,
        videoTrack: dummyTrack(),
        id3Track: this._id3Track,
        textTrack: dummyTrack()
      };
    }
    destroy() {
      this.cachedData = null;
      this._audioTrack = this._id3Track = void 0;
    }
  };
  var initPTSFn = (timestamp, timeOffset, initPTS) => {
    if (isFiniteNumber(timestamp)) {
      return timestamp * 90;
    }
    const init90kHz = initPTS ? initPTS.baseTime * 9e4 / initPTS.timescale : 0;
    return timeOffset * 9e4 + init90kHz;
  };
  var chromeVersion$1 = null;
  var BitratesMap = [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160];
  var SamplingRateMap = [44100, 48e3, 32e3, 22050, 24e3, 16e3, 11025, 12e3, 8e3];
  var SamplesCoefficients = [
    // MPEG 2.5
    [
      0,
      // Reserved
      72,
      // Layer3
      144,
      // Layer2
      12
      // Layer1
    ],
    // Reserved
    [
      0,
      // Reserved
      0,
      // Layer3
      0,
      // Layer2
      0
      // Layer1
    ],
    // MPEG 2
    [
      0,
      // Reserved
      72,
      // Layer3
      144,
      // Layer2
      12
      // Layer1
    ],
    // MPEG 1
    [
      0,
      // Reserved
      144,
      // Layer3
      144,
      // Layer2
      12
      // Layer1
    ]
  ];
  var BytesInSlot = [
    0,
    // Reserved
    1,
    // Layer3
    1,
    // Layer2
    4
    // Layer1
  ];
  function appendFrame$1(track, data, offset, pts, frameIndex) {
    if (offset + 24 > data.length) {
      return;
    }
    const header = parseHeader(data, offset);
    if (header && offset + header.frameLength <= data.length) {
      const frameDuration = header.samplesPerFrame * 9e4 / header.sampleRate;
      const stamp = pts + frameIndex * frameDuration;
      const sample = {
        unit: data.subarray(offset, offset + header.frameLength),
        pts: stamp,
        dts: stamp
      };
      track.config = [];
      track.channelCount = header.channelCount;
      track.samplerate = header.sampleRate;
      track.samples.push(sample);
      return {
        sample,
        length: header.frameLength,
        missing: 0
      };
    }
  }
  function parseHeader(data, offset) {
    const mpegVersion = data[offset + 1] >> 3 & 3;
    const mpegLayer = data[offset + 1] >> 1 & 3;
    const bitRateIndex = data[offset + 2] >> 4 & 15;
    const sampleRateIndex = data[offset + 2] >> 2 & 3;
    if (mpegVersion !== 1 && bitRateIndex !== 0 && bitRateIndex !== 15 && sampleRateIndex !== 3) {
      const paddingBit = data[offset + 2] >> 1 & 1;
      const channelMode = data[offset + 3] >> 6;
      const columnInBitrates = mpegVersion === 3 ? 3 - mpegLayer : mpegLayer === 3 ? 3 : 4;
      const bitRate = BitratesMap[columnInBitrates * 14 + bitRateIndex - 1] * 1e3;
      const columnInSampleRates = mpegVersion === 3 ? 0 : mpegVersion === 2 ? 1 : 2;
      const sampleRate = SamplingRateMap[columnInSampleRates * 3 + sampleRateIndex];
      const channelCount = channelMode === 3 ? 1 : 2;
      const sampleCoefficient = SamplesCoefficients[mpegVersion][mpegLayer];
      const bytesInSlot = BytesInSlot[mpegLayer];
      const samplesPerFrame = sampleCoefficient * 8 * bytesInSlot;
      const frameLength = Math.floor(sampleCoefficient * bitRate / sampleRate + paddingBit) * bytesInSlot;
      if (chromeVersion$1 === null) {
        const userAgent = navigator.userAgent || "";
        const result = userAgent.match(/Chrome\/(\d+)/i);
        chromeVersion$1 = result ? parseInt(result[1]) : 0;
      }
      const needChromeFix = !!chromeVersion$1 && chromeVersion$1 <= 87;
      if (needChromeFix && mpegLayer === 2 && bitRate >= 224e3 && channelMode === 0) {
        data[offset + 3] = data[offset + 3] | 128;
      }
      return {
        sampleRate,
        channelCount,
        frameLength,
        samplesPerFrame
      };
    }
  }
  function isHeaderPattern(data, offset) {
    return data[offset] === 255 && (data[offset + 1] & 224) === 224 && (data[offset + 1] & 6) !== 0;
  }
  function isHeader(data, offset) {
    return offset + 1 < data.length && isHeaderPattern(data, offset);
  }
  function canParse(data, offset) {
    const headerSize = 4;
    return isHeaderPattern(data, offset) && headerSize <= data.length - offset;
  }
  function probe(data, offset) {
    if (offset + 1 < data.length && isHeaderPattern(data, offset)) {
      const headerLength = 4;
      const header = parseHeader(data, offset);
      let frameLength = headerLength;
      if (header != null && header.frameLength) {
        frameLength = header.frameLength;
      }
      const newOffset = offset + frameLength;
      return newOffset === data.length || isHeader(data, newOffset);
    }
    return false;
  }
  var AACDemuxer = class extends BaseAudioDemuxer {
    constructor(observer2, config3) {
      super();
      this.observer = void 0;
      this.config = void 0;
      this.observer = observer2;
      this.config = config3;
    }
    resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {
      super.resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration);
      this._audioTrack = {
        container: "audio/adts",
        type: "audio",
        id: 2,
        pid: -1,
        sequenceNumber: 0,
        segmentCodec: "aac",
        samples: [],
        manifestCodec: audioCodec,
        duration: trackDuration,
        inputTimeScale: 9e4,
        dropped: 0
      };
    }
    // Source for probe info - https://wiki.multimedia.cx/index.php?title=ADTS
    static probe(data, logger2) {
      if (!data) {
        return false;
      }
      const id3Data = getId3Data(data, 0);
      let offset = (id3Data == null ? void 0 : id3Data.length) || 0;
      if (probe(data, offset)) {
        return false;
      }
      for (let length = data.length; offset < length; offset++) {
        if (probe$1(data, offset)) {
          logger2.log("ADTS sync word found !");
          return true;
        }
      }
      return false;
    }
    canParse(data, offset) {
      return canParse$1(data, offset);
    }
    appendFrame(track, data, offset) {
      initTrackConfig(track, this.observer, data, offset, track.manifestCodec);
      const frame2 = appendFrame$2(track, data, offset, this.basePTS, this.frameIndex);
      if (frame2 && frame2.missing === 0) {
        return frame2;
      }
    }
  };
  var getAudioBSID = (data, offset) => {
    let bsid = 0;
    let numBits = 5;
    offset += numBits;
    const temp = new Uint32Array(1);
    const mask = new Uint32Array(1);
    const byte = new Uint8Array(1);
    while (numBits > 0) {
      byte[0] = data[offset];
      const bits = Math.min(numBits, 8);
      const shift = 8 - bits;
      mask[0] = 4278190080 >>> 24 + shift << shift;
      temp[0] = (byte[0] & mask[0]) >> shift;
      bsid = !bsid ? temp[0] : bsid << bits | temp[0];
      offset += 1;
      numBits -= bits;
    }
    return bsid;
  };
  var AC3Demuxer = class extends BaseAudioDemuxer {
    constructor(observer2) {
      super();
      this.observer = void 0;
      this.observer = observer2;
    }
    resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {
      super.resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration);
      this._audioTrack = {
        container: "audio/ac-3",
        type: "audio",
        id: 2,
        pid: -1,
        sequenceNumber: 0,
        segmentCodec: "ac3",
        samples: [],
        manifestCodec: audioCodec,
        duration: trackDuration,
        inputTimeScale: 9e4,
        dropped: 0
      };
    }
    canParse(data, offset) {
      return offset + 64 < data.length;
    }
    appendFrame(track, data, offset) {
      const frameLength = appendFrame(track, data, offset, this.basePTS, this.frameIndex);
      if (frameLength !== -1) {
        const sample = track.samples[track.samples.length - 1];
        return {
          sample,
          length: frameLength,
          missing: 0
        };
      }
    }
    static probe(data) {
      if (!data) {
        return false;
      }
      const id3Data = getId3Data(data, 0);
      if (!id3Data) {
        return false;
      }
      const offset = id3Data.length;
      if (data[offset] === 11 && data[offset + 1] === 119 && getId3Timestamp(id3Data) !== void 0 && // check the bsid to confirm ac-3
      getAudioBSID(data, offset) < 16) {
        return true;
      }
      return false;
    }
  };
  function appendFrame(track, data, start, pts, frameIndex) {
    if (start + 8 > data.length) {
      return -1;
    }
    if (data[start] !== 11 || data[start + 1] !== 119) {
      return -1;
    }
    const samplingRateCode = data[start + 4] >> 6;
    if (samplingRateCode >= 3) {
      return -1;
    }
    const samplingRateMap = [48e3, 44100, 32e3];
    const sampleRate = samplingRateMap[samplingRateCode];
    const frameSizeCode = data[start + 4] & 63;
    const frameSizeMap = [64, 69, 96, 64, 70, 96, 80, 87, 120, 80, 88, 120, 96, 104, 144, 96, 105, 144, 112, 121, 168, 112, 122, 168, 128, 139, 192, 128, 140, 192, 160, 174, 240, 160, 175, 240, 192, 208, 288, 192, 209, 288, 224, 243, 336, 224, 244, 336, 256, 278, 384, 256, 279, 384, 320, 348, 480, 320, 349, 480, 384, 417, 576, 384, 418, 576, 448, 487, 672, 448, 488, 672, 512, 557, 768, 512, 558, 768, 640, 696, 960, 640, 697, 960, 768, 835, 1152, 768, 836, 1152, 896, 975, 1344, 896, 976, 1344, 1024, 1114, 1536, 1024, 1115, 1536, 1152, 1253, 1728, 1152, 1254, 1728, 1280, 1393, 1920, 1280, 1394, 1920];
    const frameLength = frameSizeMap[frameSizeCode * 3 + samplingRateCode] * 2;
    if (start + frameLength > data.length) {
      return -1;
    }
    const channelMode = data[start + 6] >> 5;
    let skipCount = 0;
    if (channelMode === 2) {
      skipCount += 2;
    } else {
      if (channelMode & 1 && channelMode !== 1) {
        skipCount += 2;
      }
      if (channelMode & 4) {
        skipCount += 2;
      }
    }
    const lfeon = (data[start + 6] << 8 | data[start + 7]) >> 12 - skipCount & 1;
    const channelsMap = [2, 1, 2, 3, 3, 4, 4, 5];
    const channelCount = channelsMap[channelMode] + lfeon;
    const bsid = data[start + 5] >> 3;
    const bsmod = data[start + 5] & 7;
    const config3 = new Uint8Array([samplingRateCode << 6 | bsid << 1 | bsmod >> 2, (bsmod & 3) << 6 | channelMode << 3 | lfeon << 2 | frameSizeCode >> 4, frameSizeCode << 4 & 224]);
    const frameDuration = 1536 / sampleRate * 9e4;
    const stamp = pts + frameIndex * frameDuration;
    const unit = data.subarray(start, start + frameLength);
    track.config = config3;
    track.channelCount = channelCount;
    track.samplerate = sampleRate;
    track.samples.push({
      unit,
      pts: stamp
    });
    return frameLength;
  }
  var MP3Demuxer = class extends BaseAudioDemuxer {
    resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {
      super.resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration);
      this._audioTrack = {
        container: "audio/mpeg",
        type: "audio",
        id: 2,
        pid: -1,
        sequenceNumber: 0,
        segmentCodec: "mp3",
        samples: [],
        manifestCodec: audioCodec,
        duration: trackDuration,
        inputTimeScale: 9e4,
        dropped: 0
      };
    }
    static probe(data) {
      if (!data) {
        return false;
      }
      const id3Data = getId3Data(data, 0);
      let offset = (id3Data == null ? void 0 : id3Data.length) || 0;
      if (id3Data && data[offset] === 11 && data[offset + 1] === 119 && getId3Timestamp(id3Data) !== void 0 && // check the bsid to confirm ac-3 or ec-3 (not mp3)
      getAudioBSID(data, offset) <= 16) {
        return false;
      }
      for (let length = data.length; offset < length; offset++) {
        if (probe(data, offset)) {
          logger.log("MPEG Audio sync word found !");
          return true;
        }
      }
      return false;
    }
    canParse(data, offset) {
      return canParse(data, offset);
    }
    appendFrame(track, data, offset) {
      if (this.basePTS === null) {
        return;
      }
      return appendFrame$1(track, data, offset, this.basePTS, this.frameIndex);
    }
  };
  var emsgSchemePattern = /\/emsg[-/]ID3/i;
  var MP4Demuxer = class {
    constructor(observer2, config3) {
      this.remainderData = null;
      this.timeOffset = 0;
      this.config = void 0;
      this.videoTrack = void 0;
      this.audioTrack = void 0;
      this.id3Track = void 0;
      this.txtTrack = void 0;
      this.config = config3;
    }
    resetTimeStamp() {
    }
    resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {
      const videoTrack = this.videoTrack = dummyTrack("video", 1);
      const audioTrack = this.audioTrack = dummyTrack("audio", 1);
      const captionTrack = this.txtTrack = dummyTrack("text", 1);
      this.id3Track = dummyTrack("id3", 1);
      this.timeOffset = 0;
      if (!(initSegment != null && initSegment.byteLength)) {
        return;
      }
      const initData = parseInitSegment(initSegment);
      if (initData.video) {
        const {
          id: id3,
          timescale,
          codec,
          supplemental
        } = initData.video;
        videoTrack.id = id3;
        videoTrack.timescale = captionTrack.timescale = timescale;
        videoTrack.codec = codec;
        videoTrack.supplemental = supplemental;
      }
      if (initData.audio) {
        const {
          id: id3,
          timescale,
          codec
        } = initData.audio;
        audioTrack.id = id3;
        audioTrack.timescale = timescale;
        audioTrack.codec = codec;
      }
      captionTrack.id = RemuxerTrackIdConfig.text;
      videoTrack.sampleDuration = 0;
      videoTrack.duration = audioTrack.duration = trackDuration;
    }
    resetContiguity() {
      this.remainderData = null;
    }
    static probe(data) {
      return hasMoofData(data);
    }
    demux(data, timeOffset) {
      this.timeOffset = timeOffset;
      let videoSamples = data;
      const videoTrack = this.videoTrack;
      const textTrack = this.txtTrack;
      if (this.config.progressive) {
        if (this.remainderData) {
          videoSamples = appendUint8Array(this.remainderData, data);
        }
        const segmentedData = segmentValidRange(videoSamples);
        this.remainderData = segmentedData.remainder;
        videoTrack.samples = segmentedData.valid || new Uint8Array();
      } else {
        videoTrack.samples = videoSamples;
      }
      const id3Track = this.extractID3Track(videoTrack, timeOffset);
      textTrack.samples = parseSamples(timeOffset, videoTrack);
      return {
        videoTrack,
        audioTrack: this.audioTrack,
        id3Track,
        textTrack: this.txtTrack
      };
    }
    flush() {
      const timeOffset = this.timeOffset;
      const videoTrack = this.videoTrack;
      const textTrack = this.txtTrack;
      videoTrack.samples = this.remainderData || new Uint8Array();
      this.remainderData = null;
      const id3Track = this.extractID3Track(videoTrack, this.timeOffset);
      textTrack.samples = parseSamples(timeOffset, videoTrack);
      return {
        videoTrack,
        audioTrack: dummyTrack(),
        id3Track,
        textTrack: dummyTrack()
      };
    }
    extractID3Track(videoTrack, timeOffset) {
      const id3Track = this.id3Track;
      if (videoTrack.samples.length) {
        const emsgs = findBox(videoTrack.samples, ["emsg"]);
        if (emsgs) {
          emsgs.forEach((data) => {
            const emsgInfo = parseEmsg(data);
            if (emsgSchemePattern.test(emsgInfo.schemeIdUri)) {
              const pts = getEmsgStartTime(emsgInfo, timeOffset);
              let duration = emsgInfo.eventDuration === 4294967295 ? Number.POSITIVE_INFINITY : emsgInfo.eventDuration / emsgInfo.timeScale;
              if (duration <= 1e-3) {
                duration = Number.POSITIVE_INFINITY;
              }
              const payload = emsgInfo.payload;
              id3Track.samples.push({
                data: payload,
                len: payload.byteLength,
                dts: pts,
                pts,
                type: MetadataSchema.emsg,
                duration
              });
            } else if (this.config.enableEmsgKLVMetadata && emsgInfo.schemeIdUri.startsWith("urn:misb:KLV:bin:1910.1")) {
              const pts = getEmsgStartTime(emsgInfo, timeOffset);
              id3Track.samples.push({
                data: emsgInfo.payload,
                len: emsgInfo.payload.byteLength,
                dts: pts,
                pts,
                type: MetadataSchema.misbklv,
                duration: Number.POSITIVE_INFINITY
              });
            }
          });
        }
      }
      return id3Track;
    }
    demuxSampleAes(data, keyData, timeOffset) {
      return Promise.reject(new Error("The MP4 demuxer does not support SAMPLE-AES decryption"));
    }
    destroy() {
      this.config = null;
      this.remainderData = null;
      this.videoTrack = this.audioTrack = this.id3Track = this.txtTrack = void 0;
    }
  };
  function getEmsgStartTime(emsgInfo, timeOffset) {
    return isFiniteNumber(emsgInfo.presentationTime) ? emsgInfo.presentationTime / emsgInfo.timeScale : timeOffset + emsgInfo.presentationTimeDelta / emsgInfo.timeScale;
  }
  var SampleAesDecrypter = class {
    constructor(observer2, config3, keyData) {
      this.keyData = void 0;
      this.decrypter = void 0;
      this.keyData = keyData;
      this.decrypter = new Decrypter(config3, {
        removePKCS7Padding: false
      });
    }
    decryptBuffer(encryptedData) {
      return this.decrypter.decrypt(encryptedData, this.keyData.key.buffer, this.keyData.iv.buffer, DecrypterAesMode.cbc);
    }
    // AAC - encrypt all full 16 bytes blocks starting from offset 16
    decryptAacSample(samples, sampleIndex, callback) {
      const curUnit = samples[sampleIndex].unit;
      if (curUnit.length <= 16) {
        return;
      }
      const encryptedData = curUnit.subarray(16, curUnit.length - curUnit.length % 16);
      const encryptedBuffer = encryptedData.buffer.slice(encryptedData.byteOffset, encryptedData.byteOffset + encryptedData.length);
      this.decryptBuffer(encryptedBuffer).then((decryptedBuffer) => {
        const decryptedData = new Uint8Array(decryptedBuffer);
        curUnit.set(decryptedData, 16);
        if (!this.decrypter.isSync()) {
          this.decryptAacSamples(samples, sampleIndex + 1, callback);
        }
      }).catch(callback);
    }
    decryptAacSamples(samples, sampleIndex, callback) {
      for (; ; sampleIndex++) {
        if (sampleIndex >= samples.length) {
          callback();
          return;
        }
        if (samples[sampleIndex].unit.length < 32) {
          continue;
        }
        this.decryptAacSample(samples, sampleIndex, callback);
        if (!this.decrypter.isSync()) {
          return;
        }
      }
    }
    // AVC - encrypt one 16 bytes block out of ten, starting from offset 32
    getAvcEncryptedData(decodedData) {
      const encryptedDataLen = Math.floor((decodedData.length - 48) / 160) * 16 + 16;
      const encryptedData = new Int8Array(encryptedDataLen);
      let outputPos = 0;
      for (let inputPos = 32; inputPos < decodedData.length - 16; inputPos += 160, outputPos += 16) {
        encryptedData.set(decodedData.subarray(inputPos, inputPos + 16), outputPos);
      }
      return encryptedData;
    }
    getAvcDecryptedUnit(decodedData, decryptedData) {
      const uint8DecryptedData = new Uint8Array(decryptedData);
      let inputPos = 0;
      for (let outputPos = 32; outputPos < decodedData.length - 16; outputPos += 160, inputPos += 16) {
        decodedData.set(uint8DecryptedData.subarray(inputPos, inputPos + 16), outputPos);
      }
      return decodedData;
    }
    decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit) {
      const decodedData = discardEPB(curUnit.data);
      const encryptedData = this.getAvcEncryptedData(decodedData);
      this.decryptBuffer(encryptedData.buffer).then((decryptedBuffer) => {
        curUnit.data = this.getAvcDecryptedUnit(decodedData, decryptedBuffer);
        if (!this.decrypter.isSync()) {
          this.decryptAvcSamples(samples, sampleIndex, unitIndex + 1, callback);
        }
      }).catch(callback);
    }
    decryptAvcSamples(samples, sampleIndex, unitIndex, callback) {
      if (samples instanceof Uint8Array) {
        throw new Error("Cannot decrypt samples of type Uint8Array");
      }
      for (; ; sampleIndex++, unitIndex = 0) {
        if (sampleIndex >= samples.length) {
          callback();
          return;
        }
        const curUnits = samples[sampleIndex].units;
        for (; ; unitIndex++) {
          if (unitIndex >= curUnits.length) {
            break;
          }
          const curUnit = curUnits[unitIndex];
          if (curUnit.data.length <= 48 || curUnit.type !== 1 && curUnit.type !== 5) {
            continue;
          }
          this.decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit);
          if (!this.decrypter.isSync()) {
            return;
          }
        }
      }
    }
  };
  var BaseVideoParser = class {
    constructor() {
      this.VideoSample = null;
    }
    createVideoSample(key, pts, dts) {
      return {
        key,
        frame: false,
        pts,
        dts,
        units: [],
        length: 0
      };
    }
    getLastNalUnit(samples) {
      var _VideoSample;
      let VideoSample = this.VideoSample;
      let lastUnit;
      if (!VideoSample || VideoSample.units.length === 0) {
        VideoSample = samples[samples.length - 1];
      }
      if ((_VideoSample = VideoSample) != null && _VideoSample.units) {
        const units = VideoSample.units;
        lastUnit = units[units.length - 1];
      }
      return lastUnit;
    }
    pushAccessUnit(VideoSample, videoTrack) {
      if (VideoSample.units.length && VideoSample.frame) {
        if (VideoSample.pts === void 0) {
          const samples = videoTrack.samples;
          const nbSamples = samples.length;
          if (nbSamples) {
            const lastSample = samples[nbSamples - 1];
            VideoSample.pts = lastSample.pts;
            VideoSample.dts = lastSample.dts;
          } else {
            videoTrack.dropped++;
            return;
          }
        }
        videoTrack.samples.push(VideoSample);
      }
    }
    parseNALu(track, array, endOfSegment) {
      const len = array.byteLength;
      let state = track.naluState || 0;
      const lastState = state;
      const units = [];
      let i = 0;
      let value;
      let overflow;
      let unitType;
      let lastUnitStart = -1;
      let lastUnitType = 0;
      if (state === -1) {
        lastUnitStart = 0;
        lastUnitType = this.getNALuType(array, 0);
        state = 0;
        i = 1;
      }
      while (i < len) {
        value = array[i++];
        if (!state) {
          state = value ? 0 : 1;
          continue;
        }
        if (state === 1) {
          state = value ? 0 : 2;
          continue;
        }
        if (!value) {
          state = 3;
        } else if (value === 1) {
          overflow = i - state - 1;
          if (lastUnitStart >= 0) {
            const unit = {
              data: array.subarray(lastUnitStart, overflow),
              type: lastUnitType
            };
            units.push(unit);
          } else {
            const lastUnit = this.getLastNalUnit(track.samples);
            if (lastUnit) {
              if (lastState && i <= 4 - lastState) {
                if (lastUnit.state) {
                  lastUnit.data = lastUnit.data.subarray(0, lastUnit.data.byteLength - lastState);
                }
              }
              if (overflow > 0) {
                lastUnit.data = appendUint8Array(lastUnit.data, array.subarray(0, overflow));
                lastUnit.state = 0;
              }
            }
          }
          if (i < len) {
            unitType = this.getNALuType(array, i);
            lastUnitStart = i;
            lastUnitType = unitType;
            state = 0;
          } else {
            state = -1;
          }
        } else {
          state = 0;
        }
      }
      if (lastUnitStart >= 0 && state >= 0) {
        const unit = {
          data: array.subarray(lastUnitStart, len),
          type: lastUnitType,
          state
        };
        units.push(unit);
      }
      if (units.length === 0) {
        const lastUnit = this.getLastNalUnit(track.samples);
        if (lastUnit) {
          lastUnit.data = appendUint8Array(lastUnit.data, array);
        }
      }
      track.naluState = state;
      return units;
    }
  };
  var ExpGolomb = class {
    constructor(data) {
      this.data = void 0;
      this.bytesAvailable = void 0;
      this.word = void 0;
      this.bitsAvailable = void 0;
      this.data = data;
      this.bytesAvailable = data.byteLength;
      this.word = 0;
      this.bitsAvailable = 0;
    }
    // ():void
    loadWord() {
      const data = this.data;
      const bytesAvailable = this.bytesAvailable;
      const position = data.byteLength - bytesAvailable;
      const workingBytes = new Uint8Array(4);
      const availableBytes = Math.min(4, bytesAvailable);
      if (availableBytes === 0) {
        throw new Error("no bytes available");
      }
      workingBytes.set(data.subarray(position, position + availableBytes));
      this.word = new DataView(workingBytes.buffer).getUint32(0);
      this.bitsAvailable = availableBytes * 8;
      this.bytesAvailable -= availableBytes;
    }
    // (count:int):void
    skipBits(count) {
      let skipBytes;
      count = Math.min(count, this.bytesAvailable * 8 + this.bitsAvailable);
      if (this.bitsAvailable > count) {
        this.word <<= count;
        this.bitsAvailable -= count;
      } else {
        count -= this.bitsAvailable;
        skipBytes = count >> 3;
        count -= skipBytes << 3;
        this.bytesAvailable -= skipBytes;
        this.loadWord();
        this.word <<= count;
        this.bitsAvailable -= count;
      }
    }
    // (size:int):uint
    readBits(size) {
      let bits = Math.min(this.bitsAvailable, size);
      const valu = this.word >>> 32 - bits;
      if (size > 32) {
        logger.error("Cannot read more than 32 bits at a time");
      }
      this.bitsAvailable -= bits;
      if (this.bitsAvailable > 0) {
        this.word <<= bits;
      } else if (this.bytesAvailable > 0) {
        this.loadWord();
      } else {
        throw new Error("no bits available");
      }
      bits = size - bits;
      if (bits > 0 && this.bitsAvailable) {
        return valu << bits | this.readBits(bits);
      } else {
        return valu;
      }
    }
    // ():uint
    skipLZ() {
      let leadingZeroCount;
      for (leadingZeroCount = 0; leadingZeroCount < this.bitsAvailable; ++leadingZeroCount) {
        if ((this.word & 2147483648 >>> leadingZeroCount) !== 0) {
          this.word <<= leadingZeroCount;
          this.bitsAvailable -= leadingZeroCount;
          return leadingZeroCount;
        }
      }
      this.loadWord();
      return leadingZeroCount + this.skipLZ();
    }
    // ():void
    skipUEG() {
      this.skipBits(1 + this.skipLZ());
    }
    // ():void
    skipEG() {
      this.skipBits(1 + this.skipLZ());
    }
    // ():uint
    readUEG() {
      const clz = this.skipLZ();
      return this.readBits(clz + 1) - 1;
    }
    // ():int
    readEG() {
      const valu = this.readUEG();
      if (1 & valu) {
        return 1 + valu >>> 1;
      } else {
        return -1 * (valu >>> 1);
      }
    }
    // Some convenience functions
    // :Boolean
    readBoolean() {
      return this.readBits(1) === 1;
    }
    // ():int
    readUByte() {
      return this.readBits(8);
    }
    // ():int
    readUShort() {
      return this.readBits(16);
    }
    // ():int
    readUInt() {
      return this.readBits(32);
    }
  };
  var AvcVideoParser = class extends BaseVideoParser {
    parsePES(track, textTrack, pes, endOfSegment) {
      const units = this.parseNALu(track, pes.data, endOfSegment);
      let VideoSample = this.VideoSample;
      let push2;
      let spsfound = false;
      pes.data = null;
      if (VideoSample && units.length && !track.audFound) {
        this.pushAccessUnit(VideoSample, track);
        VideoSample = this.VideoSample = this.createVideoSample(false, pes.pts, pes.dts);
      }
      units.forEach((unit) => {
        var _VideoSample2, _VideoSample3;
        switch (unit.type) {
          // NDR
          case 1: {
            let iskey = false;
            push2 = true;
            const data = unit.data;
            if (spsfound && data.length > 4) {
              const sliceType = this.readSliceType(data);
              if (sliceType === 2 || sliceType === 4 || sliceType === 7 || sliceType === 9) {
                iskey = true;
              }
            }
            if (iskey) {
              var _VideoSample;
              if ((_VideoSample = VideoSample) != null && _VideoSample.frame && !VideoSample.key) {
                this.pushAccessUnit(VideoSample, track);
                VideoSample = this.VideoSample = null;
              }
            }
            if (!VideoSample) {
              VideoSample = this.VideoSample = this.createVideoSample(true, pes.pts, pes.dts);
            }
            VideoSample.frame = true;
            VideoSample.key = iskey;
            break;
          }
          case 5:
            push2 = true;
            if ((_VideoSample2 = VideoSample) != null && _VideoSample2.frame && !VideoSample.key) {
              this.pushAccessUnit(VideoSample, track);
              VideoSample = this.VideoSample = null;
            }
            if (!VideoSample) {
              VideoSample = this.VideoSample = this.createVideoSample(true, pes.pts, pes.dts);
            }
            VideoSample.key = true;
            VideoSample.frame = true;
            break;
          // SEI
          case 6: {
            push2 = true;
            parseSEIMessageFromNALu(unit.data, 1, pes.pts, textTrack.samples);
            break;
          }
          case 7: {
            var _track$pixelRatio, _track$pixelRatio2;
            push2 = true;
            spsfound = true;
            const sps = unit.data;
            const config3 = this.readSPS(sps);
            if (!track.sps || track.width !== config3.width || track.height !== config3.height || ((_track$pixelRatio = track.pixelRatio) == null ? void 0 : _track$pixelRatio[0]) !== config3.pixelRatio[0] || ((_track$pixelRatio2 = track.pixelRatio) == null ? void 0 : _track$pixelRatio2[1]) !== config3.pixelRatio[1]) {
              track.width = config3.width;
              track.height = config3.height;
              track.pixelRatio = config3.pixelRatio;
              track.sps = [sps];
              const codecarray = sps.subarray(1, 4);
              let codecstring = "avc1.";
              for (let i = 0; i < 3; i++) {
                let h = codecarray[i].toString(16);
                if (h.length < 2) {
                  h = "0" + h;
                }
                codecstring += h;
              }
              track.codec = codecstring;
            }
            break;
          }
          // PPS
          case 8:
            push2 = true;
            track.pps = [unit.data];
            break;
          // AUD
          case 9:
            push2 = true;
            track.audFound = true;
            if ((_VideoSample3 = VideoSample) != null && _VideoSample3.frame) {
              this.pushAccessUnit(VideoSample, track);
              VideoSample = null;
            }
            if (!VideoSample) {
              VideoSample = this.VideoSample = this.createVideoSample(false, pes.pts, pes.dts);
            }
            break;
          // Filler Data
          case 12:
            push2 = true;
            break;
          default:
            push2 = false;
            break;
        }
        if (VideoSample && push2) {
          const units2 = VideoSample.units;
          units2.push(unit);
        }
      });
      if (endOfSegment && VideoSample) {
        this.pushAccessUnit(VideoSample, track);
        this.VideoSample = null;
      }
    }
    getNALuType(data, offset) {
      return data[offset] & 31;
    }
    readSliceType(data) {
      const eg = new ExpGolomb(data);
      eg.readUByte();
      eg.readUEG();
      return eg.readUEG();
    }
    /**
     * The scaling list is optionally transmitted as part of a sequence parameter
     * set and is not relevant to transmuxing.
     * @param count the number of entries in this scaling list
     * @see Recommendation ITU-T H.264, Section 7.3.2.1.1.1
     */
    skipScalingList(count, reader) {
      let lastScale = 8;
      let nextScale = 8;
      let deltaScale;
      for (let j = 0; j < count; j++) {
        if (nextScale !== 0) {
          deltaScale = reader.readEG();
          nextScale = (lastScale + deltaScale + 256) % 256;
        }
        lastScale = nextScale === 0 ? lastScale : nextScale;
      }
    }
    /**
     * Read a sequence parameter set and return some interesting video
     * properties. A sequence parameter set is the H264 metadata that
     * describes the properties of upcoming video frames.
     * @returns an object with configuration parsed from the
     * sequence parameter set, including the dimensions of the
     * associated video frames.
     */
    readSPS(sps) {
      const eg = new ExpGolomb(sps);
      let frameCropLeftOffset = 0;
      let frameCropRightOffset = 0;
      let frameCropTopOffset = 0;
      let frameCropBottomOffset = 0;
      let numRefFramesInPicOrderCntCycle;
      let scalingListCount;
      let i;
      const readUByte = eg.readUByte.bind(eg);
      const readBits = eg.readBits.bind(eg);
      const readUEG = eg.readUEG.bind(eg);
      const readBoolean = eg.readBoolean.bind(eg);
      const skipBits = eg.skipBits.bind(eg);
      const skipEG = eg.skipEG.bind(eg);
      const skipUEG = eg.skipUEG.bind(eg);
      const skipScalingList = this.skipScalingList.bind(this);
      readUByte();
      const profileIdc = readUByte();
      readBits(5);
      skipBits(3);
      readUByte();
      skipUEG();
      if (profileIdc === 100 || profileIdc === 110 || profileIdc === 122 || profileIdc === 244 || profileIdc === 44 || profileIdc === 83 || profileIdc === 86 || profileIdc === 118 || profileIdc === 128) {
        const chromaFormatIdc = readUEG();
        if (chromaFormatIdc === 3) {
          skipBits(1);
        }
        skipUEG();
        skipUEG();
        skipBits(1);
        if (readBoolean()) {
          scalingListCount = chromaFormatIdc !== 3 ? 8 : 12;
          for (i = 0; i < scalingListCount; i++) {
            if (readBoolean()) {
              if (i < 6) {
                skipScalingList(16, eg);
              } else {
                skipScalingList(64, eg);
              }
            }
          }
        }
      }
      skipUEG();
      const picOrderCntType = readUEG();
      if (picOrderCntType === 0) {
        readUEG();
      } else if (picOrderCntType === 1) {
        skipBits(1);
        skipEG();
        skipEG();
        numRefFramesInPicOrderCntCycle = readUEG();
        for (i = 0; i < numRefFramesInPicOrderCntCycle; i++) {
          skipEG();
        }
      }
      skipUEG();
      skipBits(1);
      const picWidthInMbsMinus1 = readUEG();
      const picHeightInMapUnitsMinus1 = readUEG();
      const frameMbsOnlyFlag = readBits(1);
      if (frameMbsOnlyFlag === 0) {
        skipBits(1);
      }
      skipBits(1);
      if (readBoolean()) {
        frameCropLeftOffset = readUEG();
        frameCropRightOffset = readUEG();
        frameCropTopOffset = readUEG();
        frameCropBottomOffset = readUEG();
      }
      let pixelRatio = [1, 1];
      if (readBoolean()) {
        if (readBoolean()) {
          const aspectRatioIdc = readUByte();
          switch (aspectRatioIdc) {
            case 1:
              pixelRatio = [1, 1];
              break;
            case 2:
              pixelRatio = [12, 11];
              break;
            case 3:
              pixelRatio = [10, 11];
              break;
            case 4:
              pixelRatio = [16, 11];
              break;
            case 5:
              pixelRatio = [40, 33];
              break;
            case 6:
              pixelRatio = [24, 11];
              break;
            case 7:
              pixelRatio = [20, 11];
              break;
            case 8:
              pixelRatio = [32, 11];
              break;
            case 9:
              pixelRatio = [80, 33];
              break;
            case 10:
              pixelRatio = [18, 11];
              break;
            case 11:
              pixelRatio = [15, 11];
              break;
            case 12:
              pixelRatio = [64, 33];
              break;
            case 13:
              pixelRatio = [160, 99];
              break;
            case 14:
              pixelRatio = [4, 3];
              break;
            case 15:
              pixelRatio = [3, 2];
              break;
            case 16:
              pixelRatio = [2, 1];
              break;
            case 255: {
              pixelRatio = [readUByte() << 8 | readUByte(), readUByte() << 8 | readUByte()];
              break;
            }
          }
        }
      }
      return {
        width: Math.ceil((picWidthInMbsMinus1 + 1) * 16 - frameCropLeftOffset * 2 - frameCropRightOffset * 2),
        height: (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16 - (frameMbsOnlyFlag ? 2 : 4) * (frameCropTopOffset + frameCropBottomOffset),
        pixelRatio
      };
    }
  };
  var HevcVideoParser = class extends BaseVideoParser {
    constructor(...args) {
      super(...args);
      this.initVPS = null;
    }
    parsePES(track, textTrack, pes, endOfSegment) {
      const units = this.parseNALu(track, pes.data, endOfSegment);
      let VideoSample = this.VideoSample;
      let push2;
      let spsfound = false;
      pes.data = null;
      if (VideoSample && units.length && !track.audFound) {
        this.pushAccessUnit(VideoSample, track);
        VideoSample = this.VideoSample = this.createVideoSample(false, pes.pts, pes.dts);
      }
      units.forEach((unit) => {
        var _VideoSample2, _VideoSample3;
        switch (unit.type) {
          // NON-IDR, NON RANDOM ACCESS SLICE
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 7:
          case 8:
          case 9:
            if (!VideoSample) {
              VideoSample = this.VideoSample = this.createVideoSample(false, pes.pts, pes.dts);
            }
            VideoSample.frame = true;
            push2 = true;
            break;
          // CRA, BLA (random access picture)
          case 16:
          case 17:
          case 18:
          case 21:
            push2 = true;
            if (spsfound) {
              var _VideoSample;
              if ((_VideoSample = VideoSample) != null && _VideoSample.frame && !VideoSample.key) {
                this.pushAccessUnit(VideoSample, track);
                VideoSample = this.VideoSample = null;
              }
            }
            if (!VideoSample) {
              VideoSample = this.VideoSample = this.createVideoSample(true, pes.pts, pes.dts);
            }
            VideoSample.key = true;
            VideoSample.frame = true;
            break;
          // IDR
          case 19:
          case 20:
            push2 = true;
            if ((_VideoSample2 = VideoSample) != null && _VideoSample2.frame && !VideoSample.key) {
              this.pushAccessUnit(VideoSample, track);
              VideoSample = this.VideoSample = null;
            }
            if (!VideoSample) {
              VideoSample = this.VideoSample = this.createVideoSample(true, pes.pts, pes.dts);
            }
            VideoSample.key = true;
            VideoSample.frame = true;
            break;
          // SEI
          case 39:
            push2 = true;
            parseSEIMessageFromNALu(
              unit.data,
              2,
              // NALu header size
              pes.pts,
              textTrack.samples
            );
            break;
          // VPS
          case 32:
            push2 = true;
            if (!track.vps) {
              if (typeof track.params !== "object") {
                track.params = {};
              }
              track.params = _extends4(track.params, this.readVPS(unit.data));
              this.initVPS = unit.data;
            }
            track.vps = [unit.data];
            break;
          // SPS
          case 33:
            push2 = true;
            spsfound = true;
            if (track.vps !== void 0 && track.vps[0] !== this.initVPS && track.sps !== void 0 && !this.matchSPS(track.sps[0], unit.data)) {
              this.initVPS = track.vps[0];
              track.sps = track.pps = void 0;
            }
            if (!track.sps) {
              const config3 = this.readSPS(unit.data);
              track.width = config3.width;
              track.height = config3.height;
              track.pixelRatio = config3.pixelRatio;
              track.codec = config3.codecString;
              track.sps = [];
              if (typeof track.params !== "object") {
                track.params = {};
              }
              for (const prop in config3.params) {
                track.params[prop] = config3.params[prop];
              }
            }
            this.pushParameterSet(track.sps, unit.data, track.vps);
            if (!VideoSample) {
              VideoSample = this.VideoSample = this.createVideoSample(true, pes.pts, pes.dts);
            }
            VideoSample.key = true;
            break;
          // PPS
          case 34:
            push2 = true;
            if (typeof track.params === "object") {
              if (!track.pps) {
                track.pps = [];
                const config3 = this.readPPS(unit.data);
                for (const prop in config3) {
                  track.params[prop] = config3[prop];
                }
              }
              this.pushParameterSet(track.pps, unit.data, track.vps);
            }
            break;
          // ACCESS UNIT DELIMITER
          case 35:
            push2 = true;
            track.audFound = true;
            if ((_VideoSample3 = VideoSample) != null && _VideoSample3.frame) {
              this.pushAccessUnit(VideoSample, track);
              VideoSample = null;
            }
            if (!VideoSample) {
              VideoSample = this.VideoSample = this.createVideoSample(false, pes.pts, pes.dts);
            }
            break;
          default:
            push2 = false;
            break;
        }
        if (VideoSample && push2) {
          const units2 = VideoSample.units;
          units2.push(unit);
        }
      });
      if (endOfSegment && VideoSample) {
        this.pushAccessUnit(VideoSample, track);
        this.VideoSample = null;
      }
    }
    pushParameterSet(parameterSets, data, vps) {
      if (vps && vps[0] === this.initVPS || !vps && !parameterSets.length) {
        parameterSets.push(data);
      }
    }
    getNALuType(data, offset) {
      return (data[offset] & 126) >>> 1;
    }
    ebsp2rbsp(arr) {
      const dst = new Uint8Array(arr.byteLength);
      let dstIdx = 0;
      for (let i = 0; i < arr.byteLength; i++) {
        if (i >= 2) {
          if (arr[i] === 3 && arr[i - 1] === 0 && arr[i - 2] === 0) {
            continue;
          }
        }
        dst[dstIdx] = arr[i];
        dstIdx++;
      }
      return new Uint8Array(dst.buffer, 0, dstIdx);
    }
    pushAccessUnit(VideoSample, videoTrack) {
      super.pushAccessUnit(VideoSample, videoTrack);
      if (this.initVPS) {
        this.initVPS = null;
      }
    }
    readVPS(vps) {
      const eg = new ExpGolomb(vps);
      eg.readUByte();
      eg.readUByte();
      eg.readBits(4);
      eg.skipBits(2);
      eg.readBits(6);
      const max_sub_layers_minus1 = eg.readBits(3);
      const temporal_id_nesting_flag = eg.readBoolean();
      return {
        numTemporalLayers: max_sub_layers_minus1 + 1,
        temporalIdNested: temporal_id_nesting_flag
      };
    }
    readSPS(sps) {
      const eg = new ExpGolomb(this.ebsp2rbsp(sps));
      eg.readUByte();
      eg.readUByte();
      eg.readBits(4);
      const max_sub_layers_minus1 = eg.readBits(3);
      eg.readBoolean();
      const general_profile_space = eg.readBits(2);
      const general_tier_flag = eg.readBoolean();
      const general_profile_idc = eg.readBits(5);
      const general_profile_compatibility_flags_1 = eg.readUByte();
      const general_profile_compatibility_flags_2 = eg.readUByte();
      const general_profile_compatibility_flags_3 = eg.readUByte();
      const general_profile_compatibility_flags_4 = eg.readUByte();
      const general_constraint_indicator_flags_1 = eg.readUByte();
      const general_constraint_indicator_flags_2 = eg.readUByte();
      const general_constraint_indicator_flags_3 = eg.readUByte();
      const general_constraint_indicator_flags_4 = eg.readUByte();
      const general_constraint_indicator_flags_5 = eg.readUByte();
      const general_constraint_indicator_flags_6 = eg.readUByte();
      const general_level_idc = eg.readUByte();
      const sub_layer_profile_present_flags = [];
      const sub_layer_level_present_flags = [];
      for (let i = 0; i < max_sub_layers_minus1; i++) {
        sub_layer_profile_present_flags.push(eg.readBoolean());
        sub_layer_level_present_flags.push(eg.readBoolean());
      }
      if (max_sub_layers_minus1 > 0) {
        for (let i = max_sub_layers_minus1; i < 8; i++) {
          eg.readBits(2);
        }
      }
      for (let i = 0; i < max_sub_layers_minus1; i++) {
        if (sub_layer_profile_present_flags[i]) {
          eg.readUByte();
          eg.readUByte();
          eg.readUByte();
          eg.readUByte();
          eg.readUByte();
          eg.readUByte();
          eg.readUByte();
          eg.readUByte();
          eg.readUByte();
          eg.readUByte();
          eg.readUByte();
        }
        if (sub_layer_level_present_flags[i]) {
          eg.readUByte();
        }
      }
      eg.readUEG();
      const chroma_format_idc = eg.readUEG();
      if (chroma_format_idc == 3) {
        eg.skipBits(1);
      }
      const pic_width_in_luma_samples = eg.readUEG();
      const pic_height_in_luma_samples = eg.readUEG();
      const conformance_window_flag = eg.readBoolean();
      let pic_left_offset = 0, pic_right_offset = 0, pic_top_offset = 0, pic_bottom_offset = 0;
      if (conformance_window_flag) {
        pic_left_offset += eg.readUEG();
        pic_right_offset += eg.readUEG();
        pic_top_offset += eg.readUEG();
        pic_bottom_offset += eg.readUEG();
      }
      const bit_depth_luma_minus8 = eg.readUEG();
      const bit_depth_chroma_minus8 = eg.readUEG();
      const log2_max_pic_order_cnt_lsb_minus4 = eg.readUEG();
      const sub_layer_ordering_info_present_flag = eg.readBoolean();
      for (let i = sub_layer_ordering_info_present_flag ? 0 : max_sub_layers_minus1; i <= max_sub_layers_minus1; i++) {
        eg.skipUEG();
        eg.skipUEG();
        eg.skipUEG();
      }
      eg.skipUEG();
      eg.skipUEG();
      eg.skipUEG();
      eg.skipUEG();
      eg.skipUEG();
      eg.skipUEG();
      const scaling_list_enabled_flag = eg.readBoolean();
      if (scaling_list_enabled_flag) {
        const sps_scaling_list_data_present_flag = eg.readBoolean();
        if (sps_scaling_list_data_present_flag) {
          for (let sizeId = 0; sizeId < 4; sizeId++) {
            for (let matrixId = 0; matrixId < (sizeId === 3 ? 2 : 6); matrixId++) {
              const scaling_list_pred_mode_flag = eg.readBoolean();
              if (!scaling_list_pred_mode_flag) {
                eg.readUEG();
              } else {
                const coefNum = Math.min(64, 1 << 4 + (sizeId << 1));
                if (sizeId > 1) {
                  eg.readEG();
                }
                for (let i = 0; i < coefNum; i++) {
                  eg.readEG();
                }
              }
            }
          }
        }
      }
      eg.readBoolean();
      eg.readBoolean();
      const pcm_enabled_flag = eg.readBoolean();
      if (pcm_enabled_flag) {
        eg.readUByte();
        eg.skipUEG();
        eg.skipUEG();
        eg.readBoolean();
      }
      const num_short_term_ref_pic_sets = eg.readUEG();
      let num_delta_pocs = 0;
      for (let i = 0; i < num_short_term_ref_pic_sets; i++) {
        let inter_ref_pic_set_prediction_flag = false;
        if (i !== 0) {
          inter_ref_pic_set_prediction_flag = eg.readBoolean();
        }
        if (inter_ref_pic_set_prediction_flag) {
          if (i === num_short_term_ref_pic_sets) {
            eg.readUEG();
          }
          eg.readBoolean();
          eg.readUEG();
          let next_num_delta_pocs = 0;
          for (let j = 0; j <= num_delta_pocs; j++) {
            const used_by_curr_pic_flag = eg.readBoolean();
            let use_delta_flag = false;
            if (!used_by_curr_pic_flag) {
              use_delta_flag = eg.readBoolean();
            }
            if (used_by_curr_pic_flag || use_delta_flag) {
              next_num_delta_pocs++;
            }
          }
          num_delta_pocs = next_num_delta_pocs;
        } else {
          const num_negative_pics = eg.readUEG();
          const num_positive_pics = eg.readUEG();
          num_delta_pocs = num_negative_pics + num_positive_pics;
          for (let j = 0; j < num_negative_pics; j++) {
            eg.readUEG();
            eg.readBoolean();
          }
          for (let j = 0; j < num_positive_pics; j++) {
            eg.readUEG();
            eg.readBoolean();
          }
        }
      }
      const long_term_ref_pics_present_flag = eg.readBoolean();
      if (long_term_ref_pics_present_flag) {
        const num_long_term_ref_pics_sps = eg.readUEG();
        for (let i = 0; i < num_long_term_ref_pics_sps; i++) {
          for (let j = 0; j < log2_max_pic_order_cnt_lsb_minus4 + 4; j++) {
            eg.readBits(1);
          }
          eg.readBits(1);
        }
      }
      let min_spatial_segmentation_idc = 0;
      let sar_width = 1, sar_height = 1;
      let fps_fixed = true, fps_den = 1, fps_num = 0;
      eg.readBoolean();
      eg.readBoolean();
      let default_display_window_flag = false;
      const vui_parameters_present_flag = eg.readBoolean();
      if (vui_parameters_present_flag) {
        const aspect_ratio_info_present_flag = eg.readBoolean();
        if (aspect_ratio_info_present_flag) {
          const aspect_ratio_idc = eg.readUByte();
          const sar_width_table = [1, 12, 10, 16, 40, 24, 20, 32, 80, 18, 15, 64, 160, 4, 3, 2];
          const sar_height_table = [1, 11, 11, 11, 33, 11, 11, 11, 33, 11, 11, 33, 99, 3, 2, 1];
          if (aspect_ratio_idc > 0 && aspect_ratio_idc < 16) {
            sar_width = sar_width_table[aspect_ratio_idc - 1];
            sar_height = sar_height_table[aspect_ratio_idc - 1];
          } else if (aspect_ratio_idc === 255) {
            sar_width = eg.readBits(16);
            sar_height = eg.readBits(16);
          }
        }
        const overscan_info_present_flag = eg.readBoolean();
        if (overscan_info_present_flag) {
          eg.readBoolean();
        }
        const video_signal_type_present_flag = eg.readBoolean();
        if (video_signal_type_present_flag) {
          eg.readBits(3);
          eg.readBoolean();
          const colour_description_present_flag = eg.readBoolean();
          if (colour_description_present_flag) {
            eg.readUByte();
            eg.readUByte();
            eg.readUByte();
          }
        }
        const chroma_loc_info_present_flag = eg.readBoolean();
        if (chroma_loc_info_present_flag) {
          eg.readUEG();
          eg.readUEG();
        }
        eg.readBoolean();
        eg.readBoolean();
        eg.readBoolean();
        default_display_window_flag = eg.readBoolean();
        if (default_display_window_flag) {
          eg.skipUEG();
          eg.skipUEG();
          eg.skipUEG();
          eg.skipUEG();
        }
        const vui_timing_info_present_flag = eg.readBoolean();
        if (vui_timing_info_present_flag) {
          fps_den = eg.readBits(32);
          fps_num = eg.readBits(32);
          const vui_poc_proportional_to_timing_flag = eg.readBoolean();
          if (vui_poc_proportional_to_timing_flag) {
            eg.readUEG();
          }
          const vui_hrd_parameters_present_flag = eg.readBoolean();
          if (vui_hrd_parameters_present_flag) {
            const nal_hrd_parameters_present_flag = eg.readBoolean();
            const vcl_hrd_parameters_present_flag = eg.readBoolean();
            let sub_pic_hrd_params_present_flag = false;
            if (nal_hrd_parameters_present_flag || vcl_hrd_parameters_present_flag) {
              sub_pic_hrd_params_present_flag = eg.readBoolean();
              if (sub_pic_hrd_params_present_flag) {
                eg.readUByte();
                eg.readBits(5);
                eg.readBoolean();
                eg.readBits(5);
              }
              eg.readBits(4);
              eg.readBits(4);
              if (sub_pic_hrd_params_present_flag) {
                eg.readBits(4);
              }
              eg.readBits(5);
              eg.readBits(5);
              eg.readBits(5);
            }
            for (let i = 0; i <= max_sub_layers_minus1; i++) {
              fps_fixed = eg.readBoolean();
              const fixed_pic_rate_within_cvs_flag = fps_fixed || eg.readBoolean();
              let low_delay_hrd_flag = false;
              if (fixed_pic_rate_within_cvs_flag) {
                eg.readEG();
              } else {
                low_delay_hrd_flag = eg.readBoolean();
              }
              const cpb_cnt = low_delay_hrd_flag ? 1 : eg.readUEG() + 1;
              if (nal_hrd_parameters_present_flag) {
                for (let j = 0; j < cpb_cnt; j++) {
                  eg.readUEG();
                  eg.readUEG();
                  if (sub_pic_hrd_params_present_flag) {
                    eg.readUEG();
                    eg.readUEG();
                  }
                  eg.skipBits(1);
                }
              }
              if (vcl_hrd_parameters_present_flag) {
                for (let j = 0; j < cpb_cnt; j++) {
                  eg.readUEG();
                  eg.readUEG();
                  if (sub_pic_hrd_params_present_flag) {
                    eg.readUEG();
                    eg.readUEG();
                  }
                  eg.skipBits(1);
                }
              }
            }
          }
        }
        const bitstream_restriction_flag = eg.readBoolean();
        if (bitstream_restriction_flag) {
          eg.readBoolean();
          eg.readBoolean();
          eg.readBoolean();
          min_spatial_segmentation_idc = eg.readUEG();
        }
      }
      let width = pic_width_in_luma_samples, height = pic_height_in_luma_samples;
      if (conformance_window_flag) {
        let chroma_scale_w = 1, chroma_scale_h = 1;
        if (chroma_format_idc === 1) {
          chroma_scale_w = chroma_scale_h = 2;
        } else if (chroma_format_idc == 2) {
          chroma_scale_w = 2;
        }
        width = pic_width_in_luma_samples - chroma_scale_w * pic_right_offset - chroma_scale_w * pic_left_offset;
        height = pic_height_in_luma_samples - chroma_scale_h * pic_bottom_offset - chroma_scale_h * pic_top_offset;
      }
      const profile_space_string = general_profile_space ? ["A", "B", "C"][general_profile_space] : "";
      const profile_compatibility_buf = general_profile_compatibility_flags_1 << 24 | general_profile_compatibility_flags_2 << 16 | general_profile_compatibility_flags_3 << 8 | general_profile_compatibility_flags_4;
      let profile_compatibility_rev = 0;
      for (let i = 0; i < 32; i++) {
        profile_compatibility_rev = (profile_compatibility_rev | (profile_compatibility_buf >> i & 1) << 31 - i) >>> 0;
      }
      let profile_compatibility_flags_string = profile_compatibility_rev.toString(16);
      if (general_profile_idc === 1 && profile_compatibility_flags_string === "2") {
        profile_compatibility_flags_string = "6";
      }
      const tier_flag_string = general_tier_flag ? "H" : "L";
      return {
        codecString: `hvc1.${profile_space_string}${general_profile_idc}.${profile_compatibility_flags_string}.${tier_flag_string}${general_level_idc}.B0`,
        params: {
          general_tier_flag,
          general_profile_idc,
          general_profile_space,
          general_profile_compatibility_flags: [general_profile_compatibility_flags_1, general_profile_compatibility_flags_2, general_profile_compatibility_flags_3, general_profile_compatibility_flags_4],
          general_constraint_indicator_flags: [general_constraint_indicator_flags_1, general_constraint_indicator_flags_2, general_constraint_indicator_flags_3, general_constraint_indicator_flags_4, general_constraint_indicator_flags_5, general_constraint_indicator_flags_6],
          general_level_idc,
          bit_depth: bit_depth_luma_minus8 + 8,
          bit_depth_luma_minus8,
          bit_depth_chroma_minus8,
          min_spatial_segmentation_idc,
          chroma_format_idc,
          frame_rate: {
            fixed: fps_fixed,
            fps: fps_num / fps_den
          }
        },
        width,
        height,
        pixelRatio: [sar_width, sar_height]
      };
    }
    readPPS(pps) {
      const eg = new ExpGolomb(this.ebsp2rbsp(pps));
      eg.readUByte();
      eg.readUByte();
      eg.skipUEG();
      eg.skipUEG();
      eg.skipBits(2);
      eg.skipBits(3);
      eg.skipBits(2);
      eg.skipUEG();
      eg.skipUEG();
      eg.skipEG();
      eg.skipBits(2);
      const cu_qp_delta_enabled_flag = eg.readBoolean();
      if (cu_qp_delta_enabled_flag) {
        eg.skipUEG();
      }
      eg.skipEG();
      eg.skipEG();
      eg.skipBits(4);
      const tiles_enabled_flag = eg.readBoolean();
      const entropy_coding_sync_enabled_flag = eg.readBoolean();
      let parallelismType = 1;
      if (entropy_coding_sync_enabled_flag && tiles_enabled_flag) {
        parallelismType = 0;
      } else if (entropy_coding_sync_enabled_flag) {
        parallelismType = 3;
      } else if (tiles_enabled_flag) {
        parallelismType = 2;
      }
      return {
        parallelismType
      };
    }
    matchSPS(sps1, sps2) {
      return String.fromCharCode.apply(null, sps1).substr(3) === String.fromCharCode.apply(null, sps2).substr(3);
    }
  };
  var PACKET_LENGTH = 188;
  var TSDemuxer = class _TSDemuxer {
    constructor(observer2, config3, typeSupported, logger2) {
      this.logger = void 0;
      this.observer = void 0;
      this.config = void 0;
      this.typeSupported = void 0;
      this.sampleAes = null;
      this.pmtParsed = false;
      this.audioCodec = void 0;
      this.videoCodec = void 0;
      this._pmtId = -1;
      this._videoTrack = void 0;
      this._audioTrack = void 0;
      this._id3Track = void 0;
      this._txtTrack = void 0;
      this.aacOverFlow = null;
      this.remainderData = null;
      this.videoParser = void 0;
      this.observer = observer2;
      this.config = config3;
      this.typeSupported = typeSupported;
      this.logger = logger2;
      this.videoParser = null;
    }
    static probe(data, logger2) {
      const syncOffset = _TSDemuxer.syncOffset(data);
      if (syncOffset > 0) {
        logger2.warn(`MPEG2-TS detected but first sync word found @ offset ${syncOffset}`);
      }
      return syncOffset !== -1;
    }
    static syncOffset(data) {
      const length = data.length;
      let scanwindow = Math.min(PACKET_LENGTH * 5, length - PACKET_LENGTH) + 1;
      let i = 0;
      while (i < scanwindow) {
        let foundPat = false;
        let packetStart = -1;
        let tsPackets = 0;
        for (let j = i; j < length; j += PACKET_LENGTH) {
          if (data[j] === 71 && (length - j === PACKET_LENGTH || data[j + PACKET_LENGTH] === 71)) {
            tsPackets++;
            if (packetStart === -1) {
              packetStart = j;
              if (packetStart !== 0) {
                scanwindow = Math.min(packetStart + PACKET_LENGTH * 99, data.length - PACKET_LENGTH) + 1;
              }
            }
            if (!foundPat) {
              foundPat = parsePID(data, j) === 0;
            }
            if (foundPat && tsPackets > 1 && (packetStart === 0 && tsPackets > 2 || j + PACKET_LENGTH > scanwindow)) {
              return packetStart;
            }
          } else if (tsPackets) {
            return -1;
          } else {
            break;
          }
        }
        i++;
      }
      return -1;
    }
    /**
     * Creates a track model internal to demuxer used to drive remuxing input
     */
    static createTrack(type, duration) {
      return {
        container: type === "video" || type === "audio" ? "video/mp2t" : void 0,
        type,
        id: RemuxerTrackIdConfig[type],
        pid: -1,
        inputTimeScale: 9e4,
        sequenceNumber: 0,
        samples: [],
        dropped: 0,
        duration: type === "audio" ? duration : void 0
      };
    }
    /**
     * Initializes a new init segment on the demuxer/remuxer interface. Needed for discontinuities/track-switches (or at stream start)
     * Resets all internal track instances of the demuxer.
     */
    resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {
      this.pmtParsed = false;
      this._pmtId = -1;
      this._videoTrack = _TSDemuxer.createTrack("video");
      this._videoTrack.duration = trackDuration;
      this._audioTrack = _TSDemuxer.createTrack("audio", trackDuration);
      this._id3Track = _TSDemuxer.createTrack("id3");
      this._txtTrack = _TSDemuxer.createTrack("text");
      this._audioTrack.segmentCodec = "aac";
      this.videoParser = null;
      this.aacOverFlow = null;
      this.remainderData = null;
      this.audioCodec = audioCodec;
      this.videoCodec = videoCodec;
    }
    resetTimeStamp() {
    }
    resetContiguity() {
      const {
        _audioTrack,
        _videoTrack,
        _id3Track
      } = this;
      if (_audioTrack) {
        _audioTrack.pesData = null;
      }
      if (_videoTrack) {
        _videoTrack.pesData = null;
      }
      if (_id3Track) {
        _id3Track.pesData = null;
      }
      this.aacOverFlow = null;
      this.remainderData = null;
    }
    demux(data, timeOffset, isSampleAes = false, flush = false) {
      if (!isSampleAes) {
        this.sampleAes = null;
      }
      let pes;
      const videoTrack = this._videoTrack;
      const audioTrack = this._audioTrack;
      const id3Track = this._id3Track;
      const textTrack = this._txtTrack;
      let videoPid = videoTrack.pid;
      let videoData = videoTrack.pesData;
      let audioPid = audioTrack.pid;
      let id3Pid = id3Track.pid;
      let audioData = audioTrack.pesData;
      let id3Data = id3Track.pesData;
      let unknownPID = null;
      let pmtParsed = this.pmtParsed;
      let pmtId = this._pmtId;
      let len = data.length;
      if (this.remainderData) {
        data = appendUint8Array(this.remainderData, data);
        len = data.length;
        this.remainderData = null;
      }
      if (len < PACKET_LENGTH && !flush) {
        this.remainderData = data;
        return {
          audioTrack,
          videoTrack,
          id3Track,
          textTrack
        };
      }
      const syncOffset = Math.max(0, _TSDemuxer.syncOffset(data));
      len -= (len - syncOffset) % PACKET_LENGTH;
      if (len < data.byteLength && !flush) {
        this.remainderData = new Uint8Array(data.buffer, len, data.buffer.byteLength - len);
      }
      let tsPacketErrors = 0;
      for (let start = syncOffset; start < len; start += PACKET_LENGTH) {
        if (data[start] === 71) {
          const stt = !!(data[start + 1] & 64);
          const pid = parsePID(data, start);
          const atf = (data[start + 3] & 48) >> 4;
          let offset;
          if (atf > 1) {
            offset = start + 5 + data[start + 4];
            if (offset === start + PACKET_LENGTH) {
              continue;
            }
          } else {
            offset = start + 4;
          }
          switch (pid) {
            case videoPid:
              if (stt) {
                if (videoData && (pes = parsePES(videoData, this.logger))) {
                  this.readyVideoParser(videoTrack.segmentCodec);
                  if (this.videoParser !== null) {
                    this.videoParser.parsePES(videoTrack, textTrack, pes, false);
                  }
                }
                videoData = {
                  data: [],
                  size: 0
                };
              }
              if (videoData) {
                videoData.data.push(data.subarray(offset, start + PACKET_LENGTH));
                videoData.size += start + PACKET_LENGTH - offset;
              }
              break;
            case audioPid:
              if (stt) {
                if (audioData && (pes = parsePES(audioData, this.logger))) {
                  switch (audioTrack.segmentCodec) {
                    case "aac":
                      this.parseAACPES(audioTrack, pes);
                      break;
                    case "mp3":
                      this.parseMPEGPES(audioTrack, pes);
                      break;
                    case "ac3":
                      {
                        this.parseAC3PES(audioTrack, pes);
                      }
                      break;
                  }
                }
                audioData = {
                  data: [],
                  size: 0
                };
              }
              if (audioData) {
                audioData.data.push(data.subarray(offset, start + PACKET_LENGTH));
                audioData.size += start + PACKET_LENGTH - offset;
              }
              break;
            case id3Pid:
              if (stt) {
                if (id3Data && (pes = parsePES(id3Data, this.logger))) {
                  this.parseID3PES(id3Track, pes);
                }
                id3Data = {
                  data: [],
                  size: 0
                };
              }
              if (id3Data) {
                id3Data.data.push(data.subarray(offset, start + PACKET_LENGTH));
                id3Data.size += start + PACKET_LENGTH - offset;
              }
              break;
            case 0:
              if (stt) {
                offset += data[offset] + 1;
              }
              pmtId = this._pmtId = parsePAT(data, offset);
              break;
            case pmtId: {
              if (stt) {
                offset += data[offset] + 1;
              }
              const parsedPIDs = parsePMT(data, offset, this.typeSupported, isSampleAes, this.observer, this.logger);
              videoPid = parsedPIDs.videoPid;
              if (videoPid > 0) {
                videoTrack.pid = videoPid;
                videoTrack.segmentCodec = parsedPIDs.segmentVideoCodec;
              }
              audioPid = parsedPIDs.audioPid;
              if (audioPid > 0) {
                audioTrack.pid = audioPid;
                audioTrack.segmentCodec = parsedPIDs.segmentAudioCodec;
              }
              id3Pid = parsedPIDs.id3Pid;
              if (id3Pid > 0) {
                id3Track.pid = id3Pid;
              }
              if (unknownPID !== null && !pmtParsed) {
                this.logger.warn(`MPEG-TS PMT found at ${start} after unknown PID '${unknownPID}'. Backtracking to sync byte @${syncOffset} to parse all TS packets.`);
                unknownPID = null;
                start = syncOffset - 188;
              }
              pmtParsed = this.pmtParsed = true;
              break;
            }
            case 17:
            case 8191:
              break;
            default:
              unknownPID = pid;
              break;
          }
        } else {
          tsPacketErrors++;
        }
      }
      if (tsPacketErrors > 0) {
        emitParsingError(this.observer, new Error(`Found ${tsPacketErrors} TS packet/s that do not start with 0x47`), void 0, this.logger);
      }
      videoTrack.pesData = videoData;
      audioTrack.pesData = audioData;
      id3Track.pesData = id3Data;
      const demuxResult = {
        audioTrack,
        videoTrack,
        id3Track,
        textTrack
      };
      if (flush) {
        this.extractRemainingSamples(demuxResult);
      }
      return demuxResult;
    }
    flush() {
      const {
        remainderData
      } = this;
      this.remainderData = null;
      let result;
      if (remainderData) {
        result = this.demux(remainderData, -1, false, true);
      } else {
        result = {
          videoTrack: this._videoTrack,
          audioTrack: this._audioTrack,
          id3Track: this._id3Track,
          textTrack: this._txtTrack
        };
      }
      this.extractRemainingSamples(result);
      if (this.sampleAes) {
        return this.decrypt(result, this.sampleAes);
      }
      return result;
    }
    extractRemainingSamples(demuxResult) {
      const {
        audioTrack,
        videoTrack,
        id3Track,
        textTrack
      } = demuxResult;
      const videoData = videoTrack.pesData;
      const audioData = audioTrack.pesData;
      const id3Data = id3Track.pesData;
      let pes;
      if (videoData && (pes = parsePES(videoData, this.logger))) {
        this.readyVideoParser(videoTrack.segmentCodec);
        if (this.videoParser !== null) {
          this.videoParser.parsePES(videoTrack, textTrack, pes, true);
          videoTrack.pesData = null;
        }
      } else {
        videoTrack.pesData = videoData;
      }
      if (audioData && (pes = parsePES(audioData, this.logger))) {
        switch (audioTrack.segmentCodec) {
          case "aac":
            this.parseAACPES(audioTrack, pes);
            break;
          case "mp3":
            this.parseMPEGPES(audioTrack, pes);
            break;
          case "ac3":
            {
              this.parseAC3PES(audioTrack, pes);
            }
            break;
        }
        audioTrack.pesData = null;
      } else {
        if (audioData != null && audioData.size) {
          this.logger.log("last AAC PES packet truncated,might overlap between fragments");
        }
        audioTrack.pesData = audioData;
      }
      if (id3Data && (pes = parsePES(id3Data, this.logger))) {
        this.parseID3PES(id3Track, pes);
        id3Track.pesData = null;
      } else {
        id3Track.pesData = id3Data;
      }
    }
    demuxSampleAes(data, keyData, timeOffset) {
      const demuxResult = this.demux(data, timeOffset, true, !this.config.progressive);
      const sampleAes = this.sampleAes = new SampleAesDecrypter(this.observer, this.config, keyData);
      return this.decrypt(demuxResult, sampleAes);
    }
    readyVideoParser(codec) {
      if (this.videoParser === null) {
        if (codec === "avc") {
          this.videoParser = new AvcVideoParser();
        } else if (codec === "hevc") {
          this.videoParser = new HevcVideoParser();
        }
      }
    }
    decrypt(demuxResult, sampleAes) {
      return new Promise((resolve) => {
        const {
          audioTrack,
          videoTrack
        } = demuxResult;
        if (audioTrack.samples && audioTrack.segmentCodec === "aac") {
          sampleAes.decryptAacSamples(audioTrack.samples, 0, () => {
            if (videoTrack.samples) {
              sampleAes.decryptAvcSamples(videoTrack.samples, 0, 0, () => {
                resolve(demuxResult);
              });
            } else {
              resolve(demuxResult);
            }
          });
        } else if (videoTrack.samples) {
          sampleAes.decryptAvcSamples(videoTrack.samples, 0, 0, () => {
            resolve(demuxResult);
          });
        }
      });
    }
    destroy() {
      if (this.observer) {
        this.observer.removeAllListeners();
      }
      this.config = this.logger = this.observer = null;
      this.aacOverFlow = this.videoParser = this.remainderData = this.sampleAes = null;
      this._videoTrack = this._audioTrack = this._id3Track = this._txtTrack = void 0;
    }
    parseAACPES(track, pes) {
      let startOffset = 0;
      const aacOverFlow = this.aacOverFlow;
      let data = pes.data;
      if (aacOverFlow) {
        this.aacOverFlow = null;
        const frameMissingBytes = aacOverFlow.missing;
        const sampleLength = aacOverFlow.sample.unit.byteLength;
        if (frameMissingBytes === -1) {
          data = appendUint8Array(aacOverFlow.sample.unit, data);
        } else {
          const frameOverflowBytes = sampleLength - frameMissingBytes;
          aacOverFlow.sample.unit.set(data.subarray(0, frameMissingBytes), frameOverflowBytes);
          track.samples.push(aacOverFlow.sample);
          startOffset = aacOverFlow.missing;
        }
      }
      let offset;
      let len;
      for (offset = startOffset, len = data.length; offset < len - 1; offset++) {
        if (isHeader$1(data, offset)) {
          break;
        }
      }
      if (offset !== startOffset) {
        let reason;
        const recoverable = offset < len - 1;
        if (recoverable) {
          reason = `AAC PES did not start with ADTS header,offset:${offset}`;
        } else {
          reason = "No ADTS header found in AAC PES";
        }
        emitParsingError(this.observer, new Error(reason), recoverable, this.logger);
        if (!recoverable) {
          return;
        }
      }
      initTrackConfig(track, this.observer, data, offset, this.audioCodec);
      let pts;
      if (pes.pts !== void 0) {
        pts = pes.pts;
      } else if (aacOverFlow) {
        const frameDuration = getFrameDuration(track.samplerate);
        pts = aacOverFlow.sample.pts + frameDuration;
      } else {
        this.logger.warn("[tsdemuxer]: AAC PES unknown PTS");
        return;
      }
      let frameIndex = 0;
      let frame2;
      while (offset < len) {
        frame2 = appendFrame$2(track, data, offset, pts, frameIndex);
        offset += frame2.length;
        if (!frame2.missing) {
          frameIndex++;
          for (; offset < len - 1; offset++) {
            if (isHeader$1(data, offset)) {
              break;
            }
          }
        } else {
          this.aacOverFlow = frame2;
          break;
        }
      }
    }
    parseMPEGPES(track, pes) {
      const data = pes.data;
      const length = data.length;
      let frameIndex = 0;
      let offset = 0;
      const pts = pes.pts;
      if (pts === void 0) {
        this.logger.warn("[tsdemuxer]: MPEG PES unknown PTS");
        return;
      }
      while (offset < length) {
        if (isHeader(data, offset)) {
          const frame2 = appendFrame$1(track, data, offset, pts, frameIndex);
          if (frame2) {
            offset += frame2.length;
            frameIndex++;
          } else {
            break;
          }
        } else {
          offset++;
        }
      }
    }
    parseAC3PES(track, pes) {
      {
        const data = pes.data;
        const pts = pes.pts;
        if (pts === void 0) {
          this.logger.warn("[tsdemuxer]: AC3 PES unknown PTS");
          return;
        }
        const length = data.length;
        let frameIndex = 0;
        let offset = 0;
        let parsed;
        while (offset < length && (parsed = appendFrame(track, data, offset, pts, frameIndex++)) > 0) {
          offset += parsed;
        }
      }
    }
    parseID3PES(id3Track, pes) {
      if (pes.pts === void 0) {
        this.logger.warn("[tsdemuxer]: ID3 PES unknown PTS");
        return;
      }
      const id3Sample = _extends4({}, pes, {
        type: this._videoTrack ? MetadataSchema.emsg : MetadataSchema.audioId3,
        duration: Number.POSITIVE_INFINITY
      });
      id3Track.samples.push(id3Sample);
    }
  };
  function parsePID(data, offset) {
    return ((data[offset + 1] & 31) << 8) + data[offset + 2];
  }
  function parsePAT(data, offset) {
    return (data[offset + 10] & 31) << 8 | data[offset + 11];
  }
  function parsePMT(data, offset, typeSupported, isSampleAes, observer2, logger2) {
    const result = {
      audioPid: -1,
      videoPid: -1,
      id3Pid: -1,
      segmentVideoCodec: "avc",
      segmentAudioCodec: "aac"
    };
    const sectionLength = (data[offset + 1] & 15) << 8 | data[offset + 2];
    const tableEnd = offset + 3 + sectionLength - 4;
    const programInfoLength = (data[offset + 10] & 15) << 8 | data[offset + 11];
    offset += 12 + programInfoLength;
    while (offset < tableEnd) {
      const pid = parsePID(data, offset);
      const esInfoLength = (data[offset + 3] & 15) << 8 | data[offset + 4];
      switch (data[offset]) {
        case 207:
          if (!isSampleAes) {
            logEncryptedSamplesFoundInUnencryptedStream("ADTS AAC", logger2);
            break;
          }
        /* falls through */
        case 15:
          if (result.audioPid === -1) {
            result.audioPid = pid;
          }
          break;
        // Packetized metadata (ID3)
        case 21:
          if (result.id3Pid === -1) {
            result.id3Pid = pid;
          }
          break;
        case 219:
          if (!isSampleAes) {
            logEncryptedSamplesFoundInUnencryptedStream("H.264", logger2);
            break;
          }
        /* falls through */
        case 27:
          if (result.videoPid === -1) {
            result.videoPid = pid;
          }
          break;
        // ISO/IEC 11172-3 (MPEG-1 audio)
        // or ISO/IEC 13818-3 (MPEG-2 halved sample rate audio)
        case 3:
        case 4:
          if (!typeSupported.mpeg && !typeSupported.mp3) {
            logger2.log("MPEG audio found, not supported in this browser");
          } else if (result.audioPid === -1) {
            result.audioPid = pid;
            result.segmentAudioCodec = "mp3";
          }
          break;
        case 193:
          if (!isSampleAes) {
            logEncryptedSamplesFoundInUnencryptedStream("AC-3", logger2);
            break;
          }
        /* falls through */
        case 129:
          {
            if (!typeSupported.ac3) {
              logger2.log("AC-3 audio found, not supported in this browser");
            } else if (result.audioPid === -1) {
              result.audioPid = pid;
              result.segmentAudioCodec = "ac3";
            }
          }
          break;
        case 6:
          if (result.audioPid === -1 && esInfoLength > 0) {
            let parsePos = offset + 5;
            let remaining = esInfoLength;
            while (remaining > 2) {
              const descriptorId = data[parsePos];
              switch (descriptorId) {
                case 106:
                  {
                    if (typeSupported.ac3 !== true) {
                      logger2.log("AC-3 audio found, not supported in this browser for now");
                    } else {
                      result.audioPid = pid;
                      result.segmentAudioCodec = "ac3";
                    }
                  }
                  break;
              }
              const descriptorLen = data[parsePos + 1] + 2;
              parsePos += descriptorLen;
              remaining -= descriptorLen;
            }
          }
          break;
        case 194:
        // SAMPLE-AES EC3
        /* falls through */
        case 135:
          emitParsingError(observer2, new Error("Unsupported EC-3 in M2TS found"), void 0, logger2);
          return result;
        case 36:
          {
            if (result.videoPid === -1) {
              result.videoPid = pid;
              result.segmentVideoCodec = "hevc";
              logger2.log("HEVC in M2TS found");
            }
          }
          break;
      }
      offset += esInfoLength + 5;
    }
    return result;
  }
  function emitParsingError(observer2, error, levelRetry, logger2) {
    logger2.warn(`parsing error: ${error.message}`);
    observer2.emit(Events.ERROR, Events.ERROR, {
      type: ErrorTypes.MEDIA_ERROR,
      details: ErrorDetails.FRAG_PARSING_ERROR,
      fatal: false,
      levelRetry,
      error,
      reason: error.message
    });
  }
  function logEncryptedSamplesFoundInUnencryptedStream(type, logger2) {
    logger2.log(`${type} with AES-128-CBC encryption found in unencrypted stream`);
  }
  function parsePES(stream, logger2) {
    let i = 0;
    let frag;
    let pesLen;
    let pesHdrLen;
    let pesPts;
    let pesDts;
    const data = stream.data;
    if (!stream || stream.size === 0) {
      return null;
    }
    while (data[0].length < 19 && data.length > 1) {
      data[0] = appendUint8Array(data[0], data[1]);
      data.splice(1, 1);
    }
    frag = data[0];
    const pesPrefix = (frag[0] << 16) + (frag[1] << 8) + frag[2];
    if (pesPrefix === 1) {
      pesLen = (frag[4] << 8) + frag[5];
      if (pesLen && pesLen > stream.size - 6) {
        return null;
      }
      const pesFlags = frag[7];
      if (pesFlags & 192) {
        pesPts = (frag[9] & 14) * 536870912 + // 1 << 29
        (frag[10] & 255) * 4194304 + // 1 << 22
        (frag[11] & 254) * 16384 + // 1 << 14
        (frag[12] & 255) * 128 + // 1 << 7
        (frag[13] & 254) / 2;
        if (pesFlags & 64) {
          pesDts = (frag[14] & 14) * 536870912 + // 1 << 29
          (frag[15] & 255) * 4194304 + // 1 << 22
          (frag[16] & 254) * 16384 + // 1 << 14
          (frag[17] & 255) * 128 + // 1 << 7
          (frag[18] & 254) / 2;
          if (pesPts - pesDts > 60 * 9e4) {
            logger2.warn(`${Math.round((pesPts - pesDts) / 9e4)}s delta between PTS and DTS, align them`);
            pesPts = pesDts;
          }
        } else {
          pesDts = pesPts;
        }
      }
      pesHdrLen = frag[8];
      let payloadStartOffset = pesHdrLen + 9;
      if (stream.size <= payloadStartOffset) {
        return null;
      }
      stream.size -= payloadStartOffset;
      const pesData = new Uint8Array(stream.size);
      for (let j = 0, dataLen = data.length; j < dataLen; j++) {
        frag = data[j];
        let len = frag.byteLength;
        if (payloadStartOffset) {
          if (payloadStartOffset > len) {
            payloadStartOffset -= len;
            continue;
          } else {
            frag = frag.subarray(payloadStartOffset);
            len -= payloadStartOffset;
            payloadStartOffset = 0;
          }
        }
        pesData.set(frag, i);
        i += len;
      }
      if (pesLen) {
        pesLen -= pesHdrLen + 3;
      }
      return {
        data: pesData,
        pts: pesPts,
        dts: pesDts,
        len: pesLen
      };
    }
    return null;
  }
  var AAC = class {
    static getSilentFrame(codec, channelCount) {
      switch (codec) {
        case "mp4a.40.2":
          if (channelCount === 1) {
            return new Uint8Array([0, 200, 0, 128, 35, 128]);
          } else if (channelCount === 2) {
            return new Uint8Array([33, 0, 73, 144, 2, 25, 0, 35, 128]);
          } else if (channelCount === 3) {
            return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 142]);
          } else if (channelCount === 4) {
            return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 128, 44, 128, 8, 2, 56]);
          } else if (channelCount === 5) {
            return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 56]);
          } else if (channelCount === 6) {
            return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 0, 178, 0, 32, 8, 224]);
          }
          break;
        // handle HE-AAC below (mp4a.40.5 / mp4a.40.29)
        default:
          if (channelCount === 1) {
            return new Uint8Array([1, 64, 34, 128, 163, 78, 230, 128, 186, 8, 0, 0, 0, 28, 6, 241, 193, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
          } else if (channelCount === 2) {
            return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
          } else if (channelCount === 3) {
            return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
          }
          break;
      }
      return void 0;
    }
  };
  var UINT32_MAX = Math.pow(2, 32) - 1;
  var MP4 = class _MP4 {
    static init() {
      _MP4.types = {
        avc1: [],
        // codingname
        avcC: [],
        hvc1: [],
        hvcC: [],
        btrt: [],
        dinf: [],
        dref: [],
        esds: [],
        ftyp: [],
        hdlr: [],
        mdat: [],
        mdhd: [],
        mdia: [],
        mfhd: [],
        minf: [],
        moof: [],
        moov: [],
        mp4a: [],
        ".mp3": [],
        dac3: [],
        "ac-3": [],
        mvex: [],
        mvhd: [],
        pasp: [],
        sdtp: [],
        stbl: [],
        stco: [],
        stsc: [],
        stsd: [],
        stsz: [],
        stts: [],
        tfdt: [],
        tfhd: [],
        traf: [],
        trak: [],
        trun: [],
        trex: [],
        tkhd: [],
        vmhd: [],
        smhd: []
      };
      let i;
      for (i in _MP4.types) {
        if (_MP4.types.hasOwnProperty(i)) {
          _MP4.types[i] = [i.charCodeAt(0), i.charCodeAt(1), i.charCodeAt(2), i.charCodeAt(3)];
        }
      }
      const videoHdlr = new Uint8Array([
        0,
        // version 0
        0,
        0,
        0,
        // flags
        0,
        0,
        0,
        0,
        // pre_defined
        118,
        105,
        100,
        101,
        // handler_type: 'vide'
        0,
        0,
        0,
        0,
        // reserved
        0,
        0,
        0,
        0,
        // reserved
        0,
        0,
        0,
        0,
        // reserved
        86,
        105,
        100,
        101,
        111,
        72,
        97,
        110,
        100,
        108,
        101,
        114,
        0
        // name: 'VideoHandler'
      ]);
      const audioHdlr = new Uint8Array([
        0,
        // version 0
        0,
        0,
        0,
        // flags
        0,
        0,
        0,
        0,
        // pre_defined
        115,
        111,
        117,
        110,
        // handler_type: 'soun'
        0,
        0,
        0,
        0,
        // reserved
        0,
        0,
        0,
        0,
        // reserved
        0,
        0,
        0,
        0,
        // reserved
        83,
        111,
        117,
        110,
        100,
        72,
        97,
        110,
        100,
        108,
        101,
        114,
        0
        // name: 'SoundHandler'
      ]);
      _MP4.HDLR_TYPES = {
        video: videoHdlr,
        audio: audioHdlr
      };
      const dref = new Uint8Array([
        0,
        // version 0
        0,
        0,
        0,
        // flags
        0,
        0,
        0,
        1,
        // entry_count
        0,
        0,
        0,
        12,
        // entry_size
        117,
        114,
        108,
        32,
        // 'url' type
        0,
        // version 0
        0,
        0,
        1
        // entry_flags
      ]);
      const stco = new Uint8Array([
        0,
        // version
        0,
        0,
        0,
        // flags
        0,
        0,
        0,
        0
        // entry_count
      ]);
      _MP4.STTS = _MP4.STSC = _MP4.STCO = stco;
      _MP4.STSZ = new Uint8Array([
        0,
        // version
        0,
        0,
        0,
        // flags
        0,
        0,
        0,
        0,
        // sample_size
        0,
        0,
        0,
        0
        // sample_count
      ]);
      _MP4.VMHD = new Uint8Array([
        0,
        // version
        0,
        0,
        1,
        // flags
        0,
        0,
        // graphicsmode
        0,
        0,
        0,
        0,
        0,
        0
        // opcolor
      ]);
      _MP4.SMHD = new Uint8Array([
        0,
        // version
        0,
        0,
        0,
        // flags
        0,
        0,
        // balance
        0,
        0
        // reserved
      ]);
      _MP4.STSD = new Uint8Array([
        0,
        // version 0
        0,
        0,
        0,
        // flags
        0,
        0,
        0,
        1
      ]);
      const majorBrand = new Uint8Array([105, 115, 111, 109]);
      const avc1Brand = new Uint8Array([97, 118, 99, 49]);
      const minorVersion = new Uint8Array([0, 0, 0, 1]);
      _MP4.FTYP = _MP4.box(_MP4.types.ftyp, majorBrand, minorVersion, majorBrand, avc1Brand);
      _MP4.DINF = _MP4.box(_MP4.types.dinf, _MP4.box(_MP4.types.dref, dref));
    }
    static box(type, ...payload) {
      let size = 8;
      let i = payload.length;
      const len = i;
      while (i--) {
        size += payload[i].byteLength;
      }
      const result = new Uint8Array(size);
      result[0] = size >> 24 & 255;
      result[1] = size >> 16 & 255;
      result[2] = size >> 8 & 255;
      result[3] = size & 255;
      result.set(type, 4);
      for (i = 0, size = 8; i < len; i++) {
        result.set(payload[i], size);
        size += payload[i].byteLength;
      }
      return result;
    }
    static hdlr(type) {
      return _MP4.box(_MP4.types.hdlr, _MP4.HDLR_TYPES[type]);
    }
    static mdat(data) {
      return _MP4.box(_MP4.types.mdat, data);
    }
    static mdhd(timescale, duration) {
      duration *= timescale;
      const upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));
      const lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));
      return _MP4.box(_MP4.types.mdhd, new Uint8Array([
        1,
        // version 1
        0,
        0,
        0,
        // flags
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        2,
        // creation_time
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        3,
        // modification_time
        timescale >> 24 & 255,
        timescale >> 16 & 255,
        timescale >> 8 & 255,
        timescale & 255,
        // timescale
        upperWordDuration >> 24,
        upperWordDuration >> 16 & 255,
        upperWordDuration >> 8 & 255,
        upperWordDuration & 255,
        lowerWordDuration >> 24,
        lowerWordDuration >> 16 & 255,
        lowerWordDuration >> 8 & 255,
        lowerWordDuration & 255,
        85,
        196,
        // 'und' language (undetermined)
        0,
        0
      ]));
    }
    static mdia(track) {
      return _MP4.box(_MP4.types.mdia, _MP4.mdhd(track.timescale || 0, track.duration || 0), _MP4.hdlr(track.type), _MP4.minf(track));
    }
    static mfhd(sequenceNumber) {
      return _MP4.box(_MP4.types.mfhd, new Uint8Array([
        0,
        0,
        0,
        0,
        // flags
        sequenceNumber >> 24,
        sequenceNumber >> 16 & 255,
        sequenceNumber >> 8 & 255,
        sequenceNumber & 255
        // sequence_number
      ]));
    }
    static minf(track) {
      if (track.type === "audio") {
        return _MP4.box(_MP4.types.minf, _MP4.box(_MP4.types.smhd, _MP4.SMHD), _MP4.DINF, _MP4.stbl(track));
      } else {
        return _MP4.box(_MP4.types.minf, _MP4.box(_MP4.types.vmhd, _MP4.VMHD), _MP4.DINF, _MP4.stbl(track));
      }
    }
    static moof(sn, baseMediaDecodeTime, track) {
      return _MP4.box(_MP4.types.moof, _MP4.mfhd(sn), _MP4.traf(track, baseMediaDecodeTime));
    }
    static moov(tracks) {
      let i = tracks.length;
      const boxes = [];
      while (i--) {
        boxes[i] = _MP4.trak(tracks[i]);
      }
      return _MP4.box.apply(null, [_MP4.types.moov, _MP4.mvhd(tracks[0].timescale || 0, tracks[0].duration || 0)].concat(boxes).concat(_MP4.mvex(tracks)));
    }
    static mvex(tracks) {
      let i = tracks.length;
      const boxes = [];
      while (i--) {
        boxes[i] = _MP4.trex(tracks[i]);
      }
      return _MP4.box.apply(null, [_MP4.types.mvex, ...boxes]);
    }
    static mvhd(timescale, duration) {
      duration *= timescale;
      const upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));
      const lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));
      const bytes = new Uint8Array([
        1,
        // version 1
        0,
        0,
        0,
        // flags
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        2,
        // creation_time
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        3,
        // modification_time
        timescale >> 24 & 255,
        timescale >> 16 & 255,
        timescale >> 8 & 255,
        timescale & 255,
        // timescale
        upperWordDuration >> 24,
        upperWordDuration >> 16 & 255,
        upperWordDuration >> 8 & 255,
        upperWordDuration & 255,
        lowerWordDuration >> 24,
        lowerWordDuration >> 16 & 255,
        lowerWordDuration >> 8 & 255,
        lowerWordDuration & 255,
        0,
        1,
        0,
        0,
        // 1.0 rate
        1,
        0,
        // 1.0 volume
        0,
        0,
        // reserved
        0,
        0,
        0,
        0,
        // reserved
        0,
        0,
        0,
        0,
        // reserved
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        64,
        0,
        0,
        0,
        // transformation: unity matrix
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        // pre_defined
        255,
        255,
        255,
        255
        // next_track_ID
      ]);
      return _MP4.box(_MP4.types.mvhd, bytes);
    }
    static sdtp(track) {
      const samples = track.samples || [];
      const bytes = new Uint8Array(4 + samples.length);
      let i;
      let flags;
      for (i = 0; i < samples.length; i++) {
        flags = samples[i].flags;
        bytes[i + 4] = flags.dependsOn << 4 | flags.isDependedOn << 2 | flags.hasRedundancy;
      }
      return _MP4.box(_MP4.types.sdtp, bytes);
    }
    static stbl(track) {
      return _MP4.box(_MP4.types.stbl, _MP4.stsd(track), _MP4.box(_MP4.types.stts, _MP4.STTS), _MP4.box(_MP4.types.stsc, _MP4.STSC), _MP4.box(_MP4.types.stsz, _MP4.STSZ), _MP4.box(_MP4.types.stco, _MP4.STCO));
    }
    static avc1(track) {
      let sps = [];
      let pps = [];
      let i;
      let data;
      let len;
      for (i = 0; i < track.sps.length; i++) {
        data = track.sps[i];
        len = data.byteLength;
        sps.push(len >>> 8 & 255);
        sps.push(len & 255);
        sps = sps.concat(Array.prototype.slice.call(data));
      }
      for (i = 0; i < track.pps.length; i++) {
        data = track.pps[i];
        len = data.byteLength;
        pps.push(len >>> 8 & 255);
        pps.push(len & 255);
        pps = pps.concat(Array.prototype.slice.call(data));
      }
      const avcc = _MP4.box(_MP4.types.avcC, new Uint8Array([
        1,
        // version
        sps[3],
        // profile
        sps[4],
        // profile compat
        sps[5],
        // level
        252 | 3,
        // lengthSizeMinusOne, hard-coded to 4 bytes
        224 | track.sps.length
        // 3bit reserved (111) + numOfSequenceParameterSets
      ].concat(sps).concat([
        track.pps.length
        // numOfPictureParameterSets
      ]).concat(pps)));
      const width = track.width;
      const height = track.height;
      const hSpacing = track.pixelRatio[0];
      const vSpacing = track.pixelRatio[1];
      return _MP4.box(
        _MP4.types.avc1,
        new Uint8Array([
          0,
          0,
          0,
          // reserved
          0,
          0,
          0,
          // reserved
          0,
          1,
          // data_reference_index
          0,
          0,
          // pre_defined
          0,
          0,
          // reserved
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          // pre_defined
          width >> 8 & 255,
          width & 255,
          // width
          height >> 8 & 255,
          height & 255,
          // height
          0,
          72,
          0,
          0,
          // horizresolution
          0,
          72,
          0,
          0,
          // vertresolution
          0,
          0,
          0,
          0,
          // reserved
          0,
          1,
          // frame_count
          18,
          100,
          97,
          105,
          108,
          // dailymotion/hls.js
          121,
          109,
          111,
          116,
          105,
          111,
          110,
          47,
          104,
          108,
          115,
          46,
          106,
          115,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          // compressorname
          0,
          24,
          // depth = 24
          17,
          17
        ]),
        // pre_defined = -1
        avcc,
        _MP4.box(_MP4.types.btrt, new Uint8Array([
          0,
          28,
          156,
          128,
          // bufferSizeDB
          0,
          45,
          198,
          192,
          // maxBitrate
          0,
          45,
          198,
          192
        ])),
        // avgBitrate
        _MP4.box(_MP4.types.pasp, new Uint8Array([
          hSpacing >> 24,
          // hSpacing
          hSpacing >> 16 & 255,
          hSpacing >> 8 & 255,
          hSpacing & 255,
          vSpacing >> 24,
          // vSpacing
          vSpacing >> 16 & 255,
          vSpacing >> 8 & 255,
          vSpacing & 255
        ]))
      );
    }
    static esds(track) {
      const config3 = track.config;
      return new Uint8Array([
        0,
        // version 0
        0,
        0,
        0,
        // flags
        3,
        // descriptor_type
        25,
        // length
        0,
        1,
        // es_id
        0,
        // stream_priority
        4,
        // descriptor_type
        17,
        // length
        64,
        // codec : mpeg4_audio
        21,
        // stream_type
        0,
        0,
        0,
        // buffer_size
        0,
        0,
        0,
        0,
        // maxBitrate
        0,
        0,
        0,
        0,
        // avgBitrate
        5,
        // descriptor_type
        2,
        // length
        ...config3,
        6,
        1,
        2
        // GASpecificConfig)); // length + audio config descriptor
      ]);
    }
    static audioStsd(track) {
      const samplerate = track.samplerate || 0;
      return new Uint8Array([
        0,
        0,
        0,
        // reserved
        0,
        0,
        0,
        // reserved
        0,
        1,
        // data_reference_index
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        // reserved
        0,
        track.channelCount || 0,
        // channelcount
        0,
        16,
        // sampleSize:16bits
        0,
        0,
        0,
        0,
        // reserved2
        samplerate >> 8 & 255,
        samplerate & 255,
        //
        0,
        0
      ]);
    }
    static mp4a(track) {
      return _MP4.box(_MP4.types.mp4a, _MP4.audioStsd(track), _MP4.box(_MP4.types.esds, _MP4.esds(track)));
    }
    static mp3(track) {
      return _MP4.box(_MP4.types[".mp3"], _MP4.audioStsd(track));
    }
    static ac3(track) {
      return _MP4.box(_MP4.types["ac-3"], _MP4.audioStsd(track), _MP4.box(_MP4.types.dac3, track.config));
    }
    static stsd(track) {
      const {
        segmentCodec
      } = track;
      if (track.type === "audio") {
        if (segmentCodec === "aac") {
          return _MP4.box(_MP4.types.stsd, _MP4.STSD, _MP4.mp4a(track));
        }
        if (segmentCodec === "ac3" && track.config) {
          return _MP4.box(_MP4.types.stsd, _MP4.STSD, _MP4.ac3(track));
        }
        if (segmentCodec === "mp3" && track.codec === "mp3") {
          return _MP4.box(_MP4.types.stsd, _MP4.STSD, _MP4.mp3(track));
        }
      } else {
        if (track.pps && track.sps) {
          if (segmentCodec === "avc") {
            return _MP4.box(_MP4.types.stsd, _MP4.STSD, _MP4.avc1(track));
          }
          if (segmentCodec === "hevc" && track.vps) {
            return _MP4.box(_MP4.types.stsd, _MP4.STSD, _MP4.hvc1(track));
          }
        } else {
          throw new Error(`video track missing pps or sps`);
        }
      }
      throw new Error(`unsupported ${track.type} segment codec (${segmentCodec}/${track.codec})`);
    }
    static tkhd(track) {
      const id3 = track.id;
      const duration = (track.duration || 0) * (track.timescale || 0);
      const width = track.width || 0;
      const height = track.height || 0;
      const upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));
      const lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));
      return _MP4.box(_MP4.types.tkhd, new Uint8Array([
        1,
        // version 1
        0,
        0,
        7,
        // flags
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        2,
        // creation_time
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        3,
        // modification_time
        id3 >> 24 & 255,
        id3 >> 16 & 255,
        id3 >> 8 & 255,
        id3 & 255,
        // track_ID
        0,
        0,
        0,
        0,
        // reserved
        upperWordDuration >> 24,
        upperWordDuration >> 16 & 255,
        upperWordDuration >> 8 & 255,
        upperWordDuration & 255,
        lowerWordDuration >> 24,
        lowerWordDuration >> 16 & 255,
        lowerWordDuration >> 8 & 255,
        lowerWordDuration & 255,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        // reserved
        0,
        0,
        // layer
        0,
        0,
        // alternate_group
        0,
        0,
        // non-audio track volume
        0,
        0,
        // reserved
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        64,
        0,
        0,
        0,
        // transformation: unity matrix
        width >> 8 & 255,
        width & 255,
        0,
        0,
        // width
        height >> 8 & 255,
        height & 255,
        0,
        0
        // height
      ]));
    }
    static traf(track, baseMediaDecodeTime) {
      const sampleDependencyTable = _MP4.sdtp(track);
      const id3 = track.id;
      const upperWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime / (UINT32_MAX + 1));
      const lowerWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime % (UINT32_MAX + 1));
      return _MP4.box(
        _MP4.types.traf,
        _MP4.box(_MP4.types.tfhd, new Uint8Array([
          0,
          // version 0
          0,
          0,
          0,
          // flags
          id3 >> 24,
          id3 >> 16 & 255,
          id3 >> 8 & 255,
          id3 & 255
          // track_ID
        ])),
        _MP4.box(_MP4.types.tfdt, new Uint8Array([
          1,
          // version 1
          0,
          0,
          0,
          // flags
          upperWordBaseMediaDecodeTime >> 24,
          upperWordBaseMediaDecodeTime >> 16 & 255,
          upperWordBaseMediaDecodeTime >> 8 & 255,
          upperWordBaseMediaDecodeTime & 255,
          lowerWordBaseMediaDecodeTime >> 24,
          lowerWordBaseMediaDecodeTime >> 16 & 255,
          lowerWordBaseMediaDecodeTime >> 8 & 255,
          lowerWordBaseMediaDecodeTime & 255
        ])),
        _MP4.trun(track, sampleDependencyTable.length + 16 + // tfhd
        20 + // tfdt
        8 + // traf header
        16 + // mfhd
        8 + // moof header
        8),
        // mdat header
        sampleDependencyTable
      );
    }
    /**
     * Generate a track box.
     * @param track a track definition
     */
    static trak(track) {
      track.duration = track.duration || 4294967295;
      return _MP4.box(_MP4.types.trak, _MP4.tkhd(track), _MP4.mdia(track));
    }
    static trex(track) {
      const id3 = track.id;
      return _MP4.box(_MP4.types.trex, new Uint8Array([
        0,
        // version 0
        0,
        0,
        0,
        // flags
        id3 >> 24,
        id3 >> 16 & 255,
        id3 >> 8 & 255,
        id3 & 255,
        // track_ID
        0,
        0,
        0,
        1,
        // default_sample_description_index
        0,
        0,
        0,
        0,
        // default_sample_duration
        0,
        0,
        0,
        0,
        // default_sample_size
        0,
        1,
        0,
        1
        // default_sample_flags
      ]));
    }
    static trun(track, offset) {
      const samples = track.samples || [];
      const len = samples.length;
      const arraylen = 12 + 16 * len;
      const array = new Uint8Array(arraylen);
      let i;
      let sample;
      let duration;
      let size;
      let flags;
      let cts;
      offset += 8 + arraylen;
      array.set([
        track.type === "video" ? 1 : 0,
        // version 1 for video with signed-int sample_composition_time_offset
        0,
        15,
        1,
        // flags
        len >>> 24 & 255,
        len >>> 16 & 255,
        len >>> 8 & 255,
        len & 255,
        // sample_count
        offset >>> 24 & 255,
        offset >>> 16 & 255,
        offset >>> 8 & 255,
        offset & 255
        // data_offset
      ], 0);
      for (i = 0; i < len; i++) {
        sample = samples[i];
        duration = sample.duration;
        size = sample.size;
        flags = sample.flags;
        cts = sample.cts;
        array.set([
          duration >>> 24 & 255,
          duration >>> 16 & 255,
          duration >>> 8 & 255,
          duration & 255,
          // sample_duration
          size >>> 24 & 255,
          size >>> 16 & 255,
          size >>> 8 & 255,
          size & 255,
          // sample_size
          flags.isLeading << 2 | flags.dependsOn,
          flags.isDependedOn << 6 | flags.hasRedundancy << 4 | flags.paddingValue << 1 | flags.isNonSync,
          flags.degradPrio & 240 << 8,
          flags.degradPrio & 15,
          // sample_flags
          cts >>> 24 & 255,
          cts >>> 16 & 255,
          cts >>> 8 & 255,
          cts & 255
          // sample_composition_time_offset
        ], 12 + 16 * i);
      }
      return _MP4.box(_MP4.types.trun, array);
    }
    static initSegment(tracks) {
      if (!_MP4.types) {
        _MP4.init();
      }
      const movie = _MP4.moov(tracks);
      const result = appendUint8Array(_MP4.FTYP, movie);
      return result;
    }
    static hvc1(track) {
      const ps = track.params;
      const units = [track.vps, track.sps, track.pps];
      const NALuLengthSize = 4;
      const config3 = new Uint8Array([1, ps.general_profile_space << 6 | (ps.general_tier_flag ? 32 : 0) | ps.general_profile_idc, ps.general_profile_compatibility_flags[0], ps.general_profile_compatibility_flags[1], ps.general_profile_compatibility_flags[2], ps.general_profile_compatibility_flags[3], ps.general_constraint_indicator_flags[0], ps.general_constraint_indicator_flags[1], ps.general_constraint_indicator_flags[2], ps.general_constraint_indicator_flags[3], ps.general_constraint_indicator_flags[4], ps.general_constraint_indicator_flags[5], ps.general_level_idc, 240 | ps.min_spatial_segmentation_idc >> 8, 255 & ps.min_spatial_segmentation_idc, 252 | ps.parallelismType, 252 | ps.chroma_format_idc, 248 | ps.bit_depth_luma_minus8, 248 | ps.bit_depth_chroma_minus8, 0, parseInt(ps.frame_rate.fps), NALuLengthSize - 1 | ps.temporal_id_nested << 2 | ps.num_temporal_layers << 3 | (ps.frame_rate.fixed ? 64 : 0), units.length]);
      let length = config3.length;
      for (let i = 0; i < units.length; i += 1) {
        length += 3;
        for (let j = 0; j < units[i].length; j += 1) {
          length += 2 + units[i][j].length;
        }
      }
      const hvcC = new Uint8Array(length);
      hvcC.set(config3, 0);
      length = config3.length;
      const iMax = units.length - 1;
      for (let i = 0; i < units.length; i += 1) {
        hvcC.set(new Uint8Array([32 + i | (i === iMax ? 128 : 0), 0, units[i].length]), length);
        length += 3;
        for (let j = 0; j < units[i].length; j += 1) {
          hvcC.set(new Uint8Array([units[i][j].length >> 8, units[i][j].length & 255]), length);
          length += 2;
          hvcC.set(units[i][j], length);
          length += units[i][j].length;
        }
      }
      const hvcc = _MP4.box(_MP4.types.hvcC, hvcC);
      const width = track.width;
      const height = track.height;
      const hSpacing = track.pixelRatio[0];
      const vSpacing = track.pixelRatio[1];
      return _MP4.box(
        _MP4.types.hvc1,
        new Uint8Array([
          0,
          0,
          0,
          // reserved
          0,
          0,
          0,
          // reserved
          0,
          1,
          // data_reference_index
          0,
          0,
          // pre_defined
          0,
          0,
          // reserved
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          // pre_defined
          width >> 8 & 255,
          width & 255,
          // width
          height >> 8 & 255,
          height & 255,
          // height
          0,
          72,
          0,
          0,
          // horizresolution
          0,
          72,
          0,
          0,
          // vertresolution
          0,
          0,
          0,
          0,
          // reserved
          0,
          1,
          // frame_count
          18,
          100,
          97,
          105,
          108,
          // dailymotion/hls.js
          121,
          109,
          111,
          116,
          105,
          111,
          110,
          47,
          104,
          108,
          115,
          46,
          106,
          115,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          // compressorname
          0,
          24,
          // depth = 24
          17,
          17
        ]),
        // pre_defined = -1
        hvcc,
        _MP4.box(_MP4.types.btrt, new Uint8Array([
          0,
          28,
          156,
          128,
          // bufferSizeDB
          0,
          45,
          198,
          192,
          // maxBitrate
          0,
          45,
          198,
          192
        ])),
        // avgBitrate
        _MP4.box(_MP4.types.pasp, new Uint8Array([
          hSpacing >> 24,
          // hSpacing
          hSpacing >> 16 & 255,
          hSpacing >> 8 & 255,
          hSpacing & 255,
          vSpacing >> 24,
          // vSpacing
          vSpacing >> 16 & 255,
          vSpacing >> 8 & 255,
          vSpacing & 255
        ]))
      );
    }
  };
  MP4.types = void 0;
  MP4.HDLR_TYPES = void 0;
  MP4.STTS = void 0;
  MP4.STSC = void 0;
  MP4.STCO = void 0;
  MP4.STSZ = void 0;
  MP4.VMHD = void 0;
  MP4.SMHD = void 0;
  MP4.STSD = void 0;
  MP4.FTYP = void 0;
  MP4.DINF = void 0;
  var MPEG_TS_CLOCK_FREQ_HZ = 9e4;
  function toTimescaleFromBase(baseTime, destScale, srcBase = 1, round = false) {
    const result = baseTime * destScale * srcBase;
    return round ? Math.round(result) : result;
  }
  function toTimescaleFromScale(baseTime, destScale, srcScale = 1, round = false) {
    return toTimescaleFromBase(baseTime, destScale, 1 / srcScale, round);
  }
  function toMsFromMpegTsClock(baseTime, round = false) {
    return toTimescaleFromBase(baseTime, 1e3, 1 / MPEG_TS_CLOCK_FREQ_HZ, round);
  }
  function toMpegTsClockFromTimescale(baseTime, srcScale = 1) {
    return toTimescaleFromBase(baseTime, MPEG_TS_CLOCK_FREQ_HZ, 1 / srcScale);
  }
  function timestampToString(timestamp) {
    const {
      baseTime,
      timescale,
      trackId
    } = timestamp;
    return `${baseTime / timescale} (${baseTime}/${timescale}) trackId: ${trackId}`;
  }
  var MAX_SILENT_FRAME_DURATION = 10 * 1e3;
  var AAC_SAMPLES_PER_FRAME = 1024;
  var MPEG_AUDIO_SAMPLE_PER_FRAME = 1152;
  var AC3_SAMPLES_PER_FRAME = 1536;
  var chromeVersion = null;
  var safariWebkitVersion = null;
  function createMp4Sample(isKeyframe, duration, size, cts) {
    return {
      duration,
      size,
      cts,
      flags: {
        isLeading: 0,
        isDependedOn: 0,
        hasRedundancy: 0,
        degradPrio: 0,
        dependsOn: isKeyframe ? 2 : 1,
        isNonSync: isKeyframe ? 0 : 1
      }
    };
  }
  var MP4Remuxer = class extends Logger {
    constructor(observer2, config3, typeSupported, logger2) {
      super("mp4-remuxer", logger2);
      this.observer = void 0;
      this.config = void 0;
      this.typeSupported = void 0;
      this.ISGenerated = false;
      this._initPTS = null;
      this._initDTS = null;
      this.nextVideoTs = null;
      this.nextAudioTs = null;
      this.videoSampleDuration = null;
      this.isAudioContiguous = false;
      this.isVideoContiguous = false;
      this.videoTrackConfig = void 0;
      this.observer = observer2;
      this.config = config3;
      this.typeSupported = typeSupported;
      this.ISGenerated = false;
      if (chromeVersion === null) {
        const userAgent = navigator.userAgent || "";
        const result = userAgent.match(/Chrome\/(\d+)/i);
        chromeVersion = result ? parseInt(result[1]) : 0;
      }
      if (safariWebkitVersion === null) {
        const result = navigator.userAgent.match(/Safari\/(\d+)/i);
        safariWebkitVersion = result ? parseInt(result[1]) : 0;
      }
    }
    destroy() {
      this.config = this.videoTrackConfig = this._initPTS = this._initDTS = null;
    }
    resetTimeStamp(defaultTimeStamp) {
      const initPTS = this._initPTS;
      if (!initPTS || !defaultTimeStamp || defaultTimeStamp.trackId !== initPTS.trackId || defaultTimeStamp.baseTime !== initPTS.baseTime || defaultTimeStamp.timescale !== initPTS.timescale) {
        this.log(`Reset initPTS: ${initPTS ? timestampToString(initPTS) : initPTS} > ${defaultTimeStamp ? timestampToString(defaultTimeStamp) : defaultTimeStamp}`);
      }
      this._initPTS = this._initDTS = defaultTimeStamp;
    }
    resetNextTimestamp() {
      this.log("reset next timestamp");
      this.isVideoContiguous = false;
      this.isAudioContiguous = false;
    }
    resetInitSegment() {
      this.log("ISGenerated flag reset");
      this.ISGenerated = false;
      this.videoTrackConfig = void 0;
    }
    getVideoStartPts(videoSamples) {
      let rolloverDetected = false;
      const firstPts = videoSamples[0].pts;
      const startPTS = videoSamples.reduce((minPTS, sample) => {
        let pts = sample.pts;
        let delta = pts - minPTS;
        if (delta < -4294967296) {
          rolloverDetected = true;
          pts = normalizePts(pts, firstPts);
          delta = pts - minPTS;
        }
        if (delta > 0) {
          return minPTS;
        }
        return pts;
      }, firstPts);
      if (rolloverDetected) {
        this.debug("PTS rollover detected");
      }
      return startPTS;
    }
    remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, flush, playlistType) {
      let video;
      let audio;
      let initSegment;
      let text;
      let id3;
      let independent;
      let audioTimeOffset = timeOffset;
      let videoTimeOffset = timeOffset;
      const hasAudio = audioTrack.pid > -1;
      const hasVideo = videoTrack.pid > -1;
      const length = videoTrack.samples.length;
      const enoughAudioSamples = audioTrack.samples.length > 0;
      const enoughVideoSamples = flush && length > 0 || length > 1;
      const canRemuxAvc = (!hasAudio || enoughAudioSamples) && (!hasVideo || enoughVideoSamples) || this.ISGenerated || flush;
      if (canRemuxAvc) {
        if (this.ISGenerated) {
          var _videoTrack$pixelRati, _config$pixelRatio, _videoTrack$pixelRati2, _config$pixelRatio2;
          const config3 = this.videoTrackConfig;
          if (config3 && (videoTrack.width !== config3.width || videoTrack.height !== config3.height || ((_videoTrack$pixelRati = videoTrack.pixelRatio) == null ? void 0 : _videoTrack$pixelRati[0]) !== ((_config$pixelRatio = config3.pixelRatio) == null ? void 0 : _config$pixelRatio[0]) || ((_videoTrack$pixelRati2 = videoTrack.pixelRatio) == null ? void 0 : _videoTrack$pixelRati2[1]) !== ((_config$pixelRatio2 = config3.pixelRatio) == null ? void 0 : _config$pixelRatio2[1])) || !config3 && enoughVideoSamples || this.nextAudioTs === null && enoughAudioSamples) {
            this.resetInitSegment();
          }
        }
        if (!this.ISGenerated) {
          initSegment = this.generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset);
        }
        const isVideoContiguous = this.isVideoContiguous;
        let firstKeyFrameIndex = -1;
        let firstKeyFramePTS;
        if (enoughVideoSamples) {
          firstKeyFrameIndex = findKeyframeIndex(videoTrack.samples);
          if (!isVideoContiguous && this.config.forceKeyFrameOnDiscontinuity) {
            independent = true;
            if (firstKeyFrameIndex > 0) {
              this.warn(`Dropped ${firstKeyFrameIndex} out of ${length} video samples due to a missing keyframe`);
              const startPTS = this.getVideoStartPts(videoTrack.samples);
              videoTrack.samples = videoTrack.samples.slice(firstKeyFrameIndex);
              videoTrack.dropped += firstKeyFrameIndex;
              videoTimeOffset += (videoTrack.samples[0].pts - startPTS) / videoTrack.inputTimeScale;
              firstKeyFramePTS = videoTimeOffset;
            } else if (firstKeyFrameIndex === -1) {
              this.warn(`No keyframe found out of ${length} video samples`);
              independent = false;
            }
          }
        }
        if (this.ISGenerated) {
          if (enoughAudioSamples && enoughVideoSamples) {
            const startPTS = this.getVideoStartPts(videoTrack.samples);
            const tsDelta = normalizePts(audioTrack.samples[0].pts, startPTS) - startPTS;
            const audiovideoTimestampDelta = tsDelta / videoTrack.inputTimeScale;
            audioTimeOffset += Math.max(0, audiovideoTimestampDelta);
            videoTimeOffset += Math.max(0, -audiovideoTimestampDelta);
          }
          if (enoughAudioSamples) {
            if (!audioTrack.samplerate) {
              this.warn("regenerate InitSegment as audio detected");
              initSegment = this.generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset);
            }
            audio = this.remuxAudio(audioTrack, audioTimeOffset, this.isAudioContiguous, accurateTimeOffset, hasVideo || enoughVideoSamples || playlistType === PlaylistLevelType.AUDIO ? videoTimeOffset : void 0);
            if (enoughVideoSamples) {
              const audioTrackLength = audio ? audio.endPTS - audio.startPTS : 0;
              if (!videoTrack.inputTimeScale) {
                this.warn("regenerate InitSegment as video detected");
                initSegment = this.generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset);
              }
              video = this.remuxVideo(videoTrack, videoTimeOffset, isVideoContiguous, audioTrackLength);
            }
          } else if (enoughVideoSamples) {
            video = this.remuxVideo(videoTrack, videoTimeOffset, isVideoContiguous, 0);
          }
          if (video) {
            video.firstKeyFrame = firstKeyFrameIndex;
            video.independent = firstKeyFrameIndex !== -1;
            video.firstKeyFramePTS = firstKeyFramePTS;
          }
        }
      }
      if (this.ISGenerated && this._initPTS && this._initDTS) {
        if (id3Track.samples.length) {
          id3 = flushTextTrackMetadataCueSamples(id3Track, timeOffset, this._initPTS, this._initDTS);
        }
        if (textTrack.samples.length) {
          text = flushTextTrackUserdataCueSamples(textTrack, timeOffset, this._initPTS);
        }
      }
      return {
        audio,
        video,
        initSegment,
        independent,
        text,
        id3
      };
    }
    computeInitPts(basetime, timescale, presentationTime, type) {
      const offset = Math.round(presentationTime * timescale);
      let timestamp = normalizePts(basetime, offset);
      if (timestamp < offset + timescale) {
        this.log(`Adjusting PTS for rollover in timeline near ${(offset - timestamp) / timescale} ${type}`);
        while (timestamp < offset + timescale) {
          timestamp += 8589934592;
        }
      }
      return timestamp - offset;
    }
    generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset) {
      const audioSamples = audioTrack.samples;
      const videoSamples = videoTrack.samples;
      const typeSupported = this.typeSupported;
      const tracks = {};
      const _initPTS = this._initPTS;
      let computePTSDTS = !_initPTS || accurateTimeOffset;
      let container2 = "audio/mp4";
      let initPTS;
      let initDTS;
      let timescale;
      let trackId = -1;
      if (computePTSDTS) {
        initPTS = initDTS = Infinity;
      }
      if (audioTrack.config && audioSamples.length) {
        audioTrack.timescale = audioTrack.samplerate;
        switch (audioTrack.segmentCodec) {
          case "mp3":
            if (typeSupported.mpeg) {
              container2 = "audio/mpeg";
              audioTrack.codec = "";
            } else if (typeSupported.mp3) {
              audioTrack.codec = "mp3";
            }
            break;
          case "ac3":
            audioTrack.codec = "ac-3";
            break;
        }
        tracks.audio = {
          id: "audio",
          container: container2,
          codec: audioTrack.codec,
          initSegment: audioTrack.segmentCodec === "mp3" && typeSupported.mpeg ? new Uint8Array(0) : MP4.initSegment([audioTrack]),
          metadata: {
            channelCount: audioTrack.channelCount
          }
        };
        if (computePTSDTS) {
          trackId = audioTrack.id;
          timescale = audioTrack.inputTimeScale;
          if (!_initPTS || timescale !== _initPTS.timescale) {
            initPTS = initDTS = this.computeInitPts(audioSamples[0].pts, timescale, timeOffset, "audio");
          } else {
            computePTSDTS = false;
          }
        }
      }
      if (videoTrack.sps && videoTrack.pps && videoSamples.length) {
        videoTrack.timescale = videoTrack.inputTimeScale;
        tracks.video = {
          id: "main",
          container: "video/mp4",
          codec: videoTrack.codec,
          initSegment: MP4.initSegment([videoTrack]),
          metadata: {
            width: videoTrack.width,
            height: videoTrack.height
          }
        };
        if (computePTSDTS) {
          trackId = videoTrack.id;
          timescale = videoTrack.inputTimeScale;
          if (!_initPTS || timescale !== _initPTS.timescale) {
            const basePTS = this.getVideoStartPts(videoSamples);
            const baseDTS = normalizePts(videoSamples[0].dts, basePTS);
            const videoInitDTS = this.computeInitPts(baseDTS, timescale, timeOffset, "video");
            const videoInitPTS = this.computeInitPts(basePTS, timescale, timeOffset, "video");
            initDTS = Math.min(initDTS, videoInitDTS);
            initPTS = Math.min(initPTS, videoInitPTS);
          } else {
            computePTSDTS = false;
          }
        }
        this.videoTrackConfig = {
          width: videoTrack.width,
          height: videoTrack.height,
          pixelRatio: videoTrack.pixelRatio
        };
      }
      if (Object.keys(tracks).length) {
        this.ISGenerated = true;
        if (computePTSDTS) {
          if (_initPTS) {
            this.warn(`Timestamps at playlist time: ${accurateTimeOffset ? "" : "~"}${timeOffset} ${initPTS / timescale} != initPTS: ${_initPTS.baseTime / _initPTS.timescale} (${_initPTS.baseTime}/${_initPTS.timescale}) trackId: ${_initPTS.trackId}`);
          }
          this.log(`Found initPTS at playlist time: ${timeOffset} offset: ${initPTS / timescale} (${initPTS}/${timescale}) trackId: ${trackId}`);
          this._initPTS = {
            baseTime: initPTS,
            timescale,
            trackId
          };
          this._initDTS = {
            baseTime: initDTS,
            timescale,
            trackId
          };
        } else {
          initPTS = timescale = void 0;
        }
        return {
          tracks,
          initPTS,
          timescale,
          trackId
        };
      }
    }
    remuxVideo(track, timeOffset, contiguous, audioTrackLength) {
      const timeScale = track.inputTimeScale;
      const inputSamples = track.samples;
      const outputSamples = [];
      const nbSamples = inputSamples.length;
      const initPTS = this._initPTS;
      const initTime = initPTS.baseTime * timeScale / initPTS.timescale;
      let nextVideoTs = this.nextVideoTs;
      let offset = 8;
      let mp4SampleDuration = this.videoSampleDuration;
      let firstDTS;
      let lastDTS;
      let minPTS = Number.POSITIVE_INFINITY;
      let maxPTS = Number.NEGATIVE_INFINITY;
      let sortSamples = false;
      if (!contiguous || nextVideoTs === null) {
        const pts = initTime + timeOffset * timeScale;
        const cts = inputSamples[0].pts - normalizePts(inputSamples[0].dts, inputSamples[0].pts);
        if (chromeVersion && nextVideoTs !== null && Math.abs(pts - cts - (nextVideoTs + initTime)) < 15e3) {
          contiguous = true;
        } else {
          nextVideoTs = pts - cts - initTime;
        }
      }
      const nextVideoPts = nextVideoTs + initTime;
      for (let i = 0; i < nbSamples; i++) {
        const sample = inputSamples[i];
        sample.pts = normalizePts(sample.pts, nextVideoPts);
        sample.dts = normalizePts(sample.dts, nextVideoPts);
        if (sample.dts < inputSamples[i > 0 ? i - 1 : i].dts) {
          sortSamples = true;
        }
      }
      if (sortSamples) {
        inputSamples.sort(function(a, b) {
          const deltadts = a.dts - b.dts;
          const deltapts = a.pts - b.pts;
          return deltadts || deltapts;
        });
      }
      firstDTS = inputSamples[0].dts;
      lastDTS = inputSamples[inputSamples.length - 1].dts;
      const inputDuration = lastDTS - firstDTS;
      const averageSampleDuration = inputDuration ? Math.round(inputDuration / (nbSamples - 1)) : mp4SampleDuration || track.inputTimeScale / 30;
      if (contiguous) {
        const delta = firstDTS - nextVideoPts;
        const foundHole = delta > averageSampleDuration;
        const foundOverlap = delta < -1;
        if (foundHole || foundOverlap) {
          if (foundHole) {
            this.warn(`${(track.segmentCodec || "").toUpperCase()}: ${toMsFromMpegTsClock(delta, true)} ms (${delta}dts) hole between fragments detected at ${timeOffset.toFixed(3)}`);
          } else {
            this.warn(`${(track.segmentCodec || "").toUpperCase()}: ${toMsFromMpegTsClock(-delta, true)} ms (${delta}dts) overlapping between fragments detected at ${timeOffset.toFixed(3)}`);
          }
          if (!foundOverlap || nextVideoPts >= inputSamples[0].pts || chromeVersion) {
            firstDTS = nextVideoPts;
            const firstPTS = inputSamples[0].pts - delta;
            if (foundHole) {
              inputSamples[0].dts = firstDTS;
              inputSamples[0].pts = firstPTS;
            } else {
              let isPTSOrderRetained = true;
              for (let i = 0; i < inputSamples.length; i++) {
                if (inputSamples[i].dts > firstPTS && isPTSOrderRetained) {
                  break;
                }
                const prevPTS = inputSamples[i].pts;
                inputSamples[i].dts -= delta;
                inputSamples[i].pts -= delta;
                if (i < inputSamples.length - 1) {
                  const nextSamplePTS = inputSamples[i + 1].pts;
                  const currentSamplePTS = inputSamples[i].pts;
                  const currentOrder = nextSamplePTS <= currentSamplePTS;
                  const prevOrder = nextSamplePTS <= prevPTS;
                  isPTSOrderRetained = currentOrder == prevOrder;
                }
              }
            }
            this.log(`Video: Initial PTS/DTS adjusted: ${toMsFromMpegTsClock(firstPTS, true)}/${toMsFromMpegTsClock(firstDTS, true)}, delta: ${toMsFromMpegTsClock(delta, true)} ms`);
          }
        }
      }
      firstDTS = Math.max(0, firstDTS);
      let nbNalu = 0;
      let naluLen = 0;
      let dtsStep = firstDTS;
      for (let i = 0; i < nbSamples; i++) {
        const sample = inputSamples[i];
        const units = sample.units;
        const nbUnits = units.length;
        let sampleLen = 0;
        for (let j = 0; j < nbUnits; j++) {
          sampleLen += units[j].data.length;
        }
        naluLen += sampleLen;
        nbNalu += nbUnits;
        sample.length = sampleLen;
        if (sample.dts < dtsStep) {
          sample.dts = dtsStep;
          dtsStep += averageSampleDuration / 4 | 0 || 1;
        } else {
          dtsStep = sample.dts;
        }
        minPTS = Math.min(sample.pts, minPTS);
        maxPTS = Math.max(sample.pts, maxPTS);
      }
      lastDTS = inputSamples[nbSamples - 1].dts;
      const mdatSize = naluLen + 4 * nbNalu + 8;
      let mdat;
      try {
        mdat = new Uint8Array(mdatSize);
      } catch (err) {
        this.observer.emit(Events.ERROR, Events.ERROR, {
          type: ErrorTypes.MUX_ERROR,
          details: ErrorDetails.REMUX_ALLOC_ERROR,
          fatal: false,
          error: err,
          bytes: mdatSize,
          reason: `fail allocating video mdat ${mdatSize}`
        });
        return;
      }
      const view2 = new DataView(mdat.buffer);
      view2.setUint32(0, mdatSize);
      mdat.set(MP4.types.mdat, 4);
      let stretchedLastFrame = false;
      let minDtsDelta = Number.POSITIVE_INFINITY;
      let minPtsDelta = Number.POSITIVE_INFINITY;
      let maxDtsDelta = Number.NEGATIVE_INFINITY;
      let maxPtsDelta = Number.NEGATIVE_INFINITY;
      for (let i = 0; i < nbSamples; i++) {
        const VideoSample = inputSamples[i];
        const VideoSampleUnits = VideoSample.units;
        let mp4SampleLength = 0;
        for (let j = 0, nbUnits = VideoSampleUnits.length; j < nbUnits; j++) {
          const unit = VideoSampleUnits[j];
          const unitData = unit.data;
          const unitDataLen = unit.data.byteLength;
          view2.setUint32(offset, unitDataLen);
          offset += 4;
          mdat.set(unitData, offset);
          offset += unitDataLen;
          mp4SampleLength += 4 + unitDataLen;
        }
        let ptsDelta;
        if (i < nbSamples - 1) {
          mp4SampleDuration = inputSamples[i + 1].dts - VideoSample.dts;
          ptsDelta = inputSamples[i + 1].pts - VideoSample.pts;
        } else {
          const config3 = this.config;
          const lastFrameDuration = i > 0 ? VideoSample.dts - inputSamples[i - 1].dts : averageSampleDuration;
          ptsDelta = i > 0 ? VideoSample.pts - inputSamples[i - 1].pts : averageSampleDuration;
          if (config3.stretchShortVideoTrack && this.nextAudioTs !== null) {
            const gapTolerance = Math.floor(config3.maxBufferHole * timeScale);
            const deltaToFrameEnd = (audioTrackLength ? minPTS + audioTrackLength * timeScale : this.nextAudioTs + initTime) - VideoSample.pts;
            if (deltaToFrameEnd > gapTolerance) {
              mp4SampleDuration = deltaToFrameEnd - lastFrameDuration;
              if (mp4SampleDuration < 0) {
                mp4SampleDuration = lastFrameDuration;
              } else {
                stretchedLastFrame = true;
              }
              this.log(`It is approximately ${deltaToFrameEnd / 90} ms to the next segment; using duration ${mp4SampleDuration / 90} ms for the last video frame.`);
            } else {
              mp4SampleDuration = lastFrameDuration;
            }
          } else {
            mp4SampleDuration = lastFrameDuration;
          }
        }
        const compositionTimeOffset = Math.round(VideoSample.pts - VideoSample.dts);
        minDtsDelta = Math.min(minDtsDelta, mp4SampleDuration);
        maxDtsDelta = Math.max(maxDtsDelta, mp4SampleDuration);
        minPtsDelta = Math.min(minPtsDelta, ptsDelta);
        maxPtsDelta = Math.max(maxPtsDelta, ptsDelta);
        outputSamples.push(createMp4Sample(VideoSample.key, mp4SampleDuration, mp4SampleLength, compositionTimeOffset));
      }
      if (outputSamples.length) {
        if (chromeVersion) {
          if (chromeVersion < 70) {
            const flags = outputSamples[0].flags;
            flags.dependsOn = 2;
            flags.isNonSync = 0;
          }
        } else if (safariWebkitVersion) {
          if (maxPtsDelta - minPtsDelta < maxDtsDelta - minDtsDelta && averageSampleDuration / maxDtsDelta < 0.025 && outputSamples[0].cts === 0) {
            this.warn("Found irregular gaps in sample duration. Using PTS instead of DTS to determine MP4 sample duration.");
            let dts = firstDTS;
            for (let i = 0, len = outputSamples.length; i < len; i++) {
              const nextDts = dts + outputSamples[i].duration;
              const pts = dts + outputSamples[i].cts;
              if (i < len - 1) {
                const nextPts = nextDts + outputSamples[i + 1].cts;
                outputSamples[i].duration = nextPts - pts;
              } else {
                outputSamples[i].duration = i ? outputSamples[i - 1].duration : averageSampleDuration;
              }
              outputSamples[i].cts = 0;
              dts = nextDts;
            }
          }
        }
      }
      mp4SampleDuration = stretchedLastFrame || !mp4SampleDuration ? averageSampleDuration : mp4SampleDuration;
      const endDTS = lastDTS + mp4SampleDuration;
      this.nextVideoTs = nextVideoTs = endDTS - initTime;
      this.videoSampleDuration = mp4SampleDuration;
      this.isVideoContiguous = true;
      const moof = MP4.moof(track.sequenceNumber++, firstDTS, _extends4(track, {
        samples: outputSamples
      }));
      const type = "video";
      const data = {
        data1: moof,
        data2: mdat,
        startPTS: (minPTS - initTime) / timeScale,
        endPTS: (maxPTS + mp4SampleDuration - initTime) / timeScale,
        startDTS: (firstDTS - initTime) / timeScale,
        endDTS: nextVideoTs / timeScale,
        type,
        hasAudio: false,
        hasVideo: true,
        nb: outputSamples.length,
        dropped: track.dropped
      };
      track.samples = [];
      track.dropped = 0;
      return data;
    }
    getSamplesPerFrame(track) {
      switch (track.segmentCodec) {
        case "mp3":
          return MPEG_AUDIO_SAMPLE_PER_FRAME;
        case "ac3":
          return AC3_SAMPLES_PER_FRAME;
        default:
          return AAC_SAMPLES_PER_FRAME;
      }
    }
    remuxAudio(track, timeOffset, contiguous, accurateTimeOffset, videoTimeOffset) {
      const inputTimeScale = track.inputTimeScale;
      const mp4timeScale = track.samplerate ? track.samplerate : inputTimeScale;
      const scaleFactor = inputTimeScale / mp4timeScale;
      const mp4SampleDuration = this.getSamplesPerFrame(track);
      const inputSampleDuration = mp4SampleDuration * scaleFactor;
      const initPTS = this._initPTS;
      const rawMPEG = track.segmentCodec === "mp3" && this.typeSupported.mpeg;
      const outputSamples = [];
      const alignedWithVideo = videoTimeOffset !== void 0;
      let inputSamples = track.samples;
      let offset = rawMPEG ? 0 : 8;
      let nextAudioTs = this.nextAudioTs || -1;
      const initTime = initPTS.baseTime * inputTimeScale / initPTS.timescale;
      const timeOffsetMpegTS = initTime + timeOffset * inputTimeScale;
      this.isAudioContiguous = contiguous = contiguous || inputSamples.length && nextAudioTs > 0 && (accurateTimeOffset && Math.abs(timeOffsetMpegTS - (nextAudioTs + initTime)) < 9e3 || Math.abs(normalizePts(inputSamples[0].pts, timeOffsetMpegTS) - (nextAudioTs + initTime)) < 20 * inputSampleDuration);
      inputSamples.forEach(function(sample) {
        sample.pts = normalizePts(sample.pts, timeOffsetMpegTS);
      });
      if (!contiguous || nextAudioTs < 0) {
        const sampleCount = inputSamples.length;
        inputSamples = inputSamples.filter((sample) => sample.pts >= 0);
        if (sampleCount !== inputSamples.length) {
          this.warn(`Removed ${inputSamples.length - sampleCount} of ${sampleCount} samples (initPTS ${initTime} / ${inputTimeScale})`);
        }
        if (!inputSamples.length) {
          return;
        }
        if (videoTimeOffset === 0) {
          nextAudioTs = 0;
        } else if (accurateTimeOffset && !alignedWithVideo) {
          nextAudioTs = Math.max(0, timeOffsetMpegTS - initTime);
        } else {
          nextAudioTs = inputSamples[0].pts - initTime;
        }
      }
      if (track.segmentCodec === "aac") {
        const maxAudioFramesDrift = this.config.maxAudioFramesDrift;
        for (let i = 0, nextPts = nextAudioTs + initTime; i < inputSamples.length; i++) {
          const sample = inputSamples[i];
          const pts = sample.pts;
          const delta = pts - nextPts;
          const duration = Math.abs(1e3 * delta / inputTimeScale);
          if (delta <= -maxAudioFramesDrift * inputSampleDuration && alignedWithVideo) {
            if (i === 0) {
              this.warn(`Audio frame @ ${(pts / inputTimeScale).toFixed(3)}s overlaps marker by ${Math.round(1e3 * delta / inputTimeScale)} ms.`);
              this.nextAudioTs = nextAudioTs = pts - initTime;
              nextPts = pts;
            }
          } else if (delta >= maxAudioFramesDrift * inputSampleDuration && duration < MAX_SILENT_FRAME_DURATION && alignedWithVideo) {
            let missing = Math.round(delta / inputSampleDuration);
            nextPts = pts - missing * inputSampleDuration;
            while (nextPts < 0 && missing && inputSampleDuration) {
              missing--;
              nextPts += inputSampleDuration;
            }
            if (i === 0) {
              this.nextAudioTs = nextAudioTs = nextPts - initTime;
            }
            this.warn(`Injecting ${missing} audio frames @ ${((nextPts - initTime) / inputTimeScale).toFixed(3)}s due to ${Math.round(1e3 * delta / inputTimeScale)} ms gap.`);
            for (let j = 0; j < missing; j++) {
              let fillFrame = AAC.getSilentFrame(track.parsedCodec || track.manifestCodec || track.codec, track.channelCount);
              if (!fillFrame) {
                this.log("Unable to get silent frame for given audio codec; duplicating last frame instead.");
                fillFrame = sample.unit.subarray();
              }
              inputSamples.splice(i, 0, {
                unit: fillFrame,
                pts: nextPts
              });
              nextPts += inputSampleDuration;
              i++;
            }
          }
          sample.pts = nextPts;
          nextPts += inputSampleDuration;
        }
      }
      let firstPTS = null;
      let lastPTS = null;
      let mdat;
      let mdatSize = 0;
      let sampleLength = inputSamples.length;
      while (sampleLength--) {
        mdatSize += inputSamples[sampleLength].unit.byteLength;
      }
      for (let j = 0, _nbSamples = inputSamples.length; j < _nbSamples; j++) {
        const audioSample = inputSamples[j];
        const unit = audioSample.unit;
        let pts = audioSample.pts;
        if (lastPTS !== null) {
          const prevSample = outputSamples[j - 1];
          prevSample.duration = Math.round((pts - lastPTS) / scaleFactor);
        } else {
          if (contiguous && track.segmentCodec === "aac") {
            pts = nextAudioTs + initTime;
          }
          firstPTS = pts;
          if (mdatSize > 0) {
            mdatSize += offset;
            try {
              mdat = new Uint8Array(mdatSize);
            } catch (err) {
              this.observer.emit(Events.ERROR, Events.ERROR, {
                type: ErrorTypes.MUX_ERROR,
                details: ErrorDetails.REMUX_ALLOC_ERROR,
                fatal: false,
                error: err,
                bytes: mdatSize,
                reason: `fail allocating audio mdat ${mdatSize}`
              });
              return;
            }
            if (!rawMPEG) {
              const view2 = new DataView(mdat.buffer);
              view2.setUint32(0, mdatSize);
              mdat.set(MP4.types.mdat, 4);
            }
          } else {
            return;
          }
        }
        mdat.set(unit, offset);
        const unitLen = unit.byteLength;
        offset += unitLen;
        outputSamples.push(createMp4Sample(true, mp4SampleDuration, unitLen, 0));
        lastPTS = pts;
      }
      const nbSamples = outputSamples.length;
      if (!nbSamples) {
        return;
      }
      const lastSample = outputSamples[outputSamples.length - 1];
      nextAudioTs = lastPTS - initTime;
      this.nextAudioTs = nextAudioTs + scaleFactor * lastSample.duration;
      const moof = rawMPEG ? new Uint8Array(0) : MP4.moof(track.sequenceNumber++, firstPTS / scaleFactor, _extends4({}, track, {
        samples: outputSamples
      }));
      track.samples = [];
      const start = (firstPTS - initTime) / inputTimeScale;
      const end = nextAudioTs / inputTimeScale;
      const type = "audio";
      const audioData = {
        data1: moof,
        data2: mdat,
        startPTS: start,
        endPTS: end,
        startDTS: start,
        endDTS: end,
        type,
        hasAudio: true,
        hasVideo: false,
        nb: nbSamples
      };
      this.isAudioContiguous = true;
      return audioData;
    }
  };
  function normalizePts(value, reference) {
    let offset;
    if (reference === null) {
      return value;
    }
    if (reference < value) {
      offset = -8589934592;
    } else {
      offset = 8589934592;
    }
    while (Math.abs(value - reference) > 4294967296) {
      value += offset;
    }
    return value;
  }
  function findKeyframeIndex(samples) {
    for (let i = 0; i < samples.length; i++) {
      if (samples[i].key) {
        return i;
      }
    }
    return -1;
  }
  function flushTextTrackMetadataCueSamples(track, timeOffset, initPTS, initDTS) {
    const length = track.samples.length;
    if (!length) {
      return;
    }
    const inputTimeScale = track.inputTimeScale;
    for (let index = 0; index < length; index++) {
      const sample = track.samples[index];
      sample.pts = normalizePts(sample.pts - initPTS.baseTime * inputTimeScale / initPTS.timescale, timeOffset * inputTimeScale) / inputTimeScale;
      sample.dts = normalizePts(sample.dts - initDTS.baseTime * inputTimeScale / initDTS.timescale, timeOffset * inputTimeScale) / inputTimeScale;
    }
    const samples = track.samples;
    track.samples = [];
    return {
      samples
    };
  }
  function flushTextTrackUserdataCueSamples(track, timeOffset, initPTS) {
    const length = track.samples.length;
    if (!length) {
      return;
    }
    const inputTimeScale = track.inputTimeScale;
    for (let index = 0; index < length; index++) {
      const sample = track.samples[index];
      sample.pts = normalizePts(sample.pts - initPTS.baseTime * inputTimeScale / initPTS.timescale, timeOffset * inputTimeScale) / inputTimeScale;
    }
    track.samples.sort((a, b) => a.pts - b.pts);
    const samples = track.samples;
    track.samples = [];
    return {
      samples
    };
  }
  var PassThroughRemuxer = class extends Logger {
    constructor(observer2, config3, typeSupported, logger2) {
      super("passthrough-remuxer", logger2);
      this.emitInitSegment = false;
      this.audioCodec = void 0;
      this.videoCodec = void 0;
      this.initData = void 0;
      this.initPTS = null;
      this.initTracks = void 0;
      this.lastEndTime = null;
      this.isVideoContiguous = false;
    }
    destroy() {
    }
    resetTimeStamp(defaultInitPTS) {
      this.lastEndTime = null;
      const initPTS = this.initPTS;
      if (initPTS && defaultInitPTS) {
        if (initPTS.baseTime === defaultInitPTS.baseTime && initPTS.timescale === defaultInitPTS.timescale) {
          return;
        }
      }
      this.initPTS = defaultInitPTS;
    }
    resetNextTimestamp() {
      this.isVideoContiguous = false;
      this.lastEndTime = null;
    }
    resetInitSegment(initSegment, audioCodec, videoCodec, decryptdata) {
      this.audioCodec = audioCodec;
      this.videoCodec = videoCodec;
      this.generateInitSegment(initSegment, decryptdata);
      this.emitInitSegment = true;
    }
    generateInitSegment(initSegment, decryptdata) {
      let {
        audioCodec,
        videoCodec
      } = this;
      if (!(initSegment != null && initSegment.byteLength)) {
        this.initTracks = void 0;
        this.initData = void 0;
        return;
      }
      const {
        audio,
        video
      } = this.initData = parseInitSegment(initSegment);
      if (decryptdata) {
        patchEncyptionData(initSegment, decryptdata);
      } else {
        const eitherTrack = audio || video;
        if (eitherTrack != null && eitherTrack.encrypted) {
          this.warn(`Init segment with encrypted track with has no key ("${eitherTrack.codec}")!`);
        }
      }
      if (audio) {
        audioCodec = getParsedTrackCodec(audio, ElementaryStreamTypes.AUDIO, this);
      }
      if (video) {
        videoCodec = getParsedTrackCodec(video, ElementaryStreamTypes.VIDEO, this);
      }
      const tracks = {};
      if (audio && video) {
        tracks.audiovideo = {
          container: "video/mp4",
          codec: audioCodec + "," + videoCodec,
          supplemental: video.supplemental,
          encrypted: video.encrypted,
          initSegment,
          id: "main"
        };
      } else if (audio) {
        tracks.audio = {
          container: "audio/mp4",
          codec: audioCodec,
          encrypted: audio.encrypted,
          initSegment,
          id: "audio"
        };
      } else if (video) {
        tracks.video = {
          container: "video/mp4",
          codec: videoCodec,
          supplemental: video.supplemental,
          encrypted: video.encrypted,
          initSegment,
          id: "main"
        };
      } else {
        this.warn("initSegment does not contain moov or trak boxes.");
      }
      this.initTracks = tracks;
    }
    remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset) {
      var _initData, _initData2;
      let {
        initPTS,
        lastEndTime
      } = this;
      const result = {
        audio: void 0,
        video: void 0,
        text: textTrack,
        id3: id3Track,
        initSegment: void 0
      };
      if (!isFiniteNumber(lastEndTime)) {
        lastEndTime = this.lastEndTime = timeOffset || 0;
      }
      const data = videoTrack.samples;
      if (!data.length) {
        return result;
      }
      const initSegment = {
        initPTS: void 0,
        timescale: void 0,
        trackId: void 0
      };
      let initData = this.initData;
      if (!((_initData = initData) != null && _initData.length)) {
        this.generateInitSegment(data);
        initData = this.initData;
      }
      if (!((_initData2 = initData) != null && _initData2.length)) {
        this.warn("Failed to generate initSegment.");
        return result;
      }
      if (this.emitInitSegment) {
        initSegment.tracks = this.initTracks;
        this.emitInitSegment = false;
      }
      const trackSampleData = getSampleData(data, initData, this);
      const audioSampleTimestamps = initData.audio ? trackSampleData[initData.audio.id] : null;
      const videoSampleTimestamps = initData.video ? trackSampleData[initData.video.id] : null;
      const videoStartTime = toStartEndOrDefault(videoSampleTimestamps, Infinity);
      const audioStartTime = toStartEndOrDefault(audioSampleTimestamps, Infinity);
      const videoEndTime = toStartEndOrDefault(videoSampleTimestamps, 0, true);
      const audioEndTime = toStartEndOrDefault(audioSampleTimestamps, 0, true);
      let decodeTime = timeOffset;
      let duration = 0;
      const syncOnAudio = audioSampleTimestamps && (!videoSampleTimestamps || !initPTS && audioStartTime < videoStartTime || initPTS && initPTS.trackId === initData.audio.id);
      const baseOffsetSamples = syncOnAudio ? audioSampleTimestamps : videoSampleTimestamps;
      if (baseOffsetSamples) {
        const timescale = baseOffsetSamples.timescale;
        const baseTime = baseOffsetSamples.start - timeOffset * timescale;
        const trackId = syncOnAudio ? initData.audio.id : initData.video.id;
        decodeTime = baseOffsetSamples.start / timescale;
        duration = syncOnAudio ? audioEndTime - audioStartTime : videoEndTime - videoStartTime;
        if ((accurateTimeOffset || !initPTS) && (isInvalidInitPts(initPTS, decodeTime, timeOffset, duration) || timescale !== initPTS.timescale)) {
          if (initPTS) {
            this.warn(`Timestamps at playlist time: ${accurateTimeOffset ? "" : "~"}${timeOffset} ${baseTime / timescale} != initPTS: ${initPTS.baseTime / initPTS.timescale} (${initPTS.baseTime}/${initPTS.timescale}) trackId: ${initPTS.trackId}`);
          }
          this.log(`Found initPTS at playlist time: ${timeOffset} offset: ${decodeTime - timeOffset} (${baseTime}/${timescale}) trackId: ${trackId}`);
          initPTS = null;
          initSegment.initPTS = baseTime;
          initSegment.timescale = timescale;
          initSegment.trackId = trackId;
        }
      } else {
        this.warn(`No audio or video samples found for initPTS at playlist time: ${timeOffset}`);
      }
      if (!initPTS) {
        if (!initSegment.timescale || initSegment.trackId === void 0 || initSegment.initPTS === void 0) {
          this.warn("Could not set initPTS");
          initSegment.initPTS = decodeTime;
          initSegment.timescale = 1;
          initSegment.trackId = -1;
        }
        this.initPTS = initPTS = {
          baseTime: initSegment.initPTS,
          timescale: initSegment.timescale,
          trackId: initSegment.trackId
        };
      } else {
        initSegment.initPTS = initPTS.baseTime;
        initSegment.timescale = initPTS.timescale;
        initSegment.trackId = initPTS.trackId;
      }
      const startTime = decodeTime - initPTS.baseTime / initPTS.timescale;
      const endTime = startTime + duration;
      if (duration > 0) {
        this.lastEndTime = endTime;
      } else {
        this.warn("Duration parsed from mp4 should be greater than zero");
        this.resetNextTimestamp();
      }
      const hasAudio = !!initData.audio;
      const hasVideo = !!initData.video;
      let type = "";
      if (hasAudio) {
        type += "audio";
      }
      if (hasVideo) {
        type += "video";
      }
      const encrypted = (initData.audio ? initData.audio.encrypted : false) || (initData.video ? initData.video.encrypted : false);
      const track = {
        data1: data,
        startPTS: startTime,
        startDTS: startTime,
        endPTS: endTime,
        endDTS: endTime,
        type,
        hasAudio,
        hasVideo,
        nb: 1,
        dropped: 0,
        encrypted
      };
      result.audio = hasAudio && !hasVideo ? track : void 0;
      result.video = hasVideo ? track : void 0;
      const videoSampleCount = videoSampleTimestamps == null ? void 0 : videoSampleTimestamps.sampleCount;
      if (videoSampleCount) {
        const firstKeyFrame = videoSampleTimestamps.keyFrameIndex;
        const independent = firstKeyFrame !== -1;
        track.nb = videoSampleCount;
        track.dropped = firstKeyFrame === 0 || this.isVideoContiguous ? 0 : independent ? firstKeyFrame : videoSampleCount;
        track.independent = independent;
        track.firstKeyFrame = firstKeyFrame;
        if (independent && videoSampleTimestamps.keyFrameStart) {
          track.firstKeyFramePTS = (videoSampleTimestamps.keyFrameStart - initPTS.baseTime) / initPTS.timescale;
        }
        if (!this.isVideoContiguous) {
          result.independent = independent;
        }
        this.isVideoContiguous || (this.isVideoContiguous = independent);
        if (track.dropped) {
          this.warn(`fmp4 does not start with IDR: firstIDR ${firstKeyFrame}/${videoSampleCount} dropped: ${track.dropped} start: ${track.firstKeyFramePTS || "NA"}`);
        }
      }
      result.initSegment = initSegment;
      result.id3 = flushTextTrackMetadataCueSamples(id3Track, timeOffset, initPTS, initPTS);
      if (textTrack.samples.length) {
        result.text = flushTextTrackUserdataCueSamples(textTrack, timeOffset, initPTS);
      }
      return result;
    }
  };
  function toStartEndOrDefault(trackTimes, defaultValue, end = false) {
    return (trackTimes == null ? void 0 : trackTimes.start) !== void 0 ? (trackTimes.start + (end ? trackTimes.duration : 0)) / trackTimes.timescale : defaultValue;
  }
  function isInvalidInitPts(initPTS, startDTS, timeOffset, duration) {
    if (initPTS === null) {
      return true;
    }
    const minDuration = Math.max(duration, 1);
    const startTime = startDTS - initPTS.baseTime / initPTS.timescale;
    return Math.abs(startTime - timeOffset) > minDuration;
  }
  function getParsedTrackCodec(track, type, logger2) {
    const parsedCodec = track.codec;
    if (parsedCodec && parsedCodec.length > 4) {
      return parsedCodec;
    }
    if (type === ElementaryStreamTypes.AUDIO) {
      if (parsedCodec === "ec-3" || parsedCodec === "ac-3" || parsedCodec === "alac") {
        return parsedCodec;
      }
      if (parsedCodec === "fLaC" || parsedCodec === "Opus") {
        const preferManagedMediaSource = false;
        return getCodecCompatibleName(parsedCodec, preferManagedMediaSource);
      }
      logger2.warn(`Unhandled audio codec "${parsedCodec}" in mp4 MAP`);
      return parsedCodec || "mp4a";
    }
    logger2.warn(`Unhandled video codec "${parsedCodec}" in mp4 MAP`);
    return parsedCodec || "avc1";
  }
  var now;
  try {
    now = self.performance.now.bind(self.performance);
  } catch (err) {
    now = Date.now;
  }
  var muxConfig = [{
    demux: MP4Demuxer,
    remux: PassThroughRemuxer
  }, {
    demux: TSDemuxer,
    remux: MP4Remuxer
  }, {
    demux: AACDemuxer,
    remux: MP4Remuxer
  }, {
    demux: MP3Demuxer,
    remux: MP4Remuxer
  }];
  {
    muxConfig.splice(2, 0, {
      demux: AC3Demuxer,
      remux: MP4Remuxer
    });
  }
  var Transmuxer = class {
    constructor(observer2, typeSupported, config3, vendor, id3, logger2) {
      this.asyncResult = false;
      this.logger = void 0;
      this.observer = void 0;
      this.typeSupported = void 0;
      this.config = void 0;
      this.id = void 0;
      this.demuxer = void 0;
      this.remuxer = void 0;
      this.decrypter = void 0;
      this.probe = void 0;
      this.decryptionPromise = null;
      this.transmuxConfig = void 0;
      this.currentTransmuxState = void 0;
      this.observer = observer2;
      this.typeSupported = typeSupported;
      this.config = config3;
      this.id = id3;
      this.logger = logger2;
    }
    configure(transmuxConfig) {
      this.transmuxConfig = transmuxConfig;
      if (this.decrypter) {
        this.decrypter.reset();
      }
    }
    push(data, decryptdata, chunkMeta, state) {
      const stats = chunkMeta.transmuxing;
      stats.executeStart = now();
      let uintData = new Uint8Array(data);
      const {
        currentTransmuxState,
        transmuxConfig
      } = this;
      if (state) {
        this.currentTransmuxState = state;
      }
      const {
        contiguous,
        discontinuity,
        trackSwitch,
        accurateTimeOffset,
        timeOffset,
        initSegmentChange
      } = state || currentTransmuxState;
      const {
        audioCodec,
        videoCodec,
        defaultInitPts,
        duration,
        initSegmentData
      } = transmuxConfig;
      const keyData = getEncryptionType(uintData, decryptdata);
      if (keyData && isFullSegmentEncryption(keyData.method)) {
        const decrypter = this.getDecrypter();
        const aesMode = getAesModeFromFullSegmentMethod(keyData.method);
        if (decrypter.isSync()) {
          let decryptedData = decrypter.softwareDecrypt(uintData, keyData.key.buffer, keyData.iv.buffer, aesMode);
          const loadingParts = chunkMeta.part > -1;
          if (loadingParts) {
            const _data = decrypter.flush();
            decryptedData = _data ? _data.buffer : _data;
          }
          if (!decryptedData) {
            stats.executeEnd = now();
            return emptyResult(chunkMeta);
          }
          uintData = new Uint8Array(decryptedData);
        } else {
          this.asyncResult = true;
          this.decryptionPromise = decrypter.webCryptoDecrypt(uintData, keyData.key.buffer, keyData.iv.buffer, aesMode).then((decryptedData) => {
            const result2 = this.push(decryptedData, null, chunkMeta);
            this.decryptionPromise = null;
            return result2;
          });
          return this.decryptionPromise;
        }
      }
      const resetMuxers = this.needsProbing(discontinuity, trackSwitch);
      if (resetMuxers) {
        const error = this.configureTransmuxer(uintData);
        if (error) {
          this.logger.warn(`[transmuxer] ${error.message}`);
          this.observer.emit(Events.ERROR, Events.ERROR, {
            type: ErrorTypes.MEDIA_ERROR,
            details: ErrorDetails.FRAG_PARSING_ERROR,
            fatal: false,
            error,
            reason: error.message
          });
          stats.executeEnd = now();
          return emptyResult(chunkMeta);
        }
      }
      if (discontinuity || trackSwitch || initSegmentChange || resetMuxers) {
        this.resetInitSegment(initSegmentData, audioCodec, videoCodec, duration, decryptdata);
      }
      if (discontinuity || initSegmentChange || resetMuxers) {
        this.resetInitialTimestamp(defaultInitPts);
      }
      if (!contiguous) {
        this.resetContiguity();
      }
      const result = this.transmux(uintData, keyData, timeOffset, accurateTimeOffset, chunkMeta);
      this.asyncResult = isPromise(result);
      const currentState = this.currentTransmuxState;
      currentState.contiguous = true;
      currentState.discontinuity = false;
      currentState.trackSwitch = false;
      stats.executeEnd = now();
      return result;
    }
    // Due to data caching, flush calls can produce more than one TransmuxerResult (hence the Array type)
    flush(chunkMeta) {
      const stats = chunkMeta.transmuxing;
      stats.executeStart = now();
      const {
        decrypter,
        currentTransmuxState,
        decryptionPromise
      } = this;
      if (decryptionPromise) {
        this.asyncResult = true;
        return decryptionPromise.then(() => {
          return this.flush(chunkMeta);
        });
      }
      const transmuxResults = [];
      const {
        timeOffset
      } = currentTransmuxState;
      if (decrypter) {
        const decryptedData = decrypter.flush();
        if (decryptedData) {
          transmuxResults.push(this.push(decryptedData.buffer, null, chunkMeta));
        }
      }
      const {
        demuxer,
        remuxer
      } = this;
      if (!demuxer || !remuxer) {
        stats.executeEnd = now();
        const emptyResults = [emptyResult(chunkMeta)];
        if (this.asyncResult) {
          return Promise.resolve(emptyResults);
        }
        return emptyResults;
      }
      const demuxResultOrPromise = demuxer.flush(timeOffset);
      if (isPromise(demuxResultOrPromise)) {
        this.asyncResult = true;
        return demuxResultOrPromise.then((demuxResult) => {
          this.flushRemux(transmuxResults, demuxResult, chunkMeta);
          return transmuxResults;
        });
      }
      this.flushRemux(transmuxResults, demuxResultOrPromise, chunkMeta);
      if (this.asyncResult) {
        return Promise.resolve(transmuxResults);
      }
      return transmuxResults;
    }
    flushRemux(transmuxResults, demuxResult, chunkMeta) {
      const {
        audioTrack,
        videoTrack,
        id3Track,
        textTrack
      } = demuxResult;
      const {
        accurateTimeOffset,
        timeOffset
      } = this.currentTransmuxState;
      this.logger.log(`[transmuxer.ts]: Flushed ${this.id} sn: ${chunkMeta.sn}${chunkMeta.part > -1 ? " part: " + chunkMeta.part : ""} of ${this.id === PlaylistLevelType.MAIN ? "level" : "track"} ${chunkMeta.level}`);
      const remuxResult = this.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, true, this.id);
      transmuxResults.push({
        remuxResult,
        chunkMeta
      });
      chunkMeta.transmuxing.executeEnd = now();
    }
    resetInitialTimestamp(defaultInitPts) {
      const {
        demuxer,
        remuxer
      } = this;
      if (!demuxer || !remuxer) {
        return;
      }
      demuxer.resetTimeStamp(defaultInitPts);
      remuxer.resetTimeStamp(defaultInitPts);
    }
    resetContiguity() {
      const {
        demuxer,
        remuxer
      } = this;
      if (!demuxer || !remuxer) {
        return;
      }
      demuxer.resetContiguity();
      remuxer.resetNextTimestamp();
    }
    resetInitSegment(initSegmentData, audioCodec, videoCodec, trackDuration, decryptdata) {
      const {
        demuxer,
        remuxer
      } = this;
      if (!demuxer || !remuxer) {
        return;
      }
      demuxer.resetInitSegment(initSegmentData, audioCodec, videoCodec, trackDuration);
      remuxer.resetInitSegment(initSegmentData, audioCodec, videoCodec, decryptdata);
    }
    destroy() {
      if (this.demuxer) {
        this.demuxer.destroy();
        this.demuxer = void 0;
      }
      if (this.remuxer) {
        this.remuxer.destroy();
        this.remuxer = void 0;
      }
    }
    transmux(data, keyData, timeOffset, accurateTimeOffset, chunkMeta) {
      let result;
      if (keyData && keyData.method === "SAMPLE-AES") {
        result = this.transmuxSampleAes(data, keyData, timeOffset, accurateTimeOffset, chunkMeta);
      } else {
        result = this.transmuxUnencrypted(data, timeOffset, accurateTimeOffset, chunkMeta);
      }
      return result;
    }
    transmuxUnencrypted(data, timeOffset, accurateTimeOffset, chunkMeta) {
      const {
        audioTrack,
        videoTrack,
        id3Track,
        textTrack
      } = this.demuxer.demux(data, timeOffset, false, !this.config.progressive);
      const remuxResult = this.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, false, this.id);
      return {
        remuxResult,
        chunkMeta
      };
    }
    transmuxSampleAes(data, decryptData, timeOffset, accurateTimeOffset, chunkMeta) {
      return this.demuxer.demuxSampleAes(data, decryptData, timeOffset).then((demuxResult) => {
        const remuxResult = this.remuxer.remux(demuxResult.audioTrack, demuxResult.videoTrack, demuxResult.id3Track, demuxResult.textTrack, timeOffset, accurateTimeOffset, false, this.id);
        return {
          remuxResult,
          chunkMeta
        };
      });
    }
    configureTransmuxer(data) {
      const {
        config: config3,
        observer: observer2,
        typeSupported
      } = this;
      let mux;
      for (let i = 0, len = muxConfig.length; i < len; i++) {
        var _muxConfig$i$demux;
        if ((_muxConfig$i$demux = muxConfig[i].demux) != null && _muxConfig$i$demux.probe(data, this.logger)) {
          mux = muxConfig[i];
          break;
        }
      }
      if (!mux) {
        return new Error("Failed to find demuxer by probing fragment data");
      }
      const demuxer = this.demuxer;
      const remuxer = this.remuxer;
      const Remuxer = mux.remux;
      const Demuxer = mux.demux;
      if (!remuxer || !(remuxer instanceof Remuxer)) {
        this.remuxer = new Remuxer(observer2, config3, typeSupported, this.logger);
      }
      if (!demuxer || !(demuxer instanceof Demuxer)) {
        this.demuxer = new Demuxer(observer2, config3, typeSupported, this.logger);
        this.probe = Demuxer.probe;
      }
    }
    needsProbing(discontinuity, trackSwitch) {
      return !this.demuxer || !this.remuxer || discontinuity || trackSwitch;
    }
    getDecrypter() {
      let decrypter = this.decrypter;
      if (!decrypter) {
        decrypter = this.decrypter = new Decrypter(this.config);
      }
      return decrypter;
    }
  };
  function getEncryptionType(data, decryptData) {
    let encryptionType = null;
    if (data.byteLength > 0 && (decryptData == null ? void 0 : decryptData.key) != null && decryptData.iv !== null && decryptData.method != null) {
      encryptionType = decryptData;
    }
    return encryptionType;
  }
  var emptyResult = (chunkMeta) => ({
    remuxResult: {},
    chunkMeta
  });
  function isPromise(p) {
    return "then" in p && p.then instanceof Function;
  }
  var TransmuxConfig = class {
    constructor(audioCodec, videoCodec, initSegmentData, duration, defaultInitPts) {
      this.audioCodec = void 0;
      this.videoCodec = void 0;
      this.initSegmentData = void 0;
      this.duration = void 0;
      this.defaultInitPts = void 0;
      this.audioCodec = audioCodec;
      this.videoCodec = videoCodec;
      this.initSegmentData = initSegmentData;
      this.duration = duration;
      this.defaultInitPts = defaultInitPts || null;
    }
  };
  var TransmuxState = class {
    constructor(discontinuity, contiguous, accurateTimeOffset, trackSwitch, timeOffset, initSegmentChange) {
      this.discontinuity = void 0;
      this.contiguous = void 0;
      this.accurateTimeOffset = void 0;
      this.trackSwitch = void 0;
      this.timeOffset = void 0;
      this.initSegmentChange = void 0;
      this.discontinuity = discontinuity;
      this.contiguous = contiguous;
      this.accurateTimeOffset = accurateTimeOffset;
      this.trackSwitch = trackSwitch;
      this.timeOffset = timeOffset;
      this.initSegmentChange = initSegmentChange;
    }
  };
  var transmuxerInstanceCount = 0;
  var TransmuxerInterface = class {
    constructor(_hls, id3, onTransmuxComplete, onFlush) {
      this.error = null;
      this.hls = void 0;
      this.id = void 0;
      this.instanceNo = transmuxerInstanceCount++;
      this.observer = void 0;
      this.frag = null;
      this.part = null;
      this.useWorker = void 0;
      this.workerContext = null;
      this.transmuxer = null;
      this.onTransmuxComplete = void 0;
      this.onFlush = void 0;
      this.onWorkerMessage = (event) => {
        const data = event.data;
        const hls = this.hls;
        if (!hls || !(data != null && data.event) || data.instanceNo !== this.instanceNo) {
          return;
        }
        switch (data.event) {
          case "init": {
            var _this$workerContext;
            const objectURL = (_this$workerContext = this.workerContext) == null ? void 0 : _this$workerContext.objectURL;
            if (objectURL) {
              self.URL.revokeObjectURL(objectURL);
            }
            break;
          }
          case "transmuxComplete": {
            this.handleTransmuxComplete(data.data);
            break;
          }
          case "flush": {
            this.onFlush(data.data);
            break;
          }
          // pass logs from the worker thread to the main logger
          case "workerLog": {
            if (hls.logger[data.data.logType]) {
              hls.logger[data.data.logType](data.data.message);
            }
            break;
          }
          default: {
            data.data = data.data || {};
            data.data.frag = this.frag;
            data.data.part = this.part;
            data.data.id = this.id;
            hls.trigger(data.event, data.data);
            break;
          }
        }
      };
      this.onWorkerError = (event) => {
        if (!this.hls) {
          return;
        }
        const error = new Error(`${event.message}  (${event.filename}:${event.lineno})`);
        this.hls.config.enableWorker = false;
        this.hls.logger.warn(`Error in "${this.id}" Web Worker, fallback to inline`);
        this.hls.trigger(Events.ERROR, {
          type: ErrorTypes.OTHER_ERROR,
          details: ErrorDetails.INTERNAL_EXCEPTION,
          fatal: false,
          event: "demuxerWorker",
          error
        });
      };
      const config3 = _hls.config;
      this.hls = _hls;
      this.id = id3;
      this.useWorker = !!config3.enableWorker;
      this.onTransmuxComplete = onTransmuxComplete;
      this.onFlush = onFlush;
      const forwardMessage = (ev, data) => {
        data = data || {};
        data.frag = this.frag || void 0;
        if (ev === Events.ERROR) {
          data = data;
          data.parent = this.id;
          data.part = this.part;
          this.error = data.error;
        }
        this.hls.trigger(ev, data);
      };
      this.observer = new EventEmitter();
      this.observer.on(Events.FRAG_DECRYPTED, forwardMessage);
      this.observer.on(Events.ERROR, forwardMessage);
      const m2tsTypeSupported = getM2TSSupportedAudioTypes(config3.preferManagedMediaSource);
      if (this.useWorker && typeof Worker !== "undefined") {
        const logger2 = this.hls.logger;
        const canCreateWorker = config3.workerPath || hasUMDWorker();
        if (canCreateWorker) {
          try {
            if (config3.workerPath) {
              logger2.log(`loading Web Worker ${config3.workerPath} for "${id3}"`);
              this.workerContext = loadWorker(config3.workerPath);
            } else {
              logger2.log(`injecting Web Worker for "${id3}"`);
              this.workerContext = injectWorker();
            }
            const {
              worker
            } = this.workerContext;
            worker.addEventListener("message", this.onWorkerMessage);
            worker.addEventListener("error", this.onWorkerError);
            worker.postMessage({
              instanceNo: this.instanceNo,
              cmd: "init",
              typeSupported: m2tsTypeSupported,
              id: id3,
              config: stringify(config3)
            });
          } catch (err) {
            logger2.warn(`Error setting up "${id3}" Web Worker, fallback to inline`, err);
            this.terminateWorker();
            this.error = null;
            this.transmuxer = new Transmuxer(this.observer, m2tsTypeSupported, config3, "", id3, _hls.logger);
          }
          return;
        }
      }
      this.transmuxer = new Transmuxer(this.observer, m2tsTypeSupported, config3, "", id3, _hls.logger);
    }
    reset() {
      this.frag = null;
      this.part = null;
      if (this.workerContext) {
        const instanceNo = this.instanceNo;
        this.instanceNo = transmuxerInstanceCount++;
        const config3 = this.hls.config;
        const m2tsTypeSupported = getM2TSSupportedAudioTypes(config3.preferManagedMediaSource);
        this.workerContext.worker.postMessage({
          instanceNo: this.instanceNo,
          cmd: "reset",
          resetNo: instanceNo,
          typeSupported: m2tsTypeSupported,
          id: this.id,
          config: stringify(config3)
        });
      }
    }
    terminateWorker() {
      if (this.workerContext) {
        const {
          worker
        } = this.workerContext;
        this.workerContext = null;
        worker.removeEventListener("message", this.onWorkerMessage);
        worker.removeEventListener("error", this.onWorkerError);
        removeWorkerFromStore(this.hls.config.workerPath);
      }
    }
    destroy() {
      if (this.workerContext) {
        this.terminateWorker();
        this.onWorkerMessage = this.onWorkerError = null;
      } else {
        const transmuxer = this.transmuxer;
        if (transmuxer) {
          transmuxer.destroy();
          this.transmuxer = null;
        }
      }
      const observer2 = this.observer;
      if (observer2) {
        observer2.removeAllListeners();
      }
      this.frag = null;
      this.part = null;
      this.observer = null;
      this.hls = null;
    }
    push(data, initSegmentData, audioCodec, videoCodec, frag, part, duration, accurateTimeOffset, chunkMeta, defaultInitPTS) {
      var _frag$initSegment, _lastFrag$initSegment;
      chunkMeta.transmuxing.start = self.performance.now();
      const {
        instanceNo,
        transmuxer
      } = this;
      const timeOffset = part ? part.start : frag.start;
      const decryptdata = frag.decryptdata;
      const lastFrag = this.frag;
      const discontinuity = !(lastFrag && frag.cc === lastFrag.cc);
      const trackSwitch = !(lastFrag && chunkMeta.level === lastFrag.level);
      const snDiff = lastFrag ? chunkMeta.sn - lastFrag.sn : -1;
      const partDiff = this.part ? chunkMeta.part - this.part.index : -1;
      const progressive = snDiff === 0 && chunkMeta.id > 1 && chunkMeta.id === (lastFrag == null ? void 0 : lastFrag.stats.chunkCount);
      const contiguous = !trackSwitch && (snDiff === 1 || snDiff === 0 && (partDiff === 1 || progressive && partDiff <= 0));
      const now3 = self.performance.now();
      if (trackSwitch || snDiff || frag.stats.parsing.start === 0) {
        frag.stats.parsing.start = now3;
      }
      if (part && (partDiff || !contiguous)) {
        part.stats.parsing.start = now3;
      }
      const initSegmentChange = !(lastFrag && ((_frag$initSegment = frag.initSegment) == null ? void 0 : _frag$initSegment.url) === ((_lastFrag$initSegment = lastFrag.initSegment) == null ? void 0 : _lastFrag$initSegment.url));
      const state = new TransmuxState(discontinuity, contiguous, accurateTimeOffset, trackSwitch, timeOffset, initSegmentChange);
      if (!contiguous || discontinuity || initSegmentChange) {
        this.hls.logger.log(`[transmuxer-interface]: Starting new transmux session for ${frag.type} sn: ${chunkMeta.sn}${chunkMeta.part > -1 ? " part: " + chunkMeta.part : ""} ${this.id === PlaylistLevelType.MAIN ? "level" : "track"}: ${chunkMeta.level} id: ${chunkMeta.id}
        discontinuity: ${discontinuity}
        trackSwitch: ${trackSwitch}
        contiguous: ${contiguous}
        accurateTimeOffset: ${accurateTimeOffset}
        timeOffset: ${timeOffset}
        initSegmentChange: ${initSegmentChange}`);
        const config3 = new TransmuxConfig(audioCodec, videoCodec, initSegmentData, duration, defaultInitPTS);
        this.configureTransmuxer(config3);
      }
      this.frag = frag;
      this.part = part;
      if (this.workerContext) {
        this.workerContext.worker.postMessage({
          instanceNo,
          cmd: "demux",
          data,
          decryptdata,
          chunkMeta,
          state
        }, data instanceof ArrayBuffer ? [data] : []);
      } else if (transmuxer) {
        const transmuxResult = transmuxer.push(data, decryptdata, chunkMeta, state);
        if (isPromise(transmuxResult)) {
          transmuxResult.then((data2) => {
            this.handleTransmuxComplete(data2);
          }).catch((error) => {
            this.transmuxerError(error, chunkMeta, "transmuxer-interface push error");
          });
        } else {
          this.handleTransmuxComplete(transmuxResult);
        }
      }
    }
    flush(chunkMeta) {
      chunkMeta.transmuxing.start = self.performance.now();
      const {
        instanceNo,
        transmuxer
      } = this;
      if (this.workerContext) {
        this.workerContext.worker.postMessage({
          instanceNo,
          cmd: "flush",
          chunkMeta
        });
      } else if (transmuxer) {
        const transmuxResult = transmuxer.flush(chunkMeta);
        if (isPromise(transmuxResult)) {
          transmuxResult.then((data) => {
            this.handleFlushResult(data, chunkMeta);
          }).catch((error) => {
            this.transmuxerError(error, chunkMeta, "transmuxer-interface flush error");
          });
        } else {
          this.handleFlushResult(transmuxResult, chunkMeta);
        }
      }
    }
    transmuxerError(error, chunkMeta, reason) {
      if (!this.hls) {
        return;
      }
      this.error = error;
      this.hls.trigger(Events.ERROR, {
        type: ErrorTypes.MEDIA_ERROR,
        details: ErrorDetails.FRAG_PARSING_ERROR,
        chunkMeta,
        frag: this.frag || void 0,
        part: this.part || void 0,
        fatal: false,
        error,
        err: error,
        reason
      });
    }
    handleFlushResult(results, chunkMeta) {
      results.forEach((result) => {
        this.handleTransmuxComplete(result);
      });
      this.onFlush(chunkMeta);
    }
    configureTransmuxer(config3) {
      const {
        instanceNo,
        transmuxer
      } = this;
      if (this.workerContext) {
        this.workerContext.worker.postMessage({
          instanceNo,
          cmd: "configure",
          config: config3
        });
      } else if (transmuxer) {
        transmuxer.configure(config3);
      }
    }
    handleTransmuxComplete(result) {
      result.chunkMeta.transmuxing.end = self.performance.now();
      this.onTransmuxComplete(result);
    }
  };
  var TICK_INTERVAL$3 = 100;
  var AudioStreamController = class extends BaseStreamController {
    constructor(hls, fragmentTracker, keyLoader) {
      super(hls, fragmentTracker, keyLoader, "audio-stream-controller", PlaylistLevelType.AUDIO);
      this.mainAnchor = null;
      this.mainFragLoading = null;
      this.audioOnly = false;
      this.bufferedTrack = null;
      this.switchingTrack = null;
      this.trackId = -1;
      this.waitingData = null;
      this.mainDetails = null;
      this.flushing = false;
      this.bufferFlushed = false;
      this.cachedTrackLoadedData = null;
      this.registerListeners();
    }
    onHandlerDestroying() {
      this.unregisterListeners();
      super.onHandlerDestroying();
      this.resetItem();
    }
    resetItem() {
      this.mainDetails = this.mainAnchor = this.mainFragLoading = this.bufferedTrack = this.switchingTrack = this.waitingData = this.cachedTrackLoadedData = null;
    }
    registerListeners() {
      super.registerListeners();
      const {
        hls
      } = this;
      hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);
      hls.on(Events.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this);
      hls.on(Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);
      hls.on(Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);
      hls.on(Events.BUFFER_RESET, this.onBufferReset, this);
      hls.on(Events.BUFFER_CREATED, this.onBufferCreated, this);
      hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);
      hls.on(Events.BUFFER_FLUSHED, this.onBufferFlushed, this);
      hls.on(Events.INIT_PTS_FOUND, this.onInitPtsFound, this);
      hls.on(Events.FRAG_LOADING, this.onFragLoading, this);
      hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);
    }
    unregisterListeners() {
      const {
        hls
      } = this;
      if (!hls) {
        return;
      }
      super.unregisterListeners();
      hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);
      hls.off(Events.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this);
      hls.off(Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);
      hls.off(Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);
      hls.off(Events.BUFFER_RESET, this.onBufferReset, this);
      hls.off(Events.BUFFER_CREATED, this.onBufferCreated, this);
      hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);
      hls.off(Events.BUFFER_FLUSHED, this.onBufferFlushed, this);
      hls.off(Events.INIT_PTS_FOUND, this.onInitPtsFound, this);
      hls.off(Events.FRAG_LOADING, this.onFragLoading, this);
      hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);
    }
    // INIT_PTS_FOUND is triggered when the video track parsed in the stream-controller has a new PTS value
    onInitPtsFound(event, {
      frag,
      id: id3,
      initPTS,
      timescale,
      trackId
    }) {
      if (id3 === PlaylistLevelType.MAIN) {
        const cc = frag.cc;
        const inFlightFrag = this.fragCurrent;
        this.initPTS[cc] = {
          baseTime: initPTS,
          timescale,
          trackId
        };
        this.log(`InitPTS for cc: ${cc} found from main: ${initPTS / timescale} (${initPTS}/${timescale}) trackId: ${trackId}`);
        this.mainAnchor = frag;
        if (this.state === State.WAITING_INIT_PTS) {
          const waitingData = this.waitingData;
          if (!waitingData && !this.loadingParts || waitingData && waitingData.frag.cc !== cc) {
            this.syncWithAnchor(frag, waitingData == null ? void 0 : waitingData.frag);
          }
        } else if (!this.hls.hasEnoughToStart && inFlightFrag && inFlightFrag.cc !== cc) {
          inFlightFrag.abortRequests();
          this.syncWithAnchor(frag, inFlightFrag);
        } else if (this.state === State.IDLE) {
          this.tick();
        }
      }
    }
    getLoadPosition() {
      if (!this.startFragRequested && this.nextLoadPosition >= 0) {
        return this.nextLoadPosition;
      }
      return super.getLoadPosition();
    }
    syncWithAnchor(mainAnchor, waitingToAppend) {
      var _this$mainFragLoading;
      const mainFragLoading = ((_this$mainFragLoading = this.mainFragLoading) == null ? void 0 : _this$mainFragLoading.frag) || null;
      if (waitingToAppend) {
        if ((mainFragLoading == null ? void 0 : mainFragLoading.cc) === waitingToAppend.cc) {
          return;
        }
      }
      const targetDiscontinuity = (mainFragLoading || mainAnchor).cc;
      const trackDetails = this.getLevelDetails();
      const pos = this.getLoadPosition();
      const syncFrag = findNearestWithCC(trackDetails, targetDiscontinuity, pos);
      if (syncFrag) {
        this.log(`Syncing with main frag at ${syncFrag.start} cc ${syncFrag.cc}`);
        this.startFragRequested = false;
        this.nextLoadPosition = syncFrag.start;
        this.resetLoadingState();
        if (this.state === State.IDLE) {
          this.doTickIdle();
        }
      }
    }
    startLoad(startPosition, skipSeekToStartPosition) {
      if (!this.levels) {
        this.startPosition = startPosition;
        this.state = State.STOPPED;
        return;
      }
      const lastCurrentTime = this.lastCurrentTime;
      this.stopLoad();
      this.setInterval(TICK_INTERVAL$3);
      if (lastCurrentTime > 0 && startPosition === -1) {
        this.log(`Override startPosition with lastCurrentTime @${lastCurrentTime.toFixed(3)}`);
        startPosition = lastCurrentTime;
        this.state = State.IDLE;
      } else {
        this.state = State.WAITING_TRACK;
      }
      this.nextLoadPosition = this.lastCurrentTime = startPosition + this.timelineOffset;
      this.startPosition = skipSeekToStartPosition ? -1 : startPosition;
      this.tick();
    }
    doTick() {
      switch (this.state) {
        case State.IDLE:
          this.doTickIdle();
          break;
        case State.WAITING_TRACK: {
          const {
            levels,
            trackId
          } = this;
          const currenTrack = levels == null ? void 0 : levels[trackId];
          const details = currenTrack == null ? void 0 : currenTrack.details;
          if (details && !this.waitForLive(currenTrack)) {
            if (this.waitForCdnTuneIn(details)) {
              break;
            }
            this.state = State.WAITING_INIT_PTS;
          }
          break;
        }
        case State.FRAG_LOADING_WAITING_RETRY: {
          this.checkRetryDate();
          break;
        }
        case State.WAITING_INIT_PTS: {
          const waitingData = this.waitingData;
          if (waitingData) {
            const {
              frag,
              part,
              cache,
              complete
            } = waitingData;
            const mainAnchor = this.mainAnchor;
            if (this.initPTS[frag.cc] !== void 0) {
              this.waitingData = null;
              this.state = State.FRAG_LOADING;
              const payload = cache.flush().buffer;
              const data = {
                frag,
                part,
                payload,
                networkDetails: null
              };
              this._handleFragmentLoadProgress(data);
              if (complete) {
                super._handleFragmentLoadComplete(data);
              }
            } else if (mainAnchor && mainAnchor.cc !== waitingData.frag.cc) {
              this.syncWithAnchor(mainAnchor, waitingData.frag);
            }
          } else {
            this.state = State.IDLE;
          }
        }
      }
      this.onTickEnd();
    }
    resetLoadingState() {
      const waitingData = this.waitingData;
      if (waitingData) {
        this.fragmentTracker.removeFragment(waitingData.frag);
        this.waitingData = null;
      }
      super.resetLoadingState();
    }
    onTickEnd() {
      const {
        media
      } = this;
      if (!(media != null && media.readyState)) {
        return;
      }
      this.lastCurrentTime = media.currentTime;
    }
    doTickIdle() {
      var _this$mainFragLoading2;
      const {
        hls,
        levels,
        media,
        trackId
      } = this;
      const config3 = hls.config;
      if (!this.buffering || !media && !this.primaryPrefetch && (this.startFragRequested || !config3.startFragPrefetch) || !(levels != null && levels[trackId])) {
        return;
      }
      const levelInfo = levels[trackId];
      const trackDetails = levelInfo.details;
      if (!trackDetails || this.waitForLive(levelInfo) || this.waitForCdnTuneIn(trackDetails)) {
        this.state = State.WAITING_TRACK;
        this.startFragRequested = false;
        return;
      }
      const bufferable = this.mediaBuffer ? this.mediaBuffer : this.media;
      if (this.bufferFlushed && bufferable) {
        this.bufferFlushed = false;
        this.afterBufferFlushed(bufferable, ElementaryStreamTypes.AUDIO, PlaylistLevelType.AUDIO);
      }
      const bufferInfo = this.getFwdBufferInfo(bufferable, PlaylistLevelType.AUDIO);
      if (bufferInfo === null) {
        return;
      }
      if (!this.switchingTrack && this._streamEnded(bufferInfo, trackDetails)) {
        hls.trigger(Events.BUFFER_EOS, {
          type: "audio"
        });
        this.state = State.ENDED;
        return;
      }
      const bufferLen = bufferInfo.len;
      const maxBufLen = hls.maxBufferLength;
      const fragments = trackDetails.fragments;
      const start = fragments[0].start;
      const loadPosition = this.getLoadPosition();
      const targetBufferTime = this.flushing ? loadPosition : bufferInfo.end;
      if (this.switchingTrack && media) {
        const pos = loadPosition;
        if (trackDetails.PTSKnown && pos < start) {
          if (bufferInfo.end > start || bufferInfo.nextStart) {
            this.log("Alt audio track ahead of main track, seek to start of alt audio track");
            media.currentTime = start + 0.05;
          }
        }
      }
      if (bufferLen >= maxBufLen && !this.switchingTrack && targetBufferTime < fragments[fragments.length - 1].start) {
        return;
      }
      let frag = this.getNextFragment(targetBufferTime, trackDetails);
      if (frag && this.isLoopLoading(frag, targetBufferTime)) {
        frag = this.getNextFragmentLoopLoading(frag, trackDetails, bufferInfo, PlaylistLevelType.MAIN, maxBufLen);
      }
      if (!frag) {
        this.bufferFlushed = true;
        return;
      }
      let mainFragLoading = ((_this$mainFragLoading2 = this.mainFragLoading) == null ? void 0 : _this$mainFragLoading2.frag) || null;
      if (!this.audioOnly && this.startFragRequested && mainFragLoading && isMediaFragment(frag) && !frag.endList && (!trackDetails.live || !this.loadingParts && targetBufferTime < this.hls.liveSyncPosition)) {
        if (this.fragmentTracker.getState(mainFragLoading) === FragmentState.OK) {
          this.mainFragLoading = mainFragLoading = null;
        }
        if (mainFragLoading && isMediaFragment(mainFragLoading)) {
          if (frag.start > mainFragLoading.end) {
            const mainFragAtPos = this.fragmentTracker.getFragAtPos(targetBufferTime, PlaylistLevelType.MAIN);
            if (mainFragAtPos && mainFragAtPos.end > mainFragLoading.end) {
              mainFragLoading = mainFragAtPos;
              this.mainFragLoading = {
                frag: mainFragAtPos,
                targetBufferTime: null
              };
            }
          }
          const atBufferSyncLimit = frag.start > mainFragLoading.end;
          if (atBufferSyncLimit) {
            return;
          }
        }
      }
      this.loadFragment(frag, levelInfo, targetBufferTime);
    }
    onMediaDetaching(event, data) {
      this.bufferFlushed = this.flushing = false;
      super.onMediaDetaching(event, data);
    }
    onAudioTracksUpdated(event, {
      audioTracks
    }) {
      this.resetTransmuxer();
      this.levels = audioTracks.map((mediaPlaylist) => new Level(mediaPlaylist));
    }
    onAudioTrackSwitching(event, data) {
      const altAudio = !!data.url;
      this.trackId = data.id;
      const {
        fragCurrent
      } = this;
      if (fragCurrent) {
        fragCurrent.abortRequests();
        this.removeUnbufferedFrags(fragCurrent.start);
      }
      this.resetLoadingState();
      if (altAudio) {
        this.switchingTrack = data;
        this.flushAudioIfNeeded(data);
        if (this.state !== State.STOPPED) {
          this.setInterval(TICK_INTERVAL$3);
          this.state = State.IDLE;
          this.tick();
        }
      } else {
        this.resetTransmuxer();
        this.switchingTrack = null;
        this.bufferedTrack = data;
        this.clearInterval();
      }
    }
    onManifestLoading() {
      super.onManifestLoading();
      this.bufferFlushed = this.flushing = this.audioOnly = false;
      this.resetItem();
      this.trackId = -1;
    }
    onLevelLoaded(event, data) {
      this.mainDetails = data.details;
      const cachedTrackLoadedData = this.cachedTrackLoadedData;
      if (cachedTrackLoadedData) {
        this.cachedTrackLoadedData = null;
        this.onAudioTrackLoaded(Events.AUDIO_TRACK_LOADED, cachedTrackLoadedData);
      }
    }
    onAudioTrackLoaded(event, data) {
      var _trackLevel$details;
      const {
        levels
      } = this;
      const {
        details: newDetails,
        id: trackId,
        groupId,
        track
      } = data;
      if (!levels) {
        this.warn(`Audio tracks reset while loading track ${trackId} "${track.name}" of "${groupId}"`);
        return;
      }
      const mainDetails = this.mainDetails;
      if (!mainDetails || newDetails.endCC > mainDetails.endCC || mainDetails.expired) {
        this.cachedTrackLoadedData = data;
        if (this.state !== State.STOPPED) {
          this.state = State.WAITING_TRACK;
        }
        return;
      }
      this.cachedTrackLoadedData = null;
      this.log(`Audio track ${trackId} "${track.name}" of "${groupId}" loaded [${newDetails.startSN},${newDetails.endSN}]${newDetails.lastPartSn ? `[part-${newDetails.lastPartSn}-${newDetails.lastPartIndex}]` : ""},duration:${newDetails.totalduration}`);
      const trackLevel = levels[trackId];
      let sliding = 0;
      if (newDetails.live || (_trackLevel$details = trackLevel.details) != null && _trackLevel$details.live) {
        this.checkLiveUpdate(newDetails);
        if (newDetails.deltaUpdateFailed) {
          return;
        }
        if (trackLevel.details) {
          var _this$levelLastLoaded;
          sliding = this.alignPlaylists(newDetails, trackLevel.details, (_this$levelLastLoaded = this.levelLastLoaded) == null ? void 0 : _this$levelLastLoaded.details);
        }
        if (!newDetails.alignedSliding) {
          alignDiscontinuities(newDetails, mainDetails);
          if (!newDetails.alignedSliding) {
            alignMediaPlaylistByPDT(newDetails, mainDetails);
          }
          sliding = newDetails.fragmentStart;
        }
      }
      trackLevel.details = newDetails;
      this.levelLastLoaded = trackLevel;
      if (!this.startFragRequested) {
        this.setStartPosition(mainDetails, sliding);
      }
      this.hls.trigger(Events.AUDIO_TRACK_UPDATED, {
        details: newDetails,
        id: trackId,
        groupId: data.groupId
      });
      if (this.state === State.WAITING_TRACK && !this.waitForCdnTuneIn(newDetails)) {
        this.state = State.IDLE;
      }
      this.tick();
    }
    _handleFragmentLoadProgress(data) {
      var _frag$initSegment;
      const frag = data.frag;
      const {
        part,
        payload
      } = data;
      const {
        config: config3,
        trackId,
        levels
      } = this;
      if (!levels) {
        this.warn(`Audio tracks were reset while fragment load was in progress. Fragment ${frag.sn} of level ${frag.level} will not be buffered`);
        return;
      }
      const track = levels[trackId];
      if (!track) {
        this.warn("Audio track is undefined on fragment load progress");
        return;
      }
      const details = track.details;
      if (!details) {
        this.warn("Audio track details undefined on fragment load progress");
        this.removeUnbufferedFrags(frag.start);
        return;
      }
      const audioCodec = config3.defaultAudioCodec || track.audioCodec || "mp4a.40.2";
      let transmuxer = this.transmuxer;
      if (!transmuxer) {
        transmuxer = this.transmuxer = new TransmuxerInterface(this.hls, PlaylistLevelType.AUDIO, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this));
      }
      const initPTS = this.initPTS[frag.cc];
      const initSegmentData = (_frag$initSegment = frag.initSegment) == null ? void 0 : _frag$initSegment.data;
      if (initPTS !== void 0) {
        const accurateTimeOffset = false;
        const partIndex = part ? part.index : -1;
        const partial = partIndex !== -1;
        const chunkMeta = new ChunkMetadata(frag.level, frag.sn, frag.stats.chunkCount, payload.byteLength, partIndex, partial);
        transmuxer.push(payload, initSegmentData, audioCodec, "", frag, part, details.totalduration, accurateTimeOffset, chunkMeta, initPTS);
      } else {
        this.log(`Unknown video PTS for cc ${frag.cc}, waiting for video PTS before demuxing audio frag ${frag.sn} of [${details.startSN} ,${details.endSN}],track ${trackId}`);
        const {
          cache
        } = this.waitingData = this.waitingData || {
          frag,
          part,
          cache: new ChunkCache(),
          complete: false
        };
        cache.push(new Uint8Array(payload));
        if (this.state !== State.STOPPED) {
          this.state = State.WAITING_INIT_PTS;
        }
      }
    }
    _handleFragmentLoadComplete(fragLoadedData) {
      if (this.waitingData) {
        this.waitingData.complete = true;
        return;
      }
      super._handleFragmentLoadComplete(fragLoadedData);
    }
    onBufferReset() {
      this.mediaBuffer = null;
    }
    onBufferCreated(event, data) {
      this.bufferFlushed = this.flushing = false;
      const audioTrack = data.tracks.audio;
      if (audioTrack) {
        this.mediaBuffer = audioTrack.buffer || null;
      }
    }
    onFragLoading(event, data) {
      if (!this.audioOnly && data.frag.type === PlaylistLevelType.MAIN && isMediaFragment(data.frag)) {
        this.mainFragLoading = data;
        if (this.state === State.IDLE) {
          this.tick();
        }
      }
    }
    onFragBuffered(event, data) {
      const {
        frag,
        part
      } = data;
      if (frag.type !== PlaylistLevelType.AUDIO) {
        if (!this.audioOnly && frag.type === PlaylistLevelType.MAIN && !frag.elementaryStreams.video && !frag.elementaryStreams.audiovideo) {
          this.audioOnly = true;
          this.mainFragLoading = null;
        }
        return;
      }
      if (this.fragContextChanged(frag)) {
        this.warn(`Fragment ${frag.sn}${part ? " p: " + part.index : ""} of level ${frag.level} finished buffering, but was aborted. state: ${this.state}, audioSwitch: ${this.switchingTrack ? this.switchingTrack.name : "false"}`);
        return;
      }
      if (isMediaFragment(frag)) {
        this.fragPrevious = frag;
        const track = this.switchingTrack;
        if (track) {
          this.bufferedTrack = track;
          this.switchingTrack = null;
          this.hls.trigger(Events.AUDIO_TRACK_SWITCHED, _objectSpread2({}, track));
        }
      }
      this.fragBufferedComplete(frag, part);
      if (this.media) {
        this.tick();
      }
    }
    onError(event, data) {
      var _data$context;
      if (data.fatal) {
        this.state = State.ERROR;
        return;
      }
      switch (data.details) {
        case ErrorDetails.FRAG_GAP:
        case ErrorDetails.FRAG_PARSING_ERROR:
        case ErrorDetails.FRAG_DECRYPT_ERROR:
        case ErrorDetails.FRAG_LOAD_ERROR:
        case ErrorDetails.FRAG_LOAD_TIMEOUT:
        case ErrorDetails.KEY_LOAD_ERROR:
        case ErrorDetails.KEY_LOAD_TIMEOUT:
          this.onFragmentOrKeyLoadError(PlaylistLevelType.AUDIO, data);
          break;
        case ErrorDetails.AUDIO_TRACK_LOAD_ERROR:
        case ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT:
        case ErrorDetails.LEVEL_PARSING_ERROR:
          if (!data.levelRetry && this.state === State.WAITING_TRACK && ((_data$context = data.context) == null ? void 0 : _data$context.type) === PlaylistContextType.AUDIO_TRACK) {
            this.state = State.IDLE;
          }
          break;
        case ErrorDetails.BUFFER_ADD_CODEC_ERROR:
        case ErrorDetails.BUFFER_APPEND_ERROR:
          if (data.parent !== "audio") {
            return;
          }
          if (!this.reduceLengthAndFlushBuffer(data)) {
            this.resetLoadingState();
          }
          break;
        case ErrorDetails.BUFFER_FULL_ERROR:
          if (data.parent !== "audio") {
            return;
          }
          if (this.reduceLengthAndFlushBuffer(data)) {
            this.bufferedTrack = null;
            super.flushMainBuffer(0, Number.POSITIVE_INFINITY, "audio");
          }
          break;
        case ErrorDetails.INTERNAL_EXCEPTION:
          this.recoverWorkerError(data);
          break;
      }
    }
    onBufferFlushing(event, {
      type
    }) {
      if (type !== ElementaryStreamTypes.VIDEO) {
        this.flushing = true;
      }
    }
    onBufferFlushed(event, {
      type
    }) {
      if (type !== ElementaryStreamTypes.VIDEO) {
        this.flushing = false;
        this.bufferFlushed = true;
        if (this.state === State.ENDED) {
          this.state = State.IDLE;
        }
        const mediaBuffer = this.mediaBuffer || this.media;
        if (mediaBuffer) {
          this.afterBufferFlushed(mediaBuffer, type, PlaylistLevelType.AUDIO);
          this.tick();
        }
      }
    }
    _handleTransmuxComplete(transmuxResult) {
      var _id3$samples;
      const id3 = "audio";
      const {
        hls
      } = this;
      const {
        remuxResult,
        chunkMeta
      } = transmuxResult;
      const context3 = this.getCurrentContext(chunkMeta);
      if (!context3) {
        this.resetWhenMissingContext(chunkMeta);
        return;
      }
      const {
        frag,
        part,
        level
      } = context3;
      const {
        details
      } = level;
      const {
        audio,
        text,
        id3: id32,
        initSegment
      } = remuxResult;
      if (this.fragContextChanged(frag) || !details) {
        this.fragmentTracker.removeFragment(frag);
        return;
      }
      this.state = State.PARSING;
      if (this.switchingTrack && audio) {
        this.completeAudioSwitch(this.switchingTrack);
      }
      if (initSegment != null && initSegment.tracks) {
        const mapFragment = frag.initSegment || frag;
        if (this.unhandledEncryptionError(initSegment, frag)) {
          return;
        }
        this._bufferInitSegment(level, initSegment.tracks, mapFragment, chunkMeta);
        hls.trigger(Events.FRAG_PARSING_INIT_SEGMENT, {
          frag: mapFragment,
          id: id3,
          tracks: initSegment.tracks
        });
      }
      if (audio) {
        const {
          startPTS,
          endPTS,
          startDTS,
          endDTS
        } = audio;
        if (part) {
          part.elementaryStreams[ElementaryStreamTypes.AUDIO] = {
            startPTS,
            endPTS,
            startDTS,
            endDTS
          };
        }
        frag.setElementaryStreamInfo(ElementaryStreamTypes.AUDIO, startPTS, endPTS, startDTS, endDTS);
        this.bufferFragmentData(audio, frag, part, chunkMeta);
      }
      if (id32 != null && (_id3$samples = id32.samples) != null && _id3$samples.length) {
        const emittedID3 = _extends4({
          id: id3,
          frag,
          details
        }, id32);
        hls.trigger(Events.FRAG_PARSING_METADATA, emittedID3);
      }
      if (text) {
        const emittedText = _extends4({
          id: id3,
          frag,
          details
        }, text);
        hls.trigger(Events.FRAG_PARSING_USERDATA, emittedText);
      }
    }
    _bufferInitSegment(currentLevel, tracks, frag, chunkMeta) {
      if (this.state !== State.PARSING) {
        return;
      }
      if (tracks.video) {
        delete tracks.video;
      }
      if (tracks.audiovideo) {
        delete tracks.audiovideo;
      }
      if (!tracks.audio) {
        return;
      }
      const track = tracks.audio;
      track.id = PlaylistLevelType.AUDIO;
      const variantAudioCodecs = currentLevel.audioCodec;
      this.log(`Init audio buffer, container:${track.container}, codecs[level/parsed]=[${variantAudioCodecs}/${track.codec}]`);
      if (variantAudioCodecs && variantAudioCodecs.split(",").length === 1) {
        track.levelCodec = variantAudioCodecs;
      }
      this.hls.trigger(Events.BUFFER_CODECS, tracks);
      const initSegment = track.initSegment;
      if (initSegment != null && initSegment.byteLength) {
        const segment = {
          type: "audio",
          frag,
          part: null,
          chunkMeta,
          parent: frag.type,
          data: initSegment
        };
        this.hls.trigger(Events.BUFFER_APPENDING, segment);
      }
      this.tickImmediate();
    }
    loadFragment(frag, track, targetBufferTime) {
      const fragState = this.fragmentTracker.getState(frag);
      if (this.switchingTrack || fragState === FragmentState.NOT_LOADED || fragState === FragmentState.PARTIAL) {
        var _track$details;
        if (!isMediaFragment(frag)) {
          this._loadInitSegment(frag, track);
        } else if ((_track$details = track.details) != null && _track$details.live && !this.initPTS[frag.cc]) {
          this.log(`Waiting for video PTS in continuity counter ${frag.cc} of live stream before loading audio fragment ${frag.sn} of level ${this.trackId}`);
          this.state = State.WAITING_INIT_PTS;
          const mainDetails = this.mainDetails;
          if (mainDetails && mainDetails.fragmentStart !== track.details.fragmentStart) {
            alignMediaPlaylistByPDT(track.details, mainDetails);
          }
        } else {
          super.loadFragment(frag, track, targetBufferTime);
        }
      } else {
        this.clearTrackerIfNeeded(frag);
      }
    }
    flushAudioIfNeeded(switchingTrack) {
      if (this.media && this.bufferedTrack) {
        const {
          name,
          lang,
          assocLang,
          characteristics,
          audioCodec,
          channels
        } = this.bufferedTrack;
        if (!matchesOption({
          name,
          lang,
          assocLang,
          characteristics,
          audioCodec,
          channels
        }, switchingTrack, audioMatchPredicate)) {
          if (useAlternateAudio(switchingTrack.url, this.hls)) {
            this.log("Switching audio track : flushing all audio");
            super.flushMainBuffer(0, Number.POSITIVE_INFINITY, "audio");
            this.bufferedTrack = null;
          } else {
            this.bufferedTrack = switchingTrack;
          }
        }
      }
    }
    completeAudioSwitch(switchingTrack) {
      const {
        hls
      } = this;
      this.flushAudioIfNeeded(switchingTrack);
      this.bufferedTrack = switchingTrack;
      this.switchingTrack = null;
      hls.trigger(Events.AUDIO_TRACK_SWITCHED, _objectSpread2({}, switchingTrack));
    }
  };
  var BasePlaylistController = class extends Logger {
    constructor(hls, logPrefix) {
      super(logPrefix, hls.logger);
      this.hls = void 0;
      this.canLoad = false;
      this.timer = -1;
      this.hls = hls;
    }
    destroy() {
      this.clearTimer();
      this.hls = this.log = this.warn = null;
    }
    clearTimer() {
      if (this.timer !== -1) {
        self.clearTimeout(this.timer);
        this.timer = -1;
      }
    }
    startLoad() {
      this.canLoad = true;
      this.loadPlaylist();
    }
    stopLoad() {
      this.canLoad = false;
      this.clearTimer();
    }
    switchParams(playlistUri, previous, current) {
      const renditionReports = previous == null ? void 0 : previous.renditionReports;
      if (renditionReports) {
        let foundIndex = -1;
        for (let i = 0; i < renditionReports.length; i++) {
          const attr = renditionReports[i];
          let uri;
          try {
            uri = new self.URL(attr.URI, previous.url).href;
          } catch (error) {
            this.warn(`Could not construct new URL for Rendition Report: ${error}`);
            uri = attr.URI || "";
          }
          if (uri === playlistUri) {
            foundIndex = i;
            break;
          } else if (uri === playlistUri.substring(0, uri.length)) {
            foundIndex = i;
          }
        }
        if (foundIndex !== -1) {
          const attr = renditionReports[foundIndex];
          const msn = parseInt(attr["LAST-MSN"]) || previous.lastPartSn;
          let part = parseInt(attr["LAST-PART"]) || previous.lastPartIndex;
          if (this.hls.config.lowLatencyMode) {
            const currentGoal = Math.min(previous.age - previous.partTarget, previous.targetduration);
            if (part >= 0 && currentGoal > previous.partTarget) {
              part += 1;
            }
          }
          const skip = current && getSkipValue(current);
          return new HlsUrlParameters(msn, part >= 0 ? part : void 0, skip);
        }
      }
    }
    loadPlaylist(hlsUrlParameters) {
      this.clearTimer();
    }
    loadingPlaylist(playlist, hlsUrlParameters) {
      this.clearTimer();
    }
    shouldLoadPlaylist(playlist) {
      return this.canLoad && !!playlist && !!playlist.url && (!playlist.details || playlist.details.live);
    }
    getUrlWithDirectives(uri, hlsUrlParameters) {
      if (hlsUrlParameters) {
        try {
          return hlsUrlParameters.addDirectives(uri);
        } catch (error) {
          this.warn(`Could not construct new URL with HLS Delivery Directives: ${error}`);
        }
      }
      return uri;
    }
    playlistLoaded(index, data, previousDetails) {
      const {
        details,
        stats
      } = data;
      const now3 = self.performance.now();
      const elapsed = stats.loading.first ? Math.max(0, now3 - stats.loading.first) : 0;
      details.advancedDateTime = Date.now() - elapsed;
      const timelineOffset = this.hls.config.timelineOffset;
      if (timelineOffset !== details.appliedTimelineOffset) {
        const offset = Math.max(timelineOffset || 0, 0);
        details.appliedTimelineOffset = offset;
        details.fragments.forEach((frag) => {
          frag.setStart(frag.playlistOffset + offset);
        });
      }
      if (details.live || previousDetails != null && previousDetails.live) {
        const levelOrTrack = "levelInfo" in data ? data.levelInfo : data.track;
        details.reloaded(previousDetails);
        if (previousDetails && details.fragments.length > 0) {
          mergeDetails(previousDetails, details, this);
          const error = details.playlistParsingError;
          if (error) {
            this.warn(error);
            const hls = this.hls;
            if (!hls.config.ignorePlaylistParsingErrors) {
              var _details$fragments$;
              const {
                networkDetails
              } = data;
              hls.trigger(Events.ERROR, {
                type: ErrorTypes.NETWORK_ERROR,
                details: ErrorDetails.LEVEL_PARSING_ERROR,
                fatal: false,
                url: details.url,
                error,
                reason: error.message,
                level: data.level || void 0,
                parent: (_details$fragments$ = details.fragments[0]) == null ? void 0 : _details$fragments$.type,
                networkDetails,
                stats
              });
              return;
            }
            details.playlistParsingError = null;
          }
        }
        if (details.requestScheduled === -1) {
          details.requestScheduled = stats.loading.start;
        }
        const bufferInfo = this.hls.mainForwardBufferInfo;
        const position = bufferInfo ? bufferInfo.end - bufferInfo.len : 0;
        const distanceToLiveEdgeMs = (details.edge - position) * 1e3;
        const reloadInterval = computeReloadInterval(details, distanceToLiveEdgeMs);
        if (details.requestScheduled + reloadInterval < now3) {
          details.requestScheduled = now3;
        } else {
          details.requestScheduled += reloadInterval;
        }
        this.log(`live playlist ${index} ${details.advanced ? "REFRESHED " + details.lastPartSn + "-" + details.lastPartIndex : details.updated ? "UPDATED" : "MISSED"}`);
        if (!this.canLoad || !details.live) {
          return;
        }
        let deliveryDirectives;
        let msn = void 0;
        let part = void 0;
        if (details.canBlockReload && details.endSN && details.advanced) {
          const lowLatencyMode = this.hls.config.lowLatencyMode;
          const lastPartSn = details.lastPartSn;
          const endSn = details.endSN;
          const lastPartIndex = details.lastPartIndex;
          const hasParts = lastPartIndex !== -1;
          const atLastPartOfSegment = lastPartSn === endSn;
          if (hasParts) {
            if (atLastPartOfSegment) {
              msn = endSn + 1;
              part = lowLatencyMode ? 0 : lastPartIndex;
            } else {
              msn = lastPartSn;
              part = lowLatencyMode ? lastPartIndex + 1 : details.maxPartIndex;
            }
          } else {
            msn = endSn + 1;
          }
          const lastAdvanced = details.age;
          const cdnAge = lastAdvanced + details.ageHeader;
          let currentGoal = Math.min(cdnAge - details.partTarget, details.targetduration * 1.5);
          if (currentGoal > 0) {
            if (cdnAge > details.targetduration * 3) {
              this.log(`Playlist last advanced ${lastAdvanced.toFixed(2)}s ago. Omitting segment and part directives.`);
              msn = void 0;
              part = void 0;
            } else if (previousDetails != null && previousDetails.tuneInGoal && cdnAge - details.partTarget > previousDetails.tuneInGoal) {
              this.warn(`CDN Tune-in goal increased from: ${previousDetails.tuneInGoal} to: ${currentGoal} with playlist age: ${details.age}`);
              currentGoal = 0;
            } else {
              const segments = Math.floor(currentGoal / details.targetduration);
              msn += segments;
              if (part !== void 0) {
                const parts = Math.round(currentGoal % details.targetduration / details.partTarget);
                part += parts;
              }
              this.log(`CDN Tune-in age: ${details.ageHeader}s last advanced ${lastAdvanced.toFixed(2)}s goal: ${currentGoal} skip sn ${segments} to part ${part}`);
            }
            details.tuneInGoal = currentGoal;
          }
          deliveryDirectives = this.getDeliveryDirectives(details, data.deliveryDirectives, msn, part);
          if (lowLatencyMode || !atLastPartOfSegment) {
            details.requestScheduled = now3;
            this.loadingPlaylist(levelOrTrack, deliveryDirectives);
            return;
          }
        } else if (details.canBlockReload || details.canSkipUntil) {
          deliveryDirectives = this.getDeliveryDirectives(details, data.deliveryDirectives, msn, part);
        }
        if (deliveryDirectives && msn !== void 0 && details.canBlockReload) {
          details.requestScheduled = stats.loading.first + Math.max(reloadInterval - elapsed * 2, reloadInterval / 2);
        }
        this.scheduleLoading(levelOrTrack, deliveryDirectives, details);
      } else {
        this.clearTimer();
      }
    }
    scheduleLoading(levelOrTrack, deliveryDirectives, updatedDetails) {
      const details = updatedDetails || levelOrTrack.details;
      if (!details) {
        this.loadingPlaylist(levelOrTrack, deliveryDirectives);
        return;
      }
      const now3 = self.performance.now();
      const requestScheduled = details.requestScheduled;
      if (now3 >= requestScheduled) {
        this.loadingPlaylist(levelOrTrack, deliveryDirectives);
        return;
      }
      const estimatedTimeUntilUpdate = requestScheduled - now3;
      this.log(`reload live playlist ${levelOrTrack.name || levelOrTrack.bitrate + "bps"} in ${Math.round(estimatedTimeUntilUpdate)} ms`);
      this.clearTimer();
      this.timer = self.setTimeout(() => this.loadingPlaylist(levelOrTrack, deliveryDirectives), estimatedTimeUntilUpdate);
    }
    getDeliveryDirectives(details, previousDeliveryDirectives, msn, part) {
      let skip = getSkipValue(details);
      if (previousDeliveryDirectives != null && previousDeliveryDirectives.skip && details.deltaUpdateFailed) {
        msn = previousDeliveryDirectives.msn;
        part = previousDeliveryDirectives.part;
        skip = HlsSkip.No;
      }
      return new HlsUrlParameters(msn, part, skip);
    }
    checkRetry(errorEvent) {
      const errorDetails = errorEvent.details;
      const isTimeout = isTimeoutError(errorEvent);
      const errorAction = errorEvent.errorAction;
      const {
        action,
        retryCount = 0,
        retryConfig
      } = errorAction || {};
      const retry = !!errorAction && !!retryConfig && (action === NetworkErrorAction.RetryRequest || !errorAction.resolved && action === NetworkErrorAction.SendAlternateToPenaltyBox);
      if (retry) {
        var _errorEvent$context;
        if (retryCount >= retryConfig.maxNumRetry) {
          return false;
        }
        if (isTimeout && (_errorEvent$context = errorEvent.context) != null && _errorEvent$context.deliveryDirectives) {
          this.warn(`Retrying playlist loading ${retryCount + 1}/${retryConfig.maxNumRetry} after "${errorDetails}" without delivery-directives`);
          this.loadPlaylist();
        } else {
          const delay2 = getRetryDelay(retryConfig, retryCount);
          this.clearTimer();
          this.timer = self.setTimeout(() => this.loadPlaylist(), delay2);
          this.warn(`Retrying playlist loading ${retryCount + 1}/${retryConfig.maxNumRetry} after "${errorDetails}" in ${delay2}ms`);
        }
        errorEvent.levelRetry = true;
        errorAction.resolved = true;
      }
      return retry;
    }
  };
  function subtitleOptionsIdentical(trackList1, trackList2) {
    if (trackList1.length !== trackList2.length) {
      return false;
    }
    for (let i = 0; i < trackList1.length; i++) {
      if (!mediaAttributesIdentical(trackList1[i].attrs, trackList2[i].attrs)) {
        return false;
      }
    }
    return true;
  }
  function mediaAttributesIdentical(attrs1, attrs2, customAttributes) {
    const stableRenditionId = attrs1["STABLE-RENDITION-ID"];
    if (stableRenditionId && !customAttributes) {
      return stableRenditionId === attrs2["STABLE-RENDITION-ID"];
    }
    return !(customAttributes || ["LANGUAGE", "NAME", "CHARACTERISTICS", "AUTOSELECT", "DEFAULT", "FORCED", "ASSOC-LANGUAGE"]).some((subtitleAttribute) => attrs1[subtitleAttribute] !== attrs2[subtitleAttribute]);
  }
  function subtitleTrackMatchesTextTrack(subtitleTrack, textTrack) {
    return textTrack.label.toLowerCase() === subtitleTrack.name.toLowerCase() && (!textTrack.language || textTrack.language.toLowerCase() === (subtitleTrack.lang || "").toLowerCase());
  }
  var AudioTrackController = class extends BasePlaylistController {
    constructor(hls) {
      super(hls, "audio-track-controller");
      this.tracks = [];
      this.groupIds = null;
      this.tracksInGroup = [];
      this.trackId = -1;
      this.currentTrack = null;
      this.selectDefaultTrack = true;
      this.registerListeners();
    }
    registerListeners() {
      const {
        hls
      } = this;
      hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);
      hls.on(Events.LEVEL_LOADING, this.onLevelLoading, this);
      hls.on(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);
      hls.on(Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);
      hls.on(Events.ERROR, this.onError, this);
    }
    unregisterListeners() {
      const {
        hls
      } = this;
      hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);
      hls.off(Events.LEVEL_LOADING, this.onLevelLoading, this);
      hls.off(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);
      hls.off(Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);
      hls.off(Events.ERROR, this.onError, this);
    }
    destroy() {
      this.unregisterListeners();
      this.tracks.length = 0;
      this.tracksInGroup.length = 0;
      this.currentTrack = null;
      super.destroy();
    }
    onManifestLoading() {
      this.tracks = [];
      this.tracksInGroup = [];
      this.groupIds = null;
      this.currentTrack = null;
      this.trackId = -1;
      this.selectDefaultTrack = true;
    }
    onManifestParsed(event, data) {
      this.tracks = data.audioTracks || [];
    }
    onAudioTrackLoaded(event, data) {
      const {
        id: id3,
        groupId,
        details
      } = data;
      const trackInActiveGroup = this.tracksInGroup[id3];
      if (!trackInActiveGroup || trackInActiveGroup.groupId !== groupId) {
        this.warn(`Audio track with id:${id3} and group:${groupId} not found in active group ${trackInActiveGroup == null ? void 0 : trackInActiveGroup.groupId}`);
        return;
      }
      const curDetails = trackInActiveGroup.details;
      trackInActiveGroup.details = data.details;
      this.log(`Audio track ${id3} "${trackInActiveGroup.name}" lang:${trackInActiveGroup.lang} group:${groupId} loaded [${details.startSN}-${details.endSN}]`);
      if (id3 === this.trackId) {
        this.playlistLoaded(id3, data, curDetails);
      }
    }
    onLevelLoading(event, data) {
      this.switchLevel(data.level);
    }
    onLevelSwitching(event, data) {
      this.switchLevel(data.level);
    }
    switchLevel(levelIndex) {
      const levelInfo = this.hls.levels[levelIndex];
      if (!levelInfo) {
        return;
      }
      const audioGroups = levelInfo.audioGroups || null;
      const currentGroups = this.groupIds;
      let currentTrack = this.currentTrack;
      if (!audioGroups || (currentGroups == null ? void 0 : currentGroups.length) !== (audioGroups == null ? void 0 : audioGroups.length) || audioGroups != null && audioGroups.some((groupId) => (currentGroups == null ? void 0 : currentGroups.indexOf(groupId)) === -1)) {
        this.groupIds = audioGroups;
        this.trackId = -1;
        this.currentTrack = null;
        const audioTracks = this.tracks.filter((track) => !audioGroups || audioGroups.indexOf(track.groupId) !== -1);
        if (audioTracks.length) {
          if (this.selectDefaultTrack && !audioTracks.some((track) => track.default)) {
            this.selectDefaultTrack = false;
          }
          audioTracks.forEach((track, i) => {
            track.id = i;
          });
        } else if (!currentTrack && !this.tracksInGroup.length) {
          return;
        }
        this.tracksInGroup = audioTracks;
        const audioPreference = this.hls.config.audioPreference;
        if (!currentTrack && audioPreference) {
          const groupIndex = findMatchingOption(audioPreference, audioTracks, audioMatchPredicate);
          if (groupIndex > -1) {
            currentTrack = audioTracks[groupIndex];
          } else {
            const allIndex = findMatchingOption(audioPreference, this.tracks);
            currentTrack = this.tracks[allIndex];
          }
        }
        let trackId = this.findTrackId(currentTrack);
        if (trackId === -1 && currentTrack) {
          trackId = this.findTrackId(null);
        }
        const audioTracksUpdated = {
          audioTracks
        };
        this.log(`Updating audio tracks, ${audioTracks.length} track(s) found in group(s): ${audioGroups == null ? void 0 : audioGroups.join(",")}`);
        this.hls.trigger(Events.AUDIO_TRACKS_UPDATED, audioTracksUpdated);
        const selectedTrackId = this.trackId;
        if (trackId !== -1 && selectedTrackId === -1) {
          this.setAudioTrack(trackId);
        } else if (audioTracks.length && selectedTrackId === -1) {
          var _this$groupIds;
          const error = new Error(`No audio track selected for current audio group-ID(s): ${(_this$groupIds = this.groupIds) == null ? void 0 : _this$groupIds.join(",")} track count: ${audioTracks.length}`);
          this.warn(error.message);
          this.hls.trigger(Events.ERROR, {
            type: ErrorTypes.MEDIA_ERROR,
            details: ErrorDetails.AUDIO_TRACK_LOAD_ERROR,
            fatal: true,
            error
          });
        }
      }
    }
    onError(event, data) {
      if (data.fatal || !data.context) {
        return;
      }
      if (data.context.type === PlaylistContextType.AUDIO_TRACK && data.context.id === this.trackId && (!this.groupIds || this.groupIds.indexOf(data.context.groupId) !== -1)) {
        this.checkRetry(data);
      }
    }
    get allAudioTracks() {
      return this.tracks;
    }
    get audioTracks() {
      return this.tracksInGroup;
    }
    get audioTrack() {
      return this.trackId;
    }
    set audioTrack(newId) {
      this.selectDefaultTrack = false;
      this.setAudioTrack(newId);
    }
    setAudioOption(audioOption) {
      const hls = this.hls;
      hls.config.audioPreference = audioOption;
      if (audioOption) {
        const allAudioTracks = this.allAudioTracks;
        this.selectDefaultTrack = false;
        if (allAudioTracks.length) {
          const currentTrack = this.currentTrack;
          if (currentTrack && matchesOption(audioOption, currentTrack, audioMatchPredicate)) {
            return currentTrack;
          }
          const groupIndex = findMatchingOption(audioOption, this.tracksInGroup, audioMatchPredicate);
          if (groupIndex > -1) {
            const track = this.tracksInGroup[groupIndex];
            this.setAudioTrack(groupIndex);
            return track;
          } else if (currentTrack) {
            let searchIndex = hls.loadLevel;
            if (searchIndex === -1) {
              searchIndex = hls.firstAutoLevel;
            }
            const switchIndex = findClosestLevelWithAudioGroup(audioOption, hls.levels, allAudioTracks, searchIndex, audioMatchPredicate);
            if (switchIndex === -1) {
              return null;
            }
            hls.nextLoadLevel = switchIndex;
          }
          if (audioOption.channels || audioOption.audioCodec) {
            const withoutCodecAndChannelsMatch = findMatchingOption(audioOption, allAudioTracks);
            if (withoutCodecAndChannelsMatch > -1) {
              return allAudioTracks[withoutCodecAndChannelsMatch];
            }
          }
        }
      }
      return null;
    }
    setAudioTrack(newId) {
      const tracks = this.tracksInGroup;
      if (newId < 0 || newId >= tracks.length) {
        this.warn(`Invalid audio track id: ${newId}`);
        return;
      }
      this.selectDefaultTrack = false;
      const lastTrack = this.currentTrack;
      const track = tracks[newId];
      const trackLoaded = track.details && !track.details.live;
      if (newId === this.trackId && track === lastTrack && trackLoaded) {
        return;
      }
      this.log(`Switching to audio-track ${newId} "${track.name}" lang:${track.lang} group:${track.groupId} channels:${track.channels}`);
      this.trackId = newId;
      this.currentTrack = track;
      this.hls.trigger(Events.AUDIO_TRACK_SWITCHING, _objectSpread2({}, track));
      if (trackLoaded) {
        return;
      }
      const hlsUrlParameters = this.switchParams(track.url, lastTrack == null ? void 0 : lastTrack.details, track.details);
      this.loadPlaylist(hlsUrlParameters);
    }
    findTrackId(currentTrack) {
      const audioTracks = this.tracksInGroup;
      for (let i = 0; i < audioTracks.length; i++) {
        const track = audioTracks[i];
        if (this.selectDefaultTrack && !track.default) {
          continue;
        }
        if (!currentTrack || matchesOption(currentTrack, track, audioMatchPredicate)) {
          return i;
        }
      }
      if (currentTrack) {
        const {
          name,
          lang,
          assocLang,
          characteristics,
          audioCodec,
          channels
        } = currentTrack;
        for (let i = 0; i < audioTracks.length; i++) {
          const track = audioTracks[i];
          if (matchesOption({
            name,
            lang,
            assocLang,
            characteristics,
            audioCodec,
            channels
          }, track, audioMatchPredicate)) {
            return i;
          }
        }
        for (let i = 0; i < audioTracks.length; i++) {
          const track = audioTracks[i];
          if (mediaAttributesIdentical(currentTrack.attrs, track.attrs, ["LANGUAGE", "ASSOC-LANGUAGE", "CHARACTERISTICS"])) {
            return i;
          }
        }
        for (let i = 0; i < audioTracks.length; i++) {
          const track = audioTracks[i];
          if (mediaAttributesIdentical(currentTrack.attrs, track.attrs, ["LANGUAGE"])) {
            return i;
          }
        }
      }
      return -1;
    }
    loadPlaylist(hlsUrlParameters) {
      super.loadPlaylist();
      const audioTrack = this.currentTrack;
      if (!this.shouldLoadPlaylist(audioTrack)) {
        return;
      }
      if (useAlternateAudio(audioTrack.url, this.hls)) {
        this.scheduleLoading(audioTrack, hlsUrlParameters);
      }
    }
    loadingPlaylist(audioTrack, hlsUrlParameters) {
      super.loadingPlaylist(audioTrack, hlsUrlParameters);
      const id3 = audioTrack.id;
      const groupId = audioTrack.groupId;
      const url = this.getUrlWithDirectives(audioTrack.url, hlsUrlParameters);
      const details = audioTrack.details;
      const age = details == null ? void 0 : details.age;
      this.log(`Loading audio-track ${id3} "${audioTrack.name}" lang:${audioTrack.lang} group:${groupId}${(hlsUrlParameters == null ? void 0 : hlsUrlParameters.msn) !== void 0 ? " at sn " + hlsUrlParameters.msn + " part " + hlsUrlParameters.part : ""}${age && details.live ? " age " + age.toFixed(1) + (details.type ? " " + details.type || "" : "") : ""} ${url}`);
      this.hls.trigger(Events.AUDIO_TRACK_LOADING, {
        url,
        id: id3,
        groupId,
        deliveryDirectives: hlsUrlParameters || null,
        track: audioTrack
      });
    }
  };
  var BufferOperationQueue = class {
    constructor(sourceBufferReference) {
      this.tracks = void 0;
      this.queues = {
        video: [],
        audio: [],
        audiovideo: []
      };
      this.tracks = sourceBufferReference;
    }
    destroy() {
      this.tracks = this.queues = null;
    }
    append(operation, type, pending) {
      if (this.queues === null || this.tracks === null) {
        return;
      }
      const queue = this.queues[type];
      queue.push(operation);
      if (queue.length === 1 && !pending) {
        this.executeNext(type);
      }
    }
    appendBlocker(type) {
      return new Promise((resolve) => {
        const operation = {
          label: "async-blocker",
          execute: resolve,
          onStart: () => {
          },
          onComplete: () => {
          },
          onError: () => {
          }
        };
        this.append(operation, type);
      });
    }
    prependBlocker(type) {
      return new Promise((resolve) => {
        if (this.queues) {
          const operation = {
            label: "async-blocker-prepend",
            execute: resolve,
            onStart: () => {
            },
            onComplete: () => {
            },
            onError: () => {
            }
          };
          this.queues[type].unshift(operation);
        }
      });
    }
    removeBlockers() {
      if (this.queues === null) {
        return;
      }
      [this.queues.video, this.queues.audio, this.queues.audiovideo].forEach((queue) => {
        var _queue$;
        const label = (_queue$ = queue[0]) == null ? void 0 : _queue$.label;
        if (label === "async-blocker" || label === "async-blocker-prepend") {
          queue[0].execute();
          queue.splice(0, 1);
        }
      });
    }
    unblockAudio(op) {
      if (this.queues === null) {
        return;
      }
      const queue = this.queues.audio;
      if (queue[0] === op) {
        this.shiftAndExecuteNext("audio");
      }
    }
    executeNext(type) {
      if (this.queues === null || this.tracks === null) {
        return;
      }
      const queue = this.queues[type];
      if (queue.length) {
        const operation = queue[0];
        try {
          operation.execute();
        } catch (error) {
          var _this$tracks$type;
          operation.onError(error);
          if (this.queues === null || this.tracks === null) {
            return;
          }
          const sb = (_this$tracks$type = this.tracks[type]) == null ? void 0 : _this$tracks$type.buffer;
          if (!(sb != null && sb.updating)) {
            this.shiftAndExecuteNext(type);
          }
        }
      }
    }
    shiftAndExecuteNext(type) {
      if (this.queues === null) {
        return;
      }
      this.queues[type].shift();
      this.executeNext(type);
    }
    current(type) {
      var _this$queues;
      return ((_this$queues = this.queues) == null ? void 0 : _this$queues[type][0]) || null;
    }
    toString() {
      const {
        queues,
        tracks
      } = this;
      if (queues === null || tracks === null) {
        return `<destroyed>`;
      }
      return `
${this.list("video")}
${this.list("audio")}
${this.list("audiovideo")}}`;
    }
    list(type) {
      var _this$queues2, _this$tracks;
      return (_this$queues2 = this.queues) != null && _this$queues2[type] || (_this$tracks = this.tracks) != null && _this$tracks[type] ? `${type}: (${this.listSbInfo(type)}) ${this.listOps(type)}` : "";
    }
    listSbInfo(type) {
      var _this$tracks2;
      const track = (_this$tracks2 = this.tracks) == null ? void 0 : _this$tracks2[type];
      const sb = track == null ? void 0 : track.buffer;
      if (!sb) {
        return "none";
      }
      return `SourceBuffer${sb.updating ? " updating" : ""}${track.ended ? " ended" : ""}${track.ending ? " ending" : ""}`;
    }
    listOps(type) {
      var _this$queues3;
      return ((_this$queues3 = this.queues) == null ? void 0 : _this$queues3[type].map((op) => op.label).join(", ")) || "";
    }
  };
  var VIDEO_CODEC_PROFILE_REPLACE = /(avc[1234]|hvc1|hev1|dvh[1e]|vp09|av01)(?:\.[^.,]+)+/;
  var TRACK_REMOVED_ERROR_NAME = "HlsJsTrackRemovedError";
  var HlsJsTrackRemovedError = class extends Error {
    constructor(message) {
      super(message);
      this.name = TRACK_REMOVED_ERROR_NAME;
    }
  };
  var BufferController = class extends Logger {
    constructor(hls, fragmentTracker) {
      super("buffer-controller", hls.logger);
      this.hls = void 0;
      this.fragmentTracker = void 0;
      this.details = null;
      this._objectUrl = null;
      this.operationQueue = null;
      this.bufferCodecEventsTotal = 0;
      this.media = null;
      this.mediaSource = null;
      this.lastMpegAudioChunk = null;
      this.blockedAudioAppend = null;
      this.lastVideoAppendEnd = 0;
      this.appendSource = void 0;
      this.transferData = void 0;
      this.overrides = void 0;
      this.appendErrors = {
        audio: 0,
        video: 0,
        audiovideo: 0
      };
      this.tracks = {};
      this.sourceBuffers = [[null, null], [null, null]];
      this._onEndStreaming = (event) => {
        var _this$mediaSource;
        if (!this.hls) {
          return;
        }
        if (((_this$mediaSource = this.mediaSource) == null ? void 0 : _this$mediaSource.readyState) !== "open") {
          return;
        }
        this.hls.pauseBuffering();
      };
      this._onStartStreaming = (event) => {
        if (!this.hls) {
          return;
        }
        this.hls.resumeBuffering();
      };
      this._onMediaSourceOpen = (e) => {
        const {
          media,
          mediaSource
        } = this;
        if (e) {
          this.log("Media source opened");
        }
        if (!media || !mediaSource) {
          return;
        }
        mediaSource.removeEventListener("sourceopen", this._onMediaSourceOpen);
        media.removeEventListener("emptied", this._onMediaEmptied);
        this.updateDuration();
        this.hls.trigger(Events.MEDIA_ATTACHED, {
          media,
          mediaSource
        });
        if (this.mediaSource !== null) {
          this.checkPendingTracks();
        }
      };
      this._onMediaSourceClose = () => {
        this.log("Media source closed");
      };
      this._onMediaSourceEnded = () => {
        this.log("Media source ended");
      };
      this._onMediaEmptied = () => {
        const {
          mediaSrc,
          _objectUrl
        } = this;
        if (mediaSrc !== _objectUrl) {
          this.error(`Media element src was set while attaching MediaSource (${_objectUrl} > ${mediaSrc})`);
        }
      };
      this.hls = hls;
      this.fragmentTracker = fragmentTracker;
      this.appendSource = isManagedMediaSource(getMediaSource(hls.config.preferManagedMediaSource));
      this.initTracks();
      this.registerListeners();
    }
    hasSourceTypes() {
      return Object.keys(this.tracks).length > 0;
    }
    destroy() {
      this.unregisterListeners();
      this.details = null;
      this.lastMpegAudioChunk = this.blockedAudioAppend = null;
      this.transferData = this.overrides = void 0;
      if (this.operationQueue) {
        this.operationQueue.destroy();
        this.operationQueue = null;
      }
      this.hls = this.fragmentTracker = null;
      this._onMediaSourceOpen = this._onMediaSourceClose = null;
      this._onMediaSourceEnded = null;
      this._onStartStreaming = this._onEndStreaming = null;
    }
    registerListeners() {
      const {
        hls
      } = this;
      hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);
      hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
      hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);
      hls.on(Events.BUFFER_RESET, this.onBufferReset, this);
      hls.on(Events.BUFFER_APPENDING, this.onBufferAppending, this);
      hls.on(Events.BUFFER_CODECS, this.onBufferCodecs, this);
      hls.on(Events.BUFFER_EOS, this.onBufferEos, this);
      hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);
      hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);
      hls.on(Events.FRAG_PARSED, this.onFragParsed, this);
      hls.on(Events.FRAG_CHANGED, this.onFragChanged, this);
      hls.on(Events.ERROR, this.onError, this);
    }
    unregisterListeners() {
      const {
        hls
      } = this;
      hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);
      hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
      hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);
      hls.off(Events.BUFFER_RESET, this.onBufferReset, this);
      hls.off(Events.BUFFER_APPENDING, this.onBufferAppending, this);
      hls.off(Events.BUFFER_CODECS, this.onBufferCodecs, this);
      hls.off(Events.BUFFER_EOS, this.onBufferEos, this);
      hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);
      hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);
      hls.off(Events.FRAG_PARSED, this.onFragParsed, this);
      hls.off(Events.FRAG_CHANGED, this.onFragChanged, this);
      hls.off(Events.ERROR, this.onError, this);
    }
    transferMedia() {
      const {
        media,
        mediaSource
      } = this;
      if (!media) {
        return null;
      }
      const tracks = {};
      if (this.operationQueue) {
        const updating = this.isUpdating();
        if (!updating) {
          this.operationQueue.removeBlockers();
        }
        const queued = this.isQueued();
        if (updating || queued) {
          this.warn(`Transfering MediaSource with${queued ? " operations in queue" : ""}${updating ? " updating SourceBuffer(s)" : ""} ${this.operationQueue}`);
        }
        this.operationQueue.destroy();
      }
      const transferData = this.transferData;
      if (!this.sourceBufferCount && transferData && transferData.mediaSource === mediaSource) {
        _extends4(tracks, transferData.tracks);
      } else {
        this.sourceBuffers.forEach((tuple) => {
          const [type] = tuple;
          if (type) {
            tracks[type] = _extends4({}, this.tracks[type]);
            this.removeBuffer(type);
          }
          tuple[0] = tuple[1] = null;
        });
      }
      return {
        media,
        mediaSource,
        tracks
      };
    }
    initTracks() {
      const tracks = {};
      this.sourceBuffers = [[null, null], [null, null]];
      this.tracks = tracks;
      this.resetQueue();
      this.resetAppendErrors();
      this.lastMpegAudioChunk = this.blockedAudioAppend = null;
      this.lastVideoAppendEnd = 0;
    }
    onManifestLoading() {
      this.bufferCodecEventsTotal = 0;
      this.details = null;
    }
    onManifestParsed(event, data) {
      var _this$transferData;
      let codecEvents = 2;
      if (data.audio && !data.video || !data.altAudio) {
        codecEvents = 1;
      }
      this.bufferCodecEventsTotal = codecEvents;
      this.log(`${codecEvents} bufferCodec event(s) expected.`);
      if ((_this$transferData = this.transferData) != null && _this$transferData.mediaSource && this.sourceBufferCount && codecEvents) {
        this.bufferCreated();
      }
    }
    onMediaAttaching(event, data) {
      const media = this.media = data.media;
      this.transferData = this.overrides = void 0;
      const MediaSource = getMediaSource(this.appendSource);
      if (MediaSource) {
        const transferringMedia = !!data.mediaSource;
        if (transferringMedia || data.overrides) {
          this.transferData = data;
          this.overrides = data.overrides;
        }
        const ms = this.mediaSource = data.mediaSource || new MediaSource();
        this.assignMediaSource(ms);
        if (transferringMedia) {
          this._objectUrl = media.src;
          this.attachTransferred();
        } else {
          const objectUrl = this._objectUrl = self.URL.createObjectURL(ms);
          if (this.appendSource) {
            try {
              media.removeAttribute("src");
              const MMS = self.ManagedMediaSource;
              media.disableRemotePlayback = media.disableRemotePlayback || MMS && ms instanceof MMS;
              removeSourceChildren(media);
              addSource(media, objectUrl);
              media.load();
            } catch (error) {
              media.src = objectUrl;
            }
          } else {
            media.src = objectUrl;
          }
        }
        media.addEventListener("emptied", this._onMediaEmptied);
      }
    }
    assignMediaSource(ms) {
      var _this$transferData2, _ms$constructor;
      this.log(`${((_this$transferData2 = this.transferData) == null ? void 0 : _this$transferData2.mediaSource) === ms ? "transferred" : "created"} media source: ${(_ms$constructor = ms.constructor) == null ? void 0 : _ms$constructor.name}`);
      ms.addEventListener("sourceopen", this._onMediaSourceOpen);
      ms.addEventListener("sourceended", this._onMediaSourceEnded);
      ms.addEventListener("sourceclose", this._onMediaSourceClose);
      if (this.appendSource) {
        ms.addEventListener("startstreaming", this._onStartStreaming);
        ms.addEventListener("endstreaming", this._onEndStreaming);
      }
    }
    attachTransferred() {
      const media = this.media;
      const data = this.transferData;
      if (!data || !media) {
        return;
      }
      const requiredTracks = this.tracks;
      const transferredTracks = data.tracks;
      const trackNames = transferredTracks ? Object.keys(transferredTracks) : null;
      const trackCount = trackNames ? trackNames.length : 0;
      const mediaSourceOpenCallback = () => {
        Promise.resolve().then(() => {
          if (this.media && this.mediaSourceOpenOrEnded) {
            this._onMediaSourceOpen();
          }
        });
      };
      if (transferredTracks && trackNames && trackCount) {
        if (!this.tracksReady) {
          this.hls.config.startFragPrefetch = true;
          this.log(`attachTransferred: waiting for SourceBuffer track info`);
          return;
        }
        this.log(`attachTransferred: (bufferCodecEventsTotal ${this.bufferCodecEventsTotal})
required tracks: ${stringify(requiredTracks, (key, value) => key === "initSegment" ? void 0 : value)};
transfer tracks: ${stringify(transferredTracks, (key, value) => key === "initSegment" ? void 0 : value)}}`);
        if (!isCompatibleTrackChange(transferredTracks, requiredTracks)) {
          data.mediaSource = null;
          data.tracks = void 0;
          const currentTime = media.currentTime;
          const details = this.details;
          const startTime = Math.max(currentTime, (details == null ? void 0 : details.fragments[0].start) || 0);
          if (startTime - currentTime > 1) {
            this.log(`attachTransferred: waiting for playback to reach new tracks start time ${currentTime} -> ${startTime}`);
            return;
          }
          this.warn(`attachTransferred: resetting MediaSource for incompatible tracks ("${Object.keys(transferredTracks)}"->"${Object.keys(requiredTracks)}") start time: ${startTime} currentTime: ${currentTime}`);
          this.onMediaDetaching(Events.MEDIA_DETACHING, {});
          this.onMediaAttaching(Events.MEDIA_ATTACHING, data);
          media.currentTime = startTime;
          return;
        }
        this.transferData = void 0;
        trackNames.forEach((trackName) => {
          const type = trackName;
          const track = transferredTracks[type];
          if (track) {
            const sb = track.buffer;
            if (sb) {
              const fragmentTracker = this.fragmentTracker;
              const playlistType = track.id;
              if (fragmentTracker.hasFragments(playlistType) || fragmentTracker.hasParts(playlistType)) {
                const bufferedTimeRanges = BufferHelper.getBuffered(sb);
                fragmentTracker.detectEvictedFragments(type, bufferedTimeRanges, playlistType, null, true);
              }
              const sbIndex = sourceBufferNameToIndex(type);
              const sbTuple = [type, sb];
              this.sourceBuffers[sbIndex] = sbTuple;
              if (sb.updating && this.operationQueue) {
                this.operationQueue.prependBlocker(type);
              }
              this.trackSourceBuffer(type, track);
            }
          }
        });
        mediaSourceOpenCallback();
        this.bufferCreated();
      } else {
        this.log(`attachTransferred: MediaSource w/o SourceBuffers`);
        mediaSourceOpenCallback();
      }
    }
    get mediaSourceOpenOrEnded() {
      var _this$mediaSource2;
      const readyState = (_this$mediaSource2 = this.mediaSource) == null ? void 0 : _this$mediaSource2.readyState;
      return readyState === "open" || readyState === "ended";
    }
    onMediaDetaching(event, data) {
      const transferringMedia = !!data.transferMedia;
      this.transferData = this.overrides = void 0;
      const {
        media,
        mediaSource,
        _objectUrl
      } = this;
      if (mediaSource) {
        this.log(`media source ${transferringMedia ? "transferring" : "detaching"}`);
        if (transferringMedia) {
          this.sourceBuffers.forEach(([type]) => {
            if (type) {
              this.removeBuffer(type);
            }
          });
          this.resetQueue();
        } else {
          if (this.mediaSourceOpenOrEnded) {
            const open = mediaSource.readyState === "open";
            try {
              const sourceBuffers = mediaSource.sourceBuffers;
              for (let i = sourceBuffers.length; i--; ) {
                if (open) {
                  sourceBuffers[i].abort();
                }
                mediaSource.removeSourceBuffer(sourceBuffers[i]);
              }
              if (open) {
                mediaSource.endOfStream();
              }
            } catch (err) {
              this.warn(`onMediaDetaching: ${err.message} while calling endOfStream`);
            }
          }
          if (this.sourceBufferCount) {
            this.onBufferReset();
          }
        }
        mediaSource.removeEventListener("sourceopen", this._onMediaSourceOpen);
        mediaSource.removeEventListener("sourceended", this._onMediaSourceEnded);
        mediaSource.removeEventListener("sourceclose", this._onMediaSourceClose);
        if (this.appendSource) {
          mediaSource.removeEventListener("startstreaming", this._onStartStreaming);
          mediaSource.removeEventListener("endstreaming", this._onEndStreaming);
        }
        this.mediaSource = null;
        this._objectUrl = null;
      }
      if (media) {
        media.removeEventListener("emptied", this._onMediaEmptied);
        if (!transferringMedia) {
          if (_objectUrl) {
            self.URL.revokeObjectURL(_objectUrl);
          }
          if (this.mediaSrc === _objectUrl) {
            media.removeAttribute("src");
            if (this.appendSource) {
              removeSourceChildren(media);
            }
            media.load();
          } else {
            this.warn("media|source.src was changed by a third party - skip cleanup");
          }
        }
        this.media = null;
      }
      this.hls.trigger(Events.MEDIA_DETACHED, data);
    }
    onBufferReset() {
      this.sourceBuffers.forEach(([type]) => {
        if (type) {
          this.resetBuffer(type);
        }
      });
      this.initTracks();
    }
    resetBuffer(type) {
      var _this$tracks$type;
      const sb = (_this$tracks$type = this.tracks[type]) == null ? void 0 : _this$tracks$type.buffer;
      this.removeBuffer(type);
      if (sb) {
        try {
          var _this$mediaSource3;
          if ((_this$mediaSource3 = this.mediaSource) != null && _this$mediaSource3.sourceBuffers.length) {
            this.mediaSource.removeSourceBuffer(sb);
          }
        } catch (err) {
          this.warn(`onBufferReset ${type}`, err);
        }
      }
      delete this.tracks[type];
    }
    removeBuffer(type) {
      this.removeBufferListeners(type);
      this.sourceBuffers[sourceBufferNameToIndex(type)] = [null, null];
      const track = this.tracks[type];
      if (track) {
        track.buffer = void 0;
      }
    }
    resetQueue() {
      if (this.operationQueue) {
        this.operationQueue.destroy();
      }
      this.operationQueue = new BufferOperationQueue(this.tracks);
    }
    onBufferCodecs(event, data) {
      var _data$audio;
      const tracks = this.tracks;
      const trackNames = Object.keys(data);
      this.log(`BUFFER_CODECS: "${trackNames}" (current SB count ${this.sourceBufferCount})`);
      const unmuxedToMuxed = "audiovideo" in data && (tracks.audio || tracks.video) || tracks.audiovideo && ("audio" in data || "video" in data);
      const muxedToUnmuxed = !unmuxedToMuxed && this.sourceBufferCount && this.media && trackNames.some((sbName) => !tracks[sbName]);
      if (unmuxedToMuxed || muxedToUnmuxed) {
        this.warn(`Unsupported transition between "${Object.keys(tracks)}" and "${trackNames}" SourceBuffers`);
        return;
      }
      trackNames.forEach((trackName) => {
        var _this$transferData3, _trackCodec;
        const parsedTrack = data[trackName];
        const {
          id: id3,
          codec,
          levelCodec,
          container: container2,
          metadata,
          supplemental
        } = parsedTrack;
        let track = tracks[trackName];
        const transferredTrack = (_this$transferData3 = this.transferData) == null || (_this$transferData3 = _this$transferData3.tracks) == null ? void 0 : _this$transferData3[trackName];
        const sbTrack = transferredTrack != null && transferredTrack.buffer ? transferredTrack : track;
        const sbCodec = (sbTrack == null ? void 0 : sbTrack.pendingCodec) || (sbTrack == null ? void 0 : sbTrack.codec);
        const trackLevelCodec = sbTrack == null ? void 0 : sbTrack.levelCodec;
        if (!track) {
          track = tracks[trackName] = {
            buffer: void 0,
            listeners: [],
            codec,
            supplemental,
            container: container2,
            levelCodec,
            metadata,
            id: id3
          };
        }
        const currentCodecFull = pickMostCompleteCodecName(sbCodec, trackLevelCodec);
        const currentCodec = currentCodecFull == null ? void 0 : currentCodecFull.replace(VIDEO_CODEC_PROFILE_REPLACE, "$1");
        let trackCodec = pickMostCompleteCodecName(codec, levelCodec);
        const nextCodec = (_trackCodec = trackCodec) == null ? void 0 : _trackCodec.replace(VIDEO_CODEC_PROFILE_REPLACE, "$1");
        if (trackCodec && currentCodecFull && currentCodec !== nextCodec) {
          if (trackName.slice(0, 5) === "audio") {
            trackCodec = getCodecCompatibleName(trackCodec, this.appendSource);
          }
          this.log(`switching codec ${sbCodec} to ${trackCodec}`);
          if (trackCodec !== (track.pendingCodec || track.codec)) {
            track.pendingCodec = trackCodec;
          }
          track.container = container2;
          this.appendChangeType(trackName, container2, trackCodec);
        }
      });
      if (this.tracksReady || this.sourceBufferCount) {
        data.tracks = this.sourceBufferTracks;
      }
      if (this.sourceBufferCount) {
        return;
      }
      if (this.bufferCodecEventsTotal > 1 && !this.tracks.video && !data.video && ((_data$audio = data.audio) == null ? void 0 : _data$audio.id) === "main") {
        this.log(`Main audio-only`);
        this.bufferCodecEventsTotal = 1;
      }
      if (this.mediaSourceOpenOrEnded) {
        this.checkPendingTracks();
      }
    }
    get sourceBufferTracks() {
      return Object.keys(this.tracks).reduce((baseTracks, type) => {
        const track = this.tracks[type];
        baseTracks[type] = {
          id: track.id,
          container: track.container,
          codec: track.codec,
          levelCodec: track.levelCodec
        };
        return baseTracks;
      }, {});
    }
    appendChangeType(type, container2, codec) {
      const mimeType = `${container2};codecs=${codec}`;
      const operation = {
        label: `change-type=${mimeType}`,
        execute: () => {
          const track = this.tracks[type];
          if (track) {
            const sb = track.buffer;
            if (sb != null && sb.changeType) {
              this.log(`changing ${type} sourceBuffer type to ${mimeType}`);
              sb.changeType(mimeType);
              track.codec = codec;
              track.container = container2;
            }
          }
          this.shiftAndExecuteNext(type);
        },
        onStart: () => {
        },
        onComplete: () => {
        },
        onError: (error) => {
          this.warn(`Failed to change ${type} SourceBuffer type`, error);
        }
      };
      this.append(operation, type, this.isPending(this.tracks[type]));
    }
    blockAudio(partOrFrag) {
      var _this$fragmentTracker;
      const pStart = partOrFrag.start;
      const pTime = pStart + partOrFrag.duration * 0.05;
      const atGap = ((_this$fragmentTracker = this.fragmentTracker.getAppendedFrag(pStart, PlaylistLevelType.MAIN)) == null ? void 0 : _this$fragmentTracker.gap) === true;
      if (atGap) {
        return;
      }
      const op = {
        label: "block-audio",
        execute: () => {
          var _this$fragmentTracker2;
          const videoTrack = this.tracks.video;
          if (this.lastVideoAppendEnd > pTime || videoTrack != null && videoTrack.buffer && BufferHelper.isBuffered(videoTrack.buffer, pTime) || ((_this$fragmentTracker2 = this.fragmentTracker.getAppendedFrag(pTime, PlaylistLevelType.MAIN)) == null ? void 0 : _this$fragmentTracker2.gap) === true) {
            this.blockedAudioAppend = null;
            this.shiftAndExecuteNext("audio");
          }
        },
        onStart: () => {
        },
        onComplete: () => {
        },
        onError: (error) => {
          this.warn("Error executing block-audio operation", error);
        }
      };
      this.blockedAudioAppend = {
        op,
        frag: partOrFrag
      };
      this.append(op, "audio", true);
    }
    unblockAudio() {
      const {
        blockedAudioAppend,
        operationQueue
      } = this;
      if (blockedAudioAppend && operationQueue) {
        this.blockedAudioAppend = null;
        operationQueue.unblockAudio(blockedAudioAppend.op);
      }
    }
    onBufferAppending(event, eventData) {
      const {
        tracks
      } = this;
      const {
        data,
        type,
        parent,
        frag,
        part,
        chunkMeta,
        offset
      } = eventData;
      const chunkStats = chunkMeta.buffering[type];
      const {
        sn,
        cc
      } = frag;
      const bufferAppendingStart = self.performance.now();
      chunkStats.start = bufferAppendingStart;
      const fragBuffering = frag.stats.buffering;
      const partBuffering = part ? part.stats.buffering : null;
      if (fragBuffering.start === 0) {
        fragBuffering.start = bufferAppendingStart;
      }
      if (partBuffering && partBuffering.start === 0) {
        partBuffering.start = bufferAppendingStart;
      }
      const audioTrack = tracks.audio;
      let checkTimestampOffset = false;
      if (type === "audio" && (audioTrack == null ? void 0 : audioTrack.container) === "audio/mpeg") {
        checkTimestampOffset = !this.lastMpegAudioChunk || chunkMeta.id === 1 || this.lastMpegAudioChunk.sn !== chunkMeta.sn;
        this.lastMpegAudioChunk = chunkMeta;
      }
      const videoTrack = tracks.video;
      const videoSb = videoTrack == null ? void 0 : videoTrack.buffer;
      if (videoSb && sn !== "initSegment") {
        const partOrFrag = part || frag;
        const blockedAudioAppend = this.blockedAudioAppend;
        if (type === "audio" && parent !== "main" && !this.blockedAudioAppend && !(videoTrack.ending || videoTrack.ended)) {
          const pStart = partOrFrag.start;
          const pTime = pStart + partOrFrag.duration * 0.05;
          const vbuffered = videoSb.buffered;
          const vappending = this.currentOp("video");
          if (!vbuffered.length && !vappending) {
            this.blockAudio(partOrFrag);
          } else if (!vappending && !BufferHelper.isBuffered(videoSb, pTime) && this.lastVideoAppendEnd < pTime) {
            this.blockAudio(partOrFrag);
          }
        } else if (type === "video") {
          const videoAppendEnd = partOrFrag.end;
          if (blockedAudioAppend) {
            const audioStart = blockedAudioAppend.frag.start;
            if (videoAppendEnd > audioStart || videoAppendEnd < this.lastVideoAppendEnd || BufferHelper.isBuffered(videoSb, audioStart)) {
              this.unblockAudio();
            }
          }
          this.lastVideoAppendEnd = videoAppendEnd;
        }
      }
      const fragStart = (part || frag).start;
      const operation = {
        label: `append-${type}`,
        execute: () => {
          var _this$tracks$type2;
          chunkStats.executeStart = self.performance.now();
          const sb = (_this$tracks$type2 = this.tracks[type]) == null ? void 0 : _this$tracks$type2.buffer;
          if (sb) {
            if (checkTimestampOffset) {
              this.updateTimestampOffset(sb, fragStart, 0.1, type, sn, cc);
            } else if (offset !== void 0 && isFiniteNumber(offset)) {
              this.updateTimestampOffset(sb, offset, 1e-6, type, sn, cc);
            }
          }
          this.appendExecutor(data, type);
        },
        onStart: () => {
        },
        onComplete: () => {
          const end = self.performance.now();
          chunkStats.executeEnd = chunkStats.end = end;
          if (fragBuffering.first === 0) {
            fragBuffering.first = end;
          }
          if (partBuffering && partBuffering.first === 0) {
            partBuffering.first = end;
          }
          const timeRanges = {};
          this.sourceBuffers.forEach(([type2, sb]) => {
            if (type2) {
              timeRanges[type2] = BufferHelper.getBuffered(sb);
            }
          });
          this.appendErrors[type] = 0;
          if (type === "audio" || type === "video") {
            this.appendErrors.audiovideo = 0;
          } else {
            this.appendErrors.audio = 0;
            this.appendErrors.video = 0;
          }
          this.hls.trigger(Events.BUFFER_APPENDED, {
            type,
            frag,
            part,
            chunkMeta,
            parent: frag.type,
            timeRanges
          });
        },
        onError: (error) => {
          var _this$media;
          const event2 = {
            type: ErrorTypes.MEDIA_ERROR,
            parent: frag.type,
            details: ErrorDetails.BUFFER_APPEND_ERROR,
            sourceBufferName: type,
            frag,
            part,
            chunkMeta,
            error,
            err: error,
            fatal: false
          };
          const mediaError = (_this$media = this.media) == null ? void 0 : _this$media.error;
          if (error.code === DOMException.QUOTA_EXCEEDED_ERR || error.name == "QuotaExceededError" || `quota` in error) {
            event2.details = ErrorDetails.BUFFER_FULL_ERROR;
          } else if (error.code === DOMException.INVALID_STATE_ERR && this.mediaSourceOpenOrEnded && !mediaError) {
            event2.errorAction = createDoNothingErrorAction(true);
          } else if (error.name === TRACK_REMOVED_ERROR_NAME && this.sourceBufferCount === 0) {
            event2.errorAction = createDoNothingErrorAction(true);
          } else {
            const appendErrorCount = ++this.appendErrors[type];
            this.warn(`Failed ${appendErrorCount}/${this.hls.config.appendErrorMaxRetry} times to append segment in "${type}" sourceBuffer (${mediaError ? mediaError : "no media error"})`);
            if (appendErrorCount >= this.hls.config.appendErrorMaxRetry || !!mediaError) {
              event2.fatal = true;
            }
          }
          this.hls.trigger(Events.ERROR, event2);
        }
      };
      this.log(`queuing "${type}" append sn: ${sn}${part ? " p: " + part.index : ""} of ${frag.type === PlaylistLevelType.MAIN ? "level" : "track"} ${frag.level} cc: ${cc}`);
      this.append(operation, type, this.isPending(this.tracks[type]));
    }
    getFlushOp(type, start, end) {
      this.log(`queuing "${type}" remove ${start}-${end}`);
      return {
        label: "remove",
        execute: () => {
          this.removeExecutor(type, start, end);
        },
        onStart: () => {
        },
        onComplete: () => {
          this.hls.trigger(Events.BUFFER_FLUSHED, {
            type
          });
        },
        onError: (error) => {
          this.warn(`Failed to remove ${start}-${end} from "${type}" SourceBuffer`, error);
        }
      };
    }
    onBufferFlushing(event, data) {
      const {
        type,
        startOffset,
        endOffset
      } = data;
      if (type) {
        this.append(this.getFlushOp(type, startOffset, endOffset), type);
      } else {
        this.sourceBuffers.forEach(([type2]) => {
          if (type2) {
            this.append(this.getFlushOp(type2, startOffset, endOffset), type2);
          }
        });
      }
    }
    onFragParsed(event, data) {
      const {
        frag,
        part
      } = data;
      const buffersAppendedTo = [];
      const elementaryStreams = part ? part.elementaryStreams : frag.elementaryStreams;
      if (elementaryStreams[ElementaryStreamTypes.AUDIOVIDEO]) {
        buffersAppendedTo.push("audiovideo");
      } else {
        if (elementaryStreams[ElementaryStreamTypes.AUDIO]) {
          buffersAppendedTo.push("audio");
        }
        if (elementaryStreams[ElementaryStreamTypes.VIDEO]) {
          buffersAppendedTo.push("video");
        }
      }
      const onUnblocked = () => {
        const now3 = self.performance.now();
        frag.stats.buffering.end = now3;
        if (part) {
          part.stats.buffering.end = now3;
        }
        const stats = part ? part.stats : frag.stats;
        this.hls.trigger(Events.FRAG_BUFFERED, {
          frag,
          part,
          stats,
          id: frag.type
        });
      };
      if (buffersAppendedTo.length === 0) {
        this.warn(`Fragments must have at least one ElementaryStreamType set. type: ${frag.type} level: ${frag.level} sn: ${frag.sn}`);
      }
      this.blockBuffers(onUnblocked, buffersAppendedTo).catch((error) => {
        this.warn(`Fragment buffered callback ${error}`);
        this.stepOperationQueue(this.sourceBufferTypes);
      });
    }
    onFragChanged(event, data) {
      this.trimBuffers();
    }
    get bufferedToEnd() {
      return this.sourceBufferCount > 0 && !this.sourceBuffers.some(([type]) => {
        if (type) {
          const track = this.tracks[type];
          if (track) {
            return !track.ended || track.ending;
          }
        }
        return false;
      });
    }
    // on BUFFER_EOS mark matching sourcebuffer(s) as "ending" and "ended" and queue endOfStream after remaining operations(s)
    // an undefined data.type will mark all buffers as EOS.
    onBufferEos(event, data) {
      var _this$overrides;
      this.sourceBuffers.forEach(([type]) => {
        if (type) {
          const track = this.tracks[type];
          if (!data.type || data.type === type) {
            track.ending = true;
            if (!track.ended) {
              track.ended = true;
              this.log(`${type} buffer reached EOS`);
            }
          }
        }
      });
      const allowEndOfStream = ((_this$overrides = this.overrides) == null ? void 0 : _this$overrides.endOfStream) !== false;
      const allTracksEnding = this.sourceBufferCount > 0 && !this.sourceBuffers.some(([type]) => {
        var _this$tracks$type3;
        return type && !((_this$tracks$type3 = this.tracks[type]) != null && _this$tracks$type3.ended);
      });
      if (allTracksEnding) {
        if (allowEndOfStream) {
          this.log(`Queueing EOS`);
          this.blockUntilOpen(() => {
            this.tracksEnded();
            const {
              mediaSource
            } = this;
            if (!mediaSource || mediaSource.readyState !== "open") {
              if (mediaSource) {
                this.log(`Could not call mediaSource.endOfStream(). mediaSource.readyState: ${mediaSource.readyState}`);
              }
              return;
            }
            this.log(`Calling mediaSource.endOfStream()`);
            mediaSource.endOfStream();
            this.hls.trigger(Events.BUFFERED_TO_END, void 0);
          });
        } else {
          this.tracksEnded();
          this.hls.trigger(Events.BUFFERED_TO_END, void 0);
        }
      } else if (data.type === "video") {
        this.unblockAudio();
      }
    }
    tracksEnded() {
      this.sourceBuffers.forEach(([type]) => {
        if (type !== null) {
          const track = this.tracks[type];
          if (track) {
            track.ending = false;
          }
        }
      });
    }
    onLevelUpdated(event, {
      details
    }) {
      if (!details.fragments.length) {
        return;
      }
      this.details = details;
      this.updateDuration();
    }
    updateDuration() {
      this.blockUntilOpen(() => {
        const durationAndRange = this.getDurationAndRange();
        if (!durationAndRange) {
          return;
        }
        this.updateMediaSource(durationAndRange);
      });
    }
    onError(event, data) {
      if (data.details === ErrorDetails.BUFFER_APPEND_ERROR && data.frag) {
        var _data$errorAction;
        const nextAutoLevel = (_data$errorAction = data.errorAction) == null ? void 0 : _data$errorAction.nextAutoLevel;
        if (isFiniteNumber(nextAutoLevel) && nextAutoLevel !== data.frag.level) {
          this.resetAppendErrors();
        }
      }
    }
    resetAppendErrors() {
      this.appendErrors = {
        audio: 0,
        video: 0,
        audiovideo: 0
      };
    }
    trimBuffers() {
      const {
        hls,
        details,
        media
      } = this;
      if (!media || details === null) {
        return;
      }
      if (!this.sourceBufferCount) {
        return;
      }
      const config3 = hls.config;
      const currentTime = media.currentTime;
      const targetDuration = details.levelTargetDuration;
      const backBufferLength = details.live && config3.liveBackBufferLength !== null ? config3.liveBackBufferLength : config3.backBufferLength;
      if (isFiniteNumber(backBufferLength) && backBufferLength >= 0) {
        const maxBackBufferLength = Math.max(backBufferLength, targetDuration);
        const targetBackBufferPosition = Math.floor(currentTime / targetDuration) * targetDuration - maxBackBufferLength;
        this.flushBackBuffer(currentTime, targetDuration, targetBackBufferPosition);
      }
      const frontBufferFlushThreshold = config3.frontBufferFlushThreshold;
      if (isFiniteNumber(frontBufferFlushThreshold) && frontBufferFlushThreshold > 0) {
        const frontBufferLength = Math.max(config3.maxBufferLength, frontBufferFlushThreshold);
        const maxFrontBufferLength = Math.max(frontBufferLength, targetDuration);
        const targetFrontBufferPosition = Math.floor(currentTime / targetDuration) * targetDuration + maxFrontBufferLength;
        this.flushFrontBuffer(currentTime, targetDuration, targetFrontBufferPosition);
      }
    }
    flushBackBuffer(currentTime, targetDuration, targetBackBufferPosition) {
      this.sourceBuffers.forEach(([type, sb]) => {
        if (sb) {
          const buffered = BufferHelper.getBuffered(sb);
          if (buffered.length > 0 && targetBackBufferPosition > buffered.start(0)) {
            var _this$details;
            this.hls.trigger(Events.BACK_BUFFER_REACHED, {
              bufferEnd: targetBackBufferPosition
            });
            const track = this.tracks[type];
            if ((_this$details = this.details) != null && _this$details.live) {
              this.hls.trigger(Events.LIVE_BACK_BUFFER_REACHED, {
                bufferEnd: targetBackBufferPosition
              });
            } else if (track != null && track.ended) {
              this.log(`Cannot flush ${type} back buffer while SourceBuffer is in ended state`);
              return;
            }
            this.hls.trigger(Events.BUFFER_FLUSHING, {
              startOffset: 0,
              endOffset: targetBackBufferPosition,
              type
            });
          }
        }
      });
    }
    flushFrontBuffer(currentTime, targetDuration, targetFrontBufferPosition) {
      this.sourceBuffers.forEach(([type, sb]) => {
        if (sb) {
          const buffered = BufferHelper.getBuffered(sb);
          const numBufferedRanges = buffered.length;
          if (numBufferedRanges < 2) {
            return;
          }
          const bufferStart = buffered.start(numBufferedRanges - 1);
          const bufferEnd = buffered.end(numBufferedRanges - 1);
          if (targetFrontBufferPosition > bufferStart || currentTime >= bufferStart && currentTime <= bufferEnd) {
            return;
          }
          this.hls.trigger(Events.BUFFER_FLUSHING, {
            startOffset: bufferStart,
            endOffset: Infinity,
            type
          });
        }
      });
    }
    /**
     * Update Media Source duration to current level duration or override to Infinity if configuration parameter
     * 'liveDurationInfinity` is set to `true`
     * More details: https://github.com/video-dev/hls.js/issues/355
     */
    getDurationAndRange() {
      var _this$overrides2;
      const {
        details,
        mediaSource
      } = this;
      if (!details || !this.media || (mediaSource == null ? void 0 : mediaSource.readyState) !== "open") {
        return null;
      }
      const playlistEnd = details.edge;
      if (details.live && this.hls.config.liveDurationInfinity) {
        const len = details.fragments.length;
        if (len && !!mediaSource.setLiveSeekableRange) {
          const start = Math.max(0, details.fragmentStart);
          const end = Math.max(start, playlistEnd);
          return {
            duration: Infinity,
            start,
            end
          };
        }
        return {
          duration: Infinity
        };
      }
      const overrideDuration = (_this$overrides2 = this.overrides) == null ? void 0 : _this$overrides2.duration;
      if (overrideDuration) {
        if (!isFiniteNumber(overrideDuration)) {
          return null;
        }
        return {
          duration: overrideDuration
        };
      }
      const mediaDuration = this.media.duration;
      const msDuration = isFiniteNumber(mediaSource.duration) ? mediaSource.duration : 0;
      if (playlistEnd > msDuration && playlistEnd > mediaDuration || !isFiniteNumber(mediaDuration)) {
        return {
          duration: playlistEnd
        };
      }
      return null;
    }
    updateMediaSource({
      duration,
      start,
      end
    }) {
      const mediaSource = this.mediaSource;
      if (!this.media || !mediaSource || mediaSource.readyState !== "open") {
        return;
      }
      if (mediaSource.duration !== duration) {
        if (isFiniteNumber(duration)) {
          this.log(`Updating MediaSource duration to ${duration.toFixed(3)}`);
        }
        mediaSource.duration = duration;
      }
      if (start !== void 0 && end !== void 0) {
        this.log(`MediaSource duration is set to ${mediaSource.duration}. Setting seekable range to ${start}-${end}.`);
        mediaSource.setLiveSeekableRange(start, end);
      }
    }
    get tracksReady() {
      const pendingTrackCount = this.pendingTrackCount;
      return pendingTrackCount > 0 && (pendingTrackCount >= this.bufferCodecEventsTotal || this.isPending(this.tracks.audiovideo));
    }
    checkPendingTracks() {
      const {
        bufferCodecEventsTotal,
        pendingTrackCount,
        tracks
      } = this;
      this.log(`checkPendingTracks (pending: ${pendingTrackCount} codec events expected: ${bufferCodecEventsTotal}) ${stringify(tracks)}`);
      if (this.tracksReady) {
        var _this$transferData4;
        const transferredTracks = (_this$transferData4 = this.transferData) == null ? void 0 : _this$transferData4.tracks;
        if (transferredTracks && Object.keys(transferredTracks).length) {
          this.attachTransferred();
        } else {
          this.createSourceBuffers();
        }
      }
    }
    bufferCreated() {
      if (this.sourceBufferCount) {
        const tracks = {};
        this.sourceBuffers.forEach(([type, buffer]) => {
          if (type) {
            const track = this.tracks[type];
            tracks[type] = {
              buffer,
              container: track.container,
              codec: track.codec,
              supplemental: track.supplemental,
              levelCodec: track.levelCodec,
              id: track.id,
              metadata: track.metadata
            };
          }
        });
        this.hls.trigger(Events.BUFFER_CREATED, {
          tracks
        });
        this.log(`SourceBuffers created. Running queue: ${this.operationQueue}`);
        this.sourceBuffers.forEach(([type]) => {
          this.executeNext(type);
        });
      } else {
        const error = new Error("could not create source buffer for media codec(s)");
        this.hls.trigger(Events.ERROR, {
          type: ErrorTypes.MEDIA_ERROR,
          details: ErrorDetails.BUFFER_INCOMPATIBLE_CODECS_ERROR,
          fatal: true,
          error,
          reason: error.message
        });
      }
    }
    createSourceBuffers() {
      const {
        tracks,
        sourceBuffers,
        mediaSource
      } = this;
      if (!mediaSource) {
        throw new Error("createSourceBuffers called when mediaSource was null");
      }
      for (const trackName in tracks) {
        const type = trackName;
        const track = tracks[type];
        if (this.isPending(track)) {
          const codec = this.getTrackCodec(track, type);
          const mimeType = `${track.container};codecs=${codec}`;
          track.codec = codec;
          this.log(`creating sourceBuffer(${mimeType})${this.currentOp(type) ? " Queued" : ""} ${stringify(track)}`);
          try {
            const sb = mediaSource.addSourceBuffer(mimeType);
            const sbIndex = sourceBufferNameToIndex(type);
            const sbTuple = [type, sb];
            sourceBuffers[sbIndex] = sbTuple;
            track.buffer = sb;
          } catch (error) {
            var _this$operationQueue;
            this.error(`error while trying to add sourceBuffer: ${error.message}`);
            this.shiftAndExecuteNext(type);
            (_this$operationQueue = this.operationQueue) == null || _this$operationQueue.removeBlockers();
            delete this.tracks[type];
            this.hls.trigger(Events.ERROR, {
              type: ErrorTypes.MEDIA_ERROR,
              details: ErrorDetails.BUFFER_ADD_CODEC_ERROR,
              fatal: false,
              error,
              sourceBufferName: type,
              mimeType,
              parent: track.id
            });
            return;
          }
          this.trackSourceBuffer(type, track);
        }
      }
      this.bufferCreated();
    }
    getTrackCodec(track, trackName) {
      const supplementalCodec = track.supplemental;
      let trackCodec = track.codec;
      if (supplementalCodec && (trackName === "video" || trackName === "audiovideo") && areCodecsMediaSourceSupported(supplementalCodec, "video")) {
        trackCodec = replaceVideoCodec(trackCodec, supplementalCodec);
      }
      const codec = pickMostCompleteCodecName(trackCodec, track.levelCodec);
      if (codec) {
        if (trackName.slice(0, 5) === "audio") {
          return getCodecCompatibleName(codec, this.appendSource);
        }
        return codec;
      }
      return "";
    }
    trackSourceBuffer(type, track) {
      const buffer = track.buffer;
      if (!buffer) {
        return;
      }
      const codec = this.getTrackCodec(track, type);
      this.tracks[type] = {
        buffer,
        codec,
        container: track.container,
        levelCodec: track.levelCodec,
        supplemental: track.supplemental,
        metadata: track.metadata,
        id: track.id,
        listeners: []
      };
      this.removeBufferListeners(type);
      this.addBufferListener(type, "updatestart", this.onSBUpdateStart);
      this.addBufferListener(type, "updateend", this.onSBUpdateEnd);
      this.addBufferListener(type, "error", this.onSBUpdateError);
      if (this.appendSource) {
        this.addBufferListener(type, "bufferedchange", (type2, event) => {
          const removedRanges = event.removedRanges;
          if (removedRanges != null && removedRanges.length) {
            this.hls.trigger(Events.BUFFER_FLUSHED, {
              type: type2
            });
          }
        });
      }
    }
    get mediaSrc() {
      var _this$media2, _this$media2$querySel;
      const media = ((_this$media2 = this.media) == null || (_this$media2$querySel = _this$media2.querySelector) == null ? void 0 : _this$media2$querySel.call(_this$media2, "source")) || this.media;
      return media == null ? void 0 : media.src;
    }
    onSBUpdateStart(type) {
      const operation = this.currentOp(type);
      if (!operation) {
        return;
      }
      operation.onStart();
    }
    onSBUpdateEnd(type) {
      var _this$mediaSource4;
      if (((_this$mediaSource4 = this.mediaSource) == null ? void 0 : _this$mediaSource4.readyState) === "closed") {
        this.resetBuffer(type);
        return;
      }
      const operation = this.currentOp(type);
      if (!operation) {
        return;
      }
      operation.onComplete();
      this.shiftAndExecuteNext(type);
    }
    onSBUpdateError(type, event) {
      var _this$mediaSource5;
      const error = new Error(`${type} SourceBuffer error. MediaSource readyState: ${(_this$mediaSource5 = this.mediaSource) == null ? void 0 : _this$mediaSource5.readyState}`);
      this.error(`${error}`, event);
      this.hls.trigger(Events.ERROR, {
        type: ErrorTypes.MEDIA_ERROR,
        details: ErrorDetails.BUFFER_APPENDING_ERROR,
        sourceBufferName: type,
        error,
        fatal: false
      });
      const operation = this.currentOp(type);
      if (operation) {
        operation.onError(error);
      }
    }
    updateTimestampOffset(sb, timestampOffset, tolerance, type, sn, cc) {
      const delta = timestampOffset - sb.timestampOffset;
      if (Math.abs(delta) >= tolerance) {
        this.log(`Updating ${type} SourceBuffer timestampOffset to ${timestampOffset} (sn: ${sn} cc: ${cc})`);
        sb.timestampOffset = timestampOffset;
      }
    }
    // This method must result in an updateend event; if remove is not called, onSBUpdateEnd must be called manually
    removeExecutor(type, startOffset, endOffset) {
      const {
        media,
        mediaSource
      } = this;
      const track = this.tracks[type];
      const sb = track == null ? void 0 : track.buffer;
      if (!media || !mediaSource || !sb) {
        this.warn(`Attempting to remove from the ${type} SourceBuffer, but it does not exist`);
        this.shiftAndExecuteNext(type);
        return;
      }
      const mediaDuration = isFiniteNumber(media.duration) ? media.duration : Infinity;
      const msDuration = isFiniteNumber(mediaSource.duration) ? mediaSource.duration : Infinity;
      const removeStart = Math.max(0, startOffset);
      const removeEnd = Math.min(endOffset, mediaDuration, msDuration);
      if (removeEnd > removeStart && (!track.ending || track.ended)) {
        track.ended = false;
        this.log(`Removing [${removeStart},${removeEnd}] from the ${type} SourceBuffer`);
        sb.remove(removeStart, removeEnd);
      } else {
        this.shiftAndExecuteNext(type);
      }
    }
    // This method must result in an updateend event; if append is not called, onSBUpdateEnd must be called manually
    appendExecutor(data, type) {
      const track = this.tracks[type];
      const sb = track == null ? void 0 : track.buffer;
      if (!sb) {
        throw new HlsJsTrackRemovedError(`Attempting to append to the ${type} SourceBuffer, but it does not exist`);
      }
      track.ending = false;
      track.ended = false;
      sb.appendBuffer(data);
    }
    blockUntilOpen(callback) {
      if (this.isUpdating() || this.isQueued()) {
        this.blockBuffers(callback).catch((error) => {
          this.warn(`SourceBuffer blocked callback ${error}`);
          this.stepOperationQueue(this.sourceBufferTypes);
        });
      } else {
        try {
          callback();
        } catch (error) {
          this.warn(`Callback run without blocking ${this.operationQueue} ${error}`);
        }
      }
    }
    isUpdating() {
      return this.sourceBuffers.some(([type, sb]) => type && sb.updating);
    }
    isQueued() {
      return this.sourceBuffers.some(([type]) => type && !!this.currentOp(type));
    }
    isPending(track) {
      return !!track && !track.buffer;
    }
    // Enqueues an operation to each SourceBuffer queue which, upon execution, resolves a promise. When all promises
    // resolve, the onUnblocked function is executed. Functions calling this method do not need to unblock the queue
    // upon completion, since we already do it here
    blockBuffers(onUnblocked, bufferNames = this.sourceBufferTypes) {
      if (!bufferNames.length) {
        this.log("Blocking operation requested, but no SourceBuffers exist");
        return Promise.resolve().then(onUnblocked);
      }
      const {
        operationQueue
      } = this;
      const blockingOperations = bufferNames.map((type) => this.appendBlocker(type));
      const audioBlocked = bufferNames.length > 1 && !!this.blockedAudioAppend;
      if (audioBlocked) {
        this.unblockAudio();
      }
      return Promise.all(blockingOperations).then((result) => {
        if (operationQueue !== this.operationQueue) {
          return;
        }
        onUnblocked();
        this.stepOperationQueue(this.sourceBufferTypes);
      });
    }
    stepOperationQueue(bufferNames) {
      bufferNames.forEach((type) => {
        var _this$tracks$type4;
        const sb = (_this$tracks$type4 = this.tracks[type]) == null ? void 0 : _this$tracks$type4.buffer;
        if (!sb || sb.updating) {
          return;
        }
        this.shiftAndExecuteNext(type);
      });
    }
    append(operation, type, pending) {
      if (this.operationQueue) {
        this.operationQueue.append(operation, type, pending);
      }
    }
    appendBlocker(type) {
      if (this.operationQueue) {
        return this.operationQueue.appendBlocker(type);
      }
    }
    currentOp(type) {
      if (this.operationQueue) {
        return this.operationQueue.current(type);
      }
      return null;
    }
    executeNext(type) {
      if (type && this.operationQueue) {
        this.operationQueue.executeNext(type);
      }
    }
    shiftAndExecuteNext(type) {
      if (this.operationQueue) {
        this.operationQueue.shiftAndExecuteNext(type);
      }
    }
    get pendingTrackCount() {
      return Object.keys(this.tracks).reduce((acc, type) => acc + (this.isPending(this.tracks[type]) ? 1 : 0), 0);
    }
    get sourceBufferCount() {
      return this.sourceBuffers.reduce((acc, [type]) => acc + (type ? 1 : 0), 0);
    }
    get sourceBufferTypes() {
      return this.sourceBuffers.map(([type]) => type).filter((type) => !!type);
    }
    addBufferListener(type, event, fn) {
      const track = this.tracks[type];
      if (!track) {
        return;
      }
      const buffer = track.buffer;
      if (!buffer) {
        return;
      }
      const listener = fn.bind(this, type);
      track.listeners.push({
        event,
        listener
      });
      buffer.addEventListener(event, listener);
    }
    removeBufferListeners(type) {
      const track = this.tracks[type];
      if (!track) {
        return;
      }
      const buffer = track.buffer;
      if (!buffer) {
        return;
      }
      track.listeners.forEach((l) => {
        buffer.removeEventListener(l.event, l.listener);
      });
      track.listeners.length = 0;
    }
  };
  function removeSourceChildren(node) {
    const sourceChildren = node.querySelectorAll("source");
    [].slice.call(sourceChildren).forEach((source) => {
      node.removeChild(source);
    });
  }
  function addSource(media, url) {
    const source = self.document.createElement("source");
    source.type = "video/mp4";
    source.src = url;
    media.appendChild(source);
  }
  function sourceBufferNameToIndex(type) {
    return type === "audio" ? 1 : 0;
  }
  var CapLevelController = class _CapLevelController {
    constructor(hls) {
      this.hls = void 0;
      this.autoLevelCapping = void 0;
      this.firstLevel = void 0;
      this.media = void 0;
      this.restrictedLevels = void 0;
      this.timer = void 0;
      this.clientRect = void 0;
      this.streamController = void 0;
      this.hls = hls;
      this.autoLevelCapping = Number.POSITIVE_INFINITY;
      this.firstLevel = -1;
      this.media = null;
      this.restrictedLevels = [];
      this.timer = void 0;
      this.clientRect = null;
      this.registerListeners();
    }
    setStreamController(streamController) {
      this.streamController = streamController;
    }
    destroy() {
      if (this.hls) {
        this.unregisterListener();
      }
      if (this.timer) {
        this.stopCapping();
      }
      this.media = null;
      this.clientRect = null;
      this.hls = this.streamController = null;
    }
    registerListeners() {
      const {
        hls
      } = this;
      hls.on(Events.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this);
      hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);
      hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);
      hls.on(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);
      hls.on(Events.BUFFER_CODECS, this.onBufferCodecs, this);
      hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
    }
    unregisterListener() {
      const {
        hls
      } = this;
      hls.off(Events.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this);
      hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);
      hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);
      hls.off(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);
      hls.off(Events.BUFFER_CODECS, this.onBufferCodecs, this);
      hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
    }
    onFpsDropLevelCapping(event, data) {
      const level = this.hls.levels[data.droppedLevel];
      if (this.isLevelAllowed(level)) {
        this.restrictedLevels.push({
          bitrate: level.bitrate,
          height: level.height,
          width: level.width
        });
      }
    }
    onMediaAttaching(event, data) {
      this.media = data.media instanceof HTMLVideoElement ? data.media : null;
      this.clientRect = null;
      if (this.timer && this.hls.levels.length) {
        this.detectPlayerSize();
      }
    }
    onManifestParsed(event, data) {
      const hls = this.hls;
      this.restrictedLevels = [];
      this.firstLevel = data.firstLevel;
      if (hls.config.capLevelToPlayerSize && data.video) {
        this.startCapping();
      }
    }
    onLevelsUpdated(event, data) {
      if (this.timer && isFiniteNumber(this.autoLevelCapping)) {
        this.detectPlayerSize();
      }
    }
    // Only activate capping when playing a video stream; otherwise, multi-bitrate audio-only streams will be restricted
    // to the first level
    onBufferCodecs(event, data) {
      const hls = this.hls;
      if (hls.config.capLevelToPlayerSize && data.video) {
        this.startCapping();
      }
    }
    onMediaDetaching() {
      this.stopCapping();
      this.media = null;
    }
    detectPlayerSize() {
      if (this.media) {
        if (this.mediaHeight <= 0 || this.mediaWidth <= 0) {
          this.clientRect = null;
          return;
        }
        const levels = this.hls.levels;
        if (levels.length) {
          const hls = this.hls;
          const maxLevel = this.getMaxLevel(levels.length - 1);
          if (maxLevel !== this.autoLevelCapping) {
            hls.logger.log(`Setting autoLevelCapping to ${maxLevel}: ${levels[maxLevel].height}p@${levels[maxLevel].bitrate} for media ${this.mediaWidth}x${this.mediaHeight}`);
          }
          hls.autoLevelCapping = maxLevel;
          if (hls.autoLevelEnabled && hls.autoLevelCapping > this.autoLevelCapping && this.streamController) {
            this.streamController.nextLevelSwitch();
          }
          this.autoLevelCapping = hls.autoLevelCapping;
        }
      }
    }
    /*
     * returns level should be the one with the dimensions equal or greater than the media (player) dimensions (so the video will be downscaled)
     */
    getMaxLevel(capLevelIndex) {
      const levels = this.hls.levels;
      if (!levels.length) {
        return -1;
      }
      const validLevels = levels.filter((level, index) => this.isLevelAllowed(level) && index <= capLevelIndex);
      this.clientRect = null;
      return _CapLevelController.getMaxLevelByMediaSize(validLevels, this.mediaWidth, this.mediaHeight);
    }
    startCapping() {
      if (this.timer) {
        return;
      }
      this.autoLevelCapping = Number.POSITIVE_INFINITY;
      self.clearInterval(this.timer);
      this.timer = self.setInterval(this.detectPlayerSize.bind(this), 1e3);
      this.detectPlayerSize();
    }
    stopCapping() {
      this.restrictedLevels = [];
      this.firstLevel = -1;
      this.autoLevelCapping = Number.POSITIVE_INFINITY;
      if (this.timer) {
        self.clearInterval(this.timer);
        this.timer = void 0;
      }
    }
    getDimensions() {
      if (this.clientRect) {
        return this.clientRect;
      }
      const media = this.media;
      const boundsRect = {
        width: 0,
        height: 0
      };
      if (media) {
        const clientRect = media.getBoundingClientRect();
        boundsRect.width = clientRect.width;
        boundsRect.height = clientRect.height;
        if (!boundsRect.width && !boundsRect.height) {
          boundsRect.width = clientRect.right - clientRect.left || media.width || 0;
          boundsRect.height = clientRect.bottom - clientRect.top || media.height || 0;
        }
      }
      this.clientRect = boundsRect;
      return boundsRect;
    }
    get mediaWidth() {
      return this.getDimensions().width * this.contentScaleFactor;
    }
    get mediaHeight() {
      return this.getDimensions().height * this.contentScaleFactor;
    }
    get contentScaleFactor() {
      let pixelRatio = 1;
      if (!this.hls.config.ignoreDevicePixelRatio) {
        try {
          pixelRatio = self.devicePixelRatio;
        } catch (e) {
        }
      }
      return Math.min(pixelRatio, this.hls.config.maxDevicePixelRatio);
    }
    isLevelAllowed(level) {
      const restrictedLevels = this.restrictedLevels;
      return !restrictedLevels.some((restrictedLevel) => {
        return level.bitrate === restrictedLevel.bitrate && level.width === restrictedLevel.width && level.height === restrictedLevel.height;
      });
    }
    static getMaxLevelByMediaSize(levels, width, height) {
      if (!(levels != null && levels.length)) {
        return -1;
      }
      const atGreatestBandwidth = (curLevel, nextLevel) => {
        if (!nextLevel) {
          return true;
        }
        return curLevel.width !== nextLevel.width || curLevel.height !== nextLevel.height;
      };
      let maxLevelIndex = levels.length - 1;
      const squareSize = Math.max(width, height);
      for (let i = 0; i < levels.length; i += 1) {
        const level = levels[i];
        if ((level.width >= squareSize || level.height >= squareSize) && atGreatestBandwidth(level, levels[i + 1])) {
          maxLevelIndex = i;
          break;
        }
      }
      return maxLevelIndex;
    }
  };
  var CmObjectType = {
    /**
     * text file, such as a manifest or playlist
     */
    MANIFEST: "m",
    /**
     * audio only
     */
    AUDIO: "a",
    /**
     * video only
     */
    VIDEO: "v",
    /**
     * muxed audio and video
     */
    MUXED: "av",
    /**
     * init segment
     */
    INIT: "i",
    /**
     * caption or subtitle
     */
    CAPTION: "c",
    /**
     * ISOBMFF timed text track
     */
    TIMED_TEXT: "tt",
    /**
     * cryptographic key, license or certificate.
     */
    KEY: "k",
    /**
     * other
     */
    OTHER: "o"
  };
  var CmcdObjectType = CmObjectType;
  var CmStreamingFormat = {
    /**
     * HTTP Live Streaming (HLS)
     */
    HLS: "h"
  };
  var CmcdStreamingFormat = CmStreamingFormat;
  var SfItem = class _SfItem {
    constructor(value, params) {
      if (Array.isArray(value)) {
        value = value.map((v) => v instanceof _SfItem ? v : new _SfItem(v));
      }
      this.value = value;
      this.params = params;
    }
  };
  var DICT = "Dict";
  function format(value) {
    if (Array.isArray(value)) {
      return JSON.stringify(value);
    }
    if (value instanceof Map) {
      return "Map{}";
    }
    if (value instanceof Set) {
      return "Set{}";
    }
    if (typeof value === "object") {
      return JSON.stringify(value);
    }
    return String(value);
  }
  function throwError(action, src, type, cause) {
    return new Error(`failed to ${action} "${format(src)}" as ${type}`, {
      cause
    });
  }
  function serializeError(src, type, cause) {
    return throwError("serialize", src, type, cause);
  }
  var SfToken = class {
    constructor(description) {
      this.description = description;
    }
  };
  var BARE_ITEM = "Bare Item";
  var BOOLEAN = "Boolean";
  function serializeBoolean(value) {
    if (typeof value !== "boolean") {
      throw serializeError(value, BOOLEAN);
    }
    return value ? "?1" : "?0";
  }
  function encodeBase64(binary) {
    return btoa(String.fromCharCode(...binary));
  }
  var BYTES = "Byte Sequence";
  function serializeByteSequence(value) {
    if (ArrayBuffer.isView(value) === false) {
      throw serializeError(value, BYTES);
    }
    return `:${encodeBase64(value)}:`;
  }
  var INTEGER = "Integer";
  function isInvalidInt(value) {
    return value < -999999999999999 || 999999999999999 < value;
  }
  function serializeInteger(value) {
    if (isInvalidInt(value)) {
      throw serializeError(value, INTEGER);
    }
    return value.toString();
  }
  function serializeDate(value) {
    return `@${serializeInteger(value.getTime() / 1e3)}`;
  }
  function roundToEven(value, precision) {
    if (value < 0) {
      return -roundToEven(-value, precision);
    }
    const decimalShift = Math.pow(10, precision);
    const isEquidistant = Math.abs(value * decimalShift % 1 - 0.5) < Number.EPSILON;
    if (isEquidistant) {
      const flooredValue = Math.floor(value * decimalShift);
      return (flooredValue % 2 === 0 ? flooredValue : flooredValue + 1) / decimalShift;
    } else {
      return Math.round(value * decimalShift) / decimalShift;
    }
  }
  var DECIMAL = "Decimal";
  function serializeDecimal(value) {
    const roundedValue = roundToEven(value, 3);
    if (Math.floor(Math.abs(roundedValue)).toString().length > 12) {
      throw serializeError(value, DECIMAL);
    }
    const stringValue = roundedValue.toString();
    return stringValue.includes(".") ? stringValue : `${stringValue}.0`;
  }
  var STRING = "String";
  var STRING_REGEX = /[\x00-\x1f\x7f]+/;
  function serializeString(value) {
    if (STRING_REGEX.test(value)) {
      throw serializeError(value, STRING);
    }
    return `"${value.replace(/\\/g, `\\\\`).replace(/"/g, `\\"`)}"`;
  }
  function symbolToStr(symbol) {
    return symbol.description || symbol.toString().slice(7, -1);
  }
  var TOKEN = "Token";
  function serializeToken(token) {
    const value = symbolToStr(token);
    if (/^([a-zA-Z*])([!#$%&'*+\-.^_`|~\w:/]*)$/.test(value) === false) {
      throw serializeError(value, TOKEN);
    }
    return value;
  }
  function serializeBareItem(value) {
    switch (typeof value) {
      case "number":
        if (!isFiniteNumber(value)) {
          throw serializeError(value, BARE_ITEM);
        }
        if (Number.isInteger(value)) {
          return serializeInteger(value);
        }
        return serializeDecimal(value);
      case "string":
        return serializeString(value);
      case "symbol":
        return serializeToken(value);
      case "boolean":
        return serializeBoolean(value);
      case "object":
        if (value instanceof Date) {
          return serializeDate(value);
        }
        if (value instanceof Uint8Array) {
          return serializeByteSequence(value);
        }
        if (value instanceof SfToken) {
          return serializeToken(value);
        }
      default:
        throw serializeError(value, BARE_ITEM);
    }
  }
  var KEY = "Key";
  function serializeKey(value) {
    if (/^[a-z*][a-z0-9\-_.*]*$/.test(value) === false) {
      throw serializeError(value, KEY);
    }
    return value;
  }
  function serializeParams(params) {
    if (params == null) {
      return "";
    }
    return Object.entries(params).map(([key, value]) => {
      if (value === true) {
        return `;${serializeKey(key)}`;
      }
      return `;${serializeKey(key)}=${serializeBareItem(value)}`;
    }).join("");
  }
  function serializeItem(value) {
    if (value instanceof SfItem) {
      return `${serializeBareItem(value.value)}${serializeParams(value.params)}`;
    } else {
      return serializeBareItem(value);
    }
  }
  function serializeInnerList(value) {
    return `(${value.value.map(serializeItem).join(" ")})${serializeParams(value.params)}`;
  }
  function serializeDict(dict, options = {
    whitespace: true
  }) {
    if (typeof dict !== "object" || dict == null) {
      throw serializeError(dict, DICT);
    }
    const entries = dict instanceof Map ? dict.entries() : Object.entries(dict);
    const optionalWhiteSpace = (options === null || options === void 0 ? void 0 : options.whitespace) ? " " : "";
    return Array.from(entries).map(([key, item]) => {
      if (item instanceof SfItem === false) {
        item = new SfItem(item);
      }
      let output = serializeKey(key);
      if (item.value === true) {
        output += serializeParams(item.params);
      } else {
        output += "=";
        if (Array.isArray(item.value)) {
          output += serializeInnerList(item);
        } else {
          output += serializeItem(item);
        }
      }
      return output;
    }).join(`,${optionalWhiteSpace}`);
  }
  function encodeSfDict(value, options) {
    return serializeDict(value, options);
  }
  var CMCD_OBJECT = "CMCD-Object";
  var CMCD_REQUEST = "CMCD-Request";
  var CMCD_SESSION = "CMCD-Session";
  var CMCD_STATUS = "CMCD-Status";
  var CMCD_HEADER_MAP = {
    // Object
    br: CMCD_OBJECT,
    ab: CMCD_OBJECT,
    d: CMCD_OBJECT,
    ot: CMCD_OBJECT,
    tb: CMCD_OBJECT,
    tpb: CMCD_OBJECT,
    lb: CMCD_OBJECT,
    tab: CMCD_OBJECT,
    lab: CMCD_OBJECT,
    url: CMCD_OBJECT,
    // Request
    pb: CMCD_REQUEST,
    bl: CMCD_REQUEST,
    tbl: CMCD_REQUEST,
    dl: CMCD_REQUEST,
    ltc: CMCD_REQUEST,
    mtp: CMCD_REQUEST,
    nor: CMCD_REQUEST,
    nrr: CMCD_REQUEST,
    rc: CMCD_REQUEST,
    sn: CMCD_REQUEST,
    sta: CMCD_REQUEST,
    su: CMCD_REQUEST,
    ttfb: CMCD_REQUEST,
    ttfbb: CMCD_REQUEST,
    ttlb: CMCD_REQUEST,
    cmsdd: CMCD_REQUEST,
    cmsds: CMCD_REQUEST,
    smrt: CMCD_REQUEST,
    df: CMCD_REQUEST,
    cs: CMCD_REQUEST,
    // TODO: Which header to put the `ts` field is not defined yet.
    ts: CMCD_REQUEST,
    // Session
    cid: CMCD_SESSION,
    pr: CMCD_SESSION,
    sf: CMCD_SESSION,
    sid: CMCD_SESSION,
    st: CMCD_SESSION,
    v: CMCD_SESSION,
    msd: CMCD_SESSION,
    // Status
    bs: CMCD_STATUS,
    bsd: CMCD_STATUS,
    cdn: CMCD_STATUS,
    rtp: CMCD_STATUS,
    bg: CMCD_STATUS,
    pt: CMCD_STATUS,
    ec: CMCD_STATUS,
    e: CMCD_STATUS
  };
  var CmcdHeaderField = {
    /**
     * keys whose values vary with each request.
     */
    REQUEST: CMCD_REQUEST
  };
  function createHeaderMap(headerMap) {
    return Object.keys(headerMap).reduce((acc, field) => {
      var _a;
      (_a = headerMap[field]) === null || _a === void 0 ? void 0 : _a.forEach((key) => acc[key] = field);
      return acc;
    }, {});
  }
  function groupCmcdHeaders(cmcd, customHeaderMap) {
    const result = {};
    if (!cmcd) {
      return result;
    }
    const keys2 = Object.keys(cmcd);
    const custom = customHeaderMap ? createHeaderMap(customHeaderMap) : {};
    return keys2.reduce((acc, key) => {
      var _a;
      const field = CMCD_HEADER_MAP[key] || custom[key] || CmcdHeaderField.REQUEST;
      const data = (_a = acc[field]) !== null && _a !== void 0 ? _a : acc[field] = {};
      data[key] = cmcd[key];
      return acc;
    }, result);
  }
  function isTokenField(key) {
    return ["ot", "sf", "st", "e", "sta"].includes(key);
  }
  function isValid(value) {
    if (typeof value === "number") {
      return isFiniteNumber(value);
    }
    return value != null && value !== "" && value !== false;
  }
  var CMCD_EVENT_MODE = "event";
  function urlToRelativePath(url, base) {
    const to = new URL(url);
    const from = new URL(base);
    if (to.origin !== from.origin) {
      return url;
    }
    const toPath = to.pathname.split("/").slice(1);
    const fromPath = from.pathname.split("/").slice(1, -1);
    while (toPath[0] === fromPath[0]) {
      toPath.shift();
      fromPath.shift();
    }
    while (fromPath.length) {
      fromPath.shift();
      toPath.unshift("..");
    }
    const relativePath = toPath.join("/");
    return relativePath + to.search + to.hash;
  }
  var toRounded = (value) => Math.round(value);
  var toUrlSafe = (value, options) => {
    if (Array.isArray(value)) {
      return value.map((item) => toUrlSafe(item, options));
    }
    if (value instanceof SfItem && typeof value.value === "string") {
      return new SfItem(toUrlSafe(value.value, options), value.params);
    } else {
      if (options.baseUrl) {
        value = urlToRelativePath(value, options.baseUrl);
      }
      return options.version === 1 ? encodeURIComponent(value) : value;
    }
  };
  var toHundred = (value) => toRounded(value / 100) * 100;
  var nor = (value, options) => {
    let norValue = value;
    if (options.version >= 2) {
      if (value instanceof SfItem && typeof value.value === "string") {
        norValue = new SfItem([value]);
      } else if (typeof value === "string") {
        norValue = [value];
      }
    }
    return toUrlSafe(norValue, options);
  };
  var CMCD_FORMATTER_MAP = {
    /**
     * Bitrate (kbps) rounded integer
     */
    br: toRounded,
    /**
     * Duration (milliseconds) rounded integer
     */
    d: toRounded,
    /**
     * Buffer Length (milliseconds) rounded nearest 100ms
     */
    bl: toHundred,
    /**
     * Deadline (milliseconds) rounded nearest 100ms
     */
    dl: toHundred,
    /**
     * Measured Throughput (kbps) rounded nearest 100kbps
     */
    mtp: toHundred,
    /**
     * Next Object Request URL encoded
     */
    nor,
    /**
     * Requested maximum throughput (kbps) rounded nearest 100kbps
     */
    rtp: toHundred,
    /**
     * Top Bitrate (kbps) rounded integer
     */
    tb: toRounded
  };
  var CMCD_REQUEST_MODE = "request";
  var CMCD_RESPONSE_MODE = "response";
  var CMCD_COMMON_KEYS = ["ab", "bg", "bl", "br", "bs", "bsd", "cdn", "cid", "cs", "df", "ec", "lab", "lb", "ltc", "msd", "mtp", "pb", "pr", "pt", "sf", "sid", "sn", "st", "sta", "tab", "tb", "tbl", "tpb", "ts", "v"];
  var CMCD_EVENT_KEYS = ["e"];
  var CUSTOM_KEY_REGEX = /^[a-zA-Z0-9-.]+-[a-zA-Z0-9-.]+$/;
  function isCmcdCustomKey(key) {
    return CUSTOM_KEY_REGEX.test(key);
  }
  function isCmcdEventKey(key) {
    return CMCD_COMMON_KEYS.includes(key) || CMCD_EVENT_KEYS.includes(key) || isCmcdCustomKey(key);
  }
  var CMCD_REQUEST_KEYS = ["d", "dl", "nor", "ot", "rtp", "su"];
  function isCmcdRequestKey(key) {
    return CMCD_COMMON_KEYS.includes(key) || CMCD_REQUEST_KEYS.includes(key) || isCmcdCustomKey(key);
  }
  var CMCD_RESPONSE_KEYS = ["cmsdd", "cmsds", "rc", "smrt", "ttfb", "ttfbb", "ttlb", "url"];
  function isCmcdResponseKey(key) {
    return CMCD_COMMON_KEYS.includes(key) || CMCD_REQUEST_KEYS.includes(key) || CMCD_RESPONSE_KEYS.includes(key) || isCmcdCustomKey(key);
  }
  var CMCD_V1_KEYS = ["bl", "br", "bs", "cid", "d", "dl", "mtp", "nor", "nrr", "ot", "pr", "rtp", "sf", "sid", "st", "su", "tb", "v"];
  function isCmcdV1Key(key) {
    return CMCD_V1_KEYS.includes(key) || isCmcdCustomKey(key);
  }
  var filterMap = {
    [CMCD_RESPONSE_MODE]: isCmcdResponseKey,
    [CMCD_EVENT_MODE]: isCmcdEventKey,
    [CMCD_REQUEST_MODE]: isCmcdRequestKey
  };
  function prepareCmcdData(obj, options = {}) {
    const results = {};
    if (obj == null || typeof obj !== "object") {
      return results;
    }
    const version2 = options.version || obj["v"] || 1;
    const reportingMode = options.reportingMode || CMCD_REQUEST_MODE;
    const keyFilter = version2 === 1 ? isCmcdV1Key : filterMap[reportingMode];
    let keys2 = Object.keys(obj).filter(keyFilter);
    const filter2 = options.filter;
    if (typeof filter2 === "function") {
      keys2 = keys2.filter(filter2);
    }
    const needsTimestamp = reportingMode === CMCD_RESPONSE_MODE || reportingMode === CMCD_EVENT_MODE;
    if (needsTimestamp && !keys2.includes("ts")) {
      keys2.push("ts");
    }
    if (version2 > 1 && !keys2.includes("v")) {
      keys2.push("v");
    }
    const formatters = _extends4({}, CMCD_FORMATTER_MAP, options.formatters);
    const formatterOptions = {
      version: version2,
      reportingMode,
      baseUrl: options.baseUrl
    };
    keys2.sort().forEach((key) => {
      let value = obj[key];
      const formatter = formatters[key];
      if (typeof formatter === "function") {
        value = formatter(value, formatterOptions);
      }
      if (key === "v") {
        if (version2 === 1) {
          return;
        } else {
          value = version2;
        }
      }
      if (key == "pr" && value === 1) {
        return;
      }
      if (needsTimestamp && key === "ts" && !isFiniteNumber(value)) {
        value = Date.now();
      }
      if (!isValid(value)) {
        return;
      }
      if (isTokenField(key) && typeof value === "string") {
        value = new SfToken(value);
      }
      results[key] = value;
    });
    return results;
  }
  function toCmcdHeaders(cmcd, options = {}) {
    const result = {};
    if (!cmcd) {
      return result;
    }
    const data = prepareCmcdData(cmcd, options);
    const shards = groupCmcdHeaders(data, options === null || options === void 0 ? void 0 : options.customHeaderMap);
    return Object.entries(shards).reduce((acc, [field, value]) => {
      const shard = encodeSfDict(value, {
        whitespace: false
      });
      if (shard) {
        acc[field] = shard;
      }
      return acc;
    }, result);
  }
  function appendCmcdHeaders(headers, cmcd, options) {
    return _extends4(headers, toCmcdHeaders(cmcd, options));
  }
  var CMCD_PARAM = "CMCD";
  function encodeCmcd(cmcd, options = {}) {
    if (!cmcd) {
      return "";
    }
    return encodeSfDict(prepareCmcdData(cmcd, options), {
      whitespace: false
    });
  }
  function toCmcdUrl(cmcd, options = {}) {
    if (!cmcd) {
      return "";
    }
    const params = encodeCmcd(cmcd, options);
    return encodeURIComponent(params);
  }
  function toCmcdQuery(cmcd, options = {}) {
    if (!cmcd) {
      return "";
    }
    const value = toCmcdUrl(cmcd, options);
    return `${CMCD_PARAM}=${value}`;
  }
  var REGEX = /CMCD=[^&#]+/;
  function appendCmcdQuery(url, cmcd, options) {
    const query = toCmcdQuery(cmcd, options);
    if (!query) {
      return url;
    }
    if (REGEX.test(url)) {
      return url.replace(REGEX, query);
    }
    const separator = url.includes("?") ? "&" : "?";
    return `${url}${separator}${query}`;
  }
  var CMCDController = class {
    constructor(hls) {
      this.hls = void 0;
      this.config = void 0;
      this.media = void 0;
      this.sid = void 0;
      this.cid = void 0;
      this.useHeaders = false;
      this.includeKeys = void 0;
      this.initialized = false;
      this.starved = false;
      this.buffering = true;
      this.audioBuffer = void 0;
      this.videoBuffer = void 0;
      this.onWaiting = () => {
        if (this.initialized) {
          this.starved = true;
        }
        this.buffering = true;
      };
      this.onPlaying = () => {
        if (!this.initialized) {
          this.initialized = true;
        }
        this.buffering = false;
      };
      this.applyPlaylistData = (context3) => {
        try {
          this.apply(context3, {
            ot: CmcdObjectType.MANIFEST,
            su: !this.initialized
          });
        } catch (error) {
          this.hls.logger.warn("Could not generate manifest CMCD data.", error);
        }
      };
      this.applyFragmentData = (context3) => {
        try {
          const {
            frag,
            part
          } = context3;
          const level = this.hls.levels[frag.level];
          const ot = this.getObjectType(frag);
          const data = {
            d: (part || frag).duration * 1e3,
            ot
          };
          if (ot === CmcdObjectType.VIDEO || ot === CmcdObjectType.AUDIO || ot == CmcdObjectType.MUXED) {
            data.br = level.bitrate / 1e3;
            data.tb = this.getTopBandwidth(ot) / 1e3;
            data.bl = this.getBufferLength(ot);
          }
          const next = part ? this.getNextPart(part) : this.getNextFrag(frag);
          if (next != null && next.url && next.url !== frag.url) {
            data.nor = next.url;
          }
          this.apply(context3, data);
        } catch (error) {
          this.hls.logger.warn("Could not generate segment CMCD data.", error);
        }
      };
      this.hls = hls;
      const config3 = this.config = hls.config;
      const {
        cmcd
      } = config3;
      if (cmcd != null) {
        config3.pLoader = this.createPlaylistLoader();
        config3.fLoader = this.createFragmentLoader();
        this.sid = cmcd.sessionId || hls.sessionId;
        this.cid = cmcd.contentId;
        this.useHeaders = cmcd.useHeaders === true;
        this.includeKeys = cmcd.includeKeys;
        this.registerListeners();
      }
    }
    registerListeners() {
      const hls = this.hls;
      hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
      hls.on(Events.MEDIA_DETACHED, this.onMediaDetached, this);
      hls.on(Events.BUFFER_CREATED, this.onBufferCreated, this);
    }
    unregisterListeners() {
      const hls = this.hls;
      hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
      hls.off(Events.MEDIA_DETACHED, this.onMediaDetached, this);
      hls.off(Events.BUFFER_CREATED, this.onBufferCreated, this);
    }
    destroy() {
      this.unregisterListeners();
      this.onMediaDetached();
      this.hls = this.config = this.audioBuffer = this.videoBuffer = null;
      this.onWaiting = this.onPlaying = this.media = null;
    }
    onMediaAttached(event, data) {
      this.media = data.media;
      this.media.addEventListener("waiting", this.onWaiting);
      this.media.addEventListener("playing", this.onPlaying);
    }
    onMediaDetached() {
      if (!this.media) {
        return;
      }
      this.media.removeEventListener("waiting", this.onWaiting);
      this.media.removeEventListener("playing", this.onPlaying);
      this.media = null;
    }
    onBufferCreated(event, data) {
      var _data$tracks$audio, _data$tracks$video;
      this.audioBuffer = (_data$tracks$audio = data.tracks.audio) == null ? void 0 : _data$tracks$audio.buffer;
      this.videoBuffer = (_data$tracks$video = data.tracks.video) == null ? void 0 : _data$tracks$video.buffer;
    }
    /**
     * Create baseline CMCD data
     */
    createData() {
      var _this$media;
      return {
        v: 1,
        sf: CmcdStreamingFormat.HLS,
        sid: this.sid,
        cid: this.cid,
        pr: (_this$media = this.media) == null ? void 0 : _this$media.playbackRate,
        mtp: this.hls.bandwidthEstimate / 1e3
      };
    }
    /**
     * Apply CMCD data to a request.
     */
    apply(context3, data = {}) {
      _extends4(data, this.createData());
      const isVideo = data.ot === CmcdObjectType.INIT || data.ot === CmcdObjectType.VIDEO || data.ot === CmcdObjectType.MUXED;
      if (this.starved && isVideo) {
        data.bs = true;
        data.su = true;
        this.starved = false;
      }
      if (data.su == null) {
        data.su = this.buffering;
      }
      const {
        includeKeys
      } = this;
      if (includeKeys) {
        data = Object.keys(data).reduce((acc, key) => {
          includeKeys.includes(key) && (acc[key] = data[key]);
          return acc;
        }, {});
      }
      const options = {
        baseUrl: context3.url
      };
      if (this.useHeaders) {
        if (!context3.headers) {
          context3.headers = {};
        }
        appendCmcdHeaders(context3.headers, data, options);
      } else {
        context3.url = appendCmcdQuery(context3.url, data, options);
      }
    }
    getNextFrag(fragment) {
      var _this$hls$levels$frag;
      const levelDetails = (_this$hls$levels$frag = this.hls.levels[fragment.level]) == null ? void 0 : _this$hls$levels$frag.details;
      if (levelDetails) {
        const index = fragment.sn - levelDetails.startSN;
        return levelDetails.fragments[index + 1];
      }
      return void 0;
    }
    getNextPart(part) {
      var _this$hls$levels$frag2;
      const {
        index,
        fragment
      } = part;
      const partList = (_this$hls$levels$frag2 = this.hls.levels[fragment.level]) == null || (_this$hls$levels$frag2 = _this$hls$levels$frag2.details) == null ? void 0 : _this$hls$levels$frag2.partList;
      if (partList) {
        const {
          sn
        } = fragment;
        for (let i = partList.length - 1; i >= 0; i--) {
          const p = partList[i];
          if (p.index === index && p.fragment.sn === sn) {
            return partList[i + 1];
          }
        }
      }
      return void 0;
    }
    /**
     * The CMCD object type.
     */
    getObjectType(fragment) {
      const {
        type
      } = fragment;
      if (type === "subtitle") {
        return CmcdObjectType.TIMED_TEXT;
      }
      if (fragment.sn === "initSegment") {
        return CmcdObjectType.INIT;
      }
      if (type === "audio") {
        return CmcdObjectType.AUDIO;
      }
      if (type === "main") {
        if (!this.hls.audioTracks.length) {
          return CmcdObjectType.MUXED;
        }
        return CmcdObjectType.VIDEO;
      }
      return void 0;
    }
    /**
     * Get the highest bitrate.
     */
    getTopBandwidth(type) {
      let bitrate = 0;
      let levels;
      const hls = this.hls;
      if (type === CmcdObjectType.AUDIO) {
        levels = hls.audioTracks;
      } else {
        const max = hls.maxAutoLevel;
        const len = max > -1 ? max + 1 : hls.levels.length;
        levels = hls.levels.slice(0, len);
      }
      levels.forEach((level) => {
        if (level.bitrate > bitrate) {
          bitrate = level.bitrate;
        }
      });
      return bitrate > 0 ? bitrate : NaN;
    }
    /**
     * Get the buffer length for a media type in milliseconds
     */
    getBufferLength(type) {
      const media = this.media;
      const buffer = type === CmcdObjectType.AUDIO ? this.audioBuffer : this.videoBuffer;
      if (!buffer || !media) {
        return NaN;
      }
      const info = BufferHelper.bufferInfo(buffer, media.currentTime, this.config.maxBufferHole);
      return info.len * 1e3;
    }
    /**
     * Create a playlist loader
     */
    createPlaylistLoader() {
      const {
        pLoader
      } = this.config;
      const apply = this.applyPlaylistData;
      const Ctor = pLoader || this.config.loader;
      return class CmcdPlaylistLoader {
        constructor(config3) {
          this.loader = void 0;
          this.loader = new Ctor(config3);
        }
        get stats() {
          return this.loader.stats;
        }
        get context() {
          return this.loader.context;
        }
        destroy() {
          this.loader.destroy();
        }
        abort() {
          this.loader.abort();
        }
        load(context3, config3, callbacks) {
          apply(context3);
          this.loader.load(context3, config3, callbacks);
        }
      };
    }
    /**
     * Create a playlist loader
     */
    createFragmentLoader() {
      const {
        fLoader
      } = this.config;
      const apply = this.applyFragmentData;
      const Ctor = fLoader || this.config.loader;
      return class CmcdFragmentLoader {
        constructor(config3) {
          this.loader = void 0;
          this.loader = new Ctor(config3);
        }
        get stats() {
          return this.loader.stats;
        }
        get context() {
          return this.loader.context;
        }
        destroy() {
          this.loader.destroy();
        }
        abort() {
          this.loader.abort();
        }
        load(context3, config3, callbacks) {
          apply(context3);
          this.loader.load(context3, config3, callbacks);
        }
      };
    }
  };
  var PATHWAY_PENALTY_DURATION_MS = 3e5;
  var ContentSteeringController = class extends Logger {
    constructor(hls) {
      super("content-steering", hls.logger);
      this.hls = void 0;
      this.loader = null;
      this.uri = null;
      this.pathwayId = ".";
      this._pathwayPriority = null;
      this.timeToLoad = 300;
      this.reloadTimer = -1;
      this.updated = 0;
      this.started = false;
      this.enabled = true;
      this.levels = null;
      this.audioTracks = null;
      this.subtitleTracks = null;
      this.penalizedPathways = {};
      this.hls = hls;
      this.registerListeners();
    }
    registerListeners() {
      const hls = this.hls;
      hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);
      hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);
      hls.on(Events.ERROR, this.onError, this);
    }
    unregisterListeners() {
      const hls = this.hls;
      if (!hls) {
        return;
      }
      hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);
      hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);
      hls.off(Events.ERROR, this.onError, this);
    }
    pathways() {
      return (this.levels || []).reduce((pathways, level) => {
        if (pathways.indexOf(level.pathwayId) === -1) {
          pathways.push(level.pathwayId);
        }
        return pathways;
      }, []);
    }
    get pathwayPriority() {
      return this._pathwayPriority;
    }
    set pathwayPriority(pathwayPriority) {
      this.updatePathwayPriority(pathwayPriority);
    }
    startLoad() {
      this.started = true;
      this.clearTimeout();
      if (this.enabled && this.uri) {
        if (this.updated) {
          const ttl = this.timeToLoad * 1e3 - (performance.now() - this.updated);
          if (ttl > 0) {
            this.scheduleRefresh(this.uri, ttl);
            return;
          }
        }
        this.loadSteeringManifest(this.uri);
      }
    }
    stopLoad() {
      this.started = false;
      if (this.loader) {
        this.loader.destroy();
        this.loader = null;
      }
      this.clearTimeout();
    }
    clearTimeout() {
      if (this.reloadTimer !== -1) {
        self.clearTimeout(this.reloadTimer);
        this.reloadTimer = -1;
      }
    }
    destroy() {
      this.unregisterListeners();
      this.stopLoad();
      this.hls = null;
      this.levels = this.audioTracks = this.subtitleTracks = null;
    }
    removeLevel(levelToRemove) {
      const levels = this.levels;
      if (levels) {
        this.levels = levels.filter((level) => level !== levelToRemove);
      }
    }
    onManifestLoading() {
      this.stopLoad();
      this.enabled = true;
      this.timeToLoad = 300;
      this.updated = 0;
      this.uri = null;
      this.pathwayId = ".";
      this.levels = this.audioTracks = this.subtitleTracks = null;
    }
    onManifestLoaded(event, data) {
      const {
        contentSteering
      } = data;
      if (contentSteering === null) {
        return;
      }
      this.pathwayId = contentSteering.pathwayId;
      this.uri = contentSteering.uri;
      if (this.started) {
        this.startLoad();
      }
    }
    onManifestParsed(event, data) {
      this.audioTracks = data.audioTracks;
      this.subtitleTracks = data.subtitleTracks;
    }
    onError(event, data) {
      const {
        errorAction
      } = data;
      if ((errorAction == null ? void 0 : errorAction.action) === NetworkErrorAction.SendAlternateToPenaltyBox && errorAction.flags === ErrorActionFlags.MoveAllAlternatesMatchingHost) {
        const levels = this.levels;
        let pathwayPriority = this._pathwayPriority;
        let errorPathway = this.pathwayId;
        if (data.context) {
          const {
            groupId,
            pathwayId,
            type
          } = data.context;
          if (groupId && levels) {
            errorPathway = this.getPathwayForGroupId(groupId, type, errorPathway);
          } else if (pathwayId) {
            errorPathway = pathwayId;
          }
        }
        if (!(errorPathway in this.penalizedPathways)) {
          this.penalizedPathways[errorPathway] = performance.now();
        }
        if (!pathwayPriority && levels) {
          pathwayPriority = this.pathways();
        }
        if (pathwayPriority && pathwayPriority.length > 1) {
          this.updatePathwayPriority(pathwayPriority);
          errorAction.resolved = this.pathwayId !== errorPathway;
        }
        if (data.details === ErrorDetails.BUFFER_APPEND_ERROR && !data.fatal) {
          errorAction.resolved = true;
        } else if (!errorAction.resolved) {
          this.warn(`Could not resolve ${data.details} ("${data.error.message}") with content-steering for Pathway: ${errorPathway} levels: ${levels ? levels.length : levels} priorities: ${stringify(pathwayPriority)} penalized: ${stringify(this.penalizedPathways)}`);
        }
      }
    }
    filterParsedLevels(levels) {
      this.levels = levels;
      let pathwayLevels = this.getLevelsForPathway(this.pathwayId);
      if (pathwayLevels.length === 0) {
        const pathwayId = levels[0].pathwayId;
        this.log(`No levels found in Pathway ${this.pathwayId}. Setting initial Pathway to "${pathwayId}"`);
        pathwayLevels = this.getLevelsForPathway(pathwayId);
        this.pathwayId = pathwayId;
      }
      if (pathwayLevels.length !== levels.length) {
        this.log(`Found ${pathwayLevels.length}/${levels.length} levels in Pathway "${this.pathwayId}"`);
      }
      return pathwayLevels;
    }
    getLevelsForPathway(pathwayId) {
      if (this.levels === null) {
        return [];
      }
      return this.levels.filter((level) => pathwayId === level.pathwayId);
    }
    updatePathwayPriority(pathwayPriority) {
      this._pathwayPriority = pathwayPriority;
      let levels;
      const penalizedPathways = this.penalizedPathways;
      const now3 = performance.now();
      Object.keys(penalizedPathways).forEach((pathwayId) => {
        if (now3 - penalizedPathways[pathwayId] > PATHWAY_PENALTY_DURATION_MS) {
          delete penalizedPathways[pathwayId];
        }
      });
      for (let i = 0; i < pathwayPriority.length; i++) {
        const pathwayId = pathwayPriority[i];
        if (pathwayId in penalizedPathways) {
          continue;
        }
        if (pathwayId === this.pathwayId) {
          return;
        }
        const selectedIndex = this.hls.nextLoadLevel;
        const selectedLevel = this.hls.levels[selectedIndex];
        levels = this.getLevelsForPathway(pathwayId);
        if (levels.length > 0) {
          this.log(`Setting Pathway to "${pathwayId}"`);
          this.pathwayId = pathwayId;
          reassignFragmentLevelIndexes(levels);
          this.hls.trigger(Events.LEVELS_UPDATED, {
            levels
          });
          const levelAfterChange = this.hls.levels[selectedIndex];
          if (selectedLevel && levelAfterChange && this.levels) {
            if (levelAfterChange.attrs["STABLE-VARIANT-ID"] !== selectedLevel.attrs["STABLE-VARIANT-ID"] && levelAfterChange.bitrate !== selectedLevel.bitrate) {
              this.log(`Unstable Pathways change from bitrate ${selectedLevel.bitrate} to ${levelAfterChange.bitrate}`);
            }
            this.hls.nextLoadLevel = selectedIndex;
          }
          break;
        }
      }
    }
    getPathwayForGroupId(groupId, type, defaultPathway) {
      const levels = this.getLevelsForPathway(defaultPathway).concat(this.levels || []);
      for (let i = 0; i < levels.length; i++) {
        if (type === PlaylistContextType.AUDIO_TRACK && levels[i].hasAudioGroup(groupId) || type === PlaylistContextType.SUBTITLE_TRACK && levels[i].hasSubtitleGroup(groupId)) {
          return levels[i].pathwayId;
        }
      }
      return defaultPathway;
    }
    clonePathways(pathwayClones) {
      const levels = this.levels;
      if (!levels) {
        return;
      }
      const audioGroupCloneMap = {};
      const subtitleGroupCloneMap = {};
      pathwayClones.forEach((pathwayClone) => {
        const {
          ID: cloneId,
          "BASE-ID": baseId,
          "URI-REPLACEMENT": uriReplacement
        } = pathwayClone;
        if (levels.some((level) => level.pathwayId === cloneId)) {
          return;
        }
        const clonedVariants = this.getLevelsForPathway(baseId).map((baseLevel) => {
          const attributes = new AttrList(baseLevel.attrs);
          attributes["PATHWAY-ID"] = cloneId;
          const clonedAudioGroupId = attributes.AUDIO && `${attributes.AUDIO}_clone_${cloneId}`;
          const clonedSubtitleGroupId = attributes.SUBTITLES && `${attributes.SUBTITLES}_clone_${cloneId}`;
          if (clonedAudioGroupId) {
            audioGroupCloneMap[attributes.AUDIO] = clonedAudioGroupId;
            attributes.AUDIO = clonedAudioGroupId;
          }
          if (clonedSubtitleGroupId) {
            subtitleGroupCloneMap[attributes.SUBTITLES] = clonedSubtitleGroupId;
            attributes.SUBTITLES = clonedSubtitleGroupId;
          }
          const url = performUriReplacement(baseLevel.uri, attributes["STABLE-VARIANT-ID"], "PER-VARIANT-URIS", uriReplacement);
          const clonedLevel = new Level({
            attrs: attributes,
            audioCodec: baseLevel.audioCodec,
            bitrate: baseLevel.bitrate,
            height: baseLevel.height,
            name: baseLevel.name,
            url,
            videoCodec: baseLevel.videoCodec,
            width: baseLevel.width
          });
          if (baseLevel.audioGroups) {
            for (let i = 1; i < baseLevel.audioGroups.length; i++) {
              clonedLevel.addGroupId("audio", `${baseLevel.audioGroups[i]}_clone_${cloneId}`);
            }
          }
          if (baseLevel.subtitleGroups) {
            for (let i = 1; i < baseLevel.subtitleGroups.length; i++) {
              clonedLevel.addGroupId("text", `${baseLevel.subtitleGroups[i]}_clone_${cloneId}`);
            }
          }
          return clonedLevel;
        });
        levels.push(...clonedVariants);
        cloneRenditionGroups(this.audioTracks, audioGroupCloneMap, uriReplacement, cloneId);
        cloneRenditionGroups(this.subtitleTracks, subtitleGroupCloneMap, uriReplacement, cloneId);
      });
    }
    loadSteeringManifest(uri) {
      const config3 = this.hls.config;
      const Loader = config3.loader;
      if (this.loader) {
        this.loader.destroy();
      }
      this.loader = new Loader(config3);
      let url;
      try {
        url = new self.URL(uri);
      } catch (error) {
        this.enabled = false;
        this.log(`Failed to parse Steering Manifest URI: ${uri}`);
        return;
      }
      if (url.protocol !== "data:") {
        const throughput = (this.hls.bandwidthEstimate || config3.abrEwmaDefaultEstimate) | 0;
        url.searchParams.set("_HLS_pathway", this.pathwayId);
        url.searchParams.set("_HLS_throughput", "" + throughput);
      }
      const context3 = {
        responseType: "json",
        url: url.href
      };
      const loadPolicy = config3.steeringManifestLoadPolicy.default;
      const legacyRetryCompatibility = loadPolicy.errorRetry || loadPolicy.timeoutRetry || {};
      const loaderConfig = {
        loadPolicy,
        timeout: loadPolicy.maxLoadTimeMs,
        maxRetry: legacyRetryCompatibility.maxNumRetry || 0,
        retryDelay: legacyRetryCompatibility.retryDelayMs || 0,
        maxRetryDelay: legacyRetryCompatibility.maxRetryDelayMs || 0
      };
      const callbacks = {
        onSuccess: (response, stats, context4, networkDetails) => {
          this.log(`Loaded steering manifest: "${url}"`);
          const steeringData = response.data;
          if ((steeringData == null ? void 0 : steeringData.VERSION) !== 1) {
            this.log(`Steering VERSION ${steeringData.VERSION} not supported!`);
            return;
          }
          this.updated = performance.now();
          this.timeToLoad = steeringData.TTL;
          const {
            "RELOAD-URI": reloadUri,
            "PATHWAY-CLONES": pathwayClones,
            "PATHWAY-PRIORITY": pathwayPriority
          } = steeringData;
          if (reloadUri) {
            try {
              this.uri = new self.URL(reloadUri, url).href;
            } catch (error) {
              this.enabled = false;
              this.log(`Failed to parse Steering Manifest RELOAD-URI: ${reloadUri}`);
              return;
            }
          }
          this.scheduleRefresh(this.uri || context4.url);
          if (pathwayClones) {
            this.clonePathways(pathwayClones);
          }
          const loadedSteeringData = {
            steeringManifest: steeringData,
            url: url.toString()
          };
          this.hls.trigger(Events.STEERING_MANIFEST_LOADED, loadedSteeringData);
          if (pathwayPriority) {
            this.updatePathwayPriority(pathwayPriority);
          }
        },
        onError: (error, context4, networkDetails, stats) => {
          this.log(`Error loading steering manifest: ${error.code} ${error.text} (${context4.url})`);
          this.stopLoad();
          if (error.code === 410) {
            this.enabled = false;
            this.log(`Steering manifest ${context4.url} no longer available`);
            return;
          }
          let ttl = this.timeToLoad * 1e3;
          if (error.code === 429) {
            const loader = this.loader;
            if (typeof (loader == null ? void 0 : loader.getResponseHeader) === "function") {
              const retryAfter = loader.getResponseHeader("Retry-After");
              if (retryAfter) {
                ttl = parseFloat(retryAfter) * 1e3;
              }
            }
            this.log(`Steering manifest ${context4.url} rate limited`);
            return;
          }
          this.scheduleRefresh(this.uri || context4.url, ttl);
        },
        onTimeout: (stats, context4, networkDetails) => {
          this.log(`Timeout loading steering manifest (${context4.url})`);
          this.scheduleRefresh(this.uri || context4.url);
        }
      };
      this.log(`Requesting steering manifest: ${url}`);
      this.loader.load(context3, loaderConfig, callbacks);
    }
    scheduleRefresh(uri, ttlMs = this.timeToLoad * 1e3) {
      this.clearTimeout();
      this.reloadTimer = self.setTimeout(() => {
        var _this$hls;
        const media = (_this$hls = this.hls) == null ? void 0 : _this$hls.media;
        if (media && !media.ended) {
          this.loadSteeringManifest(uri);
          return;
        }
        this.scheduleRefresh(uri, this.timeToLoad * 1e3);
      }, ttlMs);
    }
  };
  function cloneRenditionGroups(tracks, groupCloneMap, uriReplacement, cloneId) {
    if (!tracks) {
      return;
    }
    Object.keys(groupCloneMap).forEach((audioGroupId) => {
      const clonedTracks = tracks.filter((track) => track.groupId === audioGroupId).map((track) => {
        const clonedTrack = _extends4({}, track);
        clonedTrack.details = void 0;
        clonedTrack.attrs = new AttrList(clonedTrack.attrs);
        clonedTrack.url = clonedTrack.attrs.URI = performUriReplacement(track.url, track.attrs["STABLE-RENDITION-ID"], "PER-RENDITION-URIS", uriReplacement);
        clonedTrack.groupId = clonedTrack.attrs["GROUP-ID"] = groupCloneMap[audioGroupId];
        clonedTrack.attrs["PATHWAY-ID"] = cloneId;
        return clonedTrack;
      });
      tracks.push(...clonedTracks);
    });
  }
  function performUriReplacement(uri, stableId, perOptionKey, uriReplacement) {
    const {
      HOST: host,
      PARAMS: params,
      [perOptionKey]: perOptionUris
    } = uriReplacement;
    let perVariantUri;
    if (stableId) {
      perVariantUri = perOptionUris == null ? void 0 : perOptionUris[stableId];
      if (perVariantUri) {
        uri = perVariantUri;
      }
    }
    const url = new self.URL(uri);
    if (host && !perVariantUri) {
      url.host = host;
    }
    if (params) {
      Object.keys(params).sort().forEach((key) => {
        if (key) {
          url.searchParams.set(key, params[key]);
        }
      });
    }
    return url.href;
  }
  var EMEController = class _EMEController extends Logger {
    constructor(hls) {
      super("eme", hls.logger);
      this.hls = void 0;
      this.config = void 0;
      this.media = null;
      this.keyFormatPromise = null;
      this.keySystemAccessPromises = {};
      this._requestLicenseFailureCount = 0;
      this.mediaKeySessions = [];
      this.keyIdToKeySessionPromise = {};
      this.mediaKeys = null;
      this.setMediaKeysQueue = _EMEController.CDMCleanupPromise ? [_EMEController.CDMCleanupPromise] : [];
      this.bannedKeyIds = {};
      this.onMediaEncrypted = (event) => {
        const {
          initDataType,
          initData
        } = event;
        const logMessage = `"${event.type}" event: init data type: "${initDataType}"`;
        this.debug(logMessage);
        if (initData === null) {
          return;
        }
        if (!this.keyFormatPromise) {
          let keySystems = Object.keys(this.keySystemAccessPromises);
          if (!keySystems.length) {
            keySystems = getKeySystemsForConfig(this.config);
          }
          const keyFormats = keySystems.map(keySystemDomainToKeySystemFormat).filter((k) => !!k);
          this.keyFormatPromise = this.getKeyFormatPromise(keyFormats);
        }
        this.keyFormatPromise.then((keySystemFormat) => {
          const keySystem = keySystemFormatToKeySystemDomain(keySystemFormat);
          if (initDataType !== "sinf" || keySystem !== KeySystems.FAIRPLAY) {
            this.log(`Ignoring "${event.type}" event with init data type: "${initDataType}" for selected key-system ${keySystem}`);
            return;
          }
          let keyId;
          try {
            const json2 = bin2str(new Uint8Array(initData));
            const sinf = base64Decode(JSON.parse(json2).sinf);
            const tenc = parseSinf(sinf);
            if (!tenc) {
              throw new Error(`'schm' box missing or not cbcs/cenc with schi > tenc`);
            }
            keyId = new Uint8Array(tenc.subarray(8, 24));
          } catch (error) {
            this.warn(`${logMessage} Failed to parse sinf: ${error}`);
            return;
          }
          const keyIdHex = arrayToHex(keyId);
          const {
            keyIdToKeySessionPromise,
            mediaKeySessions
          } = this;
          let keySessionContextPromise = keyIdToKeySessionPromise[keyIdHex];
          for (let i = 0; i < mediaKeySessions.length; i++) {
            const keyContext = mediaKeySessions[i];
            const decryptdata = keyContext.decryptdata;
            if (!decryptdata.keyId) {
              continue;
            }
            const oldKeyIdHex = arrayToHex(decryptdata.keyId);
            if (arrayValuesMatch(keyId, decryptdata.keyId) || decryptdata.uri.replace(/-/g, "").indexOf(keyIdHex) !== -1) {
              keySessionContextPromise = keyIdToKeySessionPromise[oldKeyIdHex];
              if (!keySessionContextPromise) {
                continue;
              }
              if (decryptdata.pssh) {
                break;
              }
              delete keyIdToKeySessionPromise[oldKeyIdHex];
              decryptdata.pssh = new Uint8Array(initData);
              decryptdata.keyId = keyId;
              keySessionContextPromise = keyIdToKeySessionPromise[keyIdHex] = keySessionContextPromise.then(() => {
                return this.generateRequestWithPreferredKeySession(keyContext, initDataType, initData, "encrypted-event-key-match");
              });
              keySessionContextPromise.catch((error) => this.handleError(error));
              break;
            }
          }
          if (!keySessionContextPromise) {
            this.handleError(new Error(`Key ID ${keyIdHex} not encountered in playlist. Key-system sessions ${mediaKeySessions.length}.`));
          }
        }).catch((error) => this.handleError(error));
      };
      this.onWaitingForKey = (event) => {
        this.log(`"${event.type}" event`);
      };
      this.hls = hls;
      this.config = hls.config;
      this.registerListeners();
    }
    destroy() {
      this.onDestroying();
      this.onMediaDetached();
      const config3 = this.config;
      config3.requestMediaKeySystemAccessFunc = null;
      config3.licenseXhrSetup = config3.licenseResponseCallback = void 0;
      config3.drmSystems = config3.drmSystemOptions = {};
      this.hls = this.config = this.keyIdToKeySessionPromise = null;
      this.onMediaEncrypted = this.onWaitingForKey = null;
    }
    registerListeners() {
      this.hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
      this.hls.on(Events.MEDIA_DETACHED, this.onMediaDetached, this);
      this.hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
      this.hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);
      this.hls.on(Events.DESTROYING, this.onDestroying, this);
    }
    unregisterListeners() {
      this.hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
      this.hls.off(Events.MEDIA_DETACHED, this.onMediaDetached, this);
      this.hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
      this.hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);
      this.hls.off(Events.DESTROYING, this.onDestroying, this);
    }
    getLicenseServerUrl(keySystem) {
      const {
        drmSystems,
        widevineLicenseUrl
      } = this.config;
      const keySystemConfiguration = drmSystems == null ? void 0 : drmSystems[keySystem];
      if (keySystemConfiguration) {
        return keySystemConfiguration.licenseUrl;
      }
      if (keySystem === KeySystems.WIDEVINE && widevineLicenseUrl) {
        return widevineLicenseUrl;
      }
    }
    getLicenseServerUrlOrThrow(keySystem) {
      const url = this.getLicenseServerUrl(keySystem);
      if (url === void 0) {
        throw new Error(`no license server URL configured for key-system "${keySystem}"`);
      }
      return url;
    }
    getServerCertificateUrl(keySystem) {
      const {
        drmSystems
      } = this.config;
      const keySystemConfiguration = drmSystems == null ? void 0 : drmSystems[keySystem];
      if (keySystemConfiguration) {
        return keySystemConfiguration.serverCertificateUrl;
      } else {
        this.log(`No Server Certificate in config.drmSystems["${keySystem}"]`);
      }
    }
    attemptKeySystemAccess(keySystemsToAttempt) {
      const levels = this.hls.levels;
      const uniqueCodec = (value, i, a) => !!value && a.indexOf(value) === i;
      const audioCodecs = levels.map((level) => level.audioCodec).filter(uniqueCodec);
      const videoCodecs = levels.map((level) => level.videoCodec).filter(uniqueCodec);
      if (audioCodecs.length + videoCodecs.length === 0) {
        videoCodecs.push("avc1.42e01e");
      }
      return new Promise((resolve, reject) => {
        const attempt = (keySystems) => {
          const keySystem = keySystems.shift();
          this.getMediaKeysPromise(keySystem, audioCodecs, videoCodecs).then((mediaKeys) => resolve({
            keySystem,
            mediaKeys
          })).catch((error) => {
            if (keySystems.length) {
              attempt(keySystems);
            } else if (error instanceof EMEKeyError) {
              reject(error);
            } else {
              reject(new EMEKeyError({
                type: ErrorTypes.KEY_SYSTEM_ERROR,
                details: ErrorDetails.KEY_SYSTEM_NO_ACCESS,
                error,
                fatal: true
              }, error.message));
            }
          });
        };
        attempt(keySystemsToAttempt);
      });
    }
    requestMediaKeySystemAccess(keySystem, supportedConfigurations) {
      const {
        requestMediaKeySystemAccessFunc
      } = this.config;
      if (!(typeof requestMediaKeySystemAccessFunc === "function")) {
        let errMessage = `Configured requestMediaKeySystemAccess is not a function ${requestMediaKeySystemAccessFunc}`;
        if (requestMediaKeySystemAccess === null && self.location.protocol === "http:") {
          errMessage = `navigator.requestMediaKeySystemAccess is not available over insecure protocol ${location.protocol}`;
        }
        return Promise.reject(new Error(errMessage));
      }
      return requestMediaKeySystemAccessFunc(keySystem, supportedConfigurations);
    }
    getMediaKeysPromise(keySystem, audioCodecs, videoCodecs) {
      var _keySystemAccessPromi;
      const mediaKeySystemConfigs = getSupportedMediaKeySystemConfigurations(keySystem, audioCodecs, videoCodecs, this.config.drmSystemOptions || {});
      let keySystemAccessPromises = this.keySystemAccessPromises[keySystem];
      let keySystemAccess = (_keySystemAccessPromi = keySystemAccessPromises) == null ? void 0 : _keySystemAccessPromi.keySystemAccess;
      if (!keySystemAccess) {
        this.log(`Requesting encrypted media "${keySystem}" key-system access with config: ${stringify(mediaKeySystemConfigs)}`);
        keySystemAccess = this.requestMediaKeySystemAccess(keySystem, mediaKeySystemConfigs);
        const keySystemAccessPromisesNew = keySystemAccessPromises = this.keySystemAccessPromises[keySystem] = {
          keySystemAccess
        };
        keySystemAccess.catch((error) => {
          this.log(`Failed to obtain access to key-system "${keySystem}": ${error}`);
        });
        return keySystemAccess.then((mediaKeySystemAccess) => {
          this.log(`Access for key-system "${mediaKeySystemAccess.keySystem}" obtained`);
          const certificateRequest = this.fetchServerCertificate(keySystem);
          this.log(`Create media-keys for "${keySystem}"`);
          const mediaKeys = keySystemAccessPromisesNew.mediaKeys = mediaKeySystemAccess.createMediaKeys().then((mediaKeys2) => {
            this.log(`Media-keys created for "${keySystem}"`);
            keySystemAccessPromisesNew.hasMediaKeys = true;
            return certificateRequest.then((certificate) => {
              if (certificate) {
                return this.setMediaKeysServerCertificate(mediaKeys2, keySystem, certificate);
              }
              return mediaKeys2;
            });
          });
          mediaKeys.catch((error) => {
            this.error(`Failed to create media-keys for "${keySystem}"}: ${error}`);
          });
          return mediaKeys;
        });
      }
      return keySystemAccess.then(() => keySystemAccessPromises.mediaKeys);
    }
    createMediaKeySessionContext({
      decryptdata,
      keySystem,
      mediaKeys
    }) {
      this.log(`Creating key-system session "${keySystem}" keyId: ${arrayToHex(decryptdata.keyId || [])} keyUri: ${decryptdata.uri}`);
      const mediaKeysSession = mediaKeys.createSession();
      const mediaKeySessionContext = {
        decryptdata,
        keySystem,
        mediaKeys,
        mediaKeysSession,
        keyStatus: "status-pending"
      };
      this.mediaKeySessions.push(mediaKeySessionContext);
      return mediaKeySessionContext;
    }
    renewKeySession(mediaKeySessionContext) {
      const decryptdata = mediaKeySessionContext.decryptdata;
      if (decryptdata.pssh) {
        const keySessionContext = this.createMediaKeySessionContext(mediaKeySessionContext);
        const keyId = getKeyIdString(decryptdata);
        const scheme = "cenc";
        this.keyIdToKeySessionPromise[keyId] = this.generateRequestWithPreferredKeySession(keySessionContext, scheme, decryptdata.pssh.buffer, "expired");
      } else {
        this.warn(`Could not renew expired session. Missing pssh initData.`);
      }
      this.removeSession(mediaKeySessionContext);
    }
    updateKeySession(mediaKeySessionContext, data) {
      const keySession = mediaKeySessionContext.mediaKeysSession;
      this.log(`Updating key-session "${keySession.sessionId}" for keyId ${arrayToHex(mediaKeySessionContext.decryptdata.keyId || [])}
      } (data length: ${data.byteLength})`);
      return keySession.update(data);
    }
    getSelectedKeySystemFormats() {
      return Object.keys(this.keySystemAccessPromises).map((keySystem) => ({
        keySystem,
        hasMediaKeys: this.keySystemAccessPromises[keySystem].hasMediaKeys
      })).filter(({
        hasMediaKeys
      }) => !!hasMediaKeys).map(({
        keySystem
      }) => keySystemDomainToKeySystemFormat(keySystem)).filter((keySystem) => !!keySystem);
    }
    getKeySystemAccess(keySystemsToAttempt) {
      return this.getKeySystemSelectionPromise(keySystemsToAttempt).then(({
        keySystem,
        mediaKeys
      }) => {
        return this.attemptSetMediaKeys(keySystem, mediaKeys);
      });
    }
    selectKeySystem(keySystemsToAttempt) {
      return new Promise((resolve, reject) => {
        this.getKeySystemSelectionPromise(keySystemsToAttempt).then(({
          keySystem
        }) => {
          const keySystemFormat = keySystemDomainToKeySystemFormat(keySystem);
          if (keySystemFormat) {
            resolve(keySystemFormat);
          } else {
            reject(new Error(`Unable to find format for key-system "${keySystem}"`));
          }
        }).catch(reject);
      });
    }
    selectKeySystemFormat(frag) {
      const keyFormats = Object.keys(frag.levelkeys || {});
      if (!this.keyFormatPromise) {
        this.log(`Selecting key-system from fragment (sn: ${frag.sn} ${frag.type}: ${frag.level}) key formats ${keyFormats.join(", ")}`);
        this.keyFormatPromise = this.getKeyFormatPromise(keyFormats);
      }
      return this.keyFormatPromise;
    }
    getKeyFormatPromise(keyFormats) {
      const keySystemsInConfig = getKeySystemsForConfig(this.config);
      const keySystemsToAttempt = keyFormats.map(keySystemFormatToKeySystemDomain).filter((value) => !!value && keySystemsInConfig.indexOf(value) !== -1);
      return this.selectKeySystem(keySystemsToAttempt);
    }
    getKeyStatus(decryptdata) {
      const {
        mediaKeySessions
      } = this;
      for (let i = 0; i < mediaKeySessions.length; i++) {
        const status2 = getKeyStatus(decryptdata, mediaKeySessions[i]);
        if (status2) {
          return status2;
        }
      }
      return void 0;
    }
    loadKey(data) {
      const decryptdata = data.keyInfo.decryptdata;
      const keyId = getKeyIdString(decryptdata);
      const badStatus = this.bannedKeyIds[keyId];
      if (badStatus || this.getKeyStatus(decryptdata) === "internal-error") {
        const error = getKeyStatusError(badStatus || "internal-error", decryptdata);
        this.handleError(error, data.frag);
        return Promise.reject(error);
      }
      const keyDetails = `(keyId: ${keyId} format: "${decryptdata.keyFormat}" method: ${decryptdata.method} uri: ${decryptdata.uri})`;
      this.log(`Starting session for key ${keyDetails}`);
      const keyContextPromise = this.keyIdToKeySessionPromise[keyId];
      if (!keyContextPromise) {
        const keySessionContextPromise = this.getKeySystemForKeyPromise(decryptdata).then(({
          keySystem,
          mediaKeys
        }) => {
          this.throwIfDestroyed();
          this.log(`Handle encrypted media sn: ${data.frag.sn} ${data.frag.type}: ${data.frag.level} using key ${keyDetails}`);
          return this.attemptSetMediaKeys(keySystem, mediaKeys).then(() => {
            this.throwIfDestroyed();
            return this.createMediaKeySessionContext({
              keySystem,
              mediaKeys,
              decryptdata
            });
          });
        }).then((keySessionContext) => {
          const scheme = "cenc";
          const initData = decryptdata.pssh ? decryptdata.pssh.buffer : null;
          return this.generateRequestWithPreferredKeySession(keySessionContext, scheme, initData, "playlist-key");
        });
        keySessionContextPromise.catch((error) => this.handleError(error, data.frag));
        this.keyIdToKeySessionPromise[keyId] = keySessionContextPromise;
        return keySessionContextPromise;
      }
      keyContextPromise.catch((error) => {
        if (error instanceof EMEKeyError) {
          const errorData = _objectSpread2({}, error.data);
          if (this.getKeyStatus(decryptdata) === "internal-error") {
            errorData.decryptdata = decryptdata;
          }
          const clonedError = new EMEKeyError(errorData, error.message);
          this.handleError(clonedError, data.frag);
        }
      });
      return keyContextPromise;
    }
    throwIfDestroyed(message = "Invalid state") {
      if (!this.hls) {
        throw new Error("invalid state");
      }
    }
    handleError(error, frag) {
      if (!this.hls) {
        return;
      }
      if (error instanceof EMEKeyError) {
        if (frag) {
          error.data.frag = frag;
        }
        const levelKey = error.data.decryptdata;
        this.error(`${error.message}${levelKey ? ` (${arrayToHex(levelKey.keyId || [])})` : ""}`);
        this.hls.trigger(Events.ERROR, error.data);
      } else {
        this.error(error.message);
        this.hls.trigger(Events.ERROR, {
          type: ErrorTypes.KEY_SYSTEM_ERROR,
          details: ErrorDetails.KEY_SYSTEM_NO_KEYS,
          error,
          fatal: true
        });
      }
    }
    getKeySystemForKeyPromise(decryptdata) {
      const keyId = getKeyIdString(decryptdata);
      const mediaKeySessionContext = this.keyIdToKeySessionPromise[keyId];
      if (!mediaKeySessionContext) {
        const keySystem = keySystemFormatToKeySystemDomain(decryptdata.keyFormat);
        const keySystemsToAttempt = keySystem ? [keySystem] : getKeySystemsForConfig(this.config);
        return this.attemptKeySystemAccess(keySystemsToAttempt);
      }
      return mediaKeySessionContext;
    }
    getKeySystemSelectionPromise(keySystemsToAttempt) {
      if (!keySystemsToAttempt.length) {
        keySystemsToAttempt = getKeySystemsForConfig(this.config);
      }
      if (keySystemsToAttempt.length === 0) {
        throw new EMEKeyError({
          type: ErrorTypes.KEY_SYSTEM_ERROR,
          details: ErrorDetails.KEY_SYSTEM_NO_CONFIGURED_LICENSE,
          fatal: true
        }, `Missing key-system license configuration options ${stringify({
          drmSystems: this.config.drmSystems
        })}`);
      }
      return this.attemptKeySystemAccess(keySystemsToAttempt);
    }
    attemptSetMediaKeys(keySystem, mediaKeys) {
      if (this.mediaKeys === mediaKeys) {
        return Promise.resolve();
      }
      const queue = this.setMediaKeysQueue.slice();
      this.log(`Setting media-keys for "${keySystem}"`);
      const setMediaKeysPromise = Promise.all(queue).then(() => {
        if (!this.media) {
          this.mediaKeys = null;
          throw new Error("Attempted to set mediaKeys without media element attached");
        }
        return this.media.setMediaKeys(mediaKeys);
      });
      this.mediaKeys = mediaKeys;
      this.setMediaKeysQueue.push(setMediaKeysPromise);
      return setMediaKeysPromise.then(() => {
        this.log(`Media-keys set for "${keySystem}"`);
        queue.push(setMediaKeysPromise);
        this.setMediaKeysQueue = this.setMediaKeysQueue.filter((p) => queue.indexOf(p) === -1);
      });
    }
    generateRequestWithPreferredKeySession(context3, initDataType, initData, reason) {
      var _this$config$drmSyste;
      const generateRequestFilter = (_this$config$drmSyste = this.config.drmSystems) == null || (_this$config$drmSyste = _this$config$drmSyste[context3.keySystem]) == null ? void 0 : _this$config$drmSyste.generateRequest;
      if (generateRequestFilter) {
        try {
          const mappedInitData = generateRequestFilter.call(this.hls, initDataType, initData, context3);
          if (!mappedInitData) {
            throw new Error("Invalid response from configured generateRequest filter");
          }
          initDataType = mappedInitData.initDataType;
          initData = mappedInitData.initData ? mappedInitData.initData : null;
          context3.decryptdata.pssh = initData ? new Uint8Array(initData) : null;
        } catch (error) {
          this.warn(error.message);
          if (this.hls && this.hls.config.debug) {
            throw error;
          }
        }
      }
      if (initData === null) {
        this.log(`Skipping key-session request for "${reason}" (no initData)`);
        return Promise.resolve(context3);
      }
      const keyId = getKeyIdString(context3.decryptdata);
      const keyUri = context3.decryptdata.uri;
      this.log(`Generating key-session request for "${reason}" keyId: ${keyId} URI: ${keyUri} (init data type: ${initDataType} length: ${initData.byteLength})`);
      const licenseStatus = new EventEmitter();
      const onmessage = context3._onmessage = (event) => {
        const keySession = context3.mediaKeysSession;
        if (!keySession) {
          licenseStatus.emit("error", new Error("invalid state"));
          return;
        }
        const {
          messageType,
          message
        } = event;
        this.log(`"${messageType}" message event for session "${keySession.sessionId}" message size: ${message.byteLength}`);
        if (messageType === "license-request" || messageType === "license-renewal") {
          this.renewLicense(context3, message).catch((error) => {
            if (licenseStatus.eventNames().length) {
              licenseStatus.emit("error", error);
            } else {
              this.handleError(error);
            }
          });
        } else if (messageType === "license-release") {
          if (context3.keySystem === KeySystems.FAIRPLAY) {
            this.updateKeySession(context3, strToUtf8array("acknowledged")).then(() => this.removeSession(context3)).catch((error) => this.handleError(error));
          }
        } else {
          this.warn(`unhandled media key message type "${messageType}"`);
        }
      };
      const handleKeyStatus = (keyStatus, context4) => {
        context4.keyStatus = keyStatus;
        let keyError;
        if (keyStatus.startsWith("usable")) {
          licenseStatus.emit("resolved");
        } else if (keyStatus === "internal-error" || keyStatus === "output-restricted" || keyStatus === "output-downscaled") {
          keyError = getKeyStatusError(keyStatus, context4.decryptdata);
        } else if (keyStatus === "expired") {
          keyError = new Error(`key expired (keyId: ${keyId})`);
        } else if (keyStatus === "released") {
          keyError = new Error(`key released`);
        } else if (keyStatus === "status-pending") ;
        else {
          this.warn(`unhandled key status change "${keyStatus}" (keyId: ${keyId})`);
        }
        if (keyError) {
          if (licenseStatus.eventNames().length) {
            licenseStatus.emit("error", keyError);
          } else {
            this.handleError(keyError);
          }
        }
      };
      const onkeystatuseschange = context3._onkeystatuseschange = (event) => {
        const keySession = context3.mediaKeysSession;
        if (!keySession) {
          licenseStatus.emit("error", new Error("invalid state"));
          return;
        }
        const keyStatuses = this.getKeyStatuses(context3);
        const keyIds = Object.keys(keyStatuses);
        if (!keyIds.some((id3) => keyStatuses[id3] !== "status-pending")) {
          return;
        }
        if (keyStatuses[keyId] === "expired") {
          this.log(`Expired key ${stringify(keyStatuses)} in key-session "${context3.mediaKeysSession.sessionId}"`);
          this.renewKeySession(context3);
          return;
        }
        let keyStatus = keyStatuses[keyId];
        if (keyStatus) {
          handleKeyStatus(keyStatus, context3);
        } else {
          var _context$keyStatusTim;
          const timeout = 1e3;
          context3.keyStatusTimeouts || (context3.keyStatusTimeouts = {});
          (_context$keyStatusTim = context3.keyStatusTimeouts)[keyId] || (_context$keyStatusTim[keyId] = self.setTimeout(() => {
            if (!context3.mediaKeysSession || !this.mediaKeys) {
              return;
            }
            const sessionKeyStatus = this.getKeyStatus(context3.decryptdata);
            if (sessionKeyStatus && sessionKeyStatus !== "status-pending") {
              this.log(`No status for keyId ${keyId} in key-session "${context3.mediaKeysSession.sessionId}". Using session key-status ${sessionKeyStatus} from other session.`);
              return handleKeyStatus(sessionKeyStatus, context3);
            }
            this.log(`key status for ${keyId} in key-session "${context3.mediaKeysSession.sessionId}" timed out after ${timeout}ms`);
            keyStatus = "internal-error";
            handleKeyStatus(keyStatus, context3);
          }, timeout));
          this.log(`No status for keyId ${keyId} (${stringify(keyStatuses)}).`);
        }
      };
      addEventListener(context3.mediaKeysSession, "message", onmessage);
      addEventListener(context3.mediaKeysSession, "keystatuseschange", onkeystatuseschange);
      const keyUsablePromise = new Promise((resolve, reject) => {
        licenseStatus.on("error", reject);
        licenseStatus.on("resolved", resolve);
      });
      return context3.mediaKeysSession.generateRequest(initDataType, initData).then(() => {
        this.log(`Request generated for key-session "${context3.mediaKeysSession.sessionId}" keyId: ${keyId} URI: ${keyUri}`);
      }).catch((error) => {
        throw new EMEKeyError({
          type: ErrorTypes.KEY_SYSTEM_ERROR,
          details: ErrorDetails.KEY_SYSTEM_NO_SESSION,
          error,
          decryptdata: context3.decryptdata,
          fatal: false
        }, `Error generating key-session request: ${error}`);
      }).then(() => keyUsablePromise).catch((error) => {
        licenseStatus.removeAllListeners();
        return this.removeSession(context3).then(() => {
          throw error;
        });
      }).then(() => {
        licenseStatus.removeAllListeners();
        return context3;
      });
    }
    getKeyStatuses(mediaKeySessionContext) {
      const keyStatuses = {};
      mediaKeySessionContext.mediaKeysSession.keyStatuses.forEach((status2, keyId) => {
        if (typeof keyId === "string" && typeof status2 === "object") {
          const temp = keyId;
          keyId = status2;
          status2 = temp;
        }
        const keyIdArray = "buffer" in keyId ? new Uint8Array(keyId.buffer, keyId.byteOffset, keyId.byteLength) : new Uint8Array(keyId);
        if (mediaKeySessionContext.keySystem === KeySystems.PLAYREADY && keyIdArray.length === 16) {
          changeEndianness(keyIdArray);
        }
        const keyIdWithStatusChange = arrayToHex(keyIdArray);
        if (status2 === "internal-error") {
          this.bannedKeyIds[keyIdWithStatusChange] = status2;
        }
        this.log(`key status change "${status2}" for keyStatuses keyId: ${keyIdWithStatusChange} key-session "${mediaKeySessionContext.mediaKeysSession.sessionId}"`);
        keyStatuses[keyIdWithStatusChange] = status2;
      });
      return keyStatuses;
    }
    fetchServerCertificate(keySystem) {
      const config3 = this.config;
      const Loader = config3.loader;
      const certLoader = new Loader(config3);
      const url = this.getServerCertificateUrl(keySystem);
      if (!url) {
        return Promise.resolve();
      }
      this.log(`Fetching server certificate for "${keySystem}"`);
      return new Promise((resolve, reject) => {
        const loaderContext = {
          responseType: "arraybuffer",
          url
        };
        const loadPolicy = config3.certLoadPolicy.default;
        const loaderConfig = {
          loadPolicy,
          timeout: loadPolicy.maxLoadTimeMs,
          maxRetry: 0,
          retryDelay: 0,
          maxRetryDelay: 0
        };
        const loaderCallbacks = {
          onSuccess: (response, stats, context3, networkDetails) => {
            resolve(response.data);
          },
          onError: (response, contex, networkDetails, stats) => {
            reject(new EMEKeyError({
              type: ErrorTypes.KEY_SYSTEM_ERROR,
              details: ErrorDetails.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED,
              fatal: true,
              networkDetails,
              response: _objectSpread2({
                url: loaderContext.url,
                data: void 0
              }, response)
            }, `"${keySystem}" certificate request failed (${url}). Status: ${response.code} (${response.text})`));
          },
          onTimeout: (stats, context3, networkDetails) => {
            reject(new EMEKeyError({
              type: ErrorTypes.KEY_SYSTEM_ERROR,
              details: ErrorDetails.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED,
              fatal: true,
              networkDetails,
              response: {
                url: loaderContext.url,
                data: void 0
              }
            }, `"${keySystem}" certificate request timed out (${url})`));
          },
          onAbort: (stats, context3, networkDetails) => {
            reject(new Error("aborted"));
          }
        };
        certLoader.load(loaderContext, loaderConfig, loaderCallbacks);
      });
    }
    setMediaKeysServerCertificate(mediaKeys, keySystem, cert) {
      return new Promise((resolve, reject) => {
        mediaKeys.setServerCertificate(cert).then((success) => {
          this.log(`setServerCertificate ${success ? "success" : "not supported by CDM"} (${cert.byteLength}) on "${keySystem}"`);
          resolve(mediaKeys);
        }).catch((error) => {
          reject(new EMEKeyError({
            type: ErrorTypes.KEY_SYSTEM_ERROR,
            details: ErrorDetails.KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED,
            error,
            fatal: true
          }, error.message));
        });
      });
    }
    renewLicense(context3, keyMessage) {
      return this.requestLicense(context3, new Uint8Array(keyMessage)).then((data) => {
        return this.updateKeySession(context3, new Uint8Array(data)).catch((error) => {
          throw new EMEKeyError({
            type: ErrorTypes.KEY_SYSTEM_ERROR,
            details: ErrorDetails.KEY_SYSTEM_SESSION_UPDATE_FAILED,
            decryptdata: context3.decryptdata,
            error,
            fatal: false
          }, error.message);
        });
      });
    }
    unpackPlayReadyKeyMessage(xhr, licenseChallenge) {
      const xmlString = String.fromCharCode.apply(null, new Uint16Array(licenseChallenge.buffer));
      if (!xmlString.includes("PlayReadyKeyMessage")) {
        xhr.setRequestHeader("Content-Type", "text/xml; charset=utf-8");
        return licenseChallenge;
      }
      const keyMessageXml = new DOMParser().parseFromString(xmlString, "application/xml");
      const headers = keyMessageXml.querySelectorAll("HttpHeader");
      if (headers.length > 0) {
        let header;
        for (let i = 0, len = headers.length; i < len; i++) {
          var _header$querySelector, _header$querySelector2;
          header = headers[i];
          const name = (_header$querySelector = header.querySelector("name")) == null ? void 0 : _header$querySelector.textContent;
          const value = (_header$querySelector2 = header.querySelector("value")) == null ? void 0 : _header$querySelector2.textContent;
          if (name && value) {
            xhr.setRequestHeader(name, value);
          }
        }
      }
      const challengeElement = keyMessageXml.querySelector("Challenge");
      const challengeText = challengeElement == null ? void 0 : challengeElement.textContent;
      if (!challengeText) {
        throw new Error(`Cannot find <Challenge> in key message`);
      }
      return strToUtf8array(atob(challengeText));
    }
    setupLicenseXHR(xhr, url, keysListItem, licenseChallenge) {
      const licenseXhrSetup = this.config.licenseXhrSetup;
      if (!licenseXhrSetup) {
        xhr.open("POST", url, true);
        return Promise.resolve({
          xhr,
          licenseChallenge
        });
      }
      return Promise.resolve().then(() => {
        if (!keysListItem.decryptdata) {
          throw new Error("Key removed");
        }
        return licenseXhrSetup.call(this.hls, xhr, url, keysListItem, licenseChallenge);
      }).catch((error) => {
        if (!keysListItem.decryptdata) {
          throw error;
        }
        xhr.open("POST", url, true);
        return licenseXhrSetup.call(this.hls, xhr, url, keysListItem, licenseChallenge);
      }).then((licenseXhrSetupResult) => {
        if (!xhr.readyState) {
          xhr.open("POST", url, true);
        }
        const finalLicenseChallenge = licenseXhrSetupResult ? licenseXhrSetupResult : licenseChallenge;
        return {
          xhr,
          licenseChallenge: finalLicenseChallenge
        };
      });
    }
    requestLicense(keySessionContext, licenseChallenge) {
      const keyLoadPolicy = this.config.keyLoadPolicy.default;
      return new Promise((resolve, reject) => {
        const url = this.getLicenseServerUrlOrThrow(keySessionContext.keySystem);
        this.log(`Sending license request to URL: ${url}`);
        const xhr = new XMLHttpRequest();
        xhr.responseType = "arraybuffer";
        xhr.onreadystatechange = () => {
          if (!this.hls || !keySessionContext.mediaKeysSession) {
            return reject(new Error("invalid state"));
          }
          if (xhr.readyState === 4) {
            if (xhr.status === 200) {
              this._requestLicenseFailureCount = 0;
              let data = xhr.response;
              this.log(`License received ${data instanceof ArrayBuffer ? data.byteLength : data}`);
              const licenseResponseCallback = this.config.licenseResponseCallback;
              if (licenseResponseCallback) {
                try {
                  data = licenseResponseCallback.call(this.hls, xhr, url, keySessionContext);
                } catch (error) {
                  this.error(error);
                }
              }
              resolve(data);
            } else {
              const retryConfig = keyLoadPolicy.errorRetry;
              const maxNumRetry = retryConfig ? retryConfig.maxNumRetry : 0;
              this._requestLicenseFailureCount++;
              if (this._requestLicenseFailureCount > maxNumRetry || xhr.status >= 400 && xhr.status < 500) {
                reject(new EMEKeyError({
                  type: ErrorTypes.KEY_SYSTEM_ERROR,
                  details: ErrorDetails.KEY_SYSTEM_LICENSE_REQUEST_FAILED,
                  decryptdata: keySessionContext.decryptdata,
                  fatal: true,
                  networkDetails: xhr,
                  response: {
                    url,
                    data: void 0,
                    code: xhr.status,
                    text: xhr.statusText
                  }
                }, `License Request XHR failed (${url}). Status: ${xhr.status} (${xhr.statusText})`));
              } else {
                const attemptsLeft = maxNumRetry - this._requestLicenseFailureCount + 1;
                this.warn(`Retrying license request, ${attemptsLeft} attempts left`);
                this.requestLicense(keySessionContext, licenseChallenge).then(resolve, reject);
              }
            }
          }
        };
        if (keySessionContext.licenseXhr && keySessionContext.licenseXhr.readyState !== XMLHttpRequest.DONE) {
          keySessionContext.licenseXhr.abort();
        }
        keySessionContext.licenseXhr = xhr;
        this.setupLicenseXHR(xhr, url, keySessionContext, licenseChallenge).then(({
          xhr: xhr2,
          licenseChallenge: licenseChallenge2
        }) => {
          if (keySessionContext.keySystem == KeySystems.PLAYREADY) {
            licenseChallenge2 = this.unpackPlayReadyKeyMessage(xhr2, licenseChallenge2);
          }
          xhr2.send(licenseChallenge2);
        }).catch(reject);
      });
    }
    onDestroying() {
      this.unregisterListeners();
      this._clear();
    }
    onMediaAttached(event, data) {
      if (!this.config.emeEnabled) {
        return;
      }
      const media = data.media;
      this.media = media;
      addEventListener(media, "encrypted", this.onMediaEncrypted);
      addEventListener(media, "waitingforkey", this.onWaitingForKey);
    }
    onMediaDetached() {
      const media = this.media;
      if (media) {
        removeEventListener(media, "encrypted", this.onMediaEncrypted);
        removeEventListener(media, "waitingforkey", this.onWaitingForKey);
        this.media = null;
        this.mediaKeys = null;
      }
    }
    _clear() {
      var _media$setMediaKeys;
      this._requestLicenseFailureCount = 0;
      this.keyIdToKeySessionPromise = {};
      this.bannedKeyIds = {};
      if (!this.mediaKeys && !this.mediaKeySessions.length) {
        return;
      }
      const media = this.media;
      const mediaKeysList = this.mediaKeySessions.slice();
      this.mediaKeySessions = [];
      this.mediaKeys = null;
      LevelKey.clearKeyUriToKeyIdMap();
      const keySessionCount = mediaKeysList.length;
      _EMEController.CDMCleanupPromise = Promise.all(mediaKeysList.map((mediaKeySessionContext) => this.removeSession(mediaKeySessionContext)).concat((media == null || (_media$setMediaKeys = media.setMediaKeys(null)) == null ? void 0 : _media$setMediaKeys.catch((error) => {
        this.log(`Could not clear media keys: ${error}`);
        if (!this.hls) return;
        this.hls.trigger(Events.ERROR, {
          type: ErrorTypes.OTHER_ERROR,
          details: ErrorDetails.KEY_SYSTEM_DESTROY_MEDIA_KEYS_ERROR,
          fatal: false,
          error: new Error(`Could not clear media keys: ${error}`)
        });
      })) || Promise.resolve())).catch((error) => {
        this.log(`Could not close sessions and clear media keys: ${error}`);
        if (!this.hls) return;
        this.hls.trigger(Events.ERROR, {
          type: ErrorTypes.OTHER_ERROR,
          details: ErrorDetails.KEY_SYSTEM_DESTROY_CLOSE_SESSION_ERROR,
          fatal: false,
          error: new Error(`Could not close sessions and clear media keys: ${error}`)
        });
      }).then(() => {
        if (keySessionCount) {
          this.log("finished closing key sessions and clearing media keys");
        }
      });
    }
    onManifestLoading() {
      this.keyFormatPromise = null;
      this.bannedKeyIds = {};
    }
    onManifestLoaded(event, {
      sessionKeys
    }) {
      if (!sessionKeys || !this.config.emeEnabled) {
        return;
      }
      if (!this.keyFormatPromise) {
        const keyFormats = sessionKeys.reduce((formats, sessionKey) => {
          if (formats.indexOf(sessionKey.keyFormat) === -1) {
            formats.push(sessionKey.keyFormat);
          }
          return formats;
        }, []);
        this.log(`Selecting key-system from session-keys ${keyFormats.join(", ")}`);
        this.keyFormatPromise = this.getKeyFormatPromise(keyFormats);
      }
    }
    removeSession(mediaKeySessionContext) {
      const {
        mediaKeysSession,
        licenseXhr,
        decryptdata
      } = mediaKeySessionContext;
      if (mediaKeysSession) {
        this.log(`Remove licenses and keys and close session "${mediaKeysSession.sessionId}" keyId: ${arrayToHex((decryptdata == null ? void 0 : decryptdata.keyId) || [])}`);
        if (mediaKeySessionContext._onmessage) {
          mediaKeysSession.removeEventListener("message", mediaKeySessionContext._onmessage);
          mediaKeySessionContext._onmessage = void 0;
        }
        if (mediaKeySessionContext._onkeystatuseschange) {
          mediaKeysSession.removeEventListener("keystatuseschange", mediaKeySessionContext._onkeystatuseschange);
          mediaKeySessionContext._onkeystatuseschange = void 0;
        }
        if (licenseXhr && licenseXhr.readyState !== XMLHttpRequest.DONE) {
          licenseXhr.abort();
        }
        mediaKeySessionContext.mediaKeysSession = mediaKeySessionContext.decryptdata = mediaKeySessionContext.licenseXhr = void 0;
        const index = this.mediaKeySessions.indexOf(mediaKeySessionContext);
        if (index > -1) {
          this.mediaKeySessions.splice(index, 1);
        }
        const {
          keyStatusTimeouts
        } = mediaKeySessionContext;
        if (keyStatusTimeouts) {
          Object.keys(keyStatusTimeouts).forEach((keyId) => self.clearTimeout(keyStatusTimeouts[keyId]));
        }
        const {
          drmSystemOptions
        } = this.config;
        const removePromise = isPersistentSessionType(drmSystemOptions) ? new Promise((resolve, reject) => {
          self.setTimeout(() => reject(new Error(`MediaKeySession.remove() timeout`)), 8e3);
          mediaKeysSession.remove().then(resolve).catch(reject);
        }) : Promise.resolve();
        return removePromise.catch((error) => {
          this.log(`Could not remove session: ${error}`);
          if (!this.hls) return;
          this.hls.trigger(Events.ERROR, {
            type: ErrorTypes.OTHER_ERROR,
            details: ErrorDetails.KEY_SYSTEM_DESTROY_REMOVE_SESSION_ERROR,
            fatal: false,
            error: new Error(`Could not remove session: ${error}`)
          });
        }).then(() => {
          return mediaKeysSession.close();
        }).catch((error) => {
          this.log(`Could not close session: ${error}`);
          if (!this.hls) return;
          this.hls.trigger(Events.ERROR, {
            type: ErrorTypes.OTHER_ERROR,
            details: ErrorDetails.KEY_SYSTEM_DESTROY_CLOSE_SESSION_ERROR,
            fatal: false,
            error: new Error(`Could not close session: ${error}`)
          });
        });
      }
      return Promise.resolve();
    }
  };
  EMEController.CDMCleanupPromise = void 0;
  function getKeyIdString(decryptdata) {
    if (!decryptdata) {
      throw new Error("Could not read keyId of undefined decryptdata");
    }
    if (decryptdata.keyId === null) {
      throw new Error("keyId is null");
    }
    return arrayToHex(decryptdata.keyId);
  }
  function getKeyStatus(decryptdata, keyContext) {
    if (decryptdata.keyId && keyContext.mediaKeysSession.keyStatuses.has(decryptdata.keyId)) {
      return keyContext.mediaKeysSession.keyStatuses.get(decryptdata.keyId);
    }
    if (decryptdata.matches(keyContext.decryptdata)) {
      return keyContext.keyStatus;
    }
    return void 0;
  }
  var EMEKeyError = class extends Error {
    constructor(data, message) {
      super(message);
      this.data = void 0;
      data.error || (data.error = new Error(message));
      this.data = data;
      data.err = data.error;
    }
  };
  function getKeyStatusError(keyStatus, decryptdata) {
    const outputRestricted = keyStatus === "output-restricted";
    const details = outputRestricted ? ErrorDetails.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED : ErrorDetails.KEY_SYSTEM_STATUS_INTERNAL_ERROR;
    return new EMEKeyError({
      type: ErrorTypes.KEY_SYSTEM_ERROR,
      details,
      fatal: false,
      decryptdata
    }, outputRestricted ? "HDCP level output restricted" : `key status changed to "${keyStatus}"`);
  }
  var FPSController = class {
    constructor(hls) {
      this.hls = void 0;
      this.isVideoPlaybackQualityAvailable = false;
      this.timer = void 0;
      this.media = null;
      this.lastTime = void 0;
      this.lastDroppedFrames = 0;
      this.lastDecodedFrames = 0;
      this.streamController = void 0;
      this.hls = hls;
      this.registerListeners();
    }
    setStreamController(streamController) {
      this.streamController = streamController;
    }
    registerListeners() {
      this.hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);
      this.hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
    }
    unregisterListeners() {
      this.hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);
      this.hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
    }
    destroy() {
      if (this.timer) {
        clearInterval(this.timer);
      }
      this.unregisterListeners();
      this.isVideoPlaybackQualityAvailable = false;
      this.media = null;
    }
    onMediaAttaching(event, data) {
      const config3 = this.hls.config;
      if (config3.capLevelOnFPSDrop) {
        const media = data.media instanceof self.HTMLVideoElement ? data.media : null;
        this.media = media;
        if (media && typeof media.getVideoPlaybackQuality === "function") {
          this.isVideoPlaybackQualityAvailable = true;
        }
        self.clearInterval(this.timer);
        this.timer = self.setInterval(this.checkFPSInterval.bind(this), config3.fpsDroppedMonitoringPeriod);
      }
    }
    onMediaDetaching() {
      this.media = null;
    }
    checkFPS(video, decodedFrames, droppedFrames) {
      const currentTime = performance.now();
      if (decodedFrames) {
        if (this.lastTime) {
          const currentPeriod = currentTime - this.lastTime;
          const currentDropped = droppedFrames - this.lastDroppedFrames;
          const currentDecoded = decodedFrames - this.lastDecodedFrames;
          const droppedFPS = 1e3 * currentDropped / currentPeriod;
          const hls = this.hls;
          hls.trigger(Events.FPS_DROP, {
            currentDropped,
            currentDecoded,
            totalDroppedFrames: droppedFrames
          });
          if (droppedFPS > 0) {
            if (currentDropped > hls.config.fpsDroppedMonitoringThreshold * currentDecoded) {
              let currentLevel = hls.currentLevel;
              hls.logger.warn("drop FPS ratio greater than max allowed value for currentLevel: " + currentLevel);
              if (currentLevel > 0 && (hls.autoLevelCapping === -1 || hls.autoLevelCapping >= currentLevel)) {
                currentLevel = currentLevel - 1;
                hls.trigger(Events.FPS_DROP_LEVEL_CAPPING, {
                  level: currentLevel,
                  droppedLevel: hls.currentLevel
                });
                hls.autoLevelCapping = currentLevel;
                this.streamController.nextLevelSwitch();
              }
            }
          }
        }
        this.lastTime = currentTime;
        this.lastDroppedFrames = droppedFrames;
        this.lastDecodedFrames = decodedFrames;
      }
    }
    checkFPSInterval() {
      const video = this.media;
      if (video) {
        if (this.isVideoPlaybackQualityAvailable) {
          const videoPlaybackQuality = video.getVideoPlaybackQuality();
          this.checkFPS(video, videoPlaybackQuality.totalVideoFrames, videoPlaybackQuality.droppedVideoFrames);
        } else {
          this.checkFPS(video, video.webkitDecodedFrameCount, video.webkitDroppedFrameCount);
        }
      }
    }
  };
  function sendAddTrackEvent(track, videoEl) {
    let event;
    try {
      event = new Event("addtrack");
    } catch (err) {
      event = document.createEvent("Event");
      event.initEvent("addtrack", false, false);
    }
    event.track = track;
    videoEl.dispatchEvent(event);
  }
  function addCueToTrack(track, cue) {
    const mode = track.mode;
    if (mode === "disabled") {
      track.mode = "hidden";
    }
    if (track.cues && !track.cues.getCueById(cue.id)) {
      try {
        track.addCue(cue);
        if (!track.cues.getCueById(cue.id)) {
          throw new Error(`addCue is failed for: ${cue}`);
        }
      } catch (err) {
        logger.debug(`[texttrack-utils]: ${err}`);
        try {
          const textTrackCue = new self.TextTrackCue(cue.startTime, cue.endTime, cue.text);
          textTrackCue.id = cue.id;
          track.addCue(textTrackCue);
        } catch (err2) {
          logger.debug(`[texttrack-utils]: Legacy TextTrackCue fallback failed: ${err2}`);
        }
      }
    }
    if (mode === "disabled") {
      track.mode = mode;
    }
  }
  function clearCurrentCues(track, enterHandler) {
    const mode = track.mode;
    if (mode === "disabled") {
      track.mode = "hidden";
    }
    if (track.cues) {
      for (let i = track.cues.length; i--; ) {
        if (enterHandler) {
          track.cues[i].removeEventListener("enter", enterHandler);
        }
        track.removeCue(track.cues[i]);
      }
    }
    if (mode === "disabled") {
      track.mode = mode;
    }
  }
  function removeCuesInRange(track, start, end, predicate) {
    const mode = track.mode;
    if (mode === "disabled") {
      track.mode = "hidden";
    }
    if (track.cues && track.cues.length > 0) {
      const cues = getCuesInRange(track.cues, start, end);
      for (let i = 0; i < cues.length; i++) {
        if (!predicate || predicate(cues[i])) {
          track.removeCue(cues[i]);
        }
      }
    }
    if (mode === "disabled") {
      track.mode = mode;
    }
  }
  function getFirstCueIndexFromTime(cues, time2) {
    if (time2 <= cues[0].startTime) {
      return 0;
    }
    const len = cues.length - 1;
    if (time2 > cues[len].endTime) {
      return -1;
    }
    let left = 0;
    let right = len;
    let mid;
    while (left <= right) {
      mid = Math.floor((right + left) / 2);
      if (time2 < cues[mid].startTime) {
        right = mid - 1;
      } else if (time2 > cues[mid].startTime && left < len) {
        left = mid + 1;
      } else {
        return mid;
      }
    }
    return cues[left].startTime - time2 < time2 - cues[right].startTime ? left : right;
  }
  function getCuesInRange(cues, start, end) {
    const cuesFound = [];
    const firstCueInRange = getFirstCueIndexFromTime(cues, start);
    if (firstCueInRange > -1) {
      for (let i = firstCueInRange, len = cues.length; i < len; i++) {
        const cue = cues[i];
        if (cue.startTime >= start && cue.endTime <= end) {
          cuesFound.push(cue);
        } else if (cue.startTime > end) {
          return cuesFound;
        }
      }
    }
    return cuesFound;
  }
  function filterSubtitleTracks(textTrackList) {
    const tracks = [];
    for (let i = 0; i < textTrackList.length; i++) {
      const track = textTrackList[i];
      if ((track.kind === "subtitles" || track.kind === "captions") && track.label) {
        tracks.push(textTrackList[i]);
      }
    }
    return tracks;
  }
  var SubtitleTrackController = class extends BasePlaylistController {
    constructor(hls) {
      super(hls, "subtitle-track-controller");
      this.media = null;
      this.tracks = [];
      this.groupIds = null;
      this.tracksInGroup = [];
      this.trackId = -1;
      this.currentTrack = null;
      this.selectDefaultTrack = true;
      this.queuedDefaultTrack = -1;
      this.useTextTrackPolling = false;
      this.subtitlePollingInterval = -1;
      this._subtitleDisplay = true;
      this.asyncPollTrackChange = () => this.pollTrackChange(0);
      this.onTextTracksChanged = () => {
        if (!this.useTextTrackPolling) {
          self.clearInterval(this.subtitlePollingInterval);
        }
        if (!this.media || !this.hls.config.renderTextTracksNatively) {
          return;
        }
        let textTrack = null;
        const tracks = filterSubtitleTracks(this.media.textTracks);
        for (let i = 0; i < tracks.length; i++) {
          if (tracks[i].mode === "hidden") {
            textTrack = tracks[i];
          } else if (tracks[i].mode === "showing") {
            textTrack = tracks[i];
            break;
          }
        }
        const trackId = this.findTrackForTextTrack(textTrack);
        if (this.subtitleTrack !== trackId) {
          this.setSubtitleTrack(trackId);
        }
      };
      this.registerListeners();
    }
    destroy() {
      this.unregisterListeners();
      this.tracks.length = 0;
      this.tracksInGroup.length = 0;
      this.currentTrack = null;
      this.onTextTracksChanged = this.asyncPollTrackChange = null;
      super.destroy();
    }
    get subtitleDisplay() {
      return this._subtitleDisplay;
    }
    set subtitleDisplay(value) {
      this._subtitleDisplay = value;
      if (this.trackId > -1) {
        this.toggleTrackModes();
      }
    }
    registerListeners() {
      const {
        hls
      } = this;
      hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
      hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
      hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);
      hls.on(Events.LEVEL_LOADING, this.onLevelLoading, this);
      hls.on(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);
      hls.on(Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);
      hls.on(Events.ERROR, this.onError, this);
    }
    unregisterListeners() {
      const {
        hls
      } = this;
      hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
      hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
      hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);
      hls.off(Events.LEVEL_LOADING, this.onLevelLoading, this);
      hls.off(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);
      hls.off(Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);
      hls.off(Events.ERROR, this.onError, this);
    }
    // Listen for subtitle track change, then extract the current track ID.
    onMediaAttached(event, data) {
      this.media = data.media;
      if (!this.media) {
        return;
      }
      if (this.queuedDefaultTrack > -1) {
        this.subtitleTrack = this.queuedDefaultTrack;
        this.queuedDefaultTrack = -1;
      }
      this.useTextTrackPolling = !(this.media.textTracks && "onchange" in this.media.textTracks);
      if (this.useTextTrackPolling) {
        this.pollTrackChange(500);
      } else {
        this.media.textTracks.addEventListener("change", this.asyncPollTrackChange);
      }
    }
    pollTrackChange(timeout) {
      self.clearInterval(this.subtitlePollingInterval);
      this.subtitlePollingInterval = self.setInterval(this.onTextTracksChanged, timeout);
    }
    onMediaDetaching(event, data) {
      const media = this.media;
      if (!media) {
        return;
      }
      const transferringMedia = !!data.transferMedia;
      self.clearInterval(this.subtitlePollingInterval);
      if (!this.useTextTrackPolling) {
        media.textTracks.removeEventListener("change", this.asyncPollTrackChange);
      }
      if (this.trackId > -1) {
        this.queuedDefaultTrack = this.trackId;
      }
      this.subtitleTrack = -1;
      this.media = null;
      if (transferringMedia) {
        return;
      }
      const textTracks = filterSubtitleTracks(media.textTracks);
      textTracks.forEach((track) => {
        clearCurrentCues(track);
      });
    }
    onManifestLoading() {
      this.tracks = [];
      this.groupIds = null;
      this.tracksInGroup = [];
      this.trackId = -1;
      this.currentTrack = null;
      this.selectDefaultTrack = true;
    }
    // Fired whenever a new manifest is loaded.
    onManifestParsed(event, data) {
      this.tracks = data.subtitleTracks;
    }
    onSubtitleTrackLoaded(event, data) {
      const {
        id: id3,
        groupId,
        details
      } = data;
      const trackInActiveGroup = this.tracksInGroup[id3];
      if (!trackInActiveGroup || trackInActiveGroup.groupId !== groupId) {
        this.warn(`Subtitle track with id:${id3} and group:${groupId} not found in active group ${trackInActiveGroup == null ? void 0 : trackInActiveGroup.groupId}`);
        return;
      }
      const curDetails = trackInActiveGroup.details;
      trackInActiveGroup.details = data.details;
      this.log(`Subtitle track ${id3} "${trackInActiveGroup.name}" lang:${trackInActiveGroup.lang} group:${groupId} loaded [${details.startSN}-${details.endSN}]`);
      if (id3 === this.trackId) {
        this.playlistLoaded(id3, data, curDetails);
      }
    }
    onLevelLoading(event, data) {
      this.switchLevel(data.level);
    }
    onLevelSwitching(event, data) {
      this.switchLevel(data.level);
    }
    switchLevel(levelIndex) {
      const levelInfo = this.hls.levels[levelIndex];
      if (!levelInfo) {
        return;
      }
      const subtitleGroups = levelInfo.subtitleGroups || null;
      const currentGroups = this.groupIds;
      let currentTrack = this.currentTrack;
      if (!subtitleGroups || (currentGroups == null ? void 0 : currentGroups.length) !== (subtitleGroups == null ? void 0 : subtitleGroups.length) || subtitleGroups != null && subtitleGroups.some((groupId) => (currentGroups == null ? void 0 : currentGroups.indexOf(groupId)) === -1)) {
        this.groupIds = subtitleGroups;
        this.trackId = -1;
        this.currentTrack = null;
        const subtitleTracks = this.tracks.filter((track) => !subtitleGroups || subtitleGroups.indexOf(track.groupId) !== -1);
        if (subtitleTracks.length) {
          if (this.selectDefaultTrack && !subtitleTracks.some((track) => track.default)) {
            this.selectDefaultTrack = false;
          }
          subtitleTracks.forEach((track, i) => {
            track.id = i;
          });
        } else if (!currentTrack && !this.tracksInGroup.length) {
          return;
        }
        this.tracksInGroup = subtitleTracks;
        const subtitlePreference = this.hls.config.subtitlePreference;
        if (!currentTrack && subtitlePreference) {
          this.selectDefaultTrack = false;
          const groupIndex = findMatchingOption(subtitlePreference, subtitleTracks);
          if (groupIndex > -1) {
            currentTrack = subtitleTracks[groupIndex];
          } else {
            const allIndex = findMatchingOption(subtitlePreference, this.tracks);
            currentTrack = this.tracks[allIndex];
          }
        }
        let trackId = this.findTrackId(currentTrack);
        if (trackId === -1 && currentTrack) {
          trackId = this.findTrackId(null);
        }
        const subtitleTracksUpdated = {
          subtitleTracks
        };
        this.log(`Updating subtitle tracks, ${subtitleTracks.length} track(s) found in "${subtitleGroups == null ? void 0 : subtitleGroups.join(",")}" group-id`);
        this.hls.trigger(Events.SUBTITLE_TRACKS_UPDATED, subtitleTracksUpdated);
        if (trackId !== -1 && this.trackId === -1) {
          this.setSubtitleTrack(trackId);
        }
      }
    }
    findTrackId(currentTrack) {
      const tracks = this.tracksInGroup;
      const selectDefault = this.selectDefaultTrack;
      for (let i = 0; i < tracks.length; i++) {
        const track = tracks[i];
        if (selectDefault && !track.default || !selectDefault && !currentTrack) {
          continue;
        }
        if (!currentTrack || matchesOption(track, currentTrack)) {
          return i;
        }
      }
      if (currentTrack) {
        for (let i = 0; i < tracks.length; i++) {
          const track = tracks[i];
          if (mediaAttributesIdentical(currentTrack.attrs, track.attrs, ["LANGUAGE", "ASSOC-LANGUAGE", "CHARACTERISTICS"])) {
            return i;
          }
        }
        for (let i = 0; i < tracks.length; i++) {
          const track = tracks[i];
          if (mediaAttributesIdentical(currentTrack.attrs, track.attrs, ["LANGUAGE"])) {
            return i;
          }
        }
      }
      return -1;
    }
    findTrackForTextTrack(textTrack) {
      if (textTrack) {
        const tracks = this.tracksInGroup;
        for (let i = 0; i < tracks.length; i++) {
          const track = tracks[i];
          if (subtitleTrackMatchesTextTrack(track, textTrack)) {
            return i;
          }
        }
      }
      return -1;
    }
    onError(event, data) {
      if (data.fatal || !data.context) {
        return;
      }
      if (data.context.type === PlaylistContextType.SUBTITLE_TRACK && data.context.id === this.trackId && (!this.groupIds || this.groupIds.indexOf(data.context.groupId) !== -1)) {
        this.checkRetry(data);
      }
    }
    get allSubtitleTracks() {
      return this.tracks;
    }
    /** get alternate subtitle tracks list from playlist **/
    get subtitleTracks() {
      return this.tracksInGroup;
    }
    /** get/set index of the selected subtitle track (based on index in subtitle track lists) **/
    get subtitleTrack() {
      return this.trackId;
    }
    set subtitleTrack(newId) {
      this.selectDefaultTrack = false;
      this.setSubtitleTrack(newId);
    }
    setSubtitleOption(subtitleOption) {
      this.hls.config.subtitlePreference = subtitleOption;
      if (subtitleOption) {
        if (subtitleOption.id === -1) {
          this.setSubtitleTrack(-1);
          return null;
        }
        const allSubtitleTracks = this.allSubtitleTracks;
        this.selectDefaultTrack = false;
        if (allSubtitleTracks.length) {
          const currentTrack = this.currentTrack;
          if (currentTrack && matchesOption(subtitleOption, currentTrack)) {
            return currentTrack;
          }
          const groupIndex = findMatchingOption(subtitleOption, this.tracksInGroup);
          if (groupIndex > -1) {
            const track = this.tracksInGroup[groupIndex];
            this.setSubtitleTrack(groupIndex);
            return track;
          } else if (currentTrack) {
            return null;
          } else {
            const allIndex = findMatchingOption(subtitleOption, allSubtitleTracks);
            if (allIndex > -1) {
              return allSubtitleTracks[allIndex];
            }
          }
        }
      }
      return null;
    }
    loadPlaylist(hlsUrlParameters) {
      super.loadPlaylist();
      if (this.shouldLoadPlaylist(this.currentTrack)) {
        this.scheduleLoading(this.currentTrack, hlsUrlParameters);
      }
    }
    loadingPlaylist(currentTrack, hlsUrlParameters) {
      super.loadingPlaylist(currentTrack, hlsUrlParameters);
      const id3 = currentTrack.id;
      const groupId = currentTrack.groupId;
      const url = this.getUrlWithDirectives(currentTrack.url, hlsUrlParameters);
      const details = currentTrack.details;
      const age = details == null ? void 0 : details.age;
      this.log(`Loading subtitle ${id3} "${currentTrack.name}" lang:${currentTrack.lang} group:${groupId}${(hlsUrlParameters == null ? void 0 : hlsUrlParameters.msn) !== void 0 ? " at sn " + hlsUrlParameters.msn + " part " + hlsUrlParameters.part : ""}${age && details.live ? " age " + age.toFixed(1) + (details.type ? " " + details.type || "" : "") : ""} ${url}`);
      this.hls.trigger(Events.SUBTITLE_TRACK_LOADING, {
        url,
        id: id3,
        groupId,
        deliveryDirectives: hlsUrlParameters || null,
        track: currentTrack
      });
    }
    /**
     * Disables the old subtitleTrack and sets current mode on the next subtitleTrack.
     * This operates on the DOM textTracks.
     * A value of -1 will disable all subtitle tracks.
     */
    toggleTrackModes() {
      const {
        media
      } = this;
      if (!media) {
        return;
      }
      const textTracks = filterSubtitleTracks(media.textTracks);
      const currentTrack = this.currentTrack;
      let nextTrack;
      if (currentTrack) {
        nextTrack = textTracks.filter((textTrack) => subtitleTrackMatchesTextTrack(currentTrack, textTrack))[0];
        if (!nextTrack) {
          this.warn(`Unable to find subtitle TextTrack with name "${currentTrack.name}" and language "${currentTrack.lang}"`);
        }
      }
      [].slice.call(textTracks).forEach((track) => {
        if (track.mode !== "disabled" && track !== nextTrack) {
          track.mode = "disabled";
        }
      });
      if (nextTrack) {
        const mode = this.subtitleDisplay ? "showing" : "hidden";
        if (nextTrack.mode !== mode) {
          nextTrack.mode = mode;
        }
      }
    }
    /**
     * This method is responsible for validating the subtitle index and periodically reloading if live.
     * Dispatches the SUBTITLE_TRACK_SWITCH event, which instructs the subtitle-stream-controller to load the selected track.
     */
    setSubtitleTrack(newId) {
      const tracks = this.tracksInGroup;
      if (!this.media) {
        this.queuedDefaultTrack = newId;
        return;
      }
      if (newId < -1 || newId >= tracks.length || !isFiniteNumber(newId)) {
        this.warn(`Invalid subtitle track id: ${newId}`);
        return;
      }
      this.selectDefaultTrack = false;
      const lastTrack = this.currentTrack;
      const track = tracks[newId] || null;
      this.trackId = newId;
      this.currentTrack = track;
      this.toggleTrackModes();
      if (!track) {
        this.hls.trigger(Events.SUBTITLE_TRACK_SWITCH, {
          id: newId
        });
        return;
      }
      const trackLoaded = !!track.details && !track.details.live;
      if (newId === this.trackId && track === lastTrack && trackLoaded) {
        return;
      }
      this.log(`Switching to subtitle-track ${newId}` + (track ? ` "${track.name}" lang:${track.lang} group:${track.groupId}` : ""));
      const {
        id: id3,
        groupId = "",
        name,
        type,
        url
      } = track;
      this.hls.trigger(Events.SUBTITLE_TRACK_SWITCH, {
        id: id3,
        groupId,
        name,
        type,
        url
      });
      const hlsUrlParameters = this.switchParams(track.url, lastTrack == null ? void 0 : lastTrack.details, track.details);
      this.loadPlaylist(hlsUrlParameters);
    }
  };
  function uuid() {
    try {
      return crypto.randomUUID();
    } catch (error) {
      try {
        const url = URL.createObjectURL(new Blob());
        const uuid2 = url.toString();
        URL.revokeObjectURL(url);
        return uuid2.slice(uuid2.lastIndexOf("/") + 1);
      } catch (error2) {
        let dt = (/* @__PURE__ */ new Date()).getTime();
        const uuid2 = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
          const r = (dt + Math.random() * 16) % 16 | 0;
          dt = Math.floor(dt / 16);
          return (c == "x" ? r : r & 3 | 8).toString(16);
        });
        return uuid2;
      }
    }
  }
  function hash(text) {
    let hash2 = 5381;
    let i = text.length;
    while (i) {
      hash2 = hash2 * 33 ^ text.charCodeAt(--i);
    }
    return (hash2 >>> 0).toString();
  }
  var ALIGNED_END_THRESHOLD_SECONDS = 0.025;
  var TimelineOccupancy = /* @__PURE__ */ (function(TimelineOccupancy2) {
    TimelineOccupancy2[TimelineOccupancy2["Point"] = 0] = "Point";
    TimelineOccupancy2[TimelineOccupancy2["Range"] = 1] = "Range";
    return TimelineOccupancy2;
  })({});
  function generateAssetIdentifier(interstitial, uri, assetListIndex) {
    return `${interstitial.identifier}-${assetListIndex + 1}-${hash(uri)}`;
  }
  var InterstitialEvent = class {
    constructor(dateRange, base) {
      this.base = void 0;
      this._duration = null;
      this._timelineStart = null;
      this.appendInPlaceDisabled = void 0;
      this.appendInPlaceStarted = void 0;
      this.dateRange = void 0;
      this.hasPlayed = false;
      this.cumulativeDuration = 0;
      this.resumeOffset = NaN;
      this.playoutLimit = NaN;
      this.restrictions = {
        skip: false,
        jump: false
      };
      this.snapOptions = {
        out: false,
        in: false
      };
      this.assetList = [];
      this.assetListLoader = void 0;
      this.assetListResponse = null;
      this.resumeAnchor = void 0;
      this.error = void 0;
      this.resetOnResume = void 0;
      this.base = base;
      this.dateRange = dateRange;
      this.setDateRange(dateRange);
    }
    setDateRange(dateRange) {
      this.dateRange = dateRange;
      this.resumeOffset = dateRange.attr.optionalFloat("X-RESUME-OFFSET", this.resumeOffset);
      this.playoutLimit = dateRange.attr.optionalFloat("X-PLAYOUT-LIMIT", this.playoutLimit);
      this.restrictions = dateRange.attr.enumeratedStringList("X-RESTRICT", this.restrictions);
      this.snapOptions = dateRange.attr.enumeratedStringList("X-SNAP", this.snapOptions);
    }
    reset() {
      var _this$assetListLoader;
      this.appendInPlaceStarted = false;
      (_this$assetListLoader = this.assetListLoader) == null || _this$assetListLoader.destroy();
      this.assetListLoader = void 0;
      if (!this.supplementsPrimary) {
        this.assetListResponse = null;
        this.assetList = [];
        this._duration = null;
      }
    }
    isAssetPastPlayoutLimit(assetIndex) {
      var _this$assetList$asset;
      if (assetIndex > 0 && assetIndex >= this.assetList.length) {
        return true;
      }
      const playoutLimit = this.playoutLimit;
      if (assetIndex <= 0 || isNaN(playoutLimit)) {
        return false;
      }
      if (playoutLimit === 0) {
        return true;
      }
      const assetOffset = ((_this$assetList$asset = this.assetList[assetIndex]) == null ? void 0 : _this$assetList$asset.startOffset) || 0;
      return assetOffset > playoutLimit;
    }
    findAssetIndex(asset) {
      const index = this.assetList.indexOf(asset);
      return index;
    }
    get identifier() {
      return this.dateRange.id;
    }
    get startDate() {
      return this.dateRange.startDate;
    }
    get startTime() {
      const startTime = this.dateRange.startTime;
      if (this.snapOptions.out) {
        const frag = this.dateRange.tagAnchor;
        if (frag) {
          return getSnapToFragmentTime(startTime, frag);
        }
      }
      return startTime;
    }
    get startOffset() {
      return this.cue.pre ? 0 : this.startTime;
    }
    get startIsAligned() {
      if (this.startTime === 0 || this.snapOptions.out) {
        return true;
      }
      const frag = this.dateRange.tagAnchor;
      if (frag) {
        const startTime = this.dateRange.startTime;
        const snappedStart = getSnapToFragmentTime(startTime, frag);
        return startTime - snappedStart < 0.1;
      }
      return false;
    }
    get resumptionOffset() {
      const resumeOffset = this.resumeOffset;
      const offset = isFiniteNumber(resumeOffset) ? resumeOffset : this.duration;
      return this.cumulativeDuration + offset;
    }
    get resumeTime() {
      const resumeTime = this.startOffset + this.resumptionOffset;
      if (this.snapOptions.in) {
        const frag = this.resumeAnchor;
        if (frag) {
          return getSnapToFragmentTime(resumeTime, frag);
        }
      }
      return resumeTime;
    }
    get appendInPlace() {
      if (this.appendInPlaceStarted) {
        return true;
      }
      if (this.appendInPlaceDisabled) {
        return false;
      }
      if (!this.cue.once && !this.cue.pre && // preroll starts at startPosition before startPosition is known (live)
      this.startIsAligned && (isNaN(this.playoutLimit) && isNaN(this.resumeOffset) || this.resumeOffset && this.duration && Math.abs(this.resumeOffset - this.duration) < ALIGNED_END_THRESHOLD_SECONDS)) {
        return true;
      }
      return false;
    }
    set appendInPlace(value) {
      if (this.appendInPlaceStarted) {
        this.resetOnResume = !value;
        return;
      }
      this.appendInPlaceDisabled = !value;
    }
    // Extended timeline start time
    get timelineStart() {
      if (this._timelineStart !== null) {
        return this._timelineStart;
      }
      return this.startTime;
    }
    set timelineStart(value) {
      this._timelineStart = value;
    }
    get duration() {
      const playoutLimit = this.playoutLimit;
      let duration;
      if (this._duration !== null) {
        duration = this._duration;
      } else if (this.dateRange.duration) {
        duration = this.dateRange.duration;
      } else {
        duration = this.dateRange.plannedDuration || 0;
      }
      if (!isNaN(playoutLimit) && playoutLimit < duration) {
        duration = playoutLimit;
      }
      return duration;
    }
    set duration(value) {
      this._duration = value;
    }
    get cue() {
      return this.dateRange.cue;
    }
    get timelineOccupancy() {
      if (this.dateRange.attr["X-TIMELINE-OCCUPIES"] === "RANGE") {
        return TimelineOccupancy.Range;
      }
      return TimelineOccupancy.Point;
    }
    get supplementsPrimary() {
      return this.dateRange.attr["X-TIMELINE-STYLE"] === "PRIMARY";
    }
    get contentMayVary() {
      return this.dateRange.attr["X-CONTENT-MAY-VARY"] !== "NO";
    }
    get assetUrl() {
      return this.dateRange.attr["X-ASSET-URI"];
    }
    get assetListUrl() {
      return this.dateRange.attr["X-ASSET-LIST"];
    }
    get baseUrl() {
      return this.base.url;
    }
    get assetListLoaded() {
      return this.assetList.length > 0 || this.assetListResponse !== null;
    }
    toString() {
      return eventToString(this);
    }
  };
  function getSnapToFragmentTime(time2, frag) {
    return time2 - frag.start < frag.duration / 2 && !(Math.abs(time2 - (frag.start + frag.duration)) < ALIGNED_END_THRESHOLD_SECONDS) ? frag.start : frag.start + frag.duration;
  }
  function getInterstitialUrl(uri, sessionId, baseUrl) {
    const url = new self.URL(uri, baseUrl);
    if (url.protocol !== "data:") {
      url.searchParams.set("_HLS_primary_id", sessionId);
    }
    return url;
  }
  function getNextAssetIndex(interstitial, assetListIndex) {
    while ((_interstitial$assetLi = interstitial.assetList[++assetListIndex]) != null && _interstitial$assetLi.error) {
      var _interstitial$assetLi;
    }
    return assetListIndex;
  }
  function eventToString(interstitial) {
    return `["${interstitial.identifier}" ${interstitial.cue.pre ? "<pre>" : interstitial.cue.post ? "<post>" : ""}${interstitial.timelineStart.toFixed(2)}-${interstitial.resumeTime.toFixed(2)}]`;
  }
  function eventAssetToString(asset) {
    const start = asset.timelineStart;
    const duration = asset.duration || 0;
    return `["${asset.identifier}" ${start.toFixed(2)}-${(start + duration).toFixed(2)}]`;
  }
  var HlsAssetPlayer = class {
    constructor(HlsPlayerClass, userConfig, interstitial, assetItem) {
      this.hls = void 0;
      this.interstitial = void 0;
      this.assetItem = void 0;
      this.tracks = null;
      this.hasDetails = false;
      this.mediaAttached = null;
      this._currentTime = void 0;
      this._bufferedEosTime = void 0;
      this.checkPlayout = () => {
        if (this.reachedPlayout(this.currentTime) && this.hls) {
          this.hls.trigger(Events.PLAYOUT_LIMIT_REACHED, {});
        }
      };
      const hls = this.hls = new HlsPlayerClass(userConfig);
      this.interstitial = interstitial;
      this.assetItem = assetItem;
      const detailsLoaded = () => {
        this.hasDetails = true;
      };
      hls.once(Events.LEVEL_LOADED, detailsLoaded);
      hls.once(Events.AUDIO_TRACK_LOADED, detailsLoaded);
      hls.once(Events.SUBTITLE_TRACK_LOADED, detailsLoaded);
      hls.on(Events.MEDIA_ATTACHING, (name, {
        media
      }) => {
        this.removeMediaListeners();
        this.mediaAttached = media;
        const event = this.interstitial;
        if (event.playoutLimit) {
          media.addEventListener("timeupdate", this.checkPlayout);
          if (this.appendInPlace) {
            hls.on(Events.BUFFER_APPENDED, () => {
              const bufferedEnd = this.bufferedEnd;
              if (this.reachedPlayout(bufferedEnd)) {
                this._bufferedEosTime = bufferedEnd;
                hls.trigger(Events.BUFFERED_TO_END, void 0);
              }
            });
          }
        }
      });
    }
    get appendInPlace() {
      return this.interstitial.appendInPlace;
    }
    loadSource() {
      const hls = this.hls;
      if (!hls) {
        return;
      }
      if (!hls.url) {
        let uri = this.assetItem.uri;
        try {
          uri = getInterstitialUrl(uri, hls.config.primarySessionId || "").href;
        } catch (error) {
        }
        hls.loadSource(uri);
      } else if (hls.levels.length && !hls.started) {
        hls.startLoad(-1, true);
      }
    }
    bufferedInPlaceToEnd(media) {
      var _this$hls;
      if (!this.appendInPlace) {
        return false;
      }
      if ((_this$hls = this.hls) != null && _this$hls.bufferedToEnd) {
        return true;
      }
      if (!media) {
        return false;
      }
      const duration = Math.min(this._bufferedEosTime || Infinity, this.duration);
      const start = this.timelineOffset;
      const bufferInfo = BufferHelper.bufferInfo(media, start, 0);
      const bufferedEnd = this.getAssetTime(bufferInfo.end);
      return bufferedEnd >= duration - 0.02;
    }
    reachedPlayout(time2) {
      const interstitial = this.interstitial;
      const playoutLimit = interstitial.playoutLimit;
      return this.startOffset + time2 >= playoutLimit;
    }
    get destroyed() {
      var _this$hls2;
      return !((_this$hls2 = this.hls) != null && _this$hls2.userConfig);
    }
    get assetId() {
      return this.assetItem.identifier;
    }
    get interstitialId() {
      return this.assetItem.parentIdentifier;
    }
    get media() {
      var _this$hls3;
      return ((_this$hls3 = this.hls) == null ? void 0 : _this$hls3.media) || null;
    }
    get bufferedEnd() {
      const media = this.media || this.mediaAttached;
      if (!media) {
        if (this._bufferedEosTime) {
          return this._bufferedEosTime;
        }
        return this.currentTime;
      }
      const bufferInfo = BufferHelper.bufferInfo(media, media.currentTime, 1e-3);
      return this.getAssetTime(bufferInfo.end);
    }
    get currentTime() {
      const media = this.media || this.mediaAttached;
      if (!media) {
        return this._currentTime || 0;
      }
      return this.getAssetTime(media.currentTime);
    }
    get duration() {
      const duration = this.assetItem.duration;
      if (!duration) {
        return 0;
      }
      const playoutLimit = this.interstitial.playoutLimit;
      if (playoutLimit) {
        const assetPlayout = playoutLimit - this.startOffset;
        if (assetPlayout > 0 && assetPlayout < duration) {
          return assetPlayout;
        }
      }
      return duration;
    }
    get remaining() {
      const duration = this.duration;
      if (!duration) {
        return 0;
      }
      return Math.max(0, duration - this.currentTime);
    }
    get startOffset() {
      return this.assetItem.startOffset;
    }
    get timelineOffset() {
      var _this$hls4;
      return ((_this$hls4 = this.hls) == null ? void 0 : _this$hls4.config.timelineOffset) || 0;
    }
    set timelineOffset(value) {
      const timelineOffset = this.timelineOffset;
      if (value !== timelineOffset) {
        const diff = value - timelineOffset;
        if (Math.abs(diff) > 1 / 9e4 && this.hls) {
          if (this.hasDetails) {
            throw new Error(`Cannot set timelineOffset after playlists are loaded`);
          }
          this.hls.config.timelineOffset = value;
        }
      }
    }
    getAssetTime(time2) {
      const timelineOffset = this.timelineOffset;
      const duration = this.duration;
      return Math.min(Math.max(0, time2 - timelineOffset), duration);
    }
    removeMediaListeners() {
      const media = this.mediaAttached;
      if (media) {
        this._currentTime = media.currentTime;
        this.bufferSnapShot();
        media.removeEventListener("timeupdate", this.checkPlayout);
      }
    }
    bufferSnapShot() {
      if (this.mediaAttached) {
        var _this$hls5;
        if ((_this$hls5 = this.hls) != null && _this$hls5.bufferedToEnd) {
          this._bufferedEosTime = this.bufferedEnd;
        }
      }
    }
    destroy() {
      this.removeMediaListeners();
      if (this.hls) {
        this.hls.destroy();
      }
      this.hls = null;
      this.tracks = this.mediaAttached = this.checkPlayout = null;
    }
    attachMedia(data) {
      var _this$hls6;
      this.loadSource();
      (_this$hls6 = this.hls) == null || _this$hls6.attachMedia(data);
    }
    detachMedia() {
      var _this$hls7;
      this.removeMediaListeners();
      this.mediaAttached = null;
      (_this$hls7 = this.hls) == null || _this$hls7.detachMedia();
    }
    resumeBuffering() {
      var _this$hls8;
      (_this$hls8 = this.hls) == null || _this$hls8.resumeBuffering();
    }
    pauseBuffering() {
      var _this$hls9;
      (_this$hls9 = this.hls) == null || _this$hls9.pauseBuffering();
    }
    transferMedia() {
      var _this$hls0;
      this.bufferSnapShot();
      return ((_this$hls0 = this.hls) == null ? void 0 : _this$hls0.transferMedia()) || null;
    }
    resetDetails() {
      const hls = this.hls;
      if (hls && this.hasDetails) {
        hls.stopLoad();
        const deleteDetails = (obj) => delete obj.details;
        hls.levels.forEach(deleteDetails);
        hls.allAudioTracks.forEach(deleteDetails);
        hls.allSubtitleTracks.forEach(deleteDetails);
        this.hasDetails = false;
      }
    }
    on(event, listener, context3) {
      var _this$hls1;
      (_this$hls1 = this.hls) == null || _this$hls1.on(event, listener);
    }
    once(event, listener, context3) {
      var _this$hls10;
      (_this$hls10 = this.hls) == null || _this$hls10.once(event, listener);
    }
    off(event, listener, context3) {
      var _this$hls11;
      (_this$hls11 = this.hls) == null || _this$hls11.off(event, listener);
    }
    toString() {
      var _this$hls12;
      return `HlsAssetPlayer: ${eventAssetToString(this.assetItem)} ${(_this$hls12 = this.hls) == null ? void 0 : _this$hls12.sessionId} ${this.appendInPlace ? "append-in-place" : ""}`;
    }
  };
  var ABUTTING_THRESHOLD_SECONDS = 0.033;
  var InterstitialsSchedule = class extends Logger {
    constructor(onScheduleUpdate, logger2) {
      super("interstitials-sched", logger2);
      this.onScheduleUpdate = void 0;
      this.eventMap = {};
      this.events = null;
      this.items = null;
      this.durations = {
        primary: 0,
        playout: 0,
        integrated: 0
      };
      this.onScheduleUpdate = onScheduleUpdate;
    }
    destroy() {
      this.reset();
      this.onScheduleUpdate = null;
    }
    reset() {
      this.eventMap = {};
      this.setDurations(0, 0, 0);
      if (this.events) {
        this.events.forEach((interstitial) => interstitial.reset());
      }
      this.events = this.items = null;
    }
    resetErrorsInRange(start, end) {
      if (this.events) {
        return this.events.reduce((count, interstitial) => {
          if (start <= interstitial.startOffset && end > interstitial.startOffset) {
            delete interstitial.error;
            return count + 1;
          }
          return count;
        }, 0);
      }
      return 0;
    }
    get duration() {
      const items = this.items;
      return items ? items[items.length - 1].end : 0;
    }
    get length() {
      return this.items ? this.items.length : 0;
    }
    getEvent(identifier) {
      return identifier ? this.eventMap[identifier] || null : null;
    }
    hasEvent(identifier) {
      return identifier in this.eventMap;
    }
    findItemIndex(item, time2) {
      if (item.event) {
        return this.findEventIndex(item.event.identifier);
      }
      let index = -1;
      if (item.nextEvent) {
        index = this.findEventIndex(item.nextEvent.identifier) - 1;
      } else if (item.previousEvent) {
        index = this.findEventIndex(item.previousEvent.identifier) + 1;
      }
      const items = this.items;
      if (items) {
        if (!items[index]) {
          if (time2 === void 0) {
            time2 = item.start;
          }
          index = this.findItemIndexAtTime(time2);
        }
        while (index >= 0 && (_items$index = items[index]) != null && _items$index.event) {
          var _items$index;
          index--;
        }
      }
      return index;
    }
    findItemIndexAtTime(timelinePos, timelineType) {
      const items = this.items;
      if (items) {
        for (let i = 0; i < items.length; i++) {
          let timeRange = items[i];
          if (timelineType && timelineType !== "primary") {
            timeRange = timeRange[timelineType];
          }
          if (timelinePos === timeRange.start || timelinePos > timeRange.start && timelinePos < timeRange.end) {
            return i;
          }
        }
      }
      return -1;
    }
    findJumpRestrictedIndex(startIndex, endIndex) {
      const items = this.items;
      if (items) {
        for (let i = startIndex; i <= endIndex; i++) {
          if (!items[i]) {
            break;
          }
          const event = items[i].event;
          if (event != null && event.restrictions.jump && !event.appendInPlace) {
            return i;
          }
        }
      }
      return -1;
    }
    findEventIndex(identifier) {
      const items = this.items;
      if (items) {
        for (let i = items.length; i--; ) {
          var _items$i$event;
          if (((_items$i$event = items[i].event) == null ? void 0 : _items$i$event.identifier) === identifier) {
            return i;
          }
        }
      }
      return -1;
    }
    findAssetIndex(event, timelinePos) {
      const assetList = event.assetList;
      const length = assetList.length;
      if (length > 1) {
        for (let i = 0; i < length; i++) {
          const asset = assetList[i];
          if (!asset.error) {
            const timelineStart = asset.timelineStart;
            if (timelinePos === timelineStart || timelinePos > timelineStart && (timelinePos < timelineStart + (asset.duration || 0) || i === length - 1)) {
              return i;
            }
          }
        }
      }
      return 0;
    }
    get assetIdAtEnd() {
      var _this$items;
      const interstitialAtEnd = (_this$items = this.items) == null || (_this$items = _this$items[this.length - 1]) == null ? void 0 : _this$items.event;
      if (interstitialAtEnd) {
        const assetList = interstitialAtEnd.assetList;
        const assetAtEnd = assetList[assetList.length - 1];
        if (assetAtEnd) {
          return assetAtEnd.identifier;
        }
      }
      return null;
    }
    parseInterstitialDateRanges(mediaSelection, enableAppendInPlace) {
      const details = mediaSelection.main.details;
      const {
        dateRanges
      } = details;
      const previousInterstitialEvents = this.events;
      const interstitialEvents = this.parseDateRanges(dateRanges, {
        url: details.url
      }, enableAppendInPlace);
      const ids = Object.keys(dateRanges);
      const removedInterstitials = previousInterstitialEvents ? previousInterstitialEvents.filter((event) => !ids.includes(event.identifier)) : [];
      if (interstitialEvents.length) {
        interstitialEvents.sort((a, b) => {
          const aPre = a.cue.pre;
          const aPost = a.cue.post;
          const bPre = b.cue.pre;
          const bPost = b.cue.post;
          if (aPre && !bPre) {
            return -1;
          }
          if (bPre && !aPre) {
            return 1;
          }
          if (aPost && !bPost) {
            return 1;
          }
          if (bPost && !aPost) {
            return -1;
          }
          if (!aPre && !bPre && !aPost && !bPost) {
            const startA = a.startTime;
            const startB = b.startTime;
            if (startA !== startB) {
              return startA - startB;
            }
          }
          return a.dateRange.tagOrder - b.dateRange.tagOrder;
        });
      }
      this.events = interstitialEvents;
      removedInterstitials.forEach((interstitial) => {
        this.removeEvent(interstitial);
      });
      this.updateSchedule(mediaSelection, removedInterstitials);
    }
    updateSchedule(mediaSelection, removedInterstitials = [], forceUpdate = false) {
      const events = this.events || [];
      if (events.length || removedInterstitials.length || this.length < 2) {
        const currentItems = this.items;
        const updatedItems = this.parseSchedule(events, mediaSelection);
        const updated = forceUpdate || removedInterstitials.length || (currentItems == null ? void 0 : currentItems.length) !== updatedItems.length || updatedItems.some((item, i) => {
          return Math.abs(item.playout.start - currentItems[i].playout.start) > 5e-3 || Math.abs(item.playout.end - currentItems[i].playout.end) > 5e-3;
        });
        if (updated) {
          this.items = updatedItems;
          this.onScheduleUpdate(removedInterstitials, currentItems);
        }
      }
    }
    parseDateRanges(dateRanges, baseData, enableAppendInPlace) {
      const interstitialEvents = [];
      const ids = Object.keys(dateRanges);
      for (let i = 0; i < ids.length; i++) {
        const id3 = ids[i];
        const dateRange = dateRanges[id3];
        if (dateRange.isInterstitial) {
          let interstitial = this.eventMap[id3];
          if (interstitial) {
            interstitial.setDateRange(dateRange);
          } else {
            interstitial = new InterstitialEvent(dateRange, baseData);
            this.eventMap[id3] = interstitial;
            if (enableAppendInPlace === false) {
              interstitial.appendInPlace = enableAppendInPlace;
            }
          }
          interstitialEvents.push(interstitial);
        }
      }
      return interstitialEvents;
    }
    parseSchedule(interstitialEvents, mediaSelection) {
      const schedule = [];
      const details = mediaSelection.main.details;
      const primaryDuration = details.live ? Infinity : details.edge;
      let playoutDuration = 0;
      interstitialEvents = interstitialEvents.filter((event) => !event.error && !(event.cue.once && event.hasPlayed));
      if (interstitialEvents.length) {
        this.resolveOffsets(interstitialEvents, mediaSelection);
        let primaryPosition = 0;
        let integratedTime = 0;
        interstitialEvents.forEach((interstitial, i) => {
          const preroll = interstitial.cue.pre;
          const postroll = interstitial.cue.post;
          const previousEvent = interstitialEvents[i - 1] || null;
          const appendInPlace = interstitial.appendInPlace;
          const eventStart = postroll ? primaryDuration : interstitial.startOffset;
          const interstitialDuration = interstitial.duration;
          const timelineDuration = interstitial.timelineOccupancy === TimelineOccupancy.Range ? interstitialDuration : 0;
          const resumptionOffset = interstitial.resumptionOffset;
          const inSameStartTimeSequence = (previousEvent == null ? void 0 : previousEvent.startTime) === eventStart;
          const start = eventStart + interstitial.cumulativeDuration;
          let end = appendInPlace ? start + interstitialDuration : eventStart + resumptionOffset;
          if (preroll || !postroll && eventStart <= 0) {
            const integratedStart = integratedTime;
            integratedTime += timelineDuration;
            interstitial.timelineStart = start;
            const playoutStart = playoutDuration;
            playoutDuration += interstitialDuration;
            schedule.push({
              event: interstitial,
              start,
              end,
              playout: {
                start: playoutStart,
                end: playoutDuration
              },
              integrated: {
                start: integratedStart,
                end: integratedTime
              }
            });
          } else if (eventStart <= primaryDuration) {
            if (!inSameStartTimeSequence) {
              const segmentDuration = eventStart - primaryPosition;
              if (segmentDuration > ABUTTING_THRESHOLD_SECONDS) {
                const timelineStart = primaryPosition;
                const _integratedStart = integratedTime;
                integratedTime += segmentDuration;
                const _playoutStart = playoutDuration;
                playoutDuration += segmentDuration;
                const primarySegment = {
                  previousEvent: interstitialEvents[i - 1] || null,
                  nextEvent: interstitial,
                  start: timelineStart,
                  end: timelineStart + segmentDuration,
                  playout: {
                    start: _playoutStart,
                    end: playoutDuration
                  },
                  integrated: {
                    start: _integratedStart,
                    end: integratedTime
                  }
                };
                schedule.push(primarySegment);
              } else if (segmentDuration > 0 && previousEvent) {
                previousEvent.cumulativeDuration += segmentDuration;
                schedule[schedule.length - 1].end = eventStart;
              }
            }
            if (postroll) {
              end = start;
            }
            interstitial.timelineStart = start;
            const integratedStart = integratedTime;
            integratedTime += timelineDuration;
            const playoutStart = playoutDuration;
            playoutDuration += interstitialDuration;
            schedule.push({
              event: interstitial,
              start,
              end,
              playout: {
                start: playoutStart,
                end: playoutDuration
              },
              integrated: {
                start: integratedStart,
                end: integratedTime
              }
            });
          } else {
            return;
          }
          const resumeTime = interstitial.resumeTime;
          if (postroll || resumeTime > primaryDuration) {
            primaryPosition = primaryDuration;
          } else {
            primaryPosition = resumeTime;
          }
        });
        if (primaryPosition < primaryDuration) {
          var _schedule;
          const timelineStart = primaryPosition;
          const integratedStart = integratedTime;
          const segmentDuration = primaryDuration - primaryPosition;
          integratedTime += segmentDuration;
          const playoutStart = playoutDuration;
          playoutDuration += segmentDuration;
          schedule.push({
            previousEvent: ((_schedule = schedule[schedule.length - 1]) == null ? void 0 : _schedule.event) || null,
            nextEvent: null,
            start: primaryPosition,
            end: timelineStart + segmentDuration,
            playout: {
              start: playoutStart,
              end: playoutDuration
            },
            integrated: {
              start: integratedStart,
              end: integratedTime
            }
          });
        }
        this.setDurations(primaryDuration, playoutDuration, integratedTime);
      } else {
        const start = 0;
        schedule.push({
          previousEvent: null,
          nextEvent: null,
          start,
          end: primaryDuration,
          playout: {
            start,
            end: primaryDuration
          },
          integrated: {
            start,
            end: primaryDuration
          }
        });
        this.setDurations(primaryDuration, primaryDuration, primaryDuration);
      }
      return schedule;
    }
    setDurations(primary, playout, integrated) {
      this.durations = {
        primary,
        playout,
        integrated
      };
    }
    resolveOffsets(interstitialEvents, mediaSelection) {
      const details = mediaSelection.main.details;
      const primaryDuration = details.live ? Infinity : details.edge;
      let cumulativeDuration = 0;
      let lastScheduledStart = -1;
      interstitialEvents.forEach((interstitial, i) => {
        const preroll = interstitial.cue.pre;
        const postroll = interstitial.cue.post;
        const eventStart = preroll ? 0 : postroll ? primaryDuration : interstitial.startTime;
        this.updateAssetDurations(interstitial);
        const inSameStartTimeSequence = lastScheduledStart === eventStart;
        if (inSameStartTimeSequence) {
          interstitial.cumulativeDuration = cumulativeDuration;
        } else {
          cumulativeDuration = 0;
          lastScheduledStart = eventStart;
        }
        if (!postroll && interstitial.snapOptions.in) {
          interstitial.resumeAnchor = findFragmentByPTS(null, details.fragments, interstitial.startOffset + interstitial.resumptionOffset, 0, 0) || void 0;
        }
        if (interstitial.appendInPlace && !interstitial.appendInPlaceStarted) {
          const alignedSegmentStart = this.primaryCanResumeInPlaceAt(interstitial, mediaSelection);
          if (!alignedSegmentStart) {
            interstitial.appendInPlace = false;
          }
        }
        if (!interstitial.appendInPlace && i + 1 < interstitialEvents.length) {
          const timeBetween = interstitialEvents[i + 1].startTime - interstitialEvents[i].resumeTime;
          if (timeBetween < ABUTTING_THRESHOLD_SECONDS) {
            interstitialEvents[i + 1].appendInPlace = false;
            if (interstitialEvents[i + 1].appendInPlace) {
              this.warn(`Could not change append strategy for abutting event ${interstitial}`);
            }
          }
        }
        const resumeOffset = isFiniteNumber(interstitial.resumeOffset) ? interstitial.resumeOffset : interstitial.duration;
        cumulativeDuration += resumeOffset;
      });
    }
    primaryCanResumeInPlaceAt(interstitial, mediaSelection) {
      const resumeTime = interstitial.resumeTime;
      const resumesInPlaceAt = interstitial.startTime + interstitial.resumptionOffset;
      if (Math.abs(resumeTime - resumesInPlaceAt) > ALIGNED_END_THRESHOLD_SECONDS) {
        this.log(`"${interstitial.identifier}" resumption ${resumeTime} not aligned with estimated timeline end ${resumesInPlaceAt}`);
        return false;
      }
      const playlists = Object.keys(mediaSelection);
      return !playlists.some((playlistType) => {
        const details = mediaSelection[playlistType].details;
        const playlistEnd = details.edge;
        if (resumeTime >= playlistEnd) {
          this.log(`"${interstitial.identifier}" resumption ${resumeTime} past ${playlistType} playlist end ${playlistEnd}`);
          return false;
        }
        const startFragment = findFragmentByPTS(null, details.fragments, resumeTime);
        if (!startFragment) {
          this.log(`"${interstitial.identifier}" resumption ${resumeTime} does not align with any fragments in ${playlistType} playlist (${details.fragStart}-${details.fragmentEnd})`);
          return true;
        }
        const allowance = playlistType === "audio" ? 0.175 : 0;
        const alignedWithSegment = Math.abs(startFragment.start - resumeTime) < ALIGNED_END_THRESHOLD_SECONDS + allowance || Math.abs(startFragment.end - resumeTime) < ALIGNED_END_THRESHOLD_SECONDS + allowance;
        if (!alignedWithSegment) {
          this.log(`"${interstitial.identifier}" resumption ${resumeTime} not aligned with ${playlistType} fragment bounds (${startFragment.start}-${startFragment.end} sn: ${startFragment.sn} cc: ${startFragment.cc})`);
          return true;
        }
        return false;
      });
    }
    updateAssetDurations(interstitial) {
      if (!interstitial.assetListLoaded) {
        return;
      }
      const eventStart = interstitial.timelineStart;
      let sumDuration = 0;
      let hasUnknownDuration = false;
      let hasErrors = false;
      for (let i = 0; i < interstitial.assetList.length; i++) {
        const asset = interstitial.assetList[i];
        const timelineStart = eventStart + sumDuration;
        asset.startOffset = sumDuration;
        asset.timelineStart = timelineStart;
        hasUnknownDuration || (hasUnknownDuration = asset.duration === null);
        hasErrors || (hasErrors = !!asset.error);
        const duration = asset.error ? 0 : asset.duration || 0;
        sumDuration += duration;
      }
      if (hasUnknownDuration && !hasErrors) {
        interstitial.duration = Math.max(sumDuration, interstitial.duration);
      } else {
        interstitial.duration = sumDuration;
      }
    }
    removeEvent(interstitial) {
      interstitial.reset();
      delete this.eventMap[interstitial.identifier];
    }
  };
  function segmentToString(segment) {
    return `[${segment.event ? '"' + segment.event.identifier + '"' : "primary"}: ${segment.start.toFixed(2)}-${segment.end.toFixed(2)}]`;
  }
  var AssetListLoader = class {
    constructor(hls) {
      this.hls = void 0;
      this.hls = hls;
    }
    destroy() {
      this.hls = null;
    }
    loadAssetList(interstitial, hlsStartOffset) {
      const assetListUrl = interstitial.assetListUrl;
      let url;
      try {
        url = getInterstitialUrl(assetListUrl, this.hls.sessionId, interstitial.baseUrl);
      } catch (error) {
        const errorData = this.assignAssetListError(interstitial, ErrorDetails.ASSET_LIST_LOAD_ERROR, error, assetListUrl);
        this.hls.trigger(Events.ERROR, errorData);
        return;
      }
      if (hlsStartOffset && url.protocol !== "data:") {
        url.searchParams.set("_HLS_start_offset", "" + hlsStartOffset);
      }
      const config3 = this.hls.config;
      const Loader = config3.loader;
      const loader = new Loader(config3);
      const context3 = {
        responseType: "json",
        url: url.href
      };
      const loadPolicy = config3.interstitialAssetListLoadPolicy.default;
      const loaderConfig = {
        loadPolicy,
        timeout: loadPolicy.maxLoadTimeMs,
        maxRetry: 0,
        retryDelay: 0,
        maxRetryDelay: 0
      };
      const callbacks = {
        onSuccess: (response, stats, context4, networkDetails) => {
          const assetListResponse = response.data;
          const assets = assetListResponse == null ? void 0 : assetListResponse.ASSETS;
          if (!Array.isArray(assets)) {
            const errorData = this.assignAssetListError(interstitial, ErrorDetails.ASSET_LIST_PARSING_ERROR, new Error(`Invalid interstitial asset list`), context4.url, stats, networkDetails);
            this.hls.trigger(Events.ERROR, errorData);
            return;
          }
          interstitial.assetListResponse = assetListResponse;
          this.hls.trigger(Events.ASSET_LIST_LOADED, {
            event: interstitial,
            assetListResponse,
            networkDetails
          });
        },
        onError: (error, context4, networkDetails, stats) => {
          const errorData = this.assignAssetListError(interstitial, ErrorDetails.ASSET_LIST_LOAD_ERROR, new Error(`Error loading X-ASSET-LIST: HTTP status ${error.code} ${error.text} (${context4.url})`), context4.url, stats, networkDetails);
          this.hls.trigger(Events.ERROR, errorData);
        },
        onTimeout: (stats, context4, networkDetails) => {
          const errorData = this.assignAssetListError(interstitial, ErrorDetails.ASSET_LIST_LOAD_TIMEOUT, new Error(`Timeout loading X-ASSET-LIST (${context4.url})`), context4.url, stats, networkDetails);
          this.hls.trigger(Events.ERROR, errorData);
        }
      };
      loader.load(context3, loaderConfig, callbacks);
      this.hls.trigger(Events.ASSET_LIST_LOADING, {
        event: interstitial
      });
      return loader;
    }
    assignAssetListError(interstitial, details, error, url, stats, networkDetails) {
      interstitial.error = error;
      return {
        type: ErrorTypes.NETWORK_ERROR,
        details,
        fatal: false,
        interstitial,
        url,
        error,
        networkDetails,
        stats
      };
    }
  };
  function playWithCatch(media) {
    media == null || media.play().catch(() => {
    });
  }
  function timelineMessage(label, time2) {
    return `[${label}] Advancing timeline position to ${time2}`;
  }
  var InterstitialsController = class extends Logger {
    constructor(hls, HlsPlayerClass) {
      super("interstitials", hls.logger);
      this.HlsPlayerClass = void 0;
      this.hls = void 0;
      this.assetListLoader = void 0;
      this.mediaSelection = null;
      this.altSelection = null;
      this.media = null;
      this.detachedData = null;
      this.requiredTracks = null;
      this.manager = null;
      this.playerQueue = [];
      this.bufferedPos = -1;
      this.timelinePos = -1;
      this.schedule = void 0;
      this.playingItem = null;
      this.bufferingItem = null;
      this.waitingItem = null;
      this.endedItem = null;
      this.playingAsset = null;
      this.endedAsset = null;
      this.bufferingAsset = null;
      this.shouldPlay = false;
      this.onPlay = () => {
        this.shouldPlay = true;
      };
      this.onPause = () => {
        this.shouldPlay = false;
      };
      this.onSeeking = () => {
        const currentTime = this.currentTime;
        if (currentTime === void 0 || this.playbackDisabled || !this.schedule) {
          return;
        }
        const diff = currentTime - this.timelinePos;
        const roundingError = Math.abs(diff) < 1 / 7056e5;
        if (roundingError) {
          return;
        }
        const backwardSeek = diff <= -0.01;
        this.timelinePos = currentTime;
        this.bufferedPos = currentTime;
        const playingItem = this.playingItem;
        if (!playingItem) {
          this.checkBuffer();
          return;
        }
        if (backwardSeek) {
          const resetCount = this.schedule.resetErrorsInRange(currentTime, currentTime - diff);
          if (resetCount) {
            this.updateSchedule(true);
          }
        }
        this.checkBuffer();
        if (backwardSeek && currentTime < playingItem.start || currentTime >= playingItem.end) {
          var _this$media;
          const playingIndex = this.findItemIndex(playingItem);
          let scheduleIndex = this.schedule.findItemIndexAtTime(currentTime);
          if (scheduleIndex === -1) {
            scheduleIndex = playingIndex + (backwardSeek ? -1 : 1);
            this.log(`seeked ${backwardSeek ? "back " : ""}to position not covered by schedule ${currentTime} (resolving from ${playingIndex} to ${scheduleIndex})`);
          }
          if (!this.isInterstitial(playingItem) && (_this$media = this.media) != null && _this$media.paused) {
            this.shouldPlay = false;
          }
          if (!backwardSeek) {
            if (scheduleIndex > playingIndex) {
              const jumpIndex = this.schedule.findJumpRestrictedIndex(playingIndex + 1, scheduleIndex);
              if (jumpIndex > playingIndex) {
                this.setSchedulePosition(jumpIndex);
                return;
              }
            }
          }
          this.setSchedulePosition(scheduleIndex);
          return;
        }
        const playingAsset = this.playingAsset;
        if (!playingAsset) {
          if (this.playingLastItem && this.isInterstitial(playingItem)) {
            const restartAsset = playingItem.event.assetList[0];
            if (restartAsset) {
              this.endedItem = this.playingItem;
              this.playingItem = null;
              this.setScheduleToAssetAtTime(currentTime, restartAsset);
            }
          }
          return;
        }
        const start = playingAsset.timelineStart;
        const duration = playingAsset.duration || 0;
        if (backwardSeek && currentTime < start || currentTime >= start + duration) {
          var _playingItem$event;
          if ((_playingItem$event = playingItem.event) != null && _playingItem$event.appendInPlace) {
            this.clearInterstitial(playingItem.event, playingItem);
            this.flushFrontBuffer(currentTime);
          }
          this.setScheduleToAssetAtTime(currentTime, playingAsset);
        }
      };
      this.onTimeupdate = () => {
        const currentTime = this.currentTime;
        if (currentTime === void 0 || this.playbackDisabled) {
          return;
        }
        if (currentTime > this.timelinePos) {
          this.timelinePos = currentTime;
          if (currentTime > this.bufferedPos) {
            this.checkBuffer();
          }
        } else {
          return;
        }
        const playingItem = this.playingItem;
        if (!playingItem || this.playingLastItem) {
          return;
        }
        if (currentTime >= playingItem.end) {
          this.timelinePos = playingItem.end;
          const playingIndex = this.findItemIndex(playingItem);
          this.setSchedulePosition(playingIndex + 1);
        }
        const playingAsset = this.playingAsset;
        if (!playingAsset) {
          return;
        }
        const end = playingAsset.timelineStart + (playingAsset.duration || 0);
        if (currentTime >= end) {
          this.setScheduleToAssetAtTime(currentTime, playingAsset);
        }
      };
      this.onScheduleUpdate = (removedInterstitials, previousItems) => {
        const schedule = this.schedule;
        if (!schedule) {
          return;
        }
        const playingItem = this.playingItem;
        const interstitialEvents = schedule.events || [];
        const scheduleItems = schedule.items || [];
        const durations = schedule.durations;
        const removedIds = removedInterstitials.map((interstitial) => interstitial.identifier);
        const interstitialsUpdated = !!(interstitialEvents.length || removedIds.length);
        if (interstitialsUpdated || previousItems) {
          this.log(`INTERSTITIALS_UPDATED (${interstitialEvents.length}): ${interstitialEvents}
Schedule: ${scheduleItems.map((seg) => segmentToString(seg))} pos: ${this.timelinePos}`);
        }
        if (removedIds.length) {
          this.log(`Removed events ${removedIds}`);
        }
        let updatedPlayingItem = null;
        let updatedBufferingItem = null;
        if (playingItem) {
          updatedPlayingItem = this.updateItem(playingItem, this.timelinePos);
          if (this.itemsMatch(playingItem, updatedPlayingItem)) {
            this.playingItem = updatedPlayingItem;
          } else {
            this.waitingItem = this.endedItem = null;
          }
        }
        this.waitingItem = this.updateItem(this.waitingItem);
        this.endedItem = this.updateItem(this.endedItem);
        const bufferingItem = this.bufferingItem;
        if (bufferingItem) {
          updatedBufferingItem = this.updateItem(bufferingItem, this.bufferedPos);
          if (this.itemsMatch(bufferingItem, updatedBufferingItem)) {
            this.bufferingItem = updatedBufferingItem;
          } else if (bufferingItem.event) {
            this.bufferingItem = this.playingItem;
            this.clearInterstitial(bufferingItem.event, null);
          }
        }
        removedInterstitials.forEach((interstitial) => {
          interstitial.assetList.forEach((asset) => {
            this.clearAssetPlayer(asset.identifier, null);
          });
        });
        this.playerQueue.forEach((player) => {
          if (player.interstitial.appendInPlace) {
            const timelineStart = player.assetItem.timelineStart;
            const diff = player.timelineOffset - timelineStart;
            if (diff) {
              try {
                player.timelineOffset = timelineStart;
              } catch (e) {
                if (Math.abs(diff) > ALIGNED_END_THRESHOLD_SECONDS) {
                  this.warn(`${e} ("${player.assetId}" ${player.timelineOffset}->${timelineStart})`);
                }
              }
            }
          }
        });
        if (interstitialsUpdated || previousItems) {
          this.hls.trigger(Events.INTERSTITIALS_UPDATED, {
            events: interstitialEvents.slice(0),
            schedule: scheduleItems.slice(0),
            durations,
            removedIds
          });
          if (this.isInterstitial(playingItem) && removedIds.includes(playingItem.event.identifier)) {
            this.warn(`Interstitial "${playingItem.event.identifier}" removed while playing`);
            this.primaryFallback(playingItem.event);
            return;
          }
          if (playingItem) {
            this.trimInPlace(updatedPlayingItem, playingItem);
          }
          if (bufferingItem && updatedBufferingItem !== updatedPlayingItem) {
            this.trimInPlace(updatedBufferingItem, bufferingItem);
          }
          this.checkBuffer();
        }
      };
      this.hls = hls;
      this.HlsPlayerClass = HlsPlayerClass;
      this.assetListLoader = new AssetListLoader(hls);
      this.schedule = new InterstitialsSchedule(this.onScheduleUpdate, hls.logger);
      this.registerListeners();
    }
    registerListeners() {
      const hls = this.hls;
      if (hls) {
        hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);
        hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
        hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
        hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
        hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);
        hls.on(Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);
        hls.on(Events.AUDIO_TRACK_UPDATED, this.onAudioTrackUpdated, this);
        hls.on(Events.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this);
        hls.on(Events.SUBTITLE_TRACK_UPDATED, this.onSubtitleTrackUpdated, this);
        hls.on(Events.EVENT_CUE_ENTER, this.onInterstitialCueEnter, this);
        hls.on(Events.ASSET_LIST_LOADED, this.onAssetListLoaded, this);
        hls.on(Events.BUFFER_APPENDED, this.onBufferAppended, this);
        hls.on(Events.BUFFER_FLUSHED, this.onBufferFlushed, this);
        hls.on(Events.BUFFERED_TO_END, this.onBufferedToEnd, this);
        hls.on(Events.MEDIA_ENDED, this.onMediaEnded, this);
        hls.on(Events.ERROR, this.onError, this);
        hls.on(Events.DESTROYING, this.onDestroying, this);
      }
    }
    unregisterListeners() {
      const hls = this.hls;
      if (hls) {
        hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);
        hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
        hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
        hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
        hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);
        hls.off(Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);
        hls.off(Events.AUDIO_TRACK_UPDATED, this.onAudioTrackUpdated, this);
        hls.off(Events.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this);
        hls.off(Events.SUBTITLE_TRACK_UPDATED, this.onSubtitleTrackUpdated, this);
        hls.off(Events.EVENT_CUE_ENTER, this.onInterstitialCueEnter, this);
        hls.off(Events.ASSET_LIST_LOADED, this.onAssetListLoaded, this);
        hls.off(Events.BUFFER_CODECS, this.onBufferCodecs, this);
        hls.off(Events.BUFFER_APPENDED, this.onBufferAppended, this);
        hls.off(Events.BUFFER_FLUSHED, this.onBufferFlushed, this);
        hls.off(Events.BUFFERED_TO_END, this.onBufferedToEnd, this);
        hls.off(Events.MEDIA_ENDED, this.onMediaEnded, this);
        hls.off(Events.ERROR, this.onError, this);
        hls.off(Events.DESTROYING, this.onDestroying, this);
      }
    }
    startLoad() {
      this.resumeBuffering();
    }
    stopLoad() {
      this.pauseBuffering();
    }
    resumeBuffering() {
      var _this$getBufferingPla;
      (_this$getBufferingPla = this.getBufferingPlayer()) == null || _this$getBufferingPla.resumeBuffering();
    }
    pauseBuffering() {
      var _this$getBufferingPla2;
      (_this$getBufferingPla2 = this.getBufferingPlayer()) == null || _this$getBufferingPla2.pauseBuffering();
    }
    destroy() {
      this.unregisterListeners();
      this.stopLoad();
      if (this.assetListLoader) {
        this.assetListLoader.destroy();
      }
      this.emptyPlayerQueue();
      this.clearScheduleState();
      if (this.schedule) {
        this.schedule.destroy();
      }
      this.media = this.detachedData = this.mediaSelection = this.requiredTracks = this.altSelection = this.schedule = this.manager = null;
      this.hls = this.HlsPlayerClass = this.log = null;
      this.assetListLoader = null;
      this.onPlay = this.onPause = this.onSeeking = this.onTimeupdate = null;
      this.onScheduleUpdate = null;
    }
    onDestroying() {
      const media = this.primaryMedia || this.media;
      if (media) {
        this.removeMediaListeners(media);
      }
    }
    removeMediaListeners(media) {
      removeEventListener(media, "play", this.onPlay);
      removeEventListener(media, "pause", this.onPause);
      removeEventListener(media, "seeking", this.onSeeking);
      removeEventListener(media, "timeupdate", this.onTimeupdate);
    }
    onMediaAttaching(event, data) {
      const media = this.media = data.media;
      addEventListener(media, "seeking", this.onSeeking);
      addEventListener(media, "timeupdate", this.onTimeupdate);
      addEventListener(media, "play", this.onPlay);
      addEventListener(media, "pause", this.onPause);
    }
    onMediaAttached(event, data) {
      const playingItem = this.effectivePlayingItem;
      const detachedMedia = this.detachedData;
      this.detachedData = null;
      if (playingItem === null) {
        this.checkStart();
      } else if (!detachedMedia) {
        this.clearScheduleState();
        const playingIndex = this.findItemIndex(playingItem);
        this.setSchedulePosition(playingIndex);
      }
    }
    clearScheduleState() {
      this.log(`clear schedule state`);
      this.playingItem = this.bufferingItem = this.waitingItem = this.endedItem = this.playingAsset = this.endedAsset = this.bufferingAsset = null;
    }
    onMediaDetaching(event, data) {
      const transferringMedia = !!data.transferMedia;
      const media = this.media;
      this.media = null;
      if (transferringMedia) {
        return;
      }
      if (media) {
        this.removeMediaListeners(media);
      }
      if (this.detachedData) {
        const player = this.getBufferingPlayer();
        if (player) {
          this.log(`Removing schedule state for detachedData and ${player}`);
          this.playingAsset = this.endedAsset = this.bufferingAsset = this.bufferingItem = this.waitingItem = this.detachedData = null;
          player.detachMedia();
        }
        this.shouldPlay = false;
      }
    }
    get interstitialsManager() {
      if (!this.hls) {
        return null;
      }
      if (this.manager) {
        return this.manager;
      }
      const c = this;
      const effectiveBufferingItem = () => c.bufferingItem || c.waitingItem;
      const getAssetPlayer = (asset) => asset ? c.getAssetPlayer(asset.identifier) : asset;
      const getMappedTime = (item, timelineType, asset, controllerField, assetPlayerField) => {
        if (item) {
          let time2 = item[timelineType].start;
          const interstitial = item.event;
          if (interstitial) {
            if (timelineType === "playout" || interstitial.timelineOccupancy !== TimelineOccupancy.Point) {
              const assetPlayer = getAssetPlayer(asset);
              if ((assetPlayer == null ? void 0 : assetPlayer.interstitial) === interstitial) {
                time2 += assetPlayer.assetItem.startOffset + assetPlayer[assetPlayerField];
              }
            }
          } else {
            const value = controllerField === "bufferedPos" ? getBufferedEnd() : c[controllerField];
            time2 += value - item.start;
          }
          return time2;
        }
        return 0;
      };
      const findMappedTime = (primaryTime, timelineType) => {
        var _c$schedule;
        if (primaryTime !== 0 && timelineType !== "primary" && (_c$schedule = c.schedule) != null && _c$schedule.length) {
          var _c$schedule$items;
          const index = c.schedule.findItemIndexAtTime(primaryTime);
          const item = (_c$schedule$items = c.schedule.items) == null ? void 0 : _c$schedule$items[index];
          if (item) {
            const diff = item[timelineType].start - item.start;
            return primaryTime + diff;
          }
        }
        return primaryTime;
      };
      const getBufferedEnd = () => {
        const value = c.bufferedPos;
        if (value === Number.MAX_VALUE) {
          return getMappedDuration("primary");
        }
        return Math.max(value, 0);
      };
      const getMappedDuration = (timelineType) => {
        var _c$primaryDetails, _c$schedule2;
        if ((_c$primaryDetails = c.primaryDetails) != null && _c$primaryDetails.live) {
          return c.primaryDetails.edge;
        }
        return ((_c$schedule2 = c.schedule) == null ? void 0 : _c$schedule2.durations[timelineType]) || 0;
      };
      const seekTo = (time2, timelineType) => {
        var _item$event, _c$schedule$items2;
        const item = c.effectivePlayingItem;
        if (item != null && (_item$event = item.event) != null && _item$event.restrictions.skip || !c.schedule) {
          return;
        }
        c.log(`seek to ${time2} "${timelineType}"`);
        const playingItem = c.effectivePlayingItem;
        const targetIndex = c.schedule.findItemIndexAtTime(time2, timelineType);
        const targetItem = (_c$schedule$items2 = c.schedule.items) == null ? void 0 : _c$schedule$items2[targetIndex];
        const bufferingPlayer = c.getBufferingPlayer();
        const bufferingInterstitial = bufferingPlayer == null ? void 0 : bufferingPlayer.interstitial;
        const appendInPlace = bufferingInterstitial == null ? void 0 : bufferingInterstitial.appendInPlace;
        const seekInItem = playingItem && c.itemsMatch(playingItem, targetItem);
        if (playingItem && (appendInPlace || seekInItem)) {
          const assetPlayer = getAssetPlayer(c.playingAsset);
          const media = (assetPlayer == null ? void 0 : assetPlayer.media) || c.primaryMedia;
          if (media) {
            const currentTime = timelineType === "primary" ? media.currentTime : getMappedTime(playingItem, timelineType, c.playingAsset, "timelinePos", "currentTime");
            const diff = time2 - currentTime;
            const seekToTime = (appendInPlace ? currentTime : media.currentTime) + diff;
            if (seekToTime >= 0 && (!assetPlayer || appendInPlace || seekToTime <= assetPlayer.duration)) {
              media.currentTime = seekToTime;
              return;
            }
          }
        }
        if (targetItem) {
          let seekToTime = time2;
          if (timelineType !== "primary") {
            const primarySegmentStart = targetItem[timelineType].start;
            const diff = time2 - primarySegmentStart;
            seekToTime = targetItem.start + diff;
          }
          const targetIsPrimary = !c.isInterstitial(targetItem);
          if ((!c.isInterstitial(playingItem) || playingItem.event.appendInPlace) && (targetIsPrimary || targetItem.event.appendInPlace)) {
            const media = c.media || (appendInPlace ? bufferingPlayer == null ? void 0 : bufferingPlayer.media : null);
            if (media) {
              media.currentTime = seekToTime;
            }
          } else if (playingItem) {
            const playingIndex = c.findItemIndex(playingItem);
            if (targetIndex > playingIndex) {
              const jumpIndex = c.schedule.findJumpRestrictedIndex(playingIndex + 1, targetIndex);
              if (jumpIndex > playingIndex) {
                c.setSchedulePosition(jumpIndex);
                return;
              }
            }
            let assetIndex = 0;
            if (targetIsPrimary) {
              c.timelinePos = seekToTime;
              c.checkBuffer();
            } else {
              const assetList = targetItem.event.assetList;
              const eventTime = time2 - (targetItem[timelineType] || targetItem).start;
              for (let i = assetList.length; i--; ) {
                const asset = assetList[i];
                if (asset.duration && eventTime >= asset.startOffset && eventTime < asset.startOffset + asset.duration) {
                  assetIndex = i;
                  break;
                }
              }
            }
            c.setSchedulePosition(targetIndex, assetIndex);
          }
        }
      };
      const getActiveInterstitial = () => {
        const playingItem = c.effectivePlayingItem;
        if (c.isInterstitial(playingItem)) {
          return playingItem;
        }
        const bufferingItem = effectiveBufferingItem();
        if (c.isInterstitial(bufferingItem)) {
          return bufferingItem;
        }
        return null;
      };
      const interstitialPlayer = {
        get bufferedEnd() {
          const interstitialItem = effectiveBufferingItem();
          const bufferingItem = c.bufferingItem;
          if (bufferingItem && bufferingItem === interstitialItem) {
            var _c$bufferingAsset;
            return getMappedTime(bufferingItem, "playout", c.bufferingAsset, "bufferedPos", "bufferedEnd") - bufferingItem.playout.start || ((_c$bufferingAsset = c.bufferingAsset) == null ? void 0 : _c$bufferingAsset.startOffset) || 0;
          }
          return 0;
        },
        get currentTime() {
          const interstitialItem = getActiveInterstitial();
          const playingItem = c.effectivePlayingItem;
          if (playingItem && playingItem === interstitialItem) {
            return getMappedTime(playingItem, "playout", c.effectivePlayingAsset, "timelinePos", "currentTime") - playingItem.playout.start;
          }
          return 0;
        },
        set currentTime(time2) {
          const interstitialItem = getActiveInterstitial();
          const playingItem = c.effectivePlayingItem;
          if (playingItem && playingItem === interstitialItem) {
            seekTo(time2 + playingItem.playout.start, "playout");
          }
        },
        get duration() {
          const interstitialItem = getActiveInterstitial();
          if (interstitialItem) {
            return interstitialItem.playout.end - interstitialItem.playout.start;
          }
          return 0;
        },
        get assetPlayers() {
          var _getActiveInterstitia;
          const assetList = (_getActiveInterstitia = getActiveInterstitial()) == null ? void 0 : _getActiveInterstitia.event.assetList;
          if (assetList) {
            return assetList.map((asset) => c.getAssetPlayer(asset.identifier));
          }
          return [];
        },
        get playingIndex() {
          var _getActiveInterstitia2;
          const interstitial = (_getActiveInterstitia2 = getActiveInterstitial()) == null ? void 0 : _getActiveInterstitia2.event;
          if (interstitial && c.effectivePlayingAsset) {
            return interstitial.findAssetIndex(c.effectivePlayingAsset);
          }
          return -1;
        },
        get scheduleItem() {
          return getActiveInterstitial();
        }
      };
      return this.manager = {
        get events() {
          var _c$schedule3;
          return ((_c$schedule3 = c.schedule) == null || (_c$schedule3 = _c$schedule3.events) == null ? void 0 : _c$schedule3.slice(0)) || [];
        },
        get schedule() {
          var _c$schedule4;
          return ((_c$schedule4 = c.schedule) == null || (_c$schedule4 = _c$schedule4.items) == null ? void 0 : _c$schedule4.slice(0)) || [];
        },
        get interstitialPlayer() {
          if (getActiveInterstitial()) {
            return interstitialPlayer;
          }
          return null;
        },
        get playerQueue() {
          return c.playerQueue.slice(0);
        },
        get bufferingAsset() {
          return c.bufferingAsset;
        },
        get bufferingItem() {
          return effectiveBufferingItem();
        },
        get bufferingIndex() {
          const item = effectiveBufferingItem();
          return c.findItemIndex(item);
        },
        get playingAsset() {
          return c.effectivePlayingAsset;
        },
        get playingItem() {
          return c.effectivePlayingItem;
        },
        get playingIndex() {
          const item = c.effectivePlayingItem;
          return c.findItemIndex(item);
        },
        primary: {
          get bufferedEnd() {
            return getBufferedEnd();
          },
          get currentTime() {
            const timelinePos = c.timelinePos;
            return timelinePos > 0 ? timelinePos : 0;
          },
          set currentTime(time2) {
            seekTo(time2, "primary");
          },
          get duration() {
            return getMappedDuration("primary");
          },
          get seekableStart() {
            var _c$primaryDetails2;
            return ((_c$primaryDetails2 = c.primaryDetails) == null ? void 0 : _c$primaryDetails2.fragmentStart) || 0;
          }
        },
        integrated: {
          get bufferedEnd() {
            return getMappedTime(effectiveBufferingItem(), "integrated", c.bufferingAsset, "bufferedPos", "bufferedEnd");
          },
          get currentTime() {
            return getMappedTime(c.effectivePlayingItem, "integrated", c.effectivePlayingAsset, "timelinePos", "currentTime");
          },
          set currentTime(time2) {
            seekTo(time2, "integrated");
          },
          get duration() {
            return getMappedDuration("integrated");
          },
          get seekableStart() {
            var _c$primaryDetails3;
            return findMappedTime(((_c$primaryDetails3 = c.primaryDetails) == null ? void 0 : _c$primaryDetails3.fragmentStart) || 0, "integrated");
          }
        },
        skip: () => {
          const item = c.effectivePlayingItem;
          const event = item == null ? void 0 : item.event;
          if (event && !event.restrictions.skip) {
            const index = c.findItemIndex(item);
            if (event.appendInPlace) {
              const time2 = item.playout.start + item.event.duration;
              seekTo(time2 + 1e-3, "playout");
            } else {
              c.advanceAfterAssetEnded(event, index, Infinity);
            }
          }
        }
      };
    }
    // Schedule getters
    get effectivePlayingItem() {
      return this.waitingItem || this.playingItem || this.endedItem;
    }
    get effectivePlayingAsset() {
      return this.playingAsset || this.endedAsset;
    }
    get playingLastItem() {
      var _this$schedule;
      const playingItem = this.playingItem;
      const items = (_this$schedule = this.schedule) == null ? void 0 : _this$schedule.items;
      if (!this.playbackStarted || !playingItem || !items) {
        return false;
      }
      return this.findItemIndex(playingItem) === items.length - 1;
    }
    get playbackStarted() {
      return this.effectivePlayingItem !== null;
    }
    // Media getters and event callbacks
    get currentTime() {
      var _this$bufferingItem, _media2;
      if (this.mediaSelection === null) {
        return void 0;
      }
      const queuedForPlayback = this.waitingItem || this.playingItem;
      if (this.isInterstitial(queuedForPlayback) && !queuedForPlayback.event.appendInPlace) {
        return void 0;
      }
      let media = this.media;
      if (!media && (_this$bufferingItem = this.bufferingItem) != null && (_this$bufferingItem = _this$bufferingItem.event) != null && _this$bufferingItem.appendInPlace) {
        media = this.primaryMedia;
      }
      const currentTime = (_media2 = media) == null ? void 0 : _media2.currentTime;
      if (currentTime === void 0 || !isFiniteNumber(currentTime)) {
        return void 0;
      }
      return currentTime;
    }
    get primaryMedia() {
      var _this$detachedData;
      return this.media || ((_this$detachedData = this.detachedData) == null ? void 0 : _this$detachedData.media) || null;
    }
    isInterstitial(item) {
      return !!(item != null && item.event);
    }
    retreiveMediaSource(assetId, toSegment) {
      const player = this.getAssetPlayer(assetId);
      if (player) {
        this.transferMediaFromPlayer(player, toSegment);
      }
    }
    transferMediaFromPlayer(player, toSegment) {
      const appendInPlace = player.interstitial.appendInPlace;
      const playerMedia = player.media;
      if (appendInPlace && playerMedia === this.primaryMedia) {
        this.bufferingAsset = null;
        if (!toSegment || this.isInterstitial(toSegment) && !toSegment.event.appendInPlace) {
          if (toSegment && playerMedia) {
            this.detachedData = {
              media: playerMedia
            };
            return;
          }
        }
        const attachMediaSourceData = player.transferMedia();
        this.log(`transfer MediaSource from ${player} ${stringify(attachMediaSourceData)}`);
        this.detachedData = attachMediaSourceData;
      } else if (toSegment && playerMedia) {
        this.shouldPlay || (this.shouldPlay = !playerMedia.paused);
      }
    }
    transferMediaTo(player, media) {
      var _this$detachedData2, _attachMediaSourceDat;
      if (player.media === media) {
        return;
      }
      let attachMediaSourceData = null;
      const primaryPlayer = this.hls;
      const isAssetPlayer = player !== primaryPlayer;
      const appendInPlace = isAssetPlayer && player.interstitial.appendInPlace;
      const detachedMediaSource = (_this$detachedData2 = this.detachedData) == null ? void 0 : _this$detachedData2.mediaSource;
      let logFromSource;
      if (primaryPlayer.media) {
        if (appendInPlace) {
          attachMediaSourceData = primaryPlayer.transferMedia();
          this.detachedData = attachMediaSourceData;
        }
        logFromSource = `Primary`;
      } else if (detachedMediaSource) {
        const bufferingPlayer = this.getBufferingPlayer();
        if (bufferingPlayer) {
          attachMediaSourceData = bufferingPlayer.transferMedia();
          logFromSource = `${bufferingPlayer}`;
        } else {
          logFromSource = `detached MediaSource`;
        }
      } else {
        logFromSource = `detached media`;
      }
      if (!attachMediaSourceData) {
        if (detachedMediaSource) {
          attachMediaSourceData = this.detachedData;
          this.log(`using detachedData: MediaSource ${stringify(attachMediaSourceData)}`);
        } else if (!this.detachedData || primaryPlayer.media === media) {
          const playerQueue = this.playerQueue;
          if (playerQueue.length > 1) {
            playerQueue.forEach((queuedPlayer) => {
              if (isAssetPlayer && queuedPlayer.interstitial.appendInPlace !== appendInPlace) {
                const interstitial = queuedPlayer.interstitial;
                this.clearInterstitial(queuedPlayer.interstitial, null);
                interstitial.appendInPlace = false;
                if (interstitial.appendInPlace) {
                  this.warn(`Could not change append strategy for queued assets ${interstitial}`);
                }
              }
            });
          }
          this.hls.detachMedia();
          this.detachedData = {
            media
          };
        }
      }
      const transferring = attachMediaSourceData && "mediaSource" in attachMediaSourceData && ((_attachMediaSourceDat = attachMediaSourceData.mediaSource) == null ? void 0 : _attachMediaSourceDat.readyState) !== "closed";
      const dataToAttach = transferring && attachMediaSourceData ? attachMediaSourceData : media;
      this.log(`${transferring ? "transfering MediaSource" : "attaching media"} to ${isAssetPlayer ? player : "Primary"} from ${logFromSource} (media.currentTime: ${media.currentTime})`);
      const schedule = this.schedule;
      if (dataToAttach === attachMediaSourceData && schedule) {
        const isAssetAtEndOfSchedule = isAssetPlayer && player.assetId === schedule.assetIdAtEnd;
        dataToAttach.overrides = {
          duration: schedule.duration,
          endOfStream: !isAssetPlayer || isAssetAtEndOfSchedule,
          cueRemoval: !isAssetPlayer
        };
      }
      player.attachMedia(dataToAttach);
    }
    onInterstitialCueEnter() {
      this.onTimeupdate();
    }
    // Scheduling methods
    checkStart() {
      const schedule = this.schedule;
      const interstitialEvents = schedule == null ? void 0 : schedule.events;
      if (!interstitialEvents || this.playbackDisabled || !this.media) {
        return;
      }
      if (this.bufferedPos === -1) {
        this.bufferedPos = 0;
      }
      const timelinePos = this.timelinePos;
      const effectivePlayingItem = this.effectivePlayingItem;
      if (timelinePos === -1) {
        const startPosition = this.hls.startPosition;
        this.log(timelineMessage("checkStart", startPosition));
        this.timelinePos = startPosition;
        if (interstitialEvents.length && interstitialEvents[0].cue.pre) {
          const index = schedule.findEventIndex(interstitialEvents[0].identifier);
          this.setSchedulePosition(index);
        } else if (startPosition >= 0 || !this.primaryLive) {
          const start = this.timelinePos = startPosition > 0 ? startPosition : 0;
          const index = schedule.findItemIndexAtTime(start);
          this.setSchedulePosition(index);
        }
      } else if (effectivePlayingItem && !this.playingItem) {
        const index = schedule.findItemIndex(effectivePlayingItem);
        this.setSchedulePosition(index);
      }
    }
    advanceAssetBuffering(item, assetItem) {
      const interstitial = item.event;
      const assetListIndex = interstitial.findAssetIndex(assetItem);
      const nextAssetIndex = getNextAssetIndex(interstitial, assetListIndex);
      if (!interstitial.isAssetPastPlayoutLimit(nextAssetIndex)) {
        this.bufferedToEvent(item, nextAssetIndex);
      } else if (this.schedule) {
        var _this$schedule$items;
        const nextItem = (_this$schedule$items = this.schedule.items) == null ? void 0 : _this$schedule$items[this.findItemIndex(item) + 1];
        if (nextItem) {
          this.bufferedToItem(nextItem);
        }
      }
    }
    advanceAfterAssetEnded(interstitial, index, assetListIndex) {
      const nextAssetIndex = getNextAssetIndex(interstitial, assetListIndex);
      if (!interstitial.isAssetPastPlayoutLimit(nextAssetIndex)) {
        if (interstitial.appendInPlace) {
          const assetItem = interstitial.assetList[nextAssetIndex];
          if (assetItem) {
            this.advanceInPlace(assetItem.timelineStart);
          }
        }
        this.setSchedulePosition(index, nextAssetIndex);
      } else if (this.schedule) {
        const scheduleItems = this.schedule.items;
        if (scheduleItems) {
          const nextIndex = index + 1;
          const scheduleLength = scheduleItems.length;
          if (nextIndex >= scheduleLength) {
            this.setSchedulePosition(-1);
            return;
          }
          const resumptionTime = interstitial.resumeTime;
          if (this.timelinePos < resumptionTime) {
            this.log(timelineMessage("advanceAfterAssetEnded", resumptionTime));
            this.timelinePos = resumptionTime;
            if (interstitial.appendInPlace) {
              this.advanceInPlace(resumptionTime);
            }
            this.checkBuffer(this.bufferedPos < resumptionTime);
          }
          this.setSchedulePosition(nextIndex);
        }
      }
    }
    setScheduleToAssetAtTime(time2, playingAsset) {
      const schedule = this.schedule;
      if (!schedule) {
        return;
      }
      const parentIdentifier = playingAsset.parentIdentifier;
      const interstitial = schedule.getEvent(parentIdentifier);
      if (interstitial) {
        const itemIndex = schedule.findEventIndex(parentIdentifier);
        const assetListIndex = schedule.findAssetIndex(interstitial, time2);
        this.advanceAfterAssetEnded(interstitial, itemIndex, assetListIndex - 1);
      }
    }
    setSchedulePosition(index, assetListIndex) {
      var _this$schedule2;
      const scheduleItems = (_this$schedule2 = this.schedule) == null ? void 0 : _this$schedule2.items;
      if (!scheduleItems || this.playbackDisabled) {
        return;
      }
      const scheduledItem = index >= 0 ? scheduleItems[index] : null;
      this.log(`setSchedulePosition ${index}, ${assetListIndex} (${scheduledItem ? segmentToString(scheduledItem) : scheduledItem}) pos: ${this.timelinePos}`);
      const currentItem = this.waitingItem || this.playingItem;
      const playingLastItem = this.playingLastItem;
      if (this.isInterstitial(currentItem)) {
        const interstitial = currentItem.event;
        const playingAsset = this.playingAsset;
        const assetId = playingAsset == null ? void 0 : playingAsset.identifier;
        const player = assetId ? this.getAssetPlayer(assetId) : null;
        if (player && assetId && (!this.eventItemsMatch(currentItem, scheduledItem) || assetListIndex !== void 0 && assetId !== interstitial.assetList[assetListIndex].identifier)) {
          var _this$detachedData3;
          const playingAssetListIndex = interstitial.findAssetIndex(playingAsset);
          this.log(`INTERSTITIAL_ASSET_ENDED ${playingAssetListIndex + 1}/${interstitial.assetList.length} ${eventAssetToString(playingAsset)}`);
          this.endedAsset = playingAsset;
          this.playingAsset = null;
          this.hls.trigger(Events.INTERSTITIAL_ASSET_ENDED, {
            asset: playingAsset,
            assetListIndex: playingAssetListIndex,
            event: interstitial,
            schedule: scheduleItems.slice(0),
            scheduleIndex: index,
            player
          });
          if (currentItem !== this.playingItem) {
            if (this.itemsMatch(currentItem, this.playingItem) && // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
            !this.playingAsset) {
              this.advanceAfterAssetEnded(interstitial, this.findItemIndex(this.playingItem), playingAssetListIndex);
            }
            return;
          }
          this.retreiveMediaSource(assetId, scheduledItem);
          if (player.media && !((_this$detachedData3 = this.detachedData) != null && _this$detachedData3.mediaSource)) {
            player.detachMedia();
          }
        }
        if (!this.eventItemsMatch(currentItem, scheduledItem)) {
          this.endedItem = currentItem;
          this.playingItem = null;
          this.log(`INTERSTITIAL_ENDED ${interstitial} ${segmentToString(currentItem)}`);
          interstitial.hasPlayed = true;
          this.hls.trigger(Events.INTERSTITIAL_ENDED, {
            event: interstitial,
            schedule: scheduleItems.slice(0),
            scheduleIndex: index
          });
          if (interstitial.cue.once) {
            var _this$schedule3;
            this.updateSchedule();
            const updatedScheduleItems = (_this$schedule3 = this.schedule) == null ? void 0 : _this$schedule3.items;
            if (scheduledItem && updatedScheduleItems) {
              const updatedIndex = this.findItemIndex(scheduledItem);
              this.advanceSchedule(updatedIndex, updatedScheduleItems, assetListIndex, currentItem, playingLastItem);
            }
            return;
          }
        }
      }
      this.advanceSchedule(index, scheduleItems, assetListIndex, currentItem, playingLastItem);
    }
    advanceSchedule(index, scheduleItems, assetListIndex, currentItem, playedLastItem) {
      const schedule = this.schedule;
      if (!schedule) {
        return;
      }
      const scheduledItem = scheduleItems[index] || null;
      const media = this.primaryMedia;
      const playerQueue = this.playerQueue;
      if (playerQueue.length) {
        playerQueue.forEach((player) => {
          const interstitial = player.interstitial;
          const queuedIndex = schedule.findEventIndex(interstitial.identifier);
          if (queuedIndex < index || queuedIndex > index + 1) {
            this.clearInterstitial(interstitial, scheduledItem);
          }
        });
      }
      if (this.isInterstitial(scheduledItem)) {
        this.timelinePos = Math.min(Math.max(this.timelinePos, scheduledItem.start), scheduledItem.end);
        const interstitial = scheduledItem.event;
        if (assetListIndex === void 0) {
          assetListIndex = schedule.findAssetIndex(interstitial, this.timelinePos);
          const assetIndexCandidate = getNextAssetIndex(interstitial, assetListIndex - 1);
          if (interstitial.isAssetPastPlayoutLimit(assetIndexCandidate) || interstitial.appendInPlace && this.timelinePos === scheduledItem.end) {
            this.advanceAfterAssetEnded(interstitial, index, assetListIndex);
            return;
          }
          assetListIndex = assetIndexCandidate;
        }
        const waitingItem = this.waitingItem;
        if (!this.assetsBuffered(scheduledItem, media)) {
          this.setBufferingItem(scheduledItem);
        }
        let player = this.preloadAssets(interstitial, assetListIndex);
        if (!this.eventItemsMatch(scheduledItem, waitingItem || currentItem)) {
          this.waitingItem = scheduledItem;
          this.log(`INTERSTITIAL_STARTED ${segmentToString(scheduledItem)} ${interstitial.appendInPlace ? "append in place" : ""}`);
          this.hls.trigger(Events.INTERSTITIAL_STARTED, {
            event: interstitial,
            schedule: scheduleItems.slice(0),
            scheduleIndex: index
          });
        }
        if (!interstitial.assetListLoaded) {
          this.log(`Waiting for ASSET-LIST to complete loading ${interstitial}`);
          return;
        }
        if (interstitial.assetListLoader) {
          interstitial.assetListLoader.destroy();
          interstitial.assetListLoader = void 0;
        }
        if (!media) {
          this.log(`Waiting for attachMedia to start Interstitial ${interstitial}`);
          return;
        }
        this.waitingItem = this.endedItem = null;
        this.playingItem = scheduledItem;
        const assetItem = interstitial.assetList[assetListIndex];
        if (!assetItem) {
          this.advanceAfterAssetEnded(interstitial, index, assetListIndex || 0);
          return;
        }
        if (!player) {
          player = this.getAssetPlayer(assetItem.identifier);
        }
        if (player === null || player.destroyed) {
          const assetListLength = interstitial.assetList.length;
          this.warn(`asset ${assetListIndex + 1}/${assetListLength} player destroyed ${interstitial}`);
          player = this.createAssetPlayer(interstitial, assetItem, assetListIndex);
          player.loadSource();
        }
        if (!this.eventItemsMatch(scheduledItem, this.bufferingItem)) {
          if (interstitial.appendInPlace && this.isAssetBuffered(assetItem)) {
            return;
          }
        }
        this.startAssetPlayer(player, assetListIndex, scheduleItems, index, media);
        if (this.shouldPlay) {
          playWithCatch(player.media);
        }
      } else if (scheduledItem) {
        this.resumePrimary(scheduledItem, index, currentItem);
        if (this.shouldPlay) {
          playWithCatch(this.hls.media);
        }
      } else if (playedLastItem && this.isInterstitial(currentItem)) {
        this.endedItem = null;
        this.playingItem = currentItem;
        if (!currentItem.event.appendInPlace) {
          this.attachPrimary(schedule.durations.primary, null);
        }
      }
    }
    get playbackDisabled() {
      return this.hls.config.enableInterstitialPlayback === false;
    }
    get primaryDetails() {
      var _this$mediaSelection;
      return (_this$mediaSelection = this.mediaSelection) == null ? void 0 : _this$mediaSelection.main.details;
    }
    get primaryLive() {
      var _this$primaryDetails;
      return !!((_this$primaryDetails = this.primaryDetails) != null && _this$primaryDetails.live);
    }
    resumePrimary(scheduledItem, index, fromItem) {
      var _this$detachedData4, _this$schedule4;
      this.playingItem = scheduledItem;
      this.playingAsset = this.endedAsset = null;
      this.waitingItem = this.endedItem = null;
      this.bufferedToItem(scheduledItem);
      this.log(`resuming ${segmentToString(scheduledItem)}`);
      if (!((_this$detachedData4 = this.detachedData) != null && _this$detachedData4.mediaSource)) {
        let timelinePos = this.timelinePos;
        if (timelinePos < scheduledItem.start || timelinePos >= scheduledItem.end) {
          timelinePos = this.getPrimaryResumption(scheduledItem, index);
          this.log(timelineMessage("resumePrimary", timelinePos));
          this.timelinePos = timelinePos;
        }
        this.attachPrimary(timelinePos, scheduledItem);
      }
      if (!fromItem) {
        return;
      }
      const scheduleItems = (_this$schedule4 = this.schedule) == null ? void 0 : _this$schedule4.items;
      if (!scheduleItems) {
        return;
      }
      this.log(`INTERSTITIALS_PRIMARY_RESUMED ${segmentToString(scheduledItem)}`);
      this.hls.trigger(Events.INTERSTITIALS_PRIMARY_RESUMED, {
        schedule: scheduleItems.slice(0),
        scheduleIndex: index
      });
      this.checkBuffer();
    }
    getPrimaryResumption(scheduledItem, index) {
      const itemStart = scheduledItem.start;
      if (this.primaryLive) {
        const details = this.primaryDetails;
        if (index === 0) {
          return this.hls.startPosition;
        } else if (details && (itemStart < details.fragmentStart || itemStart > details.edge)) {
          return this.hls.liveSyncPosition || -1;
        }
      }
      return itemStart;
    }
    isAssetBuffered(asset) {
      const player = this.getAssetPlayer(asset.identifier);
      if (player != null && player.hls) {
        return player.hls.bufferedToEnd;
      }
      const bufferInfo = BufferHelper.bufferInfo(this.primaryMedia, this.timelinePos, 0);
      return bufferInfo.end + 1 >= asset.timelineStart + (asset.duration || 0);
    }
    attachPrimary(timelinePos, item, skipSeekToStartPosition) {
      if (item) {
        this.setBufferingItem(item);
      } else {
        this.bufferingItem = this.playingItem;
      }
      this.bufferingAsset = null;
      const media = this.primaryMedia;
      if (!media) {
        return;
      }
      const hls = this.hls;
      if (hls.media) {
        this.checkBuffer();
      } else {
        this.transferMediaTo(hls, media);
        if (skipSeekToStartPosition) {
          this.startLoadingPrimaryAt(timelinePos, skipSeekToStartPosition);
        }
      }
      if (!skipSeekToStartPosition) {
        this.log(timelineMessage("attachPrimary", timelinePos));
        this.timelinePos = timelinePos;
        this.startLoadingPrimaryAt(timelinePos, skipSeekToStartPosition);
      }
    }
    startLoadingPrimaryAt(timelinePos, skipSeekToStartPosition) {
      var _hls$mainForwardBuffe;
      const hls = this.hls;
      if (!hls.loadingEnabled || !hls.media || Math.abs((((_hls$mainForwardBuffe = hls.mainForwardBufferInfo) == null ? void 0 : _hls$mainForwardBuffe.start) || hls.media.currentTime) - timelinePos) > 0.5) {
        hls.startLoad(timelinePos, skipSeekToStartPosition);
      } else if (!hls.bufferingEnabled) {
        hls.resumeBuffering();
      }
    }
    // HLS.js event callbacks
    onManifestLoading() {
      var _this$schedule5;
      this.stopLoad();
      (_this$schedule5 = this.schedule) == null || _this$schedule5.reset();
      this.emptyPlayerQueue();
      this.clearScheduleState();
      this.shouldPlay = false;
      this.bufferedPos = this.timelinePos = -1;
      this.mediaSelection = this.altSelection = this.manager = this.requiredTracks = null;
      this.hls.off(Events.BUFFER_CODECS, this.onBufferCodecs, this);
      this.hls.on(Events.BUFFER_CODECS, this.onBufferCodecs, this);
    }
    onLevelUpdated(event, data) {
      if (data.level === -1 || !this.schedule) {
        return;
      }
      const main = this.hls.levels[data.level];
      if (!main.details) {
        return;
      }
      const currentSelection = _objectSpread2(_objectSpread2({}, this.mediaSelection || this.altSelection), {}, {
        main
      });
      this.mediaSelection = currentSelection;
      this.schedule.parseInterstitialDateRanges(currentSelection, this.hls.config.interstitialAppendInPlace);
      if (!this.effectivePlayingItem && this.schedule.items) {
        this.checkStart();
      }
    }
    onAudioTrackUpdated(event, data) {
      const audio = this.hls.audioTracks[data.id];
      const previousSelection = this.mediaSelection;
      if (!previousSelection) {
        this.altSelection = _objectSpread2(_objectSpread2({}, this.altSelection), {}, {
          audio
        });
        return;
      }
      const currentSelection = _objectSpread2(_objectSpread2({}, previousSelection), {}, {
        audio
      });
      this.mediaSelection = currentSelection;
    }
    onSubtitleTrackUpdated(event, data) {
      const subtitles = this.hls.subtitleTracks[data.id];
      const previousSelection = this.mediaSelection;
      if (!previousSelection) {
        this.altSelection = _objectSpread2(_objectSpread2({}, this.altSelection), {}, {
          subtitles
        });
        return;
      }
      const currentSelection = _objectSpread2(_objectSpread2({}, previousSelection), {}, {
        subtitles
      });
      this.mediaSelection = currentSelection;
    }
    onAudioTrackSwitching(event, data) {
      const audioOption = getBasicSelectionOption(data);
      this.playerQueue.forEach(({
        hls
      }) => hls && (hls.setAudioOption(data) || hls.setAudioOption(audioOption)));
    }
    onSubtitleTrackSwitch(event, data) {
      const subtitleOption = getBasicSelectionOption(data);
      this.playerQueue.forEach(({
        hls
      }) => hls && (hls.setSubtitleOption(data) || data.id !== -1 && hls.setSubtitleOption(subtitleOption)));
    }
    onBufferCodecs(event, data) {
      const requiredTracks = data.tracks;
      if (requiredTracks) {
        this.requiredTracks = requiredTracks;
      }
    }
    onBufferAppended(event, data) {
      this.checkBuffer();
    }
    onBufferFlushed(event, data) {
      const playingItem = this.playingItem;
      if (playingItem && !this.itemsMatch(playingItem, this.bufferingItem) && !this.isInterstitial(playingItem)) {
        const timelinePos = this.timelinePos;
        this.bufferedPos = timelinePos;
        this.checkBuffer();
      }
    }
    onBufferedToEnd(event) {
      if (!this.schedule) {
        return;
      }
      const interstitialEvents = this.schedule.events;
      if (this.bufferedPos < Number.MAX_VALUE && interstitialEvents) {
        for (let i = 0; i < interstitialEvents.length; i++) {
          const interstitial = interstitialEvents[i];
          if (interstitial.cue.post) {
            var _this$schedule$items2;
            const scheduleIndex = this.schedule.findEventIndex(interstitial.identifier);
            const item = (_this$schedule$items2 = this.schedule.items) == null ? void 0 : _this$schedule$items2[scheduleIndex];
            if (this.isInterstitial(item) && this.eventItemsMatch(item, this.bufferingItem)) {
              this.bufferedToItem(item, 0);
            }
            break;
          }
        }
        this.bufferedPos = Number.MAX_VALUE;
      }
    }
    onMediaEnded(event) {
      const playingItem = this.playingItem;
      if (!this.playingLastItem && playingItem) {
        const playingIndex = this.findItemIndex(playingItem);
        this.setSchedulePosition(playingIndex + 1);
      } else {
        this.shouldPlay = false;
      }
    }
    updateItem(previousItem, time2) {
      var _this$schedule6;
      const items = (_this$schedule6 = this.schedule) == null ? void 0 : _this$schedule6.items;
      if (previousItem && items) {
        const index = this.findItemIndex(previousItem, time2);
        return items[index] || null;
      }
      return null;
    }
    trimInPlace(updatedItem, itemBeforeUpdate) {
      if (this.isInterstitial(updatedItem) && updatedItem.event.appendInPlace && itemBeforeUpdate.end - updatedItem.end > 0.25) {
        updatedItem.event.assetList.forEach((asset, index) => {
          if (updatedItem.event.isAssetPastPlayoutLimit(index)) {
            this.clearAssetPlayer(asset.identifier, null);
          }
        });
        const flushStart = updatedItem.end + 0.25;
        const bufferInfo = BufferHelper.bufferInfo(this.primaryMedia, flushStart, 0);
        if (bufferInfo.end > flushStart || (bufferInfo.nextStart || 0) > flushStart) {
          this.log(`trim buffered interstitial ${segmentToString(updatedItem)} (was ${segmentToString(itemBeforeUpdate)})`);
          const skipSeekToStartPosition = true;
          this.attachPrimary(flushStart, null, skipSeekToStartPosition);
          this.flushFrontBuffer(flushStart);
        }
      }
    }
    itemsMatch(a, b) {
      return !!b && (a === b || a.event && b.event && this.eventItemsMatch(a, b) || !a.event && !b.event && this.findItemIndex(a) === this.findItemIndex(b));
    }
    eventItemsMatch(a, b) {
      var _b$event;
      return !!b && (a === b || a.event.identifier === ((_b$event = b.event) == null ? void 0 : _b$event.identifier));
    }
    findItemIndex(item, time2) {
      return item && this.schedule ? this.schedule.findItemIndex(item, time2) : -1;
    }
    updateSchedule(forceUpdate = false) {
      var _this$schedule7;
      const mediaSelection = this.mediaSelection;
      if (!mediaSelection) {
        return;
      }
      (_this$schedule7 = this.schedule) == null || _this$schedule7.updateSchedule(mediaSelection, [], forceUpdate);
    }
    // Schedule buffer control
    checkBuffer(starved) {
      var _this$schedule8;
      const items = (_this$schedule8 = this.schedule) == null ? void 0 : _this$schedule8.items;
      if (!items) {
        return;
      }
      const bufferInfo = BufferHelper.bufferInfo(this.primaryMedia, this.timelinePos, 0);
      if (starved) {
        this.bufferedPos = this.timelinePos;
      }
      starved || (starved = bufferInfo.len < 1);
      this.updateBufferedPos(bufferInfo.end, items, starved);
    }
    updateBufferedPos(bufferEnd, items, bufferIsEmpty) {
      const schedule = this.schedule;
      const bufferingItem = this.bufferingItem;
      if (this.bufferedPos > bufferEnd || !schedule) {
        return;
      }
      if (items.length === 1 && this.itemsMatch(items[0], bufferingItem)) {
        this.bufferedPos = bufferEnd;
        return;
      }
      const playingItem = this.playingItem;
      const playingIndex = this.findItemIndex(playingItem);
      let bufferEndIndex = schedule.findItemIndexAtTime(bufferEnd);
      if (this.bufferedPos < bufferEnd) {
        var _nextItemToBuffer$eve;
        const bufferingIndex = this.findItemIndex(bufferingItem);
        const nextToBufferIndex = Math.min(bufferingIndex + 1, items.length - 1);
        const nextItemToBuffer = items[nextToBufferIndex];
        if (bufferEndIndex === -1 && bufferingItem && bufferEnd >= bufferingItem.end || (_nextItemToBuffer$eve = nextItemToBuffer.event) != null && _nextItemToBuffer$eve.appendInPlace && bufferEnd + 0.01 >= nextItemToBuffer.start) {
          bufferEndIndex = nextToBufferIndex;
        }
        if (this.isInterstitial(bufferingItem)) {
          const interstitial = bufferingItem.event;
          if (nextToBufferIndex - playingIndex > 1 && interstitial.appendInPlace === false) {
            return;
          }
          if (interstitial.assetList.length === 0 && interstitial.assetListLoader) {
            return;
          }
        }
        this.bufferedPos = bufferEnd;
        if (bufferEndIndex > bufferingIndex && bufferEndIndex > playingIndex) {
          this.bufferedToItem(nextItemToBuffer);
        } else {
          const details = this.primaryDetails;
          if (this.primaryLive && details && bufferEnd > details.edge - details.targetduration && nextItemToBuffer.start < details.edge + this.hls.config.interstitialLiveLookAhead && this.isInterstitial(nextItemToBuffer)) {
            this.preloadAssets(nextItemToBuffer.event, 0);
          }
        }
      } else if (bufferIsEmpty && playingItem && !this.itemsMatch(playingItem, bufferingItem)) {
        if (bufferEndIndex === playingIndex) {
          this.bufferedToItem(playingItem);
        } else if (bufferEndIndex === playingIndex + 1) {
          this.bufferedToItem(items[bufferEndIndex]);
        }
      }
    }
    assetsBuffered(item, media) {
      const assetList = item.event.assetList;
      if (assetList.length === 0) {
        return false;
      }
      return !item.event.assetList.some((asset) => {
        const player = this.getAssetPlayer(asset.identifier);
        return !(player != null && player.bufferedInPlaceToEnd(media));
      });
    }
    setBufferingItem(item) {
      const bufferingLast = this.bufferingItem;
      const schedule = this.schedule;
      if (!this.itemsMatch(item, bufferingLast) && schedule) {
        const {
          items,
          events
        } = schedule;
        if (!items || !events) {
          return bufferingLast;
        }
        const isInterstitial = this.isInterstitial(item);
        const bufferingPlayer = this.getBufferingPlayer();
        this.bufferingItem = item;
        this.bufferedPos = Math.max(item.start, Math.min(item.end, this.timelinePos));
        const timeRemaining = bufferingPlayer ? bufferingPlayer.remaining : bufferingLast ? bufferingLast.end - this.timelinePos : 0;
        this.log(`INTERSTITIALS_BUFFERED_TO_BOUNDARY ${segmentToString(item)}` + (bufferingLast ? ` (${timeRemaining.toFixed(2)} remaining)` : ""));
        if (!this.playbackDisabled) {
          if (isInterstitial) {
            const bufferIndex = schedule.findAssetIndex(item.event, this.bufferedPos);
            item.event.assetList.forEach((asset, i) => {
              const player = this.getAssetPlayer(asset.identifier);
              if (player) {
                if (i === bufferIndex) {
                  player.loadSource();
                }
                player.resumeBuffering();
              }
            });
          } else {
            this.hls.resumeBuffering();
            this.playerQueue.forEach((player) => player.pauseBuffering());
          }
        }
        this.hls.trigger(Events.INTERSTITIALS_BUFFERED_TO_BOUNDARY, {
          events: events.slice(0),
          schedule: items.slice(0),
          bufferingIndex: this.findItemIndex(item),
          playingIndex: this.findItemIndex(this.playingItem)
        });
      } else if (this.bufferingItem !== item) {
        this.bufferingItem = item;
      }
      return bufferingLast;
    }
    bufferedToItem(item, assetListIndex = 0) {
      const bufferingLast = this.setBufferingItem(item);
      if (this.playbackDisabled) {
        return;
      }
      if (this.isInterstitial(item)) {
        this.bufferedToEvent(item, assetListIndex);
      } else if (bufferingLast !== null) {
        this.bufferingAsset = null;
        const detachedData = this.detachedData;
        if (detachedData) {
          if (detachedData.mediaSource) {
            const skipSeekToStartPosition = true;
            this.attachPrimary(item.start, item, skipSeekToStartPosition);
          } else {
            this.preloadPrimary(item);
          }
        } else {
          this.preloadPrimary(item);
        }
      }
    }
    preloadPrimary(item) {
      const index = this.findItemIndex(item);
      const timelinePos = this.getPrimaryResumption(item, index);
      this.startLoadingPrimaryAt(timelinePos);
    }
    bufferedToEvent(item, assetListIndex) {
      const interstitial = item.event;
      const neverLoaded = interstitial.assetList.length === 0 && !interstitial.assetListLoader;
      const playOnce = interstitial.cue.once;
      if (neverLoaded || !playOnce) {
        const player = this.preloadAssets(interstitial, assetListIndex);
        if (player != null && player.interstitial.appendInPlace) {
          const media = this.primaryMedia;
          if (media) {
            this.bufferAssetPlayer(player, media);
          }
        }
      }
    }
    preloadAssets(interstitial, assetListIndex) {
      const uri = interstitial.assetUrl;
      const assetListLength = interstitial.assetList.length;
      const neverLoaded = assetListLength === 0 && !interstitial.assetListLoader;
      const playOnce = interstitial.cue.once;
      if (neverLoaded) {
        const timelineStart = interstitial.timelineStart;
        if (interstitial.appendInPlace) {
          var _playingItem$nextEven;
          const playingItem = this.playingItem;
          if (!this.isInterstitial(playingItem) && (playingItem == null || (_playingItem$nextEven = playingItem.nextEvent) == null ? void 0 : _playingItem$nextEven.identifier) === interstitial.identifier) {
            this.flushFrontBuffer(timelineStart + 0.25);
          }
        }
        let hlsStartOffset;
        let liveStartPosition = 0;
        if (!this.playingItem && this.primaryLive) {
          liveStartPosition = this.hls.startPosition;
          if (liveStartPosition === -1) {
            liveStartPosition = this.hls.liveSyncPosition || 0;
          }
        }
        if (liveStartPosition && !(interstitial.cue.pre || interstitial.cue.post)) {
          const startOffset = liveStartPosition - timelineStart;
          if (startOffset > 0) {
            hlsStartOffset = Math.round(startOffset * 1e3) / 1e3;
          }
        }
        this.log(`Load interstitial asset ${assetListIndex + 1}/${uri ? 1 : assetListLength} ${interstitial}${hlsStartOffset ? ` live-start: ${liveStartPosition} start-offset: ${hlsStartOffset}` : ""}`);
        if (uri) {
          return this.createAsset(interstitial, 0, 0, timelineStart, interstitial.duration, uri);
        }
        const assetListLoader = this.assetListLoader.loadAssetList(interstitial, hlsStartOffset);
        if (assetListLoader) {
          interstitial.assetListLoader = assetListLoader;
        }
      } else if (!playOnce && assetListLength) {
        for (let i = assetListIndex; i < assetListLength; i++) {
          const _asset = interstitial.assetList[i];
          const playerIndex = this.getAssetPlayerQueueIndex(_asset.identifier);
          if ((playerIndex === -1 || this.playerQueue[playerIndex].destroyed) && !_asset.error) {
            this.createAssetPlayer(interstitial, _asset, i);
          }
        }
        const asset = interstitial.assetList[assetListIndex];
        if (asset) {
          const player = this.getAssetPlayer(asset.identifier);
          if (player) {
            player.loadSource();
          }
          return player;
        }
      }
      return null;
    }
    flushFrontBuffer(startOffset) {
      const requiredTracks = this.requiredTracks;
      if (!requiredTracks) {
        return;
      }
      this.log(`Removing front buffer starting at ${startOffset}`);
      const sourceBufferNames = Object.keys(requiredTracks);
      sourceBufferNames.forEach((type) => {
        this.hls.trigger(Events.BUFFER_FLUSHING, {
          startOffset,
          endOffset: Infinity,
          type
        });
      });
    }
    // Interstitial Asset Player control
    getAssetPlayerQueueIndex(assetId) {
      const playerQueue = this.playerQueue;
      for (let i = 0; i < playerQueue.length; i++) {
        if (assetId === playerQueue[i].assetId) {
          return i;
        }
      }
      return -1;
    }
    getAssetPlayer(assetId) {
      const index = this.getAssetPlayerQueueIndex(assetId);
      return this.playerQueue[index] || null;
    }
    getBufferingPlayer() {
      const {
        playerQueue,
        primaryMedia
      } = this;
      if (primaryMedia) {
        for (let i = 0; i < playerQueue.length; i++) {
          if (playerQueue[i].media === primaryMedia) {
            return playerQueue[i];
          }
        }
      }
      return null;
    }
    createAsset(interstitial, assetListIndex, startOffset, timelineStart, duration, uri) {
      const assetItem = {
        parentIdentifier: interstitial.identifier,
        identifier: generateAssetIdentifier(interstitial, uri, assetListIndex),
        duration,
        startOffset,
        timelineStart,
        uri
      };
      return this.createAssetPlayer(interstitial, assetItem, assetListIndex);
    }
    createAssetPlayer(interstitial, assetItem, assetListIndex) {
      const primary = this.hls;
      const userConfig = primary.userConfig;
      let videoPreference = userConfig.videoPreference;
      const currentLevel = primary.loadLevelObj || primary.levels[primary.currentLevel];
      if (videoPreference || currentLevel) {
        videoPreference = _extends4({}, videoPreference);
        if (currentLevel.videoCodec) {
          videoPreference.videoCodec = currentLevel.videoCodec;
        }
        if (currentLevel.videoRange) {
          videoPreference.allowedVideoRanges = [currentLevel.videoRange];
        }
      }
      const selectedAudio = primary.audioTracks[primary.audioTrack];
      const selectedSubtitle = primary.subtitleTracks[primary.subtitleTrack];
      let startPosition = 0;
      if (this.primaryLive || interstitial.appendInPlace) {
        const timePastStart = this.timelinePos - assetItem.timelineStart;
        if (timePastStart > 1) {
          const duration = assetItem.duration;
          if (duration && timePastStart < duration) {
            startPosition = timePastStart;
          }
        }
      }
      const assetId = assetItem.identifier;
      const playerConfig = _objectSpread2(_objectSpread2({}, userConfig), {}, {
        maxMaxBufferLength: Math.min(180, primary.config.maxMaxBufferLength),
        autoStartLoad: true,
        startFragPrefetch: true,
        primarySessionId: primary.sessionId,
        assetPlayerId: assetId,
        abrEwmaDefaultEstimate: primary.bandwidthEstimate,
        interstitialsController: void 0,
        startPosition,
        liveDurationInfinity: false,
        testBandwidth: false,
        videoPreference,
        audioPreference: selectedAudio || userConfig.audioPreference,
        subtitlePreference: selectedSubtitle || userConfig.subtitlePreference
      });
      if (interstitial.appendInPlace) {
        interstitial.appendInPlaceStarted = true;
        if (assetItem.timelineStart) {
          playerConfig.timelineOffset = assetItem.timelineStart;
        }
      }
      const cmcd = playerConfig.cmcd;
      if (cmcd != null && cmcd.sessionId && cmcd.contentId) {
        playerConfig.cmcd = _extends4({}, cmcd, {
          contentId: hash(assetItem.uri)
        });
      }
      if (this.getAssetPlayer(assetId)) {
        this.warn(`Duplicate date range identifier ${interstitial} and asset ${assetId}`);
      }
      const player = new HlsAssetPlayer(this.HlsPlayerClass, playerConfig, interstitial, assetItem);
      this.playerQueue.push(player);
      interstitial.assetList[assetListIndex] = assetItem;
      let initialDuration = true;
      const updateAssetPlayerDetails = (details) => {
        if (details.live) {
          var _this$schedule9;
          const error = new Error(`Interstitials MUST be VOD assets ${interstitial}`);
          const errorData = {
            fatal: true,
            type: ErrorTypes.OTHER_ERROR,
            details: ErrorDetails.INTERSTITIAL_ASSET_ITEM_ERROR,
            error
          };
          const scheduleIndex = ((_this$schedule9 = this.schedule) == null ? void 0 : _this$schedule9.findEventIndex(interstitial.identifier)) || -1;
          this.handleAssetItemError(errorData, interstitial, scheduleIndex, assetListIndex, error.message);
          return;
        }
        const duration = details.edge - details.fragmentStart;
        const currentAssetDuration = assetItem.duration;
        if (initialDuration || currentAssetDuration === null || duration > currentAssetDuration) {
          initialDuration = false;
          this.log(`Interstitial asset "${assetId}" duration change ${currentAssetDuration} > ${duration}`);
          assetItem.duration = duration;
          this.updateSchedule();
        }
      };
      player.on(Events.LEVEL_UPDATED, (event, {
        details
      }) => updateAssetPlayerDetails(details));
      player.on(Events.LEVEL_PTS_UPDATED, (event, {
        details
      }) => updateAssetPlayerDetails(details));
      player.on(Events.EVENT_CUE_ENTER, () => this.onInterstitialCueEnter());
      const onBufferCodecs = (event, data) => {
        const inQueuPlayer = this.getAssetPlayer(assetId);
        if (inQueuPlayer && data.tracks) {
          inQueuPlayer.off(Events.BUFFER_CODECS, onBufferCodecs);
          inQueuPlayer.tracks = data.tracks;
          const media = this.primaryMedia;
          if (this.bufferingAsset === inQueuPlayer.assetItem && media && !inQueuPlayer.media) {
            this.bufferAssetPlayer(inQueuPlayer, media);
          }
        }
      };
      player.on(Events.BUFFER_CODECS, onBufferCodecs);
      const bufferedToEnd = () => {
        var _this$schedule$items3;
        const inQueuPlayer = this.getAssetPlayer(assetId);
        this.log(`buffered to end of asset ${inQueuPlayer}`);
        if (!inQueuPlayer || !this.schedule) {
          return;
        }
        const scheduleIndex = this.schedule.findEventIndex(interstitial.identifier);
        const item = (_this$schedule$items3 = this.schedule.items) == null ? void 0 : _this$schedule$items3[scheduleIndex];
        if (this.isInterstitial(item)) {
          this.advanceAssetBuffering(item, assetItem);
        }
      };
      player.on(Events.BUFFERED_TO_END, bufferedToEnd);
      const endedWithAssetIndex = (assetIndex) => {
        return () => {
          const inQueuPlayer = this.getAssetPlayer(assetId);
          if (!inQueuPlayer || !this.schedule) {
            return;
          }
          this.shouldPlay = true;
          const scheduleIndex = this.schedule.findEventIndex(interstitial.identifier);
          this.advanceAfterAssetEnded(interstitial, scheduleIndex, assetIndex);
        };
      };
      player.once(Events.MEDIA_ENDED, endedWithAssetIndex(assetListIndex));
      player.once(Events.PLAYOUT_LIMIT_REACHED, endedWithAssetIndex(Infinity));
      player.on(Events.ERROR, (event, data) => {
        if (!this.schedule) {
          return;
        }
        const inQueuPlayer = this.getAssetPlayer(assetId);
        if (data.details === ErrorDetails.BUFFER_STALLED_ERROR) {
          if (inQueuPlayer != null && inQueuPlayer.appendInPlace) {
            this.handleInPlaceStall(interstitial);
            return;
          }
          this.onTimeupdate();
          this.checkBuffer(true);
          return;
        }
        this.handleAssetItemError(data, interstitial, this.schedule.findEventIndex(interstitial.identifier), assetListIndex, `Asset player error ${data.error} ${interstitial}`);
      });
      player.on(Events.DESTROYING, () => {
        const inQueuPlayer = this.getAssetPlayer(assetId);
        if (!inQueuPlayer || !this.schedule) {
          return;
        }
        const error = new Error(`Asset player destroyed unexpectedly ${assetId}`);
        const errorData = {
          fatal: true,
          type: ErrorTypes.OTHER_ERROR,
          details: ErrorDetails.INTERSTITIAL_ASSET_ITEM_ERROR,
          error
        };
        this.handleAssetItemError(errorData, interstitial, this.schedule.findEventIndex(interstitial.identifier), assetListIndex, error.message);
      });
      this.log(`INTERSTITIAL_ASSET_PLAYER_CREATED ${eventAssetToString(assetItem)}`);
      this.hls.trigger(Events.INTERSTITIAL_ASSET_PLAYER_CREATED, {
        asset: assetItem,
        assetListIndex,
        event: interstitial,
        player
      });
      return player;
    }
    clearInterstitial(interstitial, toSegment) {
      interstitial.assetList.forEach((asset) => {
        this.clearAssetPlayer(asset.identifier, toSegment);
      });
      interstitial.reset();
    }
    resetAssetPlayer(assetId) {
      const playerIndex = this.getAssetPlayerQueueIndex(assetId);
      if (playerIndex !== -1) {
        this.log(`reset asset player "${assetId}" after error`);
        const player = this.playerQueue[playerIndex];
        this.transferMediaFromPlayer(player, null);
        player.resetDetails();
      }
    }
    clearAssetPlayer(assetId, toSegment) {
      const playerIndex = this.getAssetPlayerQueueIndex(assetId);
      if (playerIndex !== -1) {
        const player = this.playerQueue[playerIndex];
        this.log(`clear ${player} toSegment: ${toSegment ? segmentToString(toSegment) : toSegment}`);
        this.transferMediaFromPlayer(player, toSegment);
        this.playerQueue.splice(playerIndex, 1);
        player.destroy();
      }
    }
    emptyPlayerQueue() {
      let player;
      while (player = this.playerQueue.pop()) {
        player.destroy();
      }
      this.playerQueue = [];
    }
    startAssetPlayer(player, assetListIndex, scheduleItems, scheduleIndex, media) {
      const {
        interstitial,
        assetItem,
        assetId
      } = player;
      const assetListLength = interstitial.assetList.length;
      const playingAsset = this.playingAsset;
      this.endedAsset = null;
      this.playingAsset = assetItem;
      if (!playingAsset || playingAsset.identifier !== assetId) {
        if (playingAsset) {
          this.clearAssetPlayer(playingAsset.identifier, scheduleItems[scheduleIndex]);
          delete playingAsset.error;
        }
        this.log(`INTERSTITIAL_ASSET_STARTED ${assetListIndex + 1}/${assetListLength} ${eventAssetToString(assetItem)}`);
        this.hls.trigger(Events.INTERSTITIAL_ASSET_STARTED, {
          asset: assetItem,
          assetListIndex,
          event: interstitial,
          schedule: scheduleItems.slice(0),
          scheduleIndex,
          player
        });
      }
      this.bufferAssetPlayer(player, media);
    }
    bufferAssetPlayer(player, media) {
      var _this$schedule$items4, _this$detachedData5;
      if (!this.schedule) {
        return;
      }
      const {
        interstitial,
        assetItem
      } = player;
      const scheduleIndex = this.schedule.findEventIndex(interstitial.identifier);
      const item = (_this$schedule$items4 = this.schedule.items) == null ? void 0 : _this$schedule$items4[scheduleIndex];
      if (!item) {
        return;
      }
      player.loadSource();
      this.setBufferingItem(item);
      this.bufferingAsset = assetItem;
      const bufferingPlayer = this.getBufferingPlayer();
      if (bufferingPlayer === player) {
        return;
      }
      const appendInPlaceNext = interstitial.appendInPlace;
      if (appendInPlaceNext && (bufferingPlayer == null ? void 0 : bufferingPlayer.interstitial.appendInPlace) === false) {
        return;
      }
      const activeTracks = (bufferingPlayer == null ? void 0 : bufferingPlayer.tracks) || ((_this$detachedData5 = this.detachedData) == null ? void 0 : _this$detachedData5.tracks) || this.requiredTracks;
      if (appendInPlaceNext && assetItem !== this.playingAsset) {
        if (!player.tracks) {
          this.log(`Waiting for track info before buffering ${player}`);
          return;
        }
        if (activeTracks && !isCompatibleTrackChange(activeTracks, player.tracks)) {
          const error = new Error(`Asset ${eventAssetToString(assetItem)} SourceBuffer tracks ('${Object.keys(player.tracks)}') are not compatible with primary content tracks ('${Object.keys(activeTracks)}')`);
          const errorData = {
            fatal: true,
            type: ErrorTypes.OTHER_ERROR,
            details: ErrorDetails.INTERSTITIAL_ASSET_ITEM_ERROR,
            error
          };
          const assetListIndex = interstitial.findAssetIndex(assetItem);
          this.handleAssetItemError(errorData, interstitial, scheduleIndex, assetListIndex, error.message);
          return;
        }
      }
      this.transferMediaTo(player, media);
    }
    handleInPlaceStall(interstitial) {
      const schedule = this.schedule;
      const media = this.primaryMedia;
      if (!schedule || !media) {
        return;
      }
      const currentTime = media.currentTime;
      const foundAssetIndex = schedule.findAssetIndex(interstitial, currentTime);
      const stallingAsset = interstitial.assetList[foundAssetIndex];
      if (stallingAsset) {
        const player = this.getAssetPlayer(stallingAsset.identifier);
        if (player) {
          const assetCurrentTime = player.currentTime || currentTime - stallingAsset.timelineStart;
          const distanceFromEnd = player.duration - assetCurrentTime;
          this.warn(`Stalled at ${assetCurrentTime} of ${assetCurrentTime + distanceFromEnd} in ${player} ${interstitial} (media.currentTime: ${currentTime})`);
          if (assetCurrentTime && (distanceFromEnd / media.playbackRate < 0.5 || player.bufferedInPlaceToEnd(media)) && player.hls) {
            const scheduleIndex = schedule.findEventIndex(interstitial.identifier);
            this.advanceAfterAssetEnded(interstitial, scheduleIndex, foundAssetIndex);
          }
        }
      }
    }
    advanceInPlace(time2) {
      const media = this.primaryMedia;
      if (media && media.currentTime < time2) {
        media.currentTime = time2;
      }
    }
    handleAssetItemError(data, interstitial, scheduleIndex, assetListIndex, errorMessage) {
      if (data.details === ErrorDetails.BUFFER_STALLED_ERROR) {
        return;
      }
      const assetItem = interstitial.assetList[assetListIndex] || null;
      this.warn(`INTERSTITIAL_ASSET_ERROR ${assetItem ? eventAssetToString(assetItem) : assetItem} ${data.error}`);
      if (!this.schedule) {
        return;
      }
      const assetId = (assetItem == null ? void 0 : assetItem.identifier) || "";
      const playerIndex = this.getAssetPlayerQueueIndex(assetId);
      const player = this.playerQueue[playerIndex] || null;
      const items = this.schedule.items;
      const interstitialAssetError = _extends4({}, data, {
        fatal: false,
        errorAction: createDoNothingErrorAction(true),
        asset: assetItem,
        assetListIndex,
        event: interstitial,
        schedule: items,
        scheduleIndex,
        player
      });
      this.hls.trigger(Events.INTERSTITIAL_ASSET_ERROR, interstitialAssetError);
      if (!data.fatal) {
        return;
      }
      const playingAsset = this.playingAsset;
      const bufferingAsset = this.bufferingAsset;
      const error = new Error(errorMessage);
      if (assetItem) {
        this.clearAssetPlayer(assetId, null);
        assetItem.error = error;
      }
      if (!interstitial.assetList.some((asset) => !asset.error)) {
        interstitial.error = error;
      } else {
        for (let i = assetListIndex; i < interstitial.assetList.length; i++) {
          this.resetAssetPlayer(interstitial.assetList[i].identifier);
        }
      }
      this.updateSchedule(true);
      if (interstitial.error) {
        this.primaryFallback(interstitial);
      } else if (playingAsset && playingAsset.identifier === assetId) {
        this.advanceAfterAssetEnded(interstitial, scheduleIndex, assetListIndex);
      } else if (bufferingAsset && bufferingAsset.identifier === assetId && this.isInterstitial(this.bufferingItem)) {
        this.advanceAssetBuffering(this.bufferingItem, bufferingAsset);
      }
    }
    primaryFallback(interstitial) {
      const flushStart = interstitial.timelineStart;
      const playingItem = this.effectivePlayingItem;
      if (playingItem) {
        this.log(`Fallback to primary from event "${interstitial.identifier}" start: ${flushStart} pos: ${this.timelinePos} playing: ${segmentToString(playingItem)} error: ${interstitial.error}`);
        let timelinePos = this.timelinePos;
        if (timelinePos === -1) {
          timelinePos = this.hls.startPosition;
        }
        const newPlayingItem = this.updateItem(playingItem, timelinePos);
        if (this.itemsMatch(playingItem, newPlayingItem)) {
          this.clearInterstitial(interstitial, null);
        }
        if (interstitial.appendInPlace) {
          this.attachPrimary(flushStart, null);
          this.flushFrontBuffer(flushStart);
        }
        if (!this.schedule) {
          return;
        }
        const scheduleIndex = this.schedule.findItemIndexAtTime(timelinePos);
        this.setSchedulePosition(scheduleIndex);
      } else {
        this.checkStart();
      }
    }
    // Asset List loading
    onAssetListLoaded(event, data) {
      var _this$schedule0, _this$bufferingItem2;
      const interstitial = data.event;
      const interstitialId = interstitial.identifier;
      const assets = data.assetListResponse.ASSETS;
      if (!((_this$schedule0 = this.schedule) != null && _this$schedule0.hasEvent(interstitialId))) {
        return;
      }
      const eventStart = interstitial.timelineStart;
      const previousDuration = interstitial.duration;
      let sumDuration = 0;
      assets.forEach((asset, assetListIndex) => {
        const duration = parseFloat(asset.DURATION);
        this.createAsset(interstitial, assetListIndex, sumDuration, eventStart + sumDuration, duration, asset.URI);
        sumDuration += duration;
      });
      interstitial.duration = sumDuration;
      this.log(`Loaded asset-list with duration: ${sumDuration} (was: ${previousDuration}) ${interstitial}`);
      const waitingItem = this.waitingItem;
      const waitingForItem = (waitingItem == null ? void 0 : waitingItem.event.identifier) === interstitialId;
      this.updateSchedule();
      const bufferingEvent = (_this$bufferingItem2 = this.bufferingItem) == null ? void 0 : _this$bufferingItem2.event;
      if (waitingForItem) {
        var _this$schedule$items5;
        const scheduleIndex = this.schedule.findEventIndex(interstitialId);
        const item = (_this$schedule$items5 = this.schedule.items) == null ? void 0 : _this$schedule$items5[scheduleIndex];
        if (item) {
          if (!this.playingItem && this.timelinePos > item.end) {
            const index = this.schedule.findItemIndexAtTime(this.timelinePos);
            if (index !== scheduleIndex) {
              interstitial.error = new Error(`Interstitial no longer within playback range ${this.timelinePos} ${interstitial}`);
              this.updateSchedule(true);
              this.primaryFallback(interstitial);
              return;
            }
          }
          this.setBufferingItem(item);
        }
        this.setSchedulePosition(scheduleIndex);
      } else if ((bufferingEvent == null ? void 0 : bufferingEvent.identifier) === interstitialId) {
        const assetItem = interstitial.assetList[0];
        if (assetItem) {
          const player = this.getAssetPlayer(assetItem.identifier);
          if (bufferingEvent.appendInPlace) {
            const media = this.primaryMedia;
            if (player && media) {
              this.bufferAssetPlayer(player, media);
            }
          } else if (player) {
            player.loadSource();
          }
        }
      }
    }
    onError(event, data) {
      if (!this.schedule) {
        return;
      }
      switch (data.details) {
        case ErrorDetails.ASSET_LIST_PARSING_ERROR:
        case ErrorDetails.ASSET_LIST_LOAD_ERROR:
        case ErrorDetails.ASSET_LIST_LOAD_TIMEOUT: {
          const interstitial = data.interstitial;
          if (interstitial) {
            this.updateSchedule(true);
            this.primaryFallback(interstitial);
          }
          break;
        }
        case ErrorDetails.BUFFER_STALLED_ERROR: {
          const stallingItem = this.endedItem || this.waitingItem || this.playingItem;
          if (this.isInterstitial(stallingItem) && stallingItem.event.appendInPlace) {
            this.handleInPlaceStall(stallingItem.event);
            return;
          }
          this.log(`Primary player stall @${this.timelinePos} bufferedPos: ${this.bufferedPos}`);
          this.onTimeupdate();
          this.checkBuffer(true);
          break;
        }
      }
    }
  };
  var TICK_INTERVAL$2 = 500;
  var SubtitleStreamController = class extends BaseStreamController {
    constructor(hls, fragmentTracker, keyLoader) {
      super(hls, fragmentTracker, keyLoader, "subtitle-stream-controller", PlaylistLevelType.SUBTITLE);
      this.currentTrackId = -1;
      this.tracksBuffered = [];
      this.mainDetails = null;
      this.registerListeners();
    }
    onHandlerDestroying() {
      this.unregisterListeners();
      super.onHandlerDestroying();
      this.mainDetails = null;
    }
    registerListeners() {
      super.registerListeners();
      const {
        hls
      } = this;
      hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);
      hls.on(Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);
      hls.on(Events.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this);
      hls.on(Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);
      hls.on(Events.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this);
      hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);
    }
    unregisterListeners() {
      super.unregisterListeners();
      const {
        hls
      } = this;
      hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);
      hls.off(Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);
      hls.off(Events.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this);
      hls.off(Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);
      hls.off(Events.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this);
      hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);
    }
    startLoad(startPosition, skipSeekToStartPosition) {
      this.stopLoad();
      this.state = State.IDLE;
      this.setInterval(TICK_INTERVAL$2);
      this.nextLoadPosition = this.lastCurrentTime = startPosition + this.timelineOffset;
      this.startPosition = skipSeekToStartPosition ? -1 : startPosition;
      this.tick();
    }
    onManifestLoading() {
      super.onManifestLoading();
      this.mainDetails = null;
    }
    onMediaDetaching(event, data) {
      this.tracksBuffered = [];
      super.onMediaDetaching(event, data);
    }
    onLevelLoaded(event, data) {
      this.mainDetails = data.details;
    }
    onSubtitleFragProcessed(event, data) {
      const {
        frag,
        success
      } = data;
      if (!this.fragContextChanged(frag)) {
        if (isMediaFragment(frag)) {
          this.fragPrevious = frag;
        }
        this.state = State.IDLE;
      }
      if (!success) {
        return;
      }
      const buffered = this.tracksBuffered[this.currentTrackId];
      if (!buffered) {
        return;
      }
      let timeRange;
      const fragStart = frag.start;
      for (let i = 0; i < buffered.length; i++) {
        if (fragStart >= buffered[i].start && fragStart <= buffered[i].end) {
          timeRange = buffered[i];
          break;
        }
      }
      const fragEnd = frag.start + frag.duration;
      if (timeRange) {
        timeRange.end = fragEnd;
      } else {
        timeRange = {
          start: fragStart,
          end: fragEnd
        };
        buffered.push(timeRange);
      }
      this.fragmentTracker.fragBuffered(frag);
      this.fragBufferedComplete(frag, null);
      if (this.media) {
        this.tick();
      }
    }
    onBufferFlushing(event, data) {
      const {
        startOffset,
        endOffset
      } = data;
      if (startOffset === 0 && endOffset !== Number.POSITIVE_INFINITY) {
        const endOffsetSubtitles = endOffset - 1;
        if (endOffsetSubtitles <= 0) {
          return;
        }
        data.endOffsetSubtitles = Math.max(0, endOffsetSubtitles);
        this.tracksBuffered.forEach((buffered) => {
          for (let i = 0; i < buffered.length; ) {
            if (buffered[i].end <= endOffsetSubtitles) {
              buffered.shift();
              continue;
            } else if (buffered[i].start < endOffsetSubtitles) {
              buffered[i].start = endOffsetSubtitles;
            } else {
              break;
            }
            i++;
          }
        });
        this.fragmentTracker.removeFragmentsInRange(startOffset, endOffsetSubtitles, PlaylistLevelType.SUBTITLE);
      }
    }
    // If something goes wrong, proceed to next frag, if we were processing one.
    onError(event, data) {
      const frag = data.frag;
      if ((frag == null ? void 0 : frag.type) === PlaylistLevelType.SUBTITLE) {
        if (data.details === ErrorDetails.FRAG_GAP) {
          this.fragmentTracker.fragBuffered(frag, true);
        }
        if (this.fragCurrent) {
          this.fragCurrent.abortRequests();
        }
        if (this.state !== State.STOPPED) {
          this.state = State.IDLE;
        }
      }
    }
    // Got all new subtitle levels.
    onSubtitleTracksUpdated(event, {
      subtitleTracks
    }) {
      if (this.levels && subtitleOptionsIdentical(this.levels, subtitleTracks)) {
        this.levels = subtitleTracks.map((mediaPlaylist) => new Level(mediaPlaylist));
        return;
      }
      this.tracksBuffered = [];
      this.levels = subtitleTracks.map((mediaPlaylist) => {
        const level = new Level(mediaPlaylist);
        this.tracksBuffered[level.id] = [];
        return level;
      });
      this.fragmentTracker.removeFragmentsInRange(0, Number.POSITIVE_INFINITY, PlaylistLevelType.SUBTITLE);
      this.fragPrevious = null;
      this.mediaBuffer = null;
    }
    onSubtitleTrackSwitch(event, data) {
      var _this$levels;
      this.currentTrackId = data.id;
      if (!((_this$levels = this.levels) != null && _this$levels.length) || this.currentTrackId === -1) {
        this.clearInterval();
        return;
      }
      const currentTrack = this.levels[this.currentTrackId];
      if (currentTrack != null && currentTrack.details) {
        this.mediaBuffer = this.mediaBufferTimeRanges;
      } else {
        this.mediaBuffer = null;
      }
      if (currentTrack && this.state !== State.STOPPED) {
        this.setInterval(TICK_INTERVAL$2);
      }
    }
    // Got a new set of subtitle fragments.
    onSubtitleTrackLoaded(event, data) {
      var _track$details;
      const {
        currentTrackId,
        levels
      } = this;
      const {
        details: newDetails,
        id: trackId
      } = data;
      if (!levels) {
        this.warn(`Subtitle tracks were reset while loading level ${trackId}`);
        return;
      }
      const track = levels[trackId];
      if (trackId >= levels.length || !track) {
        return;
      }
      this.log(`Subtitle track ${trackId} loaded [${newDetails.startSN},${newDetails.endSN}]${newDetails.lastPartSn ? `[part-${newDetails.lastPartSn}-${newDetails.lastPartIndex}]` : ""},duration:${newDetails.totalduration}`);
      this.mediaBuffer = this.mediaBufferTimeRanges;
      let sliding = 0;
      if (newDetails.live || (_track$details = track.details) != null && _track$details.live) {
        if (newDetails.deltaUpdateFailed) {
          return;
        }
        const mainDetails = this.mainDetails;
        if (!mainDetails) {
          this.startFragRequested = false;
          return;
        }
        const mainSlidingStartFragment = mainDetails.fragments[0];
        if (!track.details) {
          if (newDetails.hasProgramDateTime && mainDetails.hasProgramDateTime) {
            alignMediaPlaylistByPDT(newDetails, mainDetails);
            sliding = newDetails.fragmentStart;
          } else if (mainSlidingStartFragment) {
            sliding = mainSlidingStartFragment.start;
            addSliding(newDetails, sliding);
          }
        } else {
          var _this$levelLastLoaded;
          sliding = this.alignPlaylists(newDetails, track.details, (_this$levelLastLoaded = this.levelLastLoaded) == null ? void 0 : _this$levelLastLoaded.details);
          if (sliding === 0 && mainSlidingStartFragment) {
            sliding = mainSlidingStartFragment.start;
            addSliding(newDetails, sliding);
          }
        }
        if (mainDetails && !this.startFragRequested) {
          this.setStartPosition(mainDetails, sliding);
        }
      }
      track.details = newDetails;
      this.levelLastLoaded = track;
      if (trackId !== currentTrackId) {
        return;
      }
      this.hls.trigger(Events.SUBTITLE_TRACK_UPDATED, {
        details: newDetails,
        id: trackId,
        groupId: data.groupId
      });
      this.tick();
      if (newDetails.live && !this.fragCurrent && this.media && this.state === State.IDLE) {
        const foundFrag = findFragmentByPTS(null, newDetails.fragments, this.media.currentTime, 0);
        if (!foundFrag) {
          this.warn("Subtitle playlist not aligned with playback");
          track.details = void 0;
        }
      }
    }
    _handleFragmentLoadComplete(fragLoadedData) {
      const {
        frag,
        payload
      } = fragLoadedData;
      const decryptData = frag.decryptdata;
      const hls = this.hls;
      if (this.fragContextChanged(frag)) {
        return;
      }
      if (payload && payload.byteLength > 0 && decryptData != null && decryptData.key && decryptData.iv && isFullSegmentEncryption(decryptData.method)) {
        const startTime = performance.now();
        this.decrypter.decrypt(new Uint8Array(payload), decryptData.key.buffer, decryptData.iv.buffer, getAesModeFromFullSegmentMethod(decryptData.method)).catch((err) => {
          hls.trigger(Events.ERROR, {
            type: ErrorTypes.MEDIA_ERROR,
            details: ErrorDetails.FRAG_DECRYPT_ERROR,
            fatal: false,
            error: err,
            reason: err.message,
            frag
          });
          throw err;
        }).then((decryptedData) => {
          const endTime = performance.now();
          hls.trigger(Events.FRAG_DECRYPTED, {
            frag,
            payload: decryptedData,
            stats: {
              tstart: startTime,
              tdecrypt: endTime
            }
          });
        }).catch((err) => {
          this.warn(`${err.name}: ${err.message}`);
          this.state = State.IDLE;
        });
      }
    }
    doTick() {
      if (!this.media) {
        this.state = State.IDLE;
        return;
      }
      if (this.state === State.IDLE) {
        const {
          currentTrackId,
          levels
        } = this;
        const track = levels == null ? void 0 : levels[currentTrackId];
        if (!track || !levels.length || !track.details) {
          return;
        }
        if (this.waitForLive(track)) {
          return;
        }
        const {
          config: config3
        } = this;
        const currentTime = this.getLoadPosition();
        const bufferedInfo = BufferHelper.bufferedInfo(this.tracksBuffered[this.currentTrackId] || [], currentTime, config3.maxBufferHole);
        const {
          end: targetBufferTime,
          len: bufferLen
        } = bufferedInfo;
        const trackDetails = track.details;
        const maxBufLen = this.hls.maxBufferLength + trackDetails.levelTargetDuration;
        if (bufferLen > maxBufLen) {
          return;
        }
        const fragments = trackDetails.fragments;
        const fragLen = fragments.length;
        const end = trackDetails.edge;
        let foundFrag = null;
        const fragPrevious = this.fragPrevious;
        if (targetBufferTime < end) {
          const tolerance = config3.maxFragLookUpTolerance;
          const lookupTolerance = targetBufferTime > end - tolerance ? 0 : tolerance;
          foundFrag = findFragmentByPTS(fragPrevious, fragments, Math.max(fragments[0].start, targetBufferTime), lookupTolerance);
          if (!foundFrag && fragPrevious && fragPrevious.start < fragments[0].start) {
            foundFrag = fragments[0];
          }
        } else {
          foundFrag = fragments[fragLen - 1];
        }
        foundFrag = this.filterReplacedPrimary(foundFrag, track.details);
        if (!foundFrag) {
          return;
        }
        const curSNIdx = foundFrag.sn - trackDetails.startSN;
        const prevFrag = fragments[curSNIdx - 1];
        if (prevFrag && prevFrag.cc === foundFrag.cc && this.fragmentTracker.getState(prevFrag) === FragmentState.NOT_LOADED) {
          foundFrag = prevFrag;
        }
        if (this.fragmentTracker.getState(foundFrag) === FragmentState.NOT_LOADED) {
          const fragToLoad = this.mapToInitFragWhenRequired(foundFrag);
          if (fragToLoad) {
            this.loadFragment(fragToLoad, track, targetBufferTime);
          }
        }
      }
    }
    loadFragment(frag, level, targetBufferTime) {
      if (!isMediaFragment(frag)) {
        this._loadInitSegment(frag, level);
      } else {
        super.loadFragment(frag, level, targetBufferTime);
      }
    }
    get mediaBufferTimeRanges() {
      return new BufferableInstance(this.tracksBuffered[this.currentTrackId] || []);
    }
  };
  var BufferableInstance = class {
    constructor(timeranges) {
      this.buffered = void 0;
      const getRange = (name, index, length) => {
        index = index >>> 0;
        if (index > length - 1) {
          throw new DOMException(`Failed to execute '${name}' on 'TimeRanges': The index provided (${index}) is greater than the maximum bound (${length})`);
        }
        return timeranges[index][name];
      };
      this.buffered = {
        get length() {
          return timeranges.length;
        },
        end(index) {
          return getRange("end", index, timeranges.length);
        },
        start(index) {
          return getRange("start", index, timeranges.length);
        }
      };
    }
  };
  var specialCea608CharsCodes = {
    42: 225,
    // lowercase a, acute accent
    92: 233,
    // lowercase e, acute accent
    94: 237,
    // lowercase i, acute accent
    95: 243,
    // lowercase o, acute accent
    96: 250,
    // lowercase u, acute accent
    123: 231,
    // lowercase c with cedilla
    124: 247,
    // division symbol
    125: 209,
    // uppercase N tilde
    126: 241,
    // lowercase n tilde
    127: 9608,
    // Full block
    // THIS BLOCK INCLUDES THE 16 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
    // THAT COME FROM HI BYTE=0x11 AND LOW BETWEEN 0x30 AND 0x3F
    // THIS MEANS THAT \x50 MUST BE ADDED TO THE VALUES
    128: 174,
    // Registered symbol (R)
    129: 176,
    // degree sign
    130: 189,
    // 1/2 symbol
    131: 191,
    // Inverted (open) question mark
    132: 8482,
    // Trademark symbol (TM)
    133: 162,
    // Cents symbol
    134: 163,
    // Pounds sterling
    135: 9834,
    // Music 8'th note
    136: 224,
    // lowercase a, grave accent
    137: 32,
    // transparent space (regular)
    138: 232,
    // lowercase e, grave accent
    139: 226,
    // lowercase a, circumflex accent
    140: 234,
    // lowercase e, circumflex accent
    141: 238,
    // lowercase i, circumflex accent
    142: 244,
    // lowercase o, circumflex accent
    143: 251,
    // lowercase u, circumflex accent
    // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
    // THAT COME FROM HI BYTE=0x12 AND LOW BETWEEN 0x20 AND 0x3F
    144: 193,
    // capital letter A with acute
    145: 201,
    // capital letter E with acute
    146: 211,
    // capital letter O with acute
    147: 218,
    // capital letter U with acute
    148: 220,
    // capital letter U with diaresis
    149: 252,
    // lowercase letter U with diaeresis
    150: 8216,
    // opening single quote
    151: 161,
    // inverted exclamation mark
    152: 42,
    // asterisk
    153: 8217,
    // closing single quote
    154: 9473,
    // box drawings heavy horizontal
    155: 169,
    // copyright sign
    156: 8480,
    // Service mark
    157: 8226,
    // (round) bullet
    158: 8220,
    // Left double quotation mark
    159: 8221,
    // Right double quotation mark
    160: 192,
    // uppercase A, grave accent
    161: 194,
    // uppercase A, circumflex
    162: 199,
    // uppercase C with cedilla
    163: 200,
    // uppercase E, grave accent
    164: 202,
    // uppercase E, circumflex
    165: 203,
    // capital letter E with diaresis
    166: 235,
    // lowercase letter e with diaresis
    167: 206,
    // uppercase I, circumflex
    168: 207,
    // uppercase I, with diaresis
    169: 239,
    // lowercase i, with diaresis
    170: 212,
    // uppercase O, circumflex
    171: 217,
    // uppercase U, grave accent
    172: 249,
    // lowercase u, grave accent
    173: 219,
    // uppercase U, circumflex
    174: 171,
    // left-pointing double angle quotation mark
    175: 187,
    // right-pointing double angle quotation mark
    // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
    // THAT COME FROM HI BYTE=0x13 AND LOW BETWEEN 0x20 AND 0x3F
    176: 195,
    // Uppercase A, tilde
    177: 227,
    // Lowercase a, tilde
    178: 205,
    // Uppercase I, acute accent
    179: 204,
    // Uppercase I, grave accent
    180: 236,
    // Lowercase i, grave accent
    181: 210,
    // Uppercase O, grave accent
    182: 242,
    // Lowercase o, grave accent
    183: 213,
    // Uppercase O, tilde
    184: 245,
    // Lowercase o, tilde
    185: 123,
    // Open curly brace
    186: 125,
    // Closing curly brace
    187: 92,
    // Backslash
    188: 94,
    // Caret
    189: 95,
    // Underscore
    190: 124,
    // Pipe (vertical line)
    191: 8764,
    // Tilde operator
    192: 196,
    // Uppercase A, umlaut
    193: 228,
    // Lowercase A, umlaut
    194: 214,
    // Uppercase O, umlaut
    195: 246,
    // Lowercase o, umlaut
    196: 223,
    // Esszett (sharp S)
    197: 165,
    // Yen symbol
    198: 164,
    // Generic currency sign
    199: 9475,
    // Box drawings heavy vertical
    200: 197,
    // Uppercase A, ring
    201: 229,
    // Lowercase A, ring
    202: 216,
    // Uppercase O, stroke
    203: 248,
    // Lowercase o, strok
    204: 9487,
    // Box drawings heavy down and right
    205: 9491,
    // Box drawings heavy down and left
    206: 9495,
    // Box drawings heavy up and right
    207: 9499
    // Box drawings heavy up and left
  };
  var getCharForByte = (byte) => String.fromCharCode(specialCea608CharsCodes[byte] || byte);
  var NR_ROWS = 15;
  var NR_COLS = 100;
  var rowsLowCh1 = {
    17: 1,
    18: 3,
    21: 5,
    22: 7,
    23: 9,
    16: 11,
    19: 12,
    20: 14
  };
  var rowsHighCh1 = {
    17: 2,
    18: 4,
    21: 6,
    22: 8,
    23: 10,
    19: 13,
    20: 15
  };
  var rowsLowCh2 = {
    25: 1,
    26: 3,
    29: 5,
    30: 7,
    31: 9,
    24: 11,
    27: 12,
    28: 14
  };
  var rowsHighCh2 = {
    25: 2,
    26: 4,
    29: 6,
    30: 8,
    31: 10,
    27: 13,
    28: 15
  };
  var backgroundColors = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "black", "transparent"];
  var CaptionsLogger = class {
    constructor() {
      this.time = null;
      this.verboseLevel = 0;
    }
    log(severity, msg) {
      if (this.verboseLevel >= severity) {
        const m = typeof msg === "function" ? msg() : msg;
        logger.log(`${this.time} [${severity}] ${m}`);
      }
    }
  };
  var numArrayToHexArray = function numArrayToHexArray2(numArray) {
    const hexArray = [];
    for (let j = 0; j < numArray.length; j++) {
      hexArray.push(numArray[j].toString(16));
    }
    return hexArray;
  };
  var PenState = class {
    constructor() {
      this.foreground = "white";
      this.underline = false;
      this.italics = false;
      this.background = "black";
      this.flash = false;
    }
    reset() {
      this.foreground = "white";
      this.underline = false;
      this.italics = false;
      this.background = "black";
      this.flash = false;
    }
    setStyles(styles) {
      const attribs = ["foreground", "underline", "italics", "background", "flash"];
      for (let i = 0; i < attribs.length; i++) {
        const style = attribs[i];
        if (styles.hasOwnProperty(style)) {
          this[style] = styles[style];
        }
      }
    }
    isDefault() {
      return this.foreground === "white" && !this.underline && !this.italics && this.background === "black" && !this.flash;
    }
    equals(other) {
      return this.foreground === other.foreground && this.underline === other.underline && this.italics === other.italics && this.background === other.background && this.flash === other.flash;
    }
    copy(newPenState) {
      this.foreground = newPenState.foreground;
      this.underline = newPenState.underline;
      this.italics = newPenState.italics;
      this.background = newPenState.background;
      this.flash = newPenState.flash;
    }
    toString() {
      return "color=" + this.foreground + ", underline=" + this.underline + ", italics=" + this.italics + ", background=" + this.background + ", flash=" + this.flash;
    }
  };
  var StyledUnicodeChar = class {
    constructor() {
      this.uchar = " ";
      this.penState = new PenState();
    }
    reset() {
      this.uchar = " ";
      this.penState.reset();
    }
    setChar(uchar, newPenState) {
      this.uchar = uchar;
      this.penState.copy(newPenState);
    }
    setPenState(newPenState) {
      this.penState.copy(newPenState);
    }
    equals(other) {
      return this.uchar === other.uchar && this.penState.equals(other.penState);
    }
    copy(newChar) {
      this.uchar = newChar.uchar;
      this.penState.copy(newChar.penState);
    }
    isEmpty() {
      return this.uchar === " " && this.penState.isDefault();
    }
  };
  var Row = class {
    constructor(logger2) {
      this.chars = [];
      this.pos = 0;
      this.currPenState = new PenState();
      this.cueStartTime = null;
      this.logger = void 0;
      for (let i = 0; i < NR_COLS; i++) {
        this.chars.push(new StyledUnicodeChar());
      }
      this.logger = logger2;
    }
    equals(other) {
      for (let i = 0; i < NR_COLS; i++) {
        if (!this.chars[i].equals(other.chars[i])) {
          return false;
        }
      }
      return true;
    }
    copy(other) {
      for (let i = 0; i < NR_COLS; i++) {
        this.chars[i].copy(other.chars[i]);
      }
    }
    isEmpty() {
      let empty = true;
      for (let i = 0; i < NR_COLS; i++) {
        if (!this.chars[i].isEmpty()) {
          empty = false;
          break;
        }
      }
      return empty;
    }
    /**
     *  Set the cursor to a valid column.
     */
    setCursor(absPos) {
      if (this.pos !== absPos) {
        this.pos = absPos;
      }
      if (this.pos < 0) {
        this.logger.log(3, "Negative cursor position " + this.pos);
        this.pos = 0;
      } else if (this.pos > NR_COLS) {
        this.logger.log(3, "Too large cursor position " + this.pos);
        this.pos = NR_COLS;
      }
    }
    /**
     * Move the cursor relative to current position.
     */
    moveCursor(relPos) {
      const newPos = this.pos + relPos;
      if (relPos > 1) {
        for (let i = this.pos + 1; i < newPos + 1; i++) {
          this.chars[i].setPenState(this.currPenState);
        }
      }
      this.setCursor(newPos);
    }
    /**
     * Backspace, move one step back and clear character.
     */
    backSpace() {
      this.moveCursor(-1);
      this.chars[this.pos].setChar(" ", this.currPenState);
    }
    insertChar(byte) {
      if (byte >= 144) {
        this.backSpace();
      }
      const char = getCharForByte(byte);
      if (this.pos >= NR_COLS) {
        this.logger.log(0, () => "Cannot insert " + byte.toString(16) + " (" + char + ") at position " + this.pos + ". Skipping it!");
        return;
      }
      this.chars[this.pos].setChar(char, this.currPenState);
      this.moveCursor(1);
    }
    clearFromPos(startPos) {
      let i;
      for (i = startPos; i < NR_COLS; i++) {
        this.chars[i].reset();
      }
    }
    clear() {
      this.clearFromPos(0);
      this.pos = 0;
      this.currPenState.reset();
    }
    clearToEndOfRow() {
      this.clearFromPos(this.pos);
    }
    getTextString() {
      const chars = [];
      let empty = true;
      for (let i = 0; i < NR_COLS; i++) {
        const char = this.chars[i].uchar;
        if (char !== " ") {
          empty = false;
        }
        chars.push(char);
      }
      if (empty) {
        return "";
      } else {
        return chars.join("");
      }
    }
    setPenStyles(styles) {
      this.currPenState.setStyles(styles);
      const currChar = this.chars[this.pos];
      currChar.setPenState(this.currPenState);
    }
  };
  var CaptionScreen = class {
    constructor(logger2) {
      this.rows = [];
      this.currRow = NR_ROWS - 1;
      this.nrRollUpRows = null;
      this.lastOutputScreen = null;
      this.logger = void 0;
      for (let i = 0; i < NR_ROWS; i++) {
        this.rows.push(new Row(logger2));
      }
      this.logger = logger2;
    }
    reset() {
      for (let i = 0; i < NR_ROWS; i++) {
        this.rows[i].clear();
      }
      this.currRow = NR_ROWS - 1;
    }
    equals(other) {
      let equal = true;
      for (let i = 0; i < NR_ROWS; i++) {
        if (!this.rows[i].equals(other.rows[i])) {
          equal = false;
          break;
        }
      }
      return equal;
    }
    copy(other) {
      for (let i = 0; i < NR_ROWS; i++) {
        this.rows[i].copy(other.rows[i]);
      }
    }
    isEmpty() {
      let empty = true;
      for (let i = 0; i < NR_ROWS; i++) {
        if (!this.rows[i].isEmpty()) {
          empty = false;
          break;
        }
      }
      return empty;
    }
    backSpace() {
      const row = this.rows[this.currRow];
      row.backSpace();
    }
    clearToEndOfRow() {
      const row = this.rows[this.currRow];
      row.clearToEndOfRow();
    }
    /**
     * Insert a character (without styling) in the current row.
     */
    insertChar(char) {
      const row = this.rows[this.currRow];
      row.insertChar(char);
    }
    setPen(styles) {
      const row = this.rows[this.currRow];
      row.setPenStyles(styles);
    }
    moveCursor(relPos) {
      const row = this.rows[this.currRow];
      row.moveCursor(relPos);
    }
    setCursor(absPos) {
      this.logger.log(2, "setCursor: " + absPos);
      const row = this.rows[this.currRow];
      row.setCursor(absPos);
    }
    setPAC(pacData) {
      this.logger.log(2, () => "pacData = " + stringify(pacData));
      let newRow = pacData.row - 1;
      if (this.nrRollUpRows && newRow < this.nrRollUpRows - 1) {
        newRow = this.nrRollUpRows - 1;
      }
      if (this.nrRollUpRows && this.currRow !== newRow) {
        for (let i = 0; i < NR_ROWS; i++) {
          this.rows[i].clear();
        }
        const topRowIndex = this.currRow + 1 - this.nrRollUpRows;
        const lastOutputScreen = this.lastOutputScreen;
        if (lastOutputScreen) {
          const prevLineTime = lastOutputScreen.rows[topRowIndex].cueStartTime;
          const time2 = this.logger.time;
          if (prevLineTime !== null && time2 !== null && prevLineTime < time2) {
            for (let i = 0; i < this.nrRollUpRows; i++) {
              this.rows[newRow - this.nrRollUpRows + i + 1].copy(lastOutputScreen.rows[topRowIndex + i]);
            }
          }
        }
      }
      this.currRow = newRow;
      const row = this.rows[this.currRow];
      if (pacData.indent !== null) {
        const indent = pacData.indent;
        const prevPos = Math.max(indent - 1, 0);
        row.setCursor(pacData.indent);
        pacData.color = row.chars[prevPos].penState.foreground;
      }
      const styles = {
        foreground: pacData.color,
        underline: pacData.underline,
        italics: pacData.italics,
        background: "black",
        flash: false
      };
      this.setPen(styles);
    }
    /**
     * Set background/extra foreground, but first do back_space, and then insert space (backwards compatibility).
     */
    setBkgData(bkgData) {
      this.logger.log(2, () => "bkgData = " + stringify(bkgData));
      this.backSpace();
      this.setPen(bkgData);
      this.insertChar(32);
    }
    setRollUpRows(nrRows) {
      this.nrRollUpRows = nrRows;
    }
    rollUp() {
      if (this.nrRollUpRows === null) {
        this.logger.log(3, "roll_up but nrRollUpRows not set yet");
        return;
      }
      this.logger.log(1, () => this.getDisplayText());
      const topRowIndex = this.currRow + 1 - this.nrRollUpRows;
      const topRow = this.rows.splice(topRowIndex, 1)[0];
      topRow.clear();
      this.rows.splice(this.currRow, 0, topRow);
      this.logger.log(2, "Rolling up");
    }
    /**
     * Get all non-empty rows with as unicode text.
     */
    getDisplayText(asOneRow) {
      asOneRow = asOneRow || false;
      const displayText = [];
      let text = "";
      let rowNr = -1;
      for (let i = 0; i < NR_ROWS; i++) {
        const rowText = this.rows[i].getTextString();
        if (rowText) {
          rowNr = i + 1;
          if (asOneRow) {
            displayText.push("Row " + rowNr + ": '" + rowText + "'");
          } else {
            displayText.push(rowText.trim());
          }
        }
      }
      if (displayText.length > 0) {
        if (asOneRow) {
          text = "[" + displayText.join(" | ") + "]";
        } else {
          text = displayText.join("\n");
        }
      }
      return text;
    }
    getTextAndFormat() {
      return this.rows;
    }
  };
  var Cea608Channel = class {
    constructor(channelNumber, outputFilter, logger2) {
      this.chNr = void 0;
      this.outputFilter = void 0;
      this.mode = void 0;
      this.verbose = void 0;
      this.displayedMemory = void 0;
      this.nonDisplayedMemory = void 0;
      this.lastOutputScreen = void 0;
      this.currRollUpRow = void 0;
      this.writeScreen = void 0;
      this.cueStartTime = void 0;
      this.logger = void 0;
      this.chNr = channelNumber;
      this.outputFilter = outputFilter;
      this.mode = null;
      this.verbose = 0;
      this.displayedMemory = new CaptionScreen(logger2);
      this.nonDisplayedMemory = new CaptionScreen(logger2);
      this.lastOutputScreen = new CaptionScreen(logger2);
      this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];
      this.writeScreen = this.displayedMemory;
      this.mode = null;
      this.cueStartTime = null;
      this.logger = logger2;
    }
    reset() {
      this.mode = null;
      this.displayedMemory.reset();
      this.nonDisplayedMemory.reset();
      this.lastOutputScreen.reset();
      this.outputFilter.reset();
      this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];
      this.writeScreen = this.displayedMemory;
      this.mode = null;
      this.cueStartTime = null;
    }
    getHandler() {
      return this.outputFilter;
    }
    setHandler(newHandler) {
      this.outputFilter = newHandler;
    }
    setPAC(pacData) {
      this.writeScreen.setPAC(pacData);
    }
    setBkgData(bkgData) {
      this.writeScreen.setBkgData(bkgData);
    }
    setMode(newMode) {
      if (newMode === this.mode) {
        return;
      }
      this.mode = newMode;
      this.logger.log(2, () => "MODE=" + newMode);
      if (this.mode === "MODE_POP-ON") {
        this.writeScreen = this.nonDisplayedMemory;
      } else {
        this.writeScreen = this.displayedMemory;
        this.writeScreen.reset();
      }
      if (this.mode !== "MODE_ROLL-UP") {
        this.displayedMemory.nrRollUpRows = null;
        this.nonDisplayedMemory.nrRollUpRows = null;
      }
      this.mode = newMode;
    }
    insertChars(chars) {
      for (let i = 0; i < chars.length; i++) {
        this.writeScreen.insertChar(chars[i]);
      }
      const screen = this.writeScreen === this.displayedMemory ? "DISP" : "NON_DISP";
      this.logger.log(2, () => screen + ": " + this.writeScreen.getDisplayText(true));
      if (this.mode === "MODE_PAINT-ON" || this.mode === "MODE_ROLL-UP") {
        this.logger.log(1, () => "DISPLAYED: " + this.displayedMemory.getDisplayText(true));
        this.outputDataUpdate();
      }
    }
    ccRCL() {
      this.logger.log(2, "RCL - Resume Caption Loading");
      this.setMode("MODE_POP-ON");
    }
    ccBS() {
      this.logger.log(2, "BS - BackSpace");
      if (this.mode === "MODE_TEXT") {
        return;
      }
      this.writeScreen.backSpace();
      if (this.writeScreen === this.displayedMemory) {
        this.outputDataUpdate();
      }
    }
    ccAOF() {
    }
    ccAON() {
    }
    ccDER() {
      this.logger.log(2, "DER- Delete to End of Row");
      this.writeScreen.clearToEndOfRow();
      this.outputDataUpdate();
    }
    ccRU(nrRows) {
      this.logger.log(2, "RU(" + nrRows + ") - Roll Up");
      this.writeScreen = this.displayedMemory;
      this.setMode("MODE_ROLL-UP");
      this.writeScreen.setRollUpRows(nrRows);
    }
    ccFON() {
      this.logger.log(2, "FON - Flash On");
      this.writeScreen.setPen({
        flash: true
      });
    }
    ccRDC() {
      this.logger.log(2, "RDC - Resume Direct Captioning");
      this.setMode("MODE_PAINT-ON");
    }
    ccTR() {
      this.logger.log(2, "TR");
      this.setMode("MODE_TEXT");
    }
    ccRTD() {
      this.logger.log(2, "RTD");
      this.setMode("MODE_TEXT");
    }
    ccEDM() {
      this.logger.log(2, "EDM - Erase Displayed Memory");
      this.displayedMemory.reset();
      this.outputDataUpdate(true);
    }
    ccCR() {
      this.logger.log(2, "CR - Carriage Return");
      this.writeScreen.rollUp();
      this.outputDataUpdate(true);
    }
    ccENM() {
      this.logger.log(2, "ENM - Erase Non-displayed Memory");
      this.nonDisplayedMemory.reset();
    }
    ccEOC() {
      this.logger.log(2, "EOC - End Of Caption");
      if (this.mode === "MODE_POP-ON") {
        const tmp = this.displayedMemory;
        this.displayedMemory = this.nonDisplayedMemory;
        this.nonDisplayedMemory = tmp;
        this.writeScreen = this.nonDisplayedMemory;
        this.logger.log(1, () => "DISP: " + this.displayedMemory.getDisplayText());
      }
      this.outputDataUpdate(true);
    }
    ccTO(nrCols) {
      this.logger.log(2, "TO(" + nrCols + ") - Tab Offset");
      this.writeScreen.moveCursor(nrCols);
    }
    ccMIDROW(secondByte) {
      const styles = {
        flash: false
      };
      styles.underline = secondByte % 2 === 1;
      styles.italics = secondByte >= 46;
      if (!styles.italics) {
        const colorIndex = Math.floor(secondByte / 2) - 16;
        const colors = ["white", "green", "blue", "cyan", "red", "yellow", "magenta"];
        styles.foreground = colors[colorIndex];
      } else {
        styles.foreground = "white";
      }
      this.logger.log(2, "MIDROW: " + stringify(styles));
      this.writeScreen.setPen(styles);
    }
    outputDataUpdate(dispatch = false) {
      const time2 = this.logger.time;
      if (time2 === null) {
        return;
      }
      if (this.outputFilter) {
        if (this.cueStartTime === null && !this.displayedMemory.isEmpty()) {
          this.cueStartTime = time2;
        } else {
          if (!this.displayedMemory.equals(this.lastOutputScreen)) {
            this.outputFilter.newCue(this.cueStartTime, time2, this.lastOutputScreen);
            if (dispatch && this.outputFilter.dispatchCue) {
              this.outputFilter.dispatchCue();
            }
            this.cueStartTime = this.displayedMemory.isEmpty() ? null : time2;
          }
        }
        this.lastOutputScreen.copy(this.displayedMemory);
      }
    }
    cueSplitAtTime(t) {
      if (this.outputFilter) {
        if (!this.displayedMemory.isEmpty()) {
          if (this.outputFilter.newCue) {
            this.outputFilter.newCue(this.cueStartTime, t, this.displayedMemory);
          }
          this.cueStartTime = t;
        }
      }
    }
  };
  var Cea608Parser = class {
    constructor(field, out1, out2) {
      this.channels = void 0;
      this.currentChannel = 0;
      this.cmdHistory = createCmdHistory();
      this.logger = void 0;
      const logger2 = this.logger = new CaptionsLogger();
      this.channels = [null, new Cea608Channel(field, out1, logger2), new Cea608Channel(field + 1, out2, logger2)];
    }
    getHandler(channel) {
      return this.channels[channel].getHandler();
    }
    setHandler(channel, newHandler) {
      this.channels[channel].setHandler(newHandler);
    }
    /**
     * Add data for time t in forms of list of bytes (unsigned ints). The bytes are treated as pairs.
     */
    addData(time2, byteList) {
      this.logger.time = time2;
      for (let i = 0; i < byteList.length; i += 2) {
        const a = byteList[i] & 127;
        const b = byteList[i + 1] & 127;
        let cmdFound = false;
        let charsFound = null;
        if (a === 0 && b === 0) {
          continue;
        } else {
          this.logger.log(3, () => "[" + numArrayToHexArray([byteList[i], byteList[i + 1]]) + "] -> (" + numArrayToHexArray([a, b]) + ")");
        }
        const cmdHistory = this.cmdHistory;
        const isControlCode = a >= 16 && a <= 31;
        if (isControlCode) {
          if (hasCmdRepeated(a, b, cmdHistory)) {
            setLastCmd(null, null, cmdHistory);
            this.logger.log(3, () => "Repeated command (" + numArrayToHexArray([a, b]) + ") is dropped");
            continue;
          }
          setLastCmd(a, b, this.cmdHistory);
          cmdFound = this.parseCmd(a, b);
          if (!cmdFound) {
            cmdFound = this.parseMidrow(a, b);
          }
          if (!cmdFound) {
            cmdFound = this.parsePAC(a, b);
          }
          if (!cmdFound) {
            cmdFound = this.parseBackgroundAttributes(a, b);
          }
        } else {
          setLastCmd(null, null, cmdHistory);
        }
        if (!cmdFound) {
          charsFound = this.parseChars(a, b);
          if (charsFound) {
            const currChNr = this.currentChannel;
            if (currChNr && currChNr > 0) {
              const channel = this.channels[currChNr];
              channel.insertChars(charsFound);
            } else {
              this.logger.log(2, "No channel found yet. TEXT-MODE?");
            }
          }
        }
        if (!cmdFound && !charsFound) {
          this.logger.log(2, () => "Couldn't parse cleaned data " + numArrayToHexArray([a, b]) + " orig: " + numArrayToHexArray([byteList[i], byteList[i + 1]]));
        }
      }
    }
    /**
     * Parse Command.
     * @returns True if a command was found
     */
    parseCmd(a, b) {
      const cond1 = (a === 20 || a === 28 || a === 21 || a === 29) && b >= 32 && b <= 47;
      const cond2 = (a === 23 || a === 31) && b >= 33 && b <= 35;
      if (!(cond1 || cond2)) {
        return false;
      }
      const chNr = a === 20 || a === 21 || a === 23 ? 1 : 2;
      const channel = this.channels[chNr];
      if (a === 20 || a === 21 || a === 28 || a === 29) {
        if (b === 32) {
          channel.ccRCL();
        } else if (b === 33) {
          channel.ccBS();
        } else if (b === 34) {
          channel.ccAOF();
        } else if (b === 35) {
          channel.ccAON();
        } else if (b === 36) {
          channel.ccDER();
        } else if (b === 37) {
          channel.ccRU(2);
        } else if (b === 38) {
          channel.ccRU(3);
        } else if (b === 39) {
          channel.ccRU(4);
        } else if (b === 40) {
          channel.ccFON();
        } else if (b === 41) {
          channel.ccRDC();
        } else if (b === 42) {
          channel.ccTR();
        } else if (b === 43) {
          channel.ccRTD();
        } else if (b === 44) {
          channel.ccEDM();
        } else if (b === 45) {
          channel.ccCR();
        } else if (b === 46) {
          channel.ccENM();
        } else if (b === 47) {
          channel.ccEOC();
        }
      } else {
        channel.ccTO(b - 32);
      }
      this.currentChannel = chNr;
      return true;
    }
    /**
     * Parse midrow styling command
     */
    parseMidrow(a, b) {
      let chNr = 0;
      if ((a === 17 || a === 25) && b >= 32 && b <= 47) {
        if (a === 17) {
          chNr = 1;
        } else {
          chNr = 2;
        }
        if (chNr !== this.currentChannel) {
          this.logger.log(0, "Mismatch channel in midrow parsing");
          return false;
        }
        const channel = this.channels[chNr];
        if (!channel) {
          return false;
        }
        channel.ccMIDROW(b);
        this.logger.log(3, () => "MIDROW (" + numArrayToHexArray([a, b]) + ")");
        return true;
      }
      return false;
    }
    /**
     * Parse Preable Access Codes (Table 53).
     * @returns {Boolean} Tells if PAC found
     */
    parsePAC(a, b) {
      let row;
      const case1 = (a >= 17 && a <= 23 || a >= 25 && a <= 31) && b >= 64 && b <= 127;
      const case2 = (a === 16 || a === 24) && b >= 64 && b <= 95;
      if (!(case1 || case2)) {
        return false;
      }
      const chNr = a <= 23 ? 1 : 2;
      if (b >= 64 && b <= 95) {
        row = chNr === 1 ? rowsLowCh1[a] : rowsLowCh2[a];
      } else {
        row = chNr === 1 ? rowsHighCh1[a] : rowsHighCh2[a];
      }
      const channel = this.channels[chNr];
      if (!channel) {
        return false;
      }
      channel.setPAC(this.interpretPAC(row, b));
      this.currentChannel = chNr;
      return true;
    }
    /**
     * Interpret the second byte of the pac, and return the information.
     * @returns pacData with style parameters
     */
    interpretPAC(row, byte) {
      let pacIndex;
      const pacData = {
        color: null,
        italics: false,
        indent: null,
        underline: false,
        row
      };
      if (byte > 95) {
        pacIndex = byte - 96;
      } else {
        pacIndex = byte - 64;
      }
      pacData.underline = (pacIndex & 1) === 1;
      if (pacIndex <= 13) {
        pacData.color = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "white"][Math.floor(pacIndex / 2)];
      } else if (pacIndex <= 15) {
        pacData.italics = true;
        pacData.color = "white";
      } else {
        pacData.indent = Math.floor((pacIndex - 16) / 2) * 4;
      }
      return pacData;
    }
    /**
     * Parse characters.
     * @returns An array with 1 to 2 codes corresponding to chars, if found. null otherwise.
     */
    parseChars(a, b) {
      let channelNr;
      let charCodes = null;
      let charCode1 = null;
      if (a >= 25) {
        channelNr = 2;
        charCode1 = a - 8;
      } else {
        channelNr = 1;
        charCode1 = a;
      }
      if (charCode1 >= 17 && charCode1 <= 19) {
        let oneCode;
        if (charCode1 === 17) {
          oneCode = b + 80;
        } else if (charCode1 === 18) {
          oneCode = b + 112;
        } else {
          oneCode = b + 144;
        }
        this.logger.log(2, () => "Special char '" + getCharForByte(oneCode) + "' in channel " + channelNr);
        charCodes = [oneCode];
      } else if (a >= 32 && a <= 127) {
        charCodes = b === 0 ? [a] : [a, b];
      }
      if (charCodes) {
        this.logger.log(3, () => "Char codes =  " + numArrayToHexArray(charCodes).join(","));
      }
      return charCodes;
    }
    /**
     * Parse extended background attributes as well as new foreground color black.
     * @returns True if background attributes are found
     */
    parseBackgroundAttributes(a, b) {
      const case1 = (a === 16 || a === 24) && b >= 32 && b <= 47;
      const case2 = (a === 23 || a === 31) && b >= 45 && b <= 47;
      if (!(case1 || case2)) {
        return false;
      }
      let index;
      const bkgData = {};
      if (a === 16 || a === 24) {
        index = Math.floor((b - 32) / 2);
        bkgData.background = backgroundColors[index];
        if (b % 2 === 1) {
          bkgData.background = bkgData.background + "_semi";
        }
      } else if (b === 45) {
        bkgData.background = "transparent";
      } else {
        bkgData.foreground = "black";
        if (b === 47) {
          bkgData.underline = true;
        }
      }
      const chNr = a <= 23 ? 1 : 2;
      const channel = this.channels[chNr];
      channel.setBkgData(bkgData);
      return true;
    }
    /**
     * Reset state of parser and its channels.
     */
    reset() {
      for (let i = 0; i < Object.keys(this.channels).length; i++) {
        const channel = this.channels[i];
        if (channel) {
          channel.reset();
        }
      }
      setLastCmd(null, null, this.cmdHistory);
    }
    /**
     * Trigger the generation of a cue, and the start of a new one if displayScreens are not empty.
     */
    cueSplitAtTime(t) {
      for (let i = 0; i < this.channels.length; i++) {
        const channel = this.channels[i];
        if (channel) {
          channel.cueSplitAtTime(t);
        }
      }
    }
  };
  function setLastCmd(a, b, cmdHistory) {
    cmdHistory.a = a;
    cmdHistory.b = b;
  }
  function hasCmdRepeated(a, b, cmdHistory) {
    return cmdHistory.a === a && cmdHistory.b === b;
  }
  function createCmdHistory() {
    return {
      a: null,
      b: null
    };
  }
  var VTTCue = (function() {
    if (optionalSelf != null && optionalSelf.VTTCue) {
      return self.VTTCue;
    }
    const AllowedDirections = ["", "lr", "rl"];
    const AllowedAlignments = ["start", "middle", "end", "left", "right"];
    function isAllowedValue(allowed, value) {
      if (typeof value !== "string") {
        return false;
      }
      if (!Array.isArray(allowed)) {
        return false;
      }
      const lcValue = value.toLowerCase();
      if (~allowed.indexOf(lcValue)) {
        return lcValue;
      }
      return false;
    }
    function findDirectionSetting(value) {
      return isAllowedValue(AllowedDirections, value);
    }
    function findAlignSetting(value) {
      return isAllowedValue(AllowedAlignments, value);
    }
    function extend(obj, ...rest) {
      let i = 1;
      for (; i < arguments.length; i++) {
        const cobj = arguments[i];
        for (const p in cobj) {
          obj[p] = cobj[p];
        }
      }
      return obj;
    }
    function VTTCue2(startTime, endTime, text) {
      const cue = this;
      const baseObj = {
        enumerable: true
      };
      cue.hasBeenReset = false;
      let _id = "";
      let _pauseOnExit = false;
      let _startTime = startTime;
      let _endTime = endTime;
      let _text = text;
      let _region = null;
      let _vertical2 = "";
      let _snapToLines = true;
      let _line = "auto";
      let _lineAlign = "start";
      let _position = 50;
      let _positionAlign = "middle";
      let _size = 50;
      let _align = "middle";
      Object.defineProperty(cue, "id", extend({}, baseObj, {
        get: function() {
          return _id;
        },
        set: function(value) {
          _id = "" + value;
        }
      }));
      Object.defineProperty(cue, "pauseOnExit", extend({}, baseObj, {
        get: function() {
          return _pauseOnExit;
        },
        set: function(value) {
          _pauseOnExit = !!value;
        }
      }));
      Object.defineProperty(cue, "startTime", extend({}, baseObj, {
        get: function() {
          return _startTime;
        },
        set: function(value) {
          if (typeof value !== "number") {
            throw new TypeError("Start time must be set to a number.");
          }
          _startTime = value;
          this.hasBeenReset = true;
        }
      }));
      Object.defineProperty(cue, "endTime", extend({}, baseObj, {
        get: function() {
          return _endTime;
        },
        set: function(value) {
          if (typeof value !== "number") {
            throw new TypeError("End time must be set to a number.");
          }
          _endTime = value;
          this.hasBeenReset = true;
        }
      }));
      Object.defineProperty(cue, "text", extend({}, baseObj, {
        get: function() {
          return _text;
        },
        set: function(value) {
          _text = "" + value;
          this.hasBeenReset = true;
        }
      }));
      Object.defineProperty(cue, "region", extend({}, baseObj, {
        get: function() {
          return _region;
        },
        set: function(value) {
          _region = value;
          this.hasBeenReset = true;
        }
      }));
      Object.defineProperty(cue, "vertical", extend({}, baseObj, {
        get: function() {
          return _vertical2;
        },
        set: function(value) {
          const setting = findDirectionSetting(value);
          if (setting === false) {
            throw new SyntaxError("An invalid or illegal string was specified.");
          }
          _vertical2 = setting;
          this.hasBeenReset = true;
        }
      }));
      Object.defineProperty(cue, "snapToLines", extend({}, baseObj, {
        get: function() {
          return _snapToLines;
        },
        set: function(value) {
          _snapToLines = !!value;
          this.hasBeenReset = true;
        }
      }));
      Object.defineProperty(cue, "line", extend({}, baseObj, {
        get: function() {
          return _line;
        },
        set: function(value) {
          if (typeof value !== "number" && value !== "auto") {
            throw new SyntaxError("An invalid number or illegal string was specified.");
          }
          _line = value;
          this.hasBeenReset = true;
        }
      }));
      Object.defineProperty(cue, "lineAlign", extend({}, baseObj, {
        get: function() {
          return _lineAlign;
        },
        set: function(value) {
          const setting = findAlignSetting(value);
          if (!setting) {
            throw new SyntaxError("An invalid or illegal string was specified.");
          }
          _lineAlign = setting;
          this.hasBeenReset = true;
        }
      }));
      Object.defineProperty(cue, "position", extend({}, baseObj, {
        get: function() {
          return _position;
        },
        set: function(value) {
          if (value < 0 || value > 100) {
            throw new Error("Position must be between 0 and 100.");
          }
          _position = value;
          this.hasBeenReset = true;
        }
      }));
      Object.defineProperty(cue, "positionAlign", extend({}, baseObj, {
        get: function() {
          return _positionAlign;
        },
        set: function(value) {
          const setting = findAlignSetting(value);
          if (!setting) {
            throw new SyntaxError("An invalid or illegal string was specified.");
          }
          _positionAlign = setting;
          this.hasBeenReset = true;
        }
      }));
      Object.defineProperty(cue, "size", extend({}, baseObj, {
        get: function() {
          return _size;
        },
        set: function(value) {
          if (value < 0 || value > 100) {
            throw new Error("Size must be between 0 and 100.");
          }
          _size = value;
          this.hasBeenReset = true;
        }
      }));
      Object.defineProperty(cue, "align", extend({}, baseObj, {
        get: function() {
          return _align;
        },
        set: function(value) {
          const setting = findAlignSetting(value);
          if (!setting) {
            throw new SyntaxError("An invalid or illegal string was specified.");
          }
          _align = setting;
          this.hasBeenReset = true;
        }
      }));
      cue.displayState = void 0;
    }
    VTTCue2.prototype.getCueAsHTML = function() {
      const WebVTT = self.WebVTT;
      return WebVTT.convertCueToDOMTree(self, this.text);
    };
    return VTTCue2;
  })();
  var StringDecoder = class {
    decode(data, options) {
      if (!data) {
        return "";
      }
      if (typeof data !== "string") {
        throw new Error("Error - expected string data.");
      }
      return decodeURIComponent(encodeURIComponent(data));
    }
  };
  function parseTimeStamp(input) {
    function computeSeconds(h, m2, s, f) {
      return (h | 0) * 3600 + (m2 | 0) * 60 + (s | 0) + parseFloat(f || 0);
    }
    const m = input.match(/^(?:(\d+):)?(\d{2}):(\d{2})(\.\d+)?/);
    if (!m) {
      return null;
    }
    if (parseFloat(m[2]) > 59) {
      return computeSeconds(m[2], m[3], 0, m[4]);
    }
    return computeSeconds(m[1], m[2], m[3], m[4]);
  }
  var Settings = class {
    constructor() {
      this.values = /* @__PURE__ */ Object.create(null);
    }
    // Only accept the first assignment to any key.
    set(k, v) {
      if (!this.get(k) && v !== "") {
        this.values[k] = v;
      }
    }
    // Return the value for a key, or a default value.
    // If 'defaultKey' is passed then 'dflt' is assumed to be an object with
    // a number of possible default values as properties where 'defaultKey' is
    // the key of the property that will be chosen; otherwise it's assumed to be
    // a single value.
    get(k, dflt, defaultKey) {
      if (defaultKey) {
        return this.has(k) ? this.values[k] : dflt[defaultKey];
      }
      return this.has(k) ? this.values[k] : dflt;
    }
    // Check whether we have a value for a key.
    has(k) {
      return k in this.values;
    }
    // Accept a setting if its one of the given alternatives.
    alt(k, v, a) {
      for (let n = 0; n < a.length; ++n) {
        if (v === a[n]) {
          this.set(k, v);
          break;
        }
      }
    }
    // Accept a setting if its a valid (signed) integer.
    integer(k, v) {
      if (/^-?\d+$/.test(v)) {
        this.set(k, parseInt(v, 10));
      }
    }
    // Accept a setting if its a valid percentage.
    percent(k, v) {
      if (/^([\d]{1,3})(\.[\d]*)?%$/.test(v)) {
        const percent2 = parseFloat(v);
        if (percent2 >= 0 && percent2 <= 100) {
          this.set(k, percent2);
          return true;
        }
      }
      return false;
    }
  };
  function parseOptions(input, callback, keyValueDelim, groupDelim) {
    const groups = groupDelim ? input.split(groupDelim) : [input];
    for (const i in groups) {
      if (typeof groups[i] !== "string") {
        continue;
      }
      const kv = groups[i].split(keyValueDelim);
      if (kv.length !== 2) {
        continue;
      }
      const k = kv[0];
      const v = kv[1];
      callback(k, v);
    }
  }
  var defaults = new VTTCue(0, 0, "");
  var center = defaults.align === "middle" ? "middle" : "center";
  function parseCue(input, cue, regionList) {
    const oInput = input;
    function consumeTimeStamp() {
      const ts = parseTimeStamp(input);
      if (ts === null) {
        throw new Error("Malformed timestamp: " + oInput);
      }
      input = input.replace(/^[^\sa-zA-Z-]+/, "");
      return ts;
    }
    function consumeCueSettings(input2, cue2) {
      const settings = new Settings();
      parseOptions(input2, function(k, v) {
        let vals;
        switch (k) {
          case "region":
            for (let i = regionList.length - 1; i >= 0; i--) {
              if (regionList[i].id === v) {
                settings.set(k, regionList[i].region);
                break;
              }
            }
            break;
          case "vertical":
            settings.alt(k, v, ["rl", "lr"]);
            break;
          case "line":
            vals = v.split(",");
            settings.integer(k, vals[0]);
            if (settings.percent(k, vals[0])) {
              settings.set("snapToLines", false);
            }
            settings.alt(k, vals[0], ["auto"]);
            if (vals.length === 2) {
              settings.alt("lineAlign", vals[1], ["start", center, "end"]);
            }
            break;
          case "position":
            vals = v.split(",");
            settings.percent(k, vals[0]);
            if (vals.length === 2) {
              settings.alt("positionAlign", vals[1], ["start", center, "end", "line-left", "line-right", "auto"]);
            }
            break;
          case "size":
            settings.percent(k, v);
            break;
          case "align":
            settings.alt(k, v, ["start", center, "end", "left", "right"]);
            break;
        }
      }, /:/, /\s/);
      cue2.region = settings.get("region", null);
      cue2.vertical = settings.get("vertical", "");
      let line = settings.get("line", "auto");
      if (line === "auto" && defaults.line === -1) {
        line = -1;
      }
      cue2.line = line;
      cue2.lineAlign = settings.get("lineAlign", "start");
      cue2.snapToLines = settings.get("snapToLines", true);
      cue2.size = settings.get("size", 100);
      cue2.align = settings.get("align", center);
      let position = settings.get("position", "auto");
      if (position === "auto" && defaults.position === 50) {
        position = cue2.align === "start" || cue2.align === "left" ? 0 : cue2.align === "end" || cue2.align === "right" ? 100 : 50;
      }
      cue2.position = position;
    }
    function skipWhitespace() {
      input = input.replace(/^\s+/, "");
    }
    skipWhitespace();
    cue.startTime = consumeTimeStamp();
    skipWhitespace();
    if (input.slice(0, 3) !== "-->") {
      throw new Error("Malformed time stamp (time stamps must be separated by '-->'): " + oInput);
    }
    input = input.slice(3);
    skipWhitespace();
    cue.endTime = consumeTimeStamp();
    skipWhitespace();
    consumeCueSettings(input, cue);
  }
  function fixLineBreaks(input) {
    return input.replace(/<br(?: \/)?>/gi, "\n");
  }
  var VTTParser = class {
    constructor() {
      this.state = "INITIAL";
      this.buffer = "";
      this.decoder = new StringDecoder();
      this.regionList = [];
      this.cue = null;
      this.oncue = void 0;
      this.onparsingerror = void 0;
      this.onflush = void 0;
    }
    parse(data) {
      const _this = this;
      if (data) {
        _this.buffer += _this.decoder.decode(data, {
          stream: true
        });
      }
      function collectNextLine() {
        let buffer = _this.buffer;
        let pos = 0;
        buffer = fixLineBreaks(buffer);
        while (pos < buffer.length && buffer[pos] !== "\r" && buffer[pos] !== "\n") {
          ++pos;
        }
        const line = buffer.slice(0, pos);
        if (buffer[pos] === "\r") {
          ++pos;
        }
        if (buffer[pos] === "\n") {
          ++pos;
        }
        _this.buffer = buffer.slice(pos);
        return line;
      }
      function parseHeader2(input) {
        parseOptions(input, function(k, v) {
        }, /:/);
      }
      try {
        let line = "";
        if (_this.state === "INITIAL") {
          if (!/\r\n|\n/.test(_this.buffer)) {
            return this;
          }
          line = collectNextLine();
          const m = line.match(/^()?WEBVTT([ \t].*)?$/);
          if (!(m != null && m[0])) {
            throw new Error("Malformed WebVTT signature.");
          }
          _this.state = "HEADER";
        }
        let alreadyCollectedLine = false;
        while (_this.buffer) {
          if (!/\r\n|\n/.test(_this.buffer)) {
            return this;
          }
          if (!alreadyCollectedLine) {
            line = collectNextLine();
          } else {
            alreadyCollectedLine = false;
          }
          switch (_this.state) {
            case "HEADER":
              if (/:/.test(line)) {
                parseHeader2(line);
              } else if (!line) {
                _this.state = "ID";
              }
              continue;
            case "NOTE":
              if (!line) {
                _this.state = "ID";
              }
              continue;
            case "ID":
              if (/^NOTE($|[ \t])/.test(line)) {
                _this.state = "NOTE";
                break;
              }
              if (!line) {
                continue;
              }
              _this.cue = new VTTCue(0, 0, "");
              _this.state = "CUE";
              if (line.indexOf("-->") === -1) {
                _this.cue.id = line;
                continue;
              }
            // Process line as start of a cue.
            /* falls through */
            case "CUE":
              if (!_this.cue) {
                _this.state = "BADCUE";
                continue;
              }
              try {
                parseCue(line, _this.cue, _this.regionList);
              } catch (e) {
                _this.cue = null;
                _this.state = "BADCUE";
                continue;
              }
              _this.state = "CUETEXT";
              continue;
            case "CUETEXT":
              {
                const hasSubstring = line.indexOf("-->") !== -1;
                if (!line || hasSubstring && (alreadyCollectedLine = true)) {
                  if (_this.oncue && _this.cue) {
                    _this.oncue(_this.cue);
                  }
                  _this.cue = null;
                  _this.state = "ID";
                  continue;
                }
                if (_this.cue === null) {
                  continue;
                }
                if (_this.cue.text) {
                  _this.cue.text += "\n";
                }
                _this.cue.text += line;
              }
              continue;
            case "BADCUE":
              if (!line) {
                _this.state = "ID";
              }
          }
        }
      } catch (e) {
        if (_this.state === "CUETEXT" && _this.cue && _this.oncue) {
          _this.oncue(_this.cue);
        }
        _this.cue = null;
        _this.state = _this.state === "INITIAL" ? "BADWEBVTT" : "BADCUE";
      }
      return this;
    }
    flush() {
      const _this = this;
      try {
        if (_this.cue || _this.state === "HEADER") {
          _this.buffer += "\n\n";
          _this.parse();
        }
        if (_this.state === "INITIAL" || _this.state === "BADWEBVTT") {
          throw new Error("Malformed WebVTT signature.");
        }
      } catch (e) {
        if (_this.onparsingerror) {
          _this.onparsingerror(e);
        }
      }
      if (_this.onflush) {
        _this.onflush();
      }
      return this;
    }
  };
  var LINEBREAKS = /\r\n|\n\r|\n|\r/g;
  var startsWith = function startsWith2(inputString, searchString, position = 0) {
    return inputString.slice(position, position + searchString.length) === searchString;
  };
  var cueString2millis = function cueString2millis2(timeString) {
    let ts = parseInt(timeString.slice(-3));
    const secs = parseInt(timeString.slice(-6, -4));
    const mins = parseInt(timeString.slice(-9, -7));
    const hours = timeString.length > 9 ? parseInt(timeString.substring(0, timeString.indexOf(":"))) : 0;
    if (!isFiniteNumber(ts) || !isFiniteNumber(secs) || !isFiniteNumber(mins) || !isFiniteNumber(hours)) {
      throw Error(`Malformed X-TIMESTAMP-MAP: Local:${timeString}`);
    }
    ts += 1e3 * secs;
    ts += 60 * 1e3 * mins;
    ts += 60 * 60 * 1e3 * hours;
    return ts;
  };
  function generateCueId(startTime, endTime, text) {
    return hash(startTime.toString()) + hash(endTime.toString()) + hash(text);
  }
  var calculateOffset = function calculateOffset2(vttCCs, cc, presentationTime) {
    let currCC = vttCCs[cc];
    let prevCC = vttCCs[currCC.prevCC];
    if (!prevCC || !prevCC.new && currCC.new) {
      vttCCs.ccOffset = vttCCs.presentationOffset = currCC.start;
      currCC.new = false;
      return;
    }
    while ((_prevCC = prevCC) != null && _prevCC.new) {
      var _prevCC;
      vttCCs.ccOffset += currCC.start - prevCC.start;
      currCC.new = false;
      currCC = prevCC;
      prevCC = vttCCs[currCC.prevCC];
    }
    vttCCs.presentationOffset = presentationTime;
  };
  function parseWebVTT(vttByteArray, initPTS, vttCCs, cc, timeOffset, callBack, errorCallBack) {
    const parser = new VTTParser();
    const vttLines = utf8ArrayToStr(new Uint8Array(vttByteArray)).trim().replace(LINEBREAKS, "\n").split("\n");
    const cues = [];
    const init90kHz = initPTS ? toMpegTsClockFromTimescale(initPTS.baseTime, initPTS.timescale) : 0;
    let cueTime = "00:00.000";
    let timestampMapMPEGTS = 0;
    let timestampMapLOCAL = 0;
    let parsingError;
    let inHeader = true;
    parser.oncue = function(cue) {
      const currCC = vttCCs[cc];
      let cueOffset = vttCCs.ccOffset;
      const webVttMpegTsMapOffset = (timestampMapMPEGTS - init90kHz) / 9e4;
      if (currCC != null && currCC.new) {
        if (timestampMapLOCAL !== void 0) {
          cueOffset = vttCCs.ccOffset = currCC.start;
        } else {
          calculateOffset(vttCCs, cc, webVttMpegTsMapOffset);
        }
      }
      if (webVttMpegTsMapOffset) {
        if (!initPTS) {
          parsingError = new Error("Missing initPTS for VTT MPEGTS");
          return;
        }
        cueOffset = webVttMpegTsMapOffset - vttCCs.presentationOffset;
      }
      const duration = cue.endTime - cue.startTime;
      const startTime = normalizePts((cue.startTime + cueOffset - timestampMapLOCAL) * 9e4, timeOffset * 9e4) / 9e4;
      cue.startTime = Math.max(startTime, 0);
      cue.endTime = Math.max(startTime + duration, 0);
      const text = cue.text.trim();
      cue.text = decodeURIComponent(encodeURIComponent(text));
      if (!cue.id) {
        cue.id = generateCueId(cue.startTime, cue.endTime, text);
      }
      if (cue.endTime > 0) {
        cues.push(cue);
      }
    };
    parser.onparsingerror = function(error) {
      parsingError = error;
    };
    parser.onflush = function() {
      if (parsingError) {
        errorCallBack(parsingError);
        return;
      }
      callBack(cues);
    };
    vttLines.forEach((line) => {
      if (inHeader) {
        if (startsWith(line, "X-TIMESTAMP-MAP=")) {
          inHeader = false;
          line.slice(16).split(",").forEach((timestamp) => {
            if (startsWith(timestamp, "LOCAL:")) {
              cueTime = timestamp.slice(6);
            } else if (startsWith(timestamp, "MPEGTS:")) {
              timestampMapMPEGTS = parseInt(timestamp.slice(7));
            }
          });
          try {
            timestampMapLOCAL = cueString2millis(cueTime) / 1e3;
          } catch (error) {
            parsingError = error;
          }
          return;
        } else if (line === "") {
          inHeader = false;
        }
      }
      parser.parse(line + "\n");
    });
    parser.flush();
  }
  var IMSC1_CODEC = "stpp.ttml.im1t";
  var HMSF_REGEX = /^(\d{2,}):(\d{2}):(\d{2}):(\d{2})\.?(\d+)?$/;
  var TIME_UNIT_REGEX = /^(\d*(?:\.\d*)?)(h|m|s|ms|f|t)$/;
  var textAlignToLineAlign = {
    left: "start",
    center: "center",
    right: "end",
    start: "start",
    end: "end"
  };
  function parseIMSC1(payload, initPTS, callBack, errorCallBack) {
    const results = findBox(new Uint8Array(payload), ["mdat"]);
    if (results.length === 0) {
      errorCallBack(new Error("Could not parse IMSC1 mdat"));
      return;
    }
    const ttmlList = results.map((mdat) => utf8ArrayToStr(mdat));
    const syncTime = toTimescaleFromScale(initPTS.baseTime, 1, initPTS.timescale);
    try {
      ttmlList.forEach((ttml) => callBack(parseTTML(ttml, syncTime)));
    } catch (error) {
      errorCallBack(error);
    }
  }
  function parseTTML(ttml, syncTime) {
    const parser = new DOMParser();
    const xmlDoc = parser.parseFromString(ttml, "text/xml");
    const tt = xmlDoc.getElementsByTagName("tt")[0];
    if (!tt) {
      throw new Error("Invalid ttml");
    }
    const defaultRateInfo = {
      frameRate: 30,
      subFrameRate: 1,
      frameRateMultiplier: 0,
      tickRate: 0
    };
    const rateInfo = Object.keys(defaultRateInfo).reduce((result, key) => {
      result[key] = tt.getAttribute(`ttp:${key}`) || defaultRateInfo[key];
      return result;
    }, {});
    const trim = tt.getAttribute("xml:space") !== "preserve";
    const styleElements = collectionToDictionary(getElementCollection(tt, "styling", "style"));
    const regionElements = collectionToDictionary(getElementCollection(tt, "layout", "region"));
    const cueElements = getElementCollection(tt, "body", "[begin]");
    return [].map.call(cueElements, (cueElement) => {
      const cueText = getTextContent(cueElement, trim);
      if (!cueText || !cueElement.hasAttribute("begin")) {
        return null;
      }
      const startTime = parseTtmlTime(cueElement.getAttribute("begin"), rateInfo);
      const duration = parseTtmlTime(cueElement.getAttribute("dur"), rateInfo);
      let endTime = parseTtmlTime(cueElement.getAttribute("end"), rateInfo);
      if (startTime === null) {
        throw timestampParsingError(cueElement);
      }
      if (endTime === null) {
        if (duration === null) {
          throw timestampParsingError(cueElement);
        }
        endTime = startTime + duration;
      }
      const cue = new VTTCue(startTime - syncTime, endTime - syncTime, cueText);
      cue.id = generateCueId(cue.startTime, cue.endTime, cue.text);
      const region = regionElements[cueElement.getAttribute("region")];
      const style = styleElements[cueElement.getAttribute("style")];
      const styles = getTtmlStyles(region, style, styleElements);
      const {
        textAlign
      } = styles;
      if (textAlign) {
        const lineAlign = textAlignToLineAlign[textAlign];
        if (lineAlign) {
          cue.lineAlign = lineAlign;
        }
        cue.align = textAlign;
      }
      _extends4(cue, styles);
      return cue;
    }).filter((cue) => cue !== null);
  }
  function getElementCollection(fromElement, parentName, childName) {
    const parent = fromElement.getElementsByTagName(parentName)[0];
    if (parent) {
      return [].slice.call(parent.querySelectorAll(childName));
    }
    return [];
  }
  function collectionToDictionary(elementsWithId) {
    return elementsWithId.reduce((dict, element) => {
      const id3 = element.getAttribute("xml:id");
      if (id3) {
        dict[id3] = element;
      }
      return dict;
    }, {});
  }
  function getTextContent(element, trim) {
    return [].slice.call(element.childNodes).reduce((str, node, i) => {
      var _node$childNodes;
      if (node.nodeName === "br" && i) {
        return str + "\n";
      }
      if ((_node$childNodes = node.childNodes) != null && _node$childNodes.length) {
        return getTextContent(node, trim);
      } else if (trim) {
        return str + node.textContent.trim().replace(/\s+/g, " ");
      }
      return str + node.textContent;
    }, "");
  }
  function getTtmlStyles(region, style, styleElements) {
    const ttsNs = "http://www.w3.org/ns/ttml#styling";
    let regionStyle = null;
    const styleAttributes = [
      "displayAlign",
      "textAlign",
      "color",
      "backgroundColor",
      "fontSize",
      "fontFamily"
      // 'fontWeight',
      // 'lineHeight',
      // 'wrapOption',
      // 'fontStyle',
      // 'direction',
      // 'writingMode'
    ];
    const regionStyleName = region != null && region.hasAttribute("style") ? region.getAttribute("style") : null;
    if (regionStyleName && styleElements.hasOwnProperty(regionStyleName)) {
      regionStyle = styleElements[regionStyleName];
    }
    return styleAttributes.reduce((styles, name) => {
      const value = getAttributeNS(style, ttsNs, name) || getAttributeNS(region, ttsNs, name) || getAttributeNS(regionStyle, ttsNs, name);
      if (value) {
        styles[name] = value;
      }
      return styles;
    }, {});
  }
  function getAttributeNS(element, ns, name) {
    if (!element) {
      return null;
    }
    return element.hasAttributeNS(ns, name) ? element.getAttributeNS(ns, name) : null;
  }
  function timestampParsingError(node) {
    return new Error(`Could not parse ttml timestamp ${node}`);
  }
  function parseTtmlTime(timeAttributeValue, rateInfo) {
    if (!timeAttributeValue) {
      return null;
    }
    let seconds = parseTimeStamp(timeAttributeValue);
    if (seconds === null) {
      if (HMSF_REGEX.test(timeAttributeValue)) {
        seconds = parseHoursMinutesSecondsFrames(timeAttributeValue, rateInfo);
      } else if (TIME_UNIT_REGEX.test(timeAttributeValue)) {
        seconds = parseTimeUnits(timeAttributeValue, rateInfo);
      }
    }
    return seconds;
  }
  function parseHoursMinutesSecondsFrames(timeAttributeValue, rateInfo) {
    const m = HMSF_REGEX.exec(timeAttributeValue);
    const frames = (m[4] | 0) + (m[5] | 0) / rateInfo.subFrameRate;
    return (m[1] | 0) * 3600 + (m[2] | 0) * 60 + (m[3] | 0) + frames / rateInfo.frameRate;
  }
  function parseTimeUnits(timeAttributeValue, rateInfo) {
    const m = TIME_UNIT_REGEX.exec(timeAttributeValue);
    const value = Number(m[1]);
    const unit = m[2];
    switch (unit) {
      case "h":
        return value * 3600;
      case "m":
        return value * 60;
      case "ms":
        return value * 1e3;
      case "f":
        return value / rateInfo.frameRate;
      case "t":
        return value / rateInfo.tickRate;
    }
    return value;
  }
  var OutputFilter = class {
    constructor(timelineController, trackName) {
      this.timelineController = void 0;
      this.cueRanges = [];
      this.trackName = void 0;
      this.startTime = null;
      this.endTime = null;
      this.screen = null;
      this.timelineController = timelineController;
      this.trackName = trackName;
    }
    dispatchCue() {
      if (this.startTime === null) {
        return;
      }
      this.timelineController.addCues(this.trackName, this.startTime, this.endTime, this.screen, this.cueRanges);
      this.startTime = null;
    }
    newCue(startTime, endTime, screen) {
      if (this.startTime === null || this.startTime > startTime) {
        this.startTime = startTime;
      }
      this.endTime = endTime;
      this.screen = screen;
      this.timelineController.createCaptionsTrack(this.trackName);
    }
    reset() {
      this.cueRanges = [];
      this.startTime = null;
    }
  };
  var TimelineController = class {
    constructor(hls) {
      this.hls = void 0;
      this.media = null;
      this.config = void 0;
      this.enabled = true;
      this.Cues = void 0;
      this.textTracks = [];
      this.tracks = [];
      this.initPTS = [];
      this.unparsedVttFrags = [];
      this.captionsTracks = {};
      this.nonNativeCaptionsTracks = {};
      this.cea608Parser1 = void 0;
      this.cea608Parser2 = void 0;
      this.lastCc = -1;
      this.lastSn = -1;
      this.lastPartIndex = -1;
      this.prevCC = -1;
      this.vttCCs = newVTTCCs();
      this.captionsProperties = void 0;
      this.hls = hls;
      this.config = hls.config;
      this.Cues = hls.config.cueHandler;
      this.captionsProperties = {
        textTrack1: {
          label: this.config.captionsTextTrack1Label,
          languageCode: this.config.captionsTextTrack1LanguageCode
        },
        textTrack2: {
          label: this.config.captionsTextTrack2Label,
          languageCode: this.config.captionsTextTrack2LanguageCode
        },
        textTrack3: {
          label: this.config.captionsTextTrack3Label,
          languageCode: this.config.captionsTextTrack3LanguageCode
        },
        textTrack4: {
          label: this.config.captionsTextTrack4Label,
          languageCode: this.config.captionsTextTrack4LanguageCode
        }
      };
      hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);
      hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
      hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);
      hls.on(Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);
      hls.on(Events.FRAG_LOADING, this.onFragLoading, this);
      hls.on(Events.FRAG_LOADED, this.onFragLoaded, this);
      hls.on(Events.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this);
      hls.on(Events.FRAG_DECRYPTED, this.onFragDecrypted, this);
      hls.on(Events.INIT_PTS_FOUND, this.onInitPtsFound, this);
      hls.on(Events.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this);
      hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);
    }
    destroy() {
      const {
        hls
      } = this;
      hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);
      hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
      hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);
      hls.off(Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);
      hls.off(Events.FRAG_LOADING, this.onFragLoading, this);
      hls.off(Events.FRAG_LOADED, this.onFragLoaded, this);
      hls.off(Events.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this);
      hls.off(Events.FRAG_DECRYPTED, this.onFragDecrypted, this);
      hls.off(Events.INIT_PTS_FOUND, this.onInitPtsFound, this);
      hls.off(Events.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this);
      hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);
      this.hls = this.config = this.media = null;
      this.cea608Parser1 = this.cea608Parser2 = void 0;
    }
    initCea608Parsers() {
      const channel1 = new OutputFilter(this, "textTrack1");
      const channel2 = new OutputFilter(this, "textTrack2");
      const channel3 = new OutputFilter(this, "textTrack3");
      const channel4 = new OutputFilter(this, "textTrack4");
      this.cea608Parser1 = new Cea608Parser(1, channel1, channel2);
      this.cea608Parser2 = new Cea608Parser(3, channel3, channel4);
    }
    addCues(trackName, startTime, endTime, screen, cueRanges) {
      let merged = false;
      for (let i = cueRanges.length; i--; ) {
        const cueRange = cueRanges[i];
        const overlap = intersection(cueRange[0], cueRange[1], startTime, endTime);
        if (overlap >= 0) {
          cueRange[0] = Math.min(cueRange[0], startTime);
          cueRange[1] = Math.max(cueRange[1], endTime);
          merged = true;
          if (overlap / (endTime - startTime) > 0.5) {
            return;
          }
        }
      }
      if (!merged) {
        cueRanges.push([startTime, endTime]);
      }
      if (this.config.renderTextTracksNatively) {
        const track = this.captionsTracks[trackName];
        this.Cues.newCue(track, startTime, endTime, screen);
      } else {
        const cues = this.Cues.newCue(null, startTime, endTime, screen);
        this.hls.trigger(Events.CUES_PARSED, {
          type: "captions",
          cues,
          track: trackName
        });
      }
    }
    // Triggered when an initial PTS is found; used for synchronisation of WebVTT.
    onInitPtsFound(event, {
      frag,
      id: id3,
      initPTS,
      timescale,
      trackId
    }) {
      const {
        unparsedVttFrags
      } = this;
      if (id3 === PlaylistLevelType.MAIN) {
        this.initPTS[frag.cc] = {
          baseTime: initPTS,
          timescale,
          trackId
        };
      }
      if (unparsedVttFrags.length) {
        this.unparsedVttFrags = [];
        unparsedVttFrags.forEach((data) => {
          if (this.initPTS[data.frag.cc]) {
            this.onFragLoaded(Events.FRAG_LOADED, data);
          } else {
            this.hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {
              success: false,
              frag: data.frag,
              error: new Error("Subtitle discontinuity domain does not match main")
            });
          }
        });
      }
    }
    getExistingTrack(label, language) {
      const {
        media
      } = this;
      if (media) {
        for (let i = 0; i < media.textTracks.length; i++) {
          const textTrack = media.textTracks[i];
          if (canReuseVttTextTrack(textTrack, {
            name: label,
            lang: language,
            characteristics: "transcribes-spoken-dialog,describes-music-and-sound"
          })) {
            return textTrack;
          }
        }
      }
      return null;
    }
    createCaptionsTrack(trackName) {
      if (this.config.renderTextTracksNatively) {
        this.createNativeTrack(trackName);
      } else {
        this.createNonNativeTrack(trackName);
      }
    }
    createNativeTrack(trackName) {
      if (this.captionsTracks[trackName]) {
        return;
      }
      const {
        captionsProperties,
        captionsTracks,
        media
      } = this;
      const {
        label,
        languageCode
      } = captionsProperties[trackName];
      const existingTrack = this.getExistingTrack(label, languageCode);
      if (!existingTrack) {
        const textTrack = this.createTextTrack("captions", label, languageCode);
        if (textTrack) {
          textTrack[trackName] = true;
          captionsTracks[trackName] = textTrack;
        }
      } else {
        captionsTracks[trackName] = existingTrack;
        clearCurrentCues(captionsTracks[trackName]);
        sendAddTrackEvent(captionsTracks[trackName], media);
      }
    }
    createNonNativeTrack(trackName) {
      if (this.nonNativeCaptionsTracks[trackName]) {
        return;
      }
      const trackProperties = this.captionsProperties[trackName];
      if (!trackProperties) {
        return;
      }
      const label = trackProperties.label;
      const track = {
        _id: trackName,
        label,
        kind: "captions",
        default: trackProperties.media ? !!trackProperties.media.default : false,
        closedCaptions: trackProperties.media
      };
      this.nonNativeCaptionsTracks[trackName] = track;
      this.hls.trigger(Events.NON_NATIVE_TEXT_TRACKS_FOUND, {
        tracks: [track]
      });
    }
    createTextTrack(kind, label, lang) {
      const media = this.media;
      if (!media) {
        return;
      }
      return media.addTextTrack(kind, label, lang);
    }
    onMediaAttaching(event, data) {
      this.media = data.media;
      if (!data.mediaSource) {
        this._cleanTracks();
      }
    }
    onMediaDetaching(event, data) {
      const transferringMedia = !!data.transferMedia;
      this.media = null;
      if (transferringMedia) {
        return;
      }
      const {
        captionsTracks
      } = this;
      Object.keys(captionsTracks).forEach((trackName) => {
        clearCurrentCues(captionsTracks[trackName]);
        delete captionsTracks[trackName];
      });
      this.nonNativeCaptionsTracks = {};
    }
    onManifestLoading() {
      this.lastCc = -1;
      this.lastSn = -1;
      this.lastPartIndex = -1;
      this.prevCC = -1;
      this.vttCCs = newVTTCCs();
      this._cleanTracks();
      this.tracks = [];
      this.captionsTracks = {};
      this.nonNativeCaptionsTracks = {};
      this.textTracks = [];
      this.unparsedVttFrags = [];
      this.initPTS = [];
      if (this.cea608Parser1 && this.cea608Parser2) {
        this.cea608Parser1.reset();
        this.cea608Parser2.reset();
      }
    }
    _cleanTracks() {
      const {
        media
      } = this;
      if (!media) {
        return;
      }
      const textTracks = media.textTracks;
      if (textTracks) {
        for (let i = 0; i < textTracks.length; i++) {
          clearCurrentCues(textTracks[i]);
        }
      }
    }
    onSubtitleTracksUpdated(event, data) {
      const tracks = data.subtitleTracks || [];
      const hasIMSC1 = tracks.some((track) => track.textCodec === IMSC1_CODEC);
      if (this.config.enableWebVTT || hasIMSC1 && this.config.enableIMSC1) {
        const listIsIdentical = subtitleOptionsIdentical(this.tracks, tracks);
        if (listIsIdentical) {
          this.tracks = tracks;
          return;
        }
        this.textTracks = [];
        this.tracks = tracks;
        if (this.config.renderTextTracksNatively) {
          const media = this.media;
          const inUseTracks = media ? filterSubtitleTracks(media.textTracks) : null;
          this.tracks.forEach((track, index) => {
            let textTrack;
            if (inUseTracks) {
              let inUseTrack = null;
              for (let i = 0; i < inUseTracks.length; i++) {
                if (inUseTracks[i] && canReuseVttTextTrack(inUseTracks[i], track)) {
                  inUseTrack = inUseTracks[i];
                  inUseTracks[i] = null;
                  break;
                }
              }
              if (inUseTrack) {
                textTrack = inUseTrack;
              }
            }
            if (textTrack) {
              clearCurrentCues(textTrack);
            } else {
              const textTrackKind = captionsOrSubtitlesFromCharacteristics(track);
              textTrack = this.createTextTrack(textTrackKind, track.name, track.lang);
              if (textTrack) {
                textTrack.mode = "disabled";
              }
            }
            if (textTrack) {
              this.textTracks.push(textTrack);
            }
          });
          if (inUseTracks != null && inUseTracks.length) {
            const unusedTextTracks = inUseTracks.filter((t) => t !== null).map((t) => t.label);
            if (unusedTextTracks.length) {
              this.hls.logger.warn(`Media element contains unused subtitle tracks: ${unusedTextTracks.join(", ")}. Replace media element for each source to clear TextTracks and captions menu.`);
            }
          }
        } else if (this.tracks.length) {
          const tracksList = this.tracks.map((track) => {
            return {
              label: track.name,
              kind: track.type.toLowerCase(),
              default: track.default,
              subtitleTrack: track
            };
          });
          this.hls.trigger(Events.NON_NATIVE_TEXT_TRACKS_FOUND, {
            tracks: tracksList
          });
        }
      }
    }
    onManifestLoaded(event, data) {
      if (this.config.enableCEA708Captions && data.captions) {
        data.captions.forEach((captionsTrack) => {
          const instreamIdMatch = /(?:CC|SERVICE)([1-4])/.exec(captionsTrack.instreamId);
          if (!instreamIdMatch) {
            return;
          }
          const trackName = `textTrack${instreamIdMatch[1]}`;
          const trackProperties = this.captionsProperties[trackName];
          if (!trackProperties) {
            return;
          }
          trackProperties.label = captionsTrack.name;
          if (captionsTrack.lang) {
            trackProperties.languageCode = captionsTrack.lang;
          }
          trackProperties.media = captionsTrack;
        });
      }
    }
    closedCaptionsForLevel(frag) {
      const level = this.hls.levels[frag.level];
      return level == null ? void 0 : level.attrs["CLOSED-CAPTIONS"];
    }
    onFragLoading(event, data) {
      if (this.enabled && data.frag.type === PlaylistLevelType.MAIN) {
        var _data$part$index, _data$part;
        const {
          cea608Parser1,
          cea608Parser2,
          lastSn
        } = this;
        const {
          cc,
          sn
        } = data.frag;
        const partIndex = (_data$part$index = (_data$part = data.part) == null ? void 0 : _data$part.index) != null ? _data$part$index : -1;
        if (cea608Parser1 && cea608Parser2) {
          if (sn !== lastSn + 1 || sn === lastSn && partIndex !== this.lastPartIndex + 1 || cc !== this.lastCc) {
            cea608Parser1.reset();
            cea608Parser2.reset();
          }
        }
        this.lastCc = cc;
        this.lastSn = sn;
        this.lastPartIndex = partIndex;
      }
    }
    onFragLoaded(event, data) {
      const {
        frag,
        payload
      } = data;
      if (frag.type === PlaylistLevelType.SUBTITLE) {
        if (payload.byteLength) {
          const decryptData = frag.decryptdata;
          const decrypted = "stats" in data;
          if (decryptData == null || !decryptData.encrypted || decrypted) {
            const trackPlaylistMedia = this.tracks[frag.level];
            const vttCCs = this.vttCCs;
            if (!vttCCs[frag.cc]) {
              vttCCs[frag.cc] = {
                start: frag.start,
                prevCC: this.prevCC,
                new: true
              };
              this.prevCC = frag.cc;
            }
            if (trackPlaylistMedia && trackPlaylistMedia.textCodec === IMSC1_CODEC) {
              this._parseIMSC1(frag, payload);
            } else {
              this._parseVTTs(data);
            }
          }
        } else {
          this.hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {
            success: false,
            frag,
            error: new Error("Empty subtitle payload")
          });
        }
      }
    }
    _parseIMSC1(frag, payload) {
      const hls = this.hls;
      parseIMSC1(payload, this.initPTS[frag.cc], (cues) => {
        this._appendCues(cues, frag.level);
        hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {
          success: true,
          frag
        });
      }, (error) => {
        hls.logger.log(`Failed to parse IMSC1: ${error}`);
        hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {
          success: false,
          frag,
          error
        });
      });
    }
    _parseVTTs(data) {
      var _frag$initSegment;
      const {
        frag,
        payload
      } = data;
      const {
        initPTS,
        unparsedVttFrags
      } = this;
      const maxAvCC = initPTS.length - 1;
      if (!initPTS[frag.cc] && maxAvCC === -1) {
        unparsedVttFrags.push(data);
        return;
      }
      const hls = this.hls;
      const payloadWebVTT = (_frag$initSegment = frag.initSegment) != null && _frag$initSegment.data ? appendUint8Array(frag.initSegment.data, new Uint8Array(payload)).buffer : payload;
      parseWebVTT(payloadWebVTT, this.initPTS[frag.cc], this.vttCCs, frag.cc, frag.start, (cues) => {
        this._appendCues(cues, frag.level);
        hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {
          success: true,
          frag
        });
      }, (error) => {
        const missingInitPTS = error.message === "Missing initPTS for VTT MPEGTS";
        if (missingInitPTS) {
          unparsedVttFrags.push(data);
        } else {
          this._fallbackToIMSC1(frag, payload);
        }
        hls.logger.log(`Failed to parse VTT cue: ${error}`);
        if (missingInitPTS && maxAvCC > frag.cc) {
          return;
        }
        hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {
          success: false,
          frag,
          error
        });
      });
    }
    _fallbackToIMSC1(frag, payload) {
      const trackPlaylistMedia = this.tracks[frag.level];
      if (!trackPlaylistMedia.textCodec) {
        parseIMSC1(payload, this.initPTS[frag.cc], () => {
          trackPlaylistMedia.textCodec = IMSC1_CODEC;
          this._parseIMSC1(frag, payload);
        }, () => {
          trackPlaylistMedia.textCodec = "wvtt";
        });
      }
    }
    _appendCues(cues, fragLevel) {
      const hls = this.hls;
      if (this.config.renderTextTracksNatively) {
        const textTrack = this.textTracks[fragLevel];
        if (!textTrack || textTrack.mode === "disabled") {
          return;
        }
        cues.forEach((cue) => addCueToTrack(textTrack, cue));
      } else {
        const currentTrack = this.tracks[fragLevel];
        if (!currentTrack) {
          return;
        }
        const track = currentTrack.default ? "default" : "subtitles" + fragLevel;
        hls.trigger(Events.CUES_PARSED, {
          type: "subtitles",
          cues,
          track
        });
      }
    }
    onFragDecrypted(event, data) {
      const {
        frag
      } = data;
      if (frag.type === PlaylistLevelType.SUBTITLE) {
        this.onFragLoaded(Events.FRAG_LOADED, data);
      }
    }
    onSubtitleTracksCleared() {
      this.tracks = [];
      this.captionsTracks = {};
    }
    onFragParsingUserdata(event, data) {
      if (!this.enabled || !this.config.enableCEA708Captions) {
        return;
      }
      const {
        frag,
        samples
      } = data;
      if (frag.type === PlaylistLevelType.MAIN && this.closedCaptionsForLevel(frag) === "NONE") {
        return;
      }
      for (let i = 0; i < samples.length; i++) {
        const ccBytes = samples[i].bytes;
        if (ccBytes) {
          if (!this.cea608Parser1) {
            this.initCea608Parsers();
          }
          const ccdatas = this.extractCea608Data(ccBytes);
          this.cea608Parser1.addData(samples[i].pts, ccdatas[0]);
          this.cea608Parser2.addData(samples[i].pts, ccdatas[1]);
        }
      }
    }
    onBufferFlushing(event, {
      startOffset,
      endOffset,
      endOffsetSubtitles,
      type
    }) {
      const {
        media
      } = this;
      if (!media || media.currentTime < endOffset) {
        return;
      }
      if (!type || type === "video") {
        const {
          captionsTracks
        } = this;
        Object.keys(captionsTracks).forEach((trackName) => removeCuesInRange(captionsTracks[trackName], startOffset, endOffset));
      }
      if (this.config.renderTextTracksNatively) {
        if (startOffset === 0 && endOffsetSubtitles !== void 0) {
          const {
            textTracks
          } = this;
          Object.keys(textTracks).forEach((trackName) => removeCuesInRange(textTracks[trackName], startOffset, endOffsetSubtitles));
        }
      }
    }
    extractCea608Data(byteArray) {
      const actualCCBytes = [[], []];
      const count = byteArray[0] & 31;
      let position = 2;
      for (let j = 0; j < count; j++) {
        const tmpByte = byteArray[position++];
        const ccbyte1 = 127 & byteArray[position++];
        const ccbyte2 = 127 & byteArray[position++];
        if (ccbyte1 === 0 && ccbyte2 === 0) {
          continue;
        }
        const ccValid = (4 & tmpByte) !== 0;
        if (ccValid) {
          const ccType = 3 & tmpByte;
          if (0 === ccType || 1 === ccType) {
            actualCCBytes[ccType].push(ccbyte1);
            actualCCBytes[ccType].push(ccbyte2);
          }
        }
      }
      return actualCCBytes;
    }
  };
  function captionsOrSubtitlesFromCharacteristics(track) {
    if (track.characteristics) {
      if (/transcribes-spoken-dialog/gi.test(track.characteristics) && /describes-music-and-sound/gi.test(track.characteristics)) {
        return "captions";
      }
    }
    return "subtitles";
  }
  function canReuseVttTextTrack(inUseTrack, manifestTrack) {
    return !!inUseTrack && inUseTrack.kind === captionsOrSubtitlesFromCharacteristics(manifestTrack) && subtitleTrackMatchesTextTrack(manifestTrack, inUseTrack);
  }
  function intersection(x1, x2, y1, y2) {
    return Math.min(x2, y2) - Math.max(x1, y1);
  }
  function newVTTCCs() {
    return {
      ccOffset: 0,
      presentationOffset: 0,
      0: {
        start: 0,
        prevCC: -1,
        new: true
      }
    };
  }
  var WHITESPACE_CHAR = /\s/;
  var Cues = {
    newCue(track, startTime, endTime, captionScreen) {
      const result = [];
      let row;
      let cue;
      let indenting;
      let indent;
      let text;
      const Cue = self.VTTCue || self.TextTrackCue;
      for (let r = 0; r < captionScreen.rows.length; r++) {
        row = captionScreen.rows[r];
        indenting = true;
        indent = 0;
        text = "";
        if (!row.isEmpty()) {
          var _track$cues;
          for (let c = 0; c < row.chars.length; c++) {
            if (WHITESPACE_CHAR.test(row.chars[c].uchar) && indenting) {
              indent++;
            } else {
              text += row.chars[c].uchar;
              indenting = false;
            }
          }
          row.cueStartTime = startTime;
          if (startTime === endTime) {
            endTime += 1e-4;
          }
          if (indent >= 16) {
            indent--;
          } else {
            indent++;
          }
          const cueText = fixLineBreaks(text.trim());
          const id3 = generateCueId(startTime, endTime, cueText);
          if (!(track != null && (_track$cues = track.cues) != null && _track$cues.getCueById(id3))) {
            cue = new Cue(startTime, endTime, cueText);
            cue.id = id3;
            cue.line = r + 1;
            cue.align = "left";
            cue.position = 10 + Math.min(80, Math.floor(indent * 8 / 32) * 10);
            result.push(cue);
          }
        }
      }
      if (track && result.length) {
        result.sort((cueA, cueB) => {
          if (cueA.line === "auto" || cueB.line === "auto") {
            return 0;
          }
          if (cueA.line > 8 && cueB.line > 8) {
            return cueB.line - cueA.line;
          }
          return cueA.line - cueB.line;
        });
        result.forEach((cue2) => addCueToTrack(track, cue2));
      }
      return result;
    }
  };
  function fetchSupported() {
    if (
      // @ts-ignore
      self.fetch && self.AbortController && self.ReadableStream && self.Request
    ) {
      try {
        new self.ReadableStream({});
        return true;
      } catch (e) {
      }
    }
    return false;
  }
  var BYTERANGE = /(\d+)-(\d+)\/(\d+)/;
  var FetchLoader = class {
    constructor(config3) {
      this.fetchSetup = void 0;
      this.requestTimeout = void 0;
      this.request = null;
      this.response = null;
      this.controller = void 0;
      this.context = null;
      this.config = null;
      this.callbacks = null;
      this.stats = void 0;
      this.loader = null;
      this.fetchSetup = config3.fetchSetup || getRequest;
      this.controller = new self.AbortController();
      this.stats = new LoadStats();
    }
    destroy() {
      this.loader = this.callbacks = this.context = this.config = this.request = null;
      this.abortInternal();
      this.response = null;
      this.fetchSetup = this.controller = this.stats = null;
    }
    abortInternal() {
      if (this.controller && !this.stats.loading.end) {
        this.stats.aborted = true;
        this.controller.abort();
      }
    }
    abort() {
      var _this$callbacks;
      this.abortInternal();
      if ((_this$callbacks = this.callbacks) != null && _this$callbacks.onAbort) {
        this.callbacks.onAbort(this.stats, this.context, this.response);
      }
    }
    load(context3, config3, callbacks) {
      const stats = this.stats;
      if (stats.loading.start) {
        throw new Error("Loader can only be used once.");
      }
      stats.loading.start = self.performance.now();
      const initParams = getRequestParameters(context3, this.controller.signal);
      const isArrayBuffer = context3.responseType === "arraybuffer";
      const LENGTH = isArrayBuffer ? "byteLength" : "length";
      const {
        maxTimeToFirstByteMs,
        maxLoadTimeMs
      } = config3.loadPolicy;
      this.context = context3;
      this.config = config3;
      this.callbacks = callbacks;
      this.request = this.fetchSetup(context3, initParams);
      self.clearTimeout(this.requestTimeout);
      config3.timeout = maxTimeToFirstByteMs && isFiniteNumber(maxTimeToFirstByteMs) ? maxTimeToFirstByteMs : maxLoadTimeMs;
      this.requestTimeout = self.setTimeout(() => {
        if (this.callbacks) {
          this.abortInternal();
          this.callbacks.onTimeout(stats, context3, this.response);
        }
      }, config3.timeout);
      const fetchPromise = isPromise(this.request) ? this.request.then(self.fetch) : self.fetch(this.request);
      fetchPromise.then((response) => {
        var _this$callbacks2;
        this.response = this.loader = response;
        const first = Math.max(self.performance.now(), stats.loading.start);
        self.clearTimeout(this.requestTimeout);
        config3.timeout = maxLoadTimeMs;
        this.requestTimeout = self.setTimeout(() => {
          if (this.callbacks) {
            this.abortInternal();
            this.callbacks.onTimeout(stats, context3, this.response);
          }
        }, maxLoadTimeMs - (first - stats.loading.start));
        if (!response.ok) {
          const {
            status: status2,
            statusText
          } = response;
          throw new FetchError(statusText || "fetch, bad network response", status2, response);
        }
        stats.loading.first = first;
        stats.total = getContentLength(response.headers) || stats.total;
        const onProgress = (_this$callbacks2 = this.callbacks) == null ? void 0 : _this$callbacks2.onProgress;
        if (onProgress && isFiniteNumber(config3.highWaterMark)) {
          return this.loadProgressively(response, stats, context3, config3.highWaterMark, onProgress);
        }
        if (isArrayBuffer) {
          return response.arrayBuffer();
        }
        if (context3.responseType === "json") {
          return response.json();
        }
        return response.text();
      }).then((responseData) => {
        var _this$callbacks3, _this$callbacks4;
        const response = this.response;
        if (!response) {
          throw new Error("loader destroyed");
        }
        self.clearTimeout(this.requestTimeout);
        stats.loading.end = Math.max(self.performance.now(), stats.loading.first);
        const total = responseData[LENGTH];
        if (total) {
          stats.loaded = stats.total = total;
        }
        const loaderResponse = {
          url: response.url,
          data: responseData,
          code: response.status
        };
        const onProgress = (_this$callbacks3 = this.callbacks) == null ? void 0 : _this$callbacks3.onProgress;
        if (onProgress && !isFiniteNumber(config3.highWaterMark)) {
          onProgress(stats, context3, responseData, response);
        }
        (_this$callbacks4 = this.callbacks) == null || _this$callbacks4.onSuccess(loaderResponse, stats, context3, response);
      }).catch((error) => {
        var _this$callbacks5;
        self.clearTimeout(this.requestTimeout);
        if (stats.aborted) {
          return;
        }
        const code = !error ? 0 : error.code || 0;
        const text = !error ? null : error.message;
        (_this$callbacks5 = this.callbacks) == null || _this$callbacks5.onError({
          code,
          text
        }, context3, error ? error.details : null, stats);
      });
    }
    getCacheAge() {
      let result = null;
      if (this.response) {
        const ageHeader = this.response.headers.get("age");
        result = ageHeader ? parseFloat(ageHeader) : null;
      }
      return result;
    }
    getResponseHeader(name) {
      return this.response ? this.response.headers.get(name) : null;
    }
    loadProgressively(response, stats, context3, highWaterMark = 0, onProgress) {
      const chunkCache = new ChunkCache();
      const reader = response.body.getReader();
      const pump = () => {
        return reader.read().then((data) => {
          if (data.done) {
            if (chunkCache.dataLength) {
              onProgress(stats, context3, chunkCache.flush().buffer, response);
            }
            return Promise.resolve(new ArrayBuffer(0));
          }
          const chunk = data.value;
          const len = chunk.length;
          stats.loaded += len;
          if (len < highWaterMark || chunkCache.dataLength) {
            chunkCache.push(chunk);
            if (chunkCache.dataLength >= highWaterMark) {
              onProgress(stats, context3, chunkCache.flush().buffer, response);
            }
          } else {
            onProgress(stats, context3, chunk.buffer, response);
          }
          return pump();
        }).catch(() => {
          return Promise.reject();
        });
      };
      return pump();
    }
  };
  function getRequestParameters(context3, signal) {
    const initParams = {
      method: "GET",
      mode: "cors",
      credentials: "same-origin",
      signal,
      headers: new self.Headers(_extends4({}, context3.headers))
    };
    if (context3.rangeEnd) {
      initParams.headers.set("Range", "bytes=" + context3.rangeStart + "-" + String(context3.rangeEnd - 1));
    }
    return initParams;
  }
  function getByteRangeLength(byteRangeHeader) {
    const result = BYTERANGE.exec(byteRangeHeader);
    if (result) {
      return parseInt(result[2]) - parseInt(result[1]) + 1;
    }
  }
  function getContentLength(headers) {
    const contentRange = headers.get("Content-Range");
    if (contentRange) {
      const byteRangeLength = getByteRangeLength(contentRange);
      if (isFiniteNumber(byteRangeLength)) {
        return byteRangeLength;
      }
    }
    const contentLength = headers.get("Content-Length");
    if (contentLength) {
      return parseInt(contentLength);
    }
  }
  function getRequest(context3, initParams) {
    return new self.Request(context3.url, initParams);
  }
  var FetchError = class extends Error {
    constructor(message, code, details) {
      super(message);
      this.code = void 0;
      this.details = void 0;
      this.code = code;
      this.details = details;
    }
  };
  var AGE_HEADER_LINE_REGEX = /^age:\s*[\d.]+\s*$/im;
  var XhrLoader = class {
    constructor(config3) {
      this.xhrSetup = void 0;
      this.requestTimeout = void 0;
      this.retryTimeout = void 0;
      this.retryDelay = void 0;
      this.config = null;
      this.callbacks = null;
      this.context = null;
      this.loader = null;
      this.stats = void 0;
      this.xhrSetup = config3 ? config3.xhrSetup || null : null;
      this.stats = new LoadStats();
      this.retryDelay = 0;
    }
    destroy() {
      this.callbacks = null;
      this.abortInternal();
      this.loader = null;
      this.config = null;
      this.context = null;
      this.xhrSetup = null;
    }
    abortInternal() {
      const loader = this.loader;
      self.clearTimeout(this.requestTimeout);
      self.clearTimeout(this.retryTimeout);
      if (loader) {
        loader.onreadystatechange = null;
        loader.onprogress = null;
        if (loader.readyState !== 4) {
          this.stats.aborted = true;
          loader.abort();
        }
      }
    }
    abort() {
      var _this$callbacks;
      this.abortInternal();
      if ((_this$callbacks = this.callbacks) != null && _this$callbacks.onAbort) {
        this.callbacks.onAbort(this.stats, this.context, this.loader);
      }
    }
    load(context3, config3, callbacks) {
      if (this.stats.loading.start) {
        throw new Error("Loader can only be used once.");
      }
      this.stats.loading.start = self.performance.now();
      this.context = context3;
      this.config = config3;
      this.callbacks = callbacks;
      this.loadInternal();
    }
    loadInternal() {
      const {
        config: config3,
        context: context3
      } = this;
      if (!config3 || !context3) {
        return;
      }
      const xhr = this.loader = new self.XMLHttpRequest();
      const stats = this.stats;
      stats.loading.first = 0;
      stats.loaded = 0;
      stats.aborted = false;
      const xhrSetup = this.xhrSetup;
      if (xhrSetup) {
        Promise.resolve().then(() => {
          if (this.loader !== xhr || this.stats.aborted) return;
          return xhrSetup(xhr, context3.url);
        }).catch((error) => {
          if (this.loader !== xhr || this.stats.aborted) return;
          xhr.open("GET", context3.url, true);
          return xhrSetup(xhr, context3.url);
        }).then(() => {
          if (this.loader !== xhr || this.stats.aborted) return;
          this.openAndSendXhr(xhr, context3, config3);
        }).catch((error) => {
          var _this$callbacks2;
          (_this$callbacks2 = this.callbacks) == null || _this$callbacks2.onError({
            code: xhr.status,
            text: error.message
          }, context3, xhr, stats);
          return;
        });
      } else {
        this.openAndSendXhr(xhr, context3, config3);
      }
    }
    openAndSendXhr(xhr, context3, config3) {
      if (!xhr.readyState) {
        xhr.open("GET", context3.url, true);
      }
      const headers = context3.headers;
      const {
        maxTimeToFirstByteMs,
        maxLoadTimeMs
      } = config3.loadPolicy;
      if (headers) {
        for (const header in headers) {
          xhr.setRequestHeader(header, headers[header]);
        }
      }
      if (context3.rangeEnd) {
        xhr.setRequestHeader("Range", "bytes=" + context3.rangeStart + "-" + (context3.rangeEnd - 1));
      }
      xhr.onreadystatechange = this.readystatechange.bind(this);
      xhr.onprogress = this.loadprogress.bind(this);
      xhr.responseType = context3.responseType;
      self.clearTimeout(this.requestTimeout);
      config3.timeout = maxTimeToFirstByteMs && isFiniteNumber(maxTimeToFirstByteMs) ? maxTimeToFirstByteMs : maxLoadTimeMs;
      this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), config3.timeout);
      xhr.send();
    }
    readystatechange() {
      const {
        context: context3,
        loader: xhr,
        stats
      } = this;
      if (!context3 || !xhr) {
        return;
      }
      const readyState = xhr.readyState;
      const config3 = this.config;
      if (stats.aborted) {
        return;
      }
      if (readyState >= 2) {
        if (stats.loading.first === 0) {
          stats.loading.first = Math.max(self.performance.now(), stats.loading.start);
          if (config3.timeout !== config3.loadPolicy.maxLoadTimeMs) {
            self.clearTimeout(this.requestTimeout);
            config3.timeout = config3.loadPolicy.maxLoadTimeMs;
            this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), config3.loadPolicy.maxLoadTimeMs - (stats.loading.first - stats.loading.start));
          }
        }
        if (readyState === 4) {
          self.clearTimeout(this.requestTimeout);
          xhr.onreadystatechange = null;
          xhr.onprogress = null;
          const status2 = xhr.status;
          const useResponseText = xhr.responseType === "text" ? xhr.responseText : null;
          if (status2 >= 200 && status2 < 300) {
            const data = useResponseText != null ? useResponseText : xhr.response;
            if (data != null) {
              var _this$callbacks3, _this$callbacks4;
              stats.loading.end = Math.max(self.performance.now(), stats.loading.first);
              const len = xhr.responseType === "arraybuffer" ? data.byteLength : data.length;
              stats.loaded = stats.total = len;
              stats.bwEstimate = stats.total * 8e3 / (stats.loading.end - stats.loading.first);
              const onProgress = (_this$callbacks3 = this.callbacks) == null ? void 0 : _this$callbacks3.onProgress;
              if (onProgress) {
                onProgress(stats, context3, data, xhr);
              }
              const _response = {
                url: xhr.responseURL,
                data,
                code: status2
              };
              (_this$callbacks4 = this.callbacks) == null || _this$callbacks4.onSuccess(_response, stats, context3, xhr);
              return;
            }
          }
          const retryConfig = config3.loadPolicy.errorRetry;
          const retryCount = stats.retry;
          const response = {
            url: context3.url,
            data: void 0,
            code: status2
          };
          if (shouldRetry(retryConfig, retryCount, false, response)) {
            this.retry(retryConfig);
          } else {
            var _this$callbacks5;
            logger.error(`${status2} while loading ${context3.url}`);
            (_this$callbacks5 = this.callbacks) == null || _this$callbacks5.onError({
              code: status2,
              text: xhr.statusText
            }, context3, xhr, stats);
          }
        }
      }
    }
    loadtimeout() {
      if (!this.config) return;
      const retryConfig = this.config.loadPolicy.timeoutRetry;
      const retryCount = this.stats.retry;
      if (shouldRetry(retryConfig, retryCount, true)) {
        this.retry(retryConfig);
      } else {
        var _this$context;
        logger.warn(`timeout while loading ${(_this$context = this.context) == null ? void 0 : _this$context.url}`);
        const callbacks = this.callbacks;
        if (callbacks) {
          this.abortInternal();
          callbacks.onTimeout(this.stats, this.context, this.loader);
        }
      }
    }
    retry(retryConfig) {
      const {
        context: context3,
        stats
      } = this;
      this.retryDelay = getRetryDelay(retryConfig, stats.retry);
      stats.retry++;
      logger.warn(`${status ? "HTTP Status " + status : "Timeout"} while loading ${context3 == null ? void 0 : context3.url}, retrying ${stats.retry}/${retryConfig.maxNumRetry} in ${this.retryDelay}ms`);
      this.abortInternal();
      this.loader = null;
      self.clearTimeout(this.retryTimeout);
      this.retryTimeout = self.setTimeout(this.loadInternal.bind(this), this.retryDelay);
    }
    loadprogress(event) {
      const stats = this.stats;
      stats.loaded = event.loaded;
      if (event.lengthComputable) {
        stats.total = event.total;
      }
    }
    getCacheAge() {
      let result = null;
      if (this.loader && AGE_HEADER_LINE_REGEX.test(this.loader.getAllResponseHeaders())) {
        const ageHeader = this.loader.getResponseHeader("age");
        result = ageHeader ? parseFloat(ageHeader) : null;
      }
      return result;
    }
    getResponseHeader(name) {
      if (this.loader && new RegExp(`^${name}:\\s*[\\d.]+\\s*$`, "im").test(this.loader.getAllResponseHeaders())) {
        return this.loader.getResponseHeader(name);
      }
      return null;
    }
  };
  var defaultLoadPolicy = {
    maxTimeToFirstByteMs: 8e3,
    maxLoadTimeMs: 2e4,
    timeoutRetry: null,
    errorRetry: null
  };
  var hlsDefaultConfig = _objectSpread2(_objectSpread2({
    autoStartLoad: true,
    // used by stream-controller
    startPosition: -1,
    // used by stream-controller
    defaultAudioCodec: void 0,
    // used by stream-controller
    debug: false,
    // used by logger
    capLevelOnFPSDrop: false,
    // used by fps-controller
    capLevelToPlayerSize: false,
    // used by cap-level-controller
    ignoreDevicePixelRatio: false,
    // used by cap-level-controller
    maxDevicePixelRatio: Number.POSITIVE_INFINITY,
    // used by cap-level-controller
    preferManagedMediaSource: true,
    initialLiveManifestSize: 1,
    // used by stream-controller
    maxBufferLength: 30,
    // used by stream-controller
    backBufferLength: Infinity,
    // used by buffer-controller
    frontBufferFlushThreshold: Infinity,
    startOnSegmentBoundary: false,
    // used by stream-controller
    maxBufferSize: 60 * 1e3 * 1e3,
    // used by stream-controller
    maxFragLookUpTolerance: 0.25,
    // used by stream-controller
    maxBufferHole: 0.1,
    // used by stream-controller and gap-controller
    detectStallWithCurrentTimeMs: 1250,
    // used by gap-controller
    highBufferWatchdogPeriod: 2,
    // used by gap-controller
    nudgeOffset: 0.1,
    // used by gap-controller
    nudgeMaxRetry: 3,
    // used by gap-controller
    nudgeOnVideoHole: true,
    // used by gap-controller
    liveSyncMode: "edge",
    // used by stream-controller
    liveSyncDurationCount: 3,
    // used by latency-controller
    liveSyncOnStallIncrease: 1,
    // used by latency-controller
    liveMaxLatencyDurationCount: Infinity,
    // used by latency-controller
    liveSyncDuration: void 0,
    // used by latency-controller
    liveMaxLatencyDuration: void 0,
    // used by latency-controller
    maxLiveSyncPlaybackRate: 1,
    // used by latency-controller
    liveDurationInfinity: false,
    // used by buffer-controller
    /**
     * @deprecated use backBufferLength
     */
    liveBackBufferLength: null,
    // used by buffer-controller
    maxMaxBufferLength: 600,
    // used by stream-controller
    enableWorker: true,
    // used by transmuxer
    workerPath: null,
    // used by transmuxer
    enableSoftwareAES: true,
    // used by decrypter
    startLevel: void 0,
    // used by level-controller
    startFragPrefetch: false,
    // used by stream-controller
    fpsDroppedMonitoringPeriod: 5e3,
    // used by fps-controller
    fpsDroppedMonitoringThreshold: 0.2,
    // used by fps-controller
    appendErrorMaxRetry: 3,
    // used by buffer-controller
    ignorePlaylistParsingErrors: false,
    loader: XhrLoader,
    // loader: FetchLoader,
    fLoader: void 0,
    // used by fragment-loader
    pLoader: void 0,
    // used by playlist-loader
    xhrSetup: void 0,
    // used by xhr-loader
    licenseXhrSetup: void 0,
    // used by eme-controller
    licenseResponseCallback: void 0,
    // used by eme-controller
    abrController: AbrController,
    bufferController: BufferController,
    capLevelController: CapLevelController,
    errorController: ErrorController,
    fpsController: FPSController,
    stretchShortVideoTrack: false,
    // used by mp4-remuxer
    maxAudioFramesDrift: 1,
    // used by mp4-remuxer
    forceKeyFrameOnDiscontinuity: true,
    // used by ts-demuxer
    abrEwmaFastLive: 3,
    // used by abr-controller
    abrEwmaSlowLive: 9,
    // used by abr-controller
    abrEwmaFastVoD: 3,
    // used by abr-controller
    abrEwmaSlowVoD: 9,
    // used by abr-controller
    abrEwmaDefaultEstimate: 5e5,
    // 500 kbps  // used by abr-controller
    abrEwmaDefaultEstimateMax: 5e6,
    // 5 mbps
    abrBandWidthFactor: 0.95,
    // used by abr-controller
    abrBandWidthUpFactor: 0.7,
    // used by abr-controller
    abrMaxWithRealBitrate: false,
    // used by abr-controller
    maxStarvationDelay: 4,
    // used by abr-controller
    maxLoadingDelay: 4,
    // used by abr-controller
    minAutoBitrate: 0,
    // used by hls
    emeEnabled: false,
    // used by eme-controller
    widevineLicenseUrl: void 0,
    // used by eme-controller
    drmSystems: {},
    // used by eme-controller
    drmSystemOptions: {},
    // used by eme-controller
    requestMediaKeySystemAccessFunc: requestMediaKeySystemAccess,
    // used by eme-controller
    requireKeySystemAccessOnStart: false,
    // used by eme-controller
    testBandwidth: true,
    progressive: false,
    lowLatencyMode: true,
    cmcd: void 0,
    enableDateRangeMetadataCues: true,
    enableEmsgMetadataCues: true,
    enableEmsgKLVMetadata: false,
    enableID3MetadataCues: true,
    enableInterstitialPlayback: true,
    interstitialAppendInPlace: true,
    interstitialLiveLookAhead: 10,
    useMediaCapabilities: true,
    preserveManualLevelOnError: false,
    certLoadPolicy: {
      default: defaultLoadPolicy
    },
    keyLoadPolicy: {
      default: {
        maxTimeToFirstByteMs: 8e3,
        maxLoadTimeMs: 2e4,
        timeoutRetry: {
          maxNumRetry: 1,
          retryDelayMs: 1e3,
          maxRetryDelayMs: 2e4,
          backoff: "linear"
        },
        errorRetry: {
          maxNumRetry: 8,
          retryDelayMs: 1e3,
          maxRetryDelayMs: 2e4,
          backoff: "linear"
        }
      }
    },
    manifestLoadPolicy: {
      default: {
        maxTimeToFirstByteMs: Infinity,
        maxLoadTimeMs: 2e4,
        timeoutRetry: {
          maxNumRetry: 2,
          retryDelayMs: 0,
          maxRetryDelayMs: 0
        },
        errorRetry: {
          maxNumRetry: 1,
          retryDelayMs: 1e3,
          maxRetryDelayMs: 8e3
        }
      }
    },
    playlistLoadPolicy: {
      default: {
        maxTimeToFirstByteMs: 1e4,
        maxLoadTimeMs: 2e4,
        timeoutRetry: {
          maxNumRetry: 2,
          retryDelayMs: 0,
          maxRetryDelayMs: 0
        },
        errorRetry: {
          maxNumRetry: 2,
          retryDelayMs: 1e3,
          maxRetryDelayMs: 8e3
        }
      }
    },
    fragLoadPolicy: {
      default: {
        maxTimeToFirstByteMs: 1e4,
        maxLoadTimeMs: 12e4,
        timeoutRetry: {
          maxNumRetry: 4,
          retryDelayMs: 0,
          maxRetryDelayMs: 0
        },
        errorRetry: {
          maxNumRetry: 6,
          retryDelayMs: 1e3,
          maxRetryDelayMs: 8e3
        }
      }
    },
    steeringManifestLoadPolicy: {
      default: {
        maxTimeToFirstByteMs: 1e4,
        maxLoadTimeMs: 2e4,
        timeoutRetry: {
          maxNumRetry: 2,
          retryDelayMs: 0,
          maxRetryDelayMs: 0
        },
        errorRetry: {
          maxNumRetry: 1,
          retryDelayMs: 1e3,
          maxRetryDelayMs: 8e3
        }
      }
    },
    interstitialAssetListLoadPolicy: {
      default: {
        maxTimeToFirstByteMs: 1e4,
        maxLoadTimeMs: 3e4,
        timeoutRetry: {
          maxNumRetry: 0,
          retryDelayMs: 0,
          maxRetryDelayMs: 0
        },
        errorRetry: {
          maxNumRetry: 0,
          retryDelayMs: 1e3,
          maxRetryDelayMs: 8e3
        }
      }
    },
    // These default settings are deprecated in favor of the above policies
    // and are maintained for backwards compatibility
    manifestLoadingTimeOut: 1e4,
    manifestLoadingMaxRetry: 1,
    manifestLoadingRetryDelay: 1e3,
    manifestLoadingMaxRetryTimeout: 64e3,
    levelLoadingTimeOut: 1e4,
    levelLoadingMaxRetry: 4,
    levelLoadingRetryDelay: 1e3,
    levelLoadingMaxRetryTimeout: 64e3,
    fragLoadingTimeOut: 2e4,
    fragLoadingMaxRetry: 6,
    fragLoadingRetryDelay: 1e3,
    fragLoadingMaxRetryTimeout: 64e3
  }, timelineConfig()), {}, {
    subtitleStreamController: SubtitleStreamController,
    subtitleTrackController: SubtitleTrackController,
    timelineController: TimelineController,
    audioStreamController: AudioStreamController,
    audioTrackController: AudioTrackController,
    emeController: EMEController,
    cmcdController: CMCDController,
    contentSteeringController: ContentSteeringController,
    interstitialsController: InterstitialsController
  });
  function timelineConfig() {
    return {
      cueHandler: Cues,
      // used by timeline-controller
      enableWebVTT: true,
      // used by timeline-controller
      enableIMSC1: true,
      // used by timeline-controller
      enableCEA708Captions: true,
      // used by timeline-controller
      captionsTextTrack1Label: "English",
      // used by timeline-controller
      captionsTextTrack1LanguageCode: "en",
      // used by timeline-controller
      captionsTextTrack2Label: "Spanish",
      // used by timeline-controller
      captionsTextTrack2LanguageCode: "es",
      // used by timeline-controller
      captionsTextTrack3Label: "Unknown CC",
      // used by timeline-controller
      captionsTextTrack3LanguageCode: "",
      // used by timeline-controller
      captionsTextTrack4Label: "Unknown CC",
      // used by timeline-controller
      captionsTextTrack4LanguageCode: "",
      // used by timeline-controller
      renderTextTracksNatively: true
    };
  }
  function mergeConfig(defaultConfig2, userConfig, logger2) {
    if ((userConfig.liveSyncDurationCount || userConfig.liveMaxLatencyDurationCount) && (userConfig.liveSyncDuration || userConfig.liveMaxLatencyDuration)) {
      throw new Error("Illegal hls.js config: don't mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration");
    }
    if (userConfig.liveMaxLatencyDurationCount !== void 0 && (userConfig.liveSyncDurationCount === void 0 || userConfig.liveMaxLatencyDurationCount <= userConfig.liveSyncDurationCount)) {
      throw new Error('Illegal hls.js config: "liveMaxLatencyDurationCount" must be greater than "liveSyncDurationCount"');
    }
    if (userConfig.liveMaxLatencyDuration !== void 0 && (userConfig.liveSyncDuration === void 0 || userConfig.liveMaxLatencyDuration <= userConfig.liveSyncDuration)) {
      throw new Error('Illegal hls.js config: "liveMaxLatencyDuration" must be greater than "liveSyncDuration"');
    }
    const defaultsCopy = deepCpy(defaultConfig2);
    const deprecatedSettingTypes = ["manifest", "level", "frag"];
    const deprecatedSettings = ["TimeOut", "MaxRetry", "RetryDelay", "MaxRetryTimeout"];
    deprecatedSettingTypes.forEach((type) => {
      const policyName = `${type === "level" ? "playlist" : type}LoadPolicy`;
      const policyNotSet = userConfig[policyName] === void 0;
      const report = [];
      deprecatedSettings.forEach((setting) => {
        const deprecatedSetting = `${type}Loading${setting}`;
        const value = userConfig[deprecatedSetting];
        if (value !== void 0 && policyNotSet) {
          report.push(deprecatedSetting);
          const settings = defaultsCopy[policyName].default;
          userConfig[policyName] = {
            default: settings
          };
          switch (setting) {
            case "TimeOut":
              settings.maxLoadTimeMs = value;
              settings.maxTimeToFirstByteMs = value;
              break;
            case "MaxRetry":
              settings.errorRetry.maxNumRetry = value;
              settings.timeoutRetry.maxNumRetry = value;
              break;
            case "RetryDelay":
              settings.errorRetry.retryDelayMs = value;
              settings.timeoutRetry.retryDelayMs = value;
              break;
            case "MaxRetryTimeout":
              settings.errorRetry.maxRetryDelayMs = value;
              settings.timeoutRetry.maxRetryDelayMs = value;
              break;
          }
        }
      });
      if (report.length) {
        logger2.warn(`hls.js config: "${report.join('", "')}" setting(s) are deprecated, use "${policyName}": ${stringify(userConfig[policyName])}`);
      }
    });
    return _objectSpread2(_objectSpread2({}, defaultsCopy), userConfig);
  }
  function deepCpy(obj) {
    if (obj && typeof obj === "object") {
      if (Array.isArray(obj)) {
        return obj.map(deepCpy);
      }
      return Object.keys(obj).reduce((result, key) => {
        result[key] = deepCpy(obj[key]);
        return result;
      }, {});
    }
    return obj;
  }
  function enableStreamingMode(config3, logger2) {
    const currentLoader = config3.loader;
    if (currentLoader !== FetchLoader && currentLoader !== XhrLoader) {
      logger2.log("[config]: Custom loader detected, cannot enable progressive streaming");
      config3.progressive = false;
    } else {
      const canStreamProgressively = fetchSupported();
      if (canStreamProgressively) {
        config3.loader = FetchLoader;
        config3.progressive = true;
        config3.enableSoftwareAES = true;
        logger2.log("[config]: Progressive streaming enabled, using FetchLoader");
      }
    }
  }
  var MAX_START_GAP_JUMP = 2;
  var SKIP_BUFFER_HOLE_STEP_SECONDS = 0.1;
  var SKIP_BUFFER_RANGE_START = 0.05;
  var TICK_INTERVAL$1 = 100;
  var GapController = class extends TaskLoop {
    constructor(hls, fragmentTracker) {
      super("gap-controller", hls.logger);
      this.hls = void 0;
      this.fragmentTracker = void 0;
      this.media = null;
      this.mediaSource = void 0;
      this.nudgeRetry = 0;
      this.stallReported = false;
      this.stalled = null;
      this.moved = false;
      this.seeking = false;
      this.buffered = {};
      this.lastCurrentTime = 0;
      this.ended = 0;
      this.waiting = 0;
      this.onMediaPlaying = () => {
        this.ended = 0;
        this.waiting = 0;
      };
      this.onMediaWaiting = () => {
        var _this$media;
        if ((_this$media = this.media) != null && _this$media.seeking) {
          return;
        }
        this.waiting = self.performance.now();
        this.tick();
      };
      this.onMediaEnded = () => {
        if (this.hls) {
          var _this$media2;
          this.ended = ((_this$media2 = this.media) == null ? void 0 : _this$media2.currentTime) || 1;
          this.hls.trigger(Events.MEDIA_ENDED, {
            stalled: false
          });
        }
      };
      this.hls = hls;
      this.fragmentTracker = fragmentTracker;
      this.registerListeners();
    }
    registerListeners() {
      const {
        hls
      } = this;
      if (hls) {
        hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
        hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
        hls.on(Events.BUFFER_APPENDED, this.onBufferAppended, this);
      }
    }
    unregisterListeners() {
      const {
        hls
      } = this;
      if (hls) {
        hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
        hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
        hls.off(Events.BUFFER_APPENDED, this.onBufferAppended, this);
      }
    }
    destroy() {
      super.destroy();
      this.unregisterListeners();
      this.media = this.hls = this.fragmentTracker = null;
      this.mediaSource = void 0;
    }
    onMediaAttached(event, data) {
      this.setInterval(TICK_INTERVAL$1);
      this.mediaSource = data.mediaSource;
      const media = this.media = data.media;
      addEventListener(media, "playing", this.onMediaPlaying);
      addEventListener(media, "waiting", this.onMediaWaiting);
      addEventListener(media, "ended", this.onMediaEnded);
    }
    onMediaDetaching(event, data) {
      this.clearInterval();
      const {
        media
      } = this;
      if (media) {
        removeEventListener(media, "playing", this.onMediaPlaying);
        removeEventListener(media, "waiting", this.onMediaWaiting);
        removeEventListener(media, "ended", this.onMediaEnded);
        this.media = null;
      }
      this.mediaSource = void 0;
    }
    onBufferAppended(event, data) {
      this.buffered = data.timeRanges;
    }
    get hasBuffered() {
      return Object.keys(this.buffered).length > 0;
    }
    tick() {
      var _this$media3;
      if (!((_this$media3 = this.media) != null && _this$media3.readyState) || !this.hasBuffered) {
        return;
      }
      const currentTime = this.media.currentTime;
      this.poll(currentTime, this.lastCurrentTime);
      this.lastCurrentTime = currentTime;
    }
    /**
     * Checks if the playhead is stuck within a gap, and if so, attempts to free it.
     * A gap is an unbuffered range between two buffered ranges (or the start and the first buffered range).
     *
     * @param lastCurrentTime - Previously read playhead position
     */
    poll(currentTime, lastCurrentTime) {
      var _this$hls, _this$hls2;
      const config3 = (_this$hls = this.hls) == null ? void 0 : _this$hls.config;
      if (!config3) {
        return;
      }
      const media = this.media;
      if (!media) {
        return;
      }
      const {
        seeking
      } = media;
      const seeked = this.seeking && !seeking;
      const beginSeek = !this.seeking && seeking;
      const pausedEndedOrHalted = media.paused && !seeking || media.ended || media.playbackRate === 0;
      this.seeking = seeking;
      if (currentTime !== lastCurrentTime) {
        if (lastCurrentTime) {
          this.ended = 0;
        }
        this.moved = true;
        if (!seeking) {
          this.nudgeRetry = 0;
          if (config3.nudgeOnVideoHole && !pausedEndedOrHalted && currentTime > lastCurrentTime) {
            this.nudgeOnVideoHole(currentTime, lastCurrentTime);
          }
        }
        if (this.waiting === 0) {
          this.stallResolved(currentTime);
        }
        return;
      }
      if (beginSeek || seeked) {
        if (seeked) {
          this.stallResolved(currentTime);
        }
        return;
      }
      if (pausedEndedOrHalted) {
        this.nudgeRetry = 0;
        this.stallResolved(currentTime);
        if (!this.ended && media.ended && this.hls) {
          this.ended = currentTime || 1;
          this.hls.trigger(Events.MEDIA_ENDED, {
            stalled: false
          });
        }
        return;
      }
      if (!BufferHelper.getBuffered(media).length) {
        this.nudgeRetry = 0;
        return;
      }
      const bufferInfo = BufferHelper.bufferInfo(media, currentTime, 0);
      const nextStart = bufferInfo.nextStart || 0;
      const fragmentTracker = this.fragmentTracker;
      if (seeking && fragmentTracker && this.hls) {
        const inFlightDependency = getInFlightDependency(this.hls.inFlightFragments, currentTime);
        const hasEnoughBuffer = bufferInfo.len > MAX_START_GAP_JUMP;
        const noBufferHole = !nextStart || inFlightDependency || nextStart - currentTime > MAX_START_GAP_JUMP && !fragmentTracker.getPartialFragment(currentTime);
        if (hasEnoughBuffer || noBufferHole) {
          return;
        }
        this.moved = false;
      }
      const levelDetails = (_this$hls2 = this.hls) == null ? void 0 : _this$hls2.latestLevelDetails;
      if (!this.moved && this.stalled !== null && fragmentTracker) {
        const isBuffered = bufferInfo.len > 0;
        if (!isBuffered && !nextStart) {
          return;
        }
        const startJump = Math.max(nextStart, bufferInfo.start || 0) - currentTime;
        const isLive = !!(levelDetails != null && levelDetails.live);
        const maxStartGapJump = isLive ? levelDetails.targetduration * 2 : MAX_START_GAP_JUMP;
        const appended = appendedFragAtPosition(currentTime, fragmentTracker);
        if (startJump > 0 && (startJump <= maxStartGapJump || appended)) {
          if (!media.paused) {
            this._trySkipBufferHole(appended);
          }
          return;
        }
      }
      const detectStallWithCurrentTimeMs = config3.detectStallWithCurrentTimeMs;
      const tnow = self.performance.now();
      const tWaiting = this.waiting;
      let stalled = this.stalled;
      if (stalled === null) {
        if (tWaiting > 0 && tnow - tWaiting < detectStallWithCurrentTimeMs) {
          stalled = this.stalled = tWaiting;
        } else {
          this.stalled = tnow;
          return;
        }
      }
      const stalledDuration = tnow - stalled;
      if (!seeking && (stalledDuration >= detectStallWithCurrentTimeMs || tWaiting) && this.hls) {
        var _this$mediaSource;
        if (((_this$mediaSource = this.mediaSource) == null ? void 0 : _this$mediaSource.readyState) === "ended" && !(levelDetails != null && levelDetails.live) && Math.abs(currentTime - ((levelDetails == null ? void 0 : levelDetails.edge) || 0)) < 1) {
          if (this.ended) {
            return;
          }
          this.ended = currentTime || 1;
          this.hls.trigger(Events.MEDIA_ENDED, {
            stalled: true
          });
          return;
        }
        this._reportStall(bufferInfo);
        if (!this.media || !this.hls) {
          return;
        }
      }
      const bufferedWithHoles = BufferHelper.bufferInfo(media, currentTime, config3.maxBufferHole);
      this._tryFixBufferStall(bufferedWithHoles, stalledDuration, currentTime);
    }
    stallResolved(currentTime) {
      const stalled = this.stalled;
      if (stalled && this.hls) {
        this.stalled = null;
        if (this.stallReported) {
          const stalledDuration = self.performance.now() - stalled;
          this.log(`playback not stuck anymore @${currentTime}, after ${Math.round(stalledDuration)}ms`);
          this.stallReported = false;
          this.waiting = 0;
          this.hls.trigger(Events.STALL_RESOLVED, {});
        }
      }
    }
    nudgeOnVideoHole(currentTime, lastCurrentTime) {
      var _this$buffered$audio;
      const videoSourceBuffered = this.buffered.video;
      if (this.hls && this.media && this.fragmentTracker && (_this$buffered$audio = this.buffered.audio) != null && _this$buffered$audio.length && videoSourceBuffered && videoSourceBuffered.length > 1 && currentTime > videoSourceBuffered.end(0)) {
        const audioBufferInfo = BufferHelper.bufferedInfo(BufferHelper.timeRangesToArray(this.buffered.audio), currentTime, 0);
        if (audioBufferInfo.len > 1 && lastCurrentTime >= audioBufferInfo.start) {
          const videoTimes = BufferHelper.timeRangesToArray(videoSourceBuffered);
          const lastBufferedIndex = BufferHelper.bufferedInfo(videoTimes, lastCurrentTime, 0).bufferedIndex;
          if (lastBufferedIndex > -1 && lastBufferedIndex < videoTimes.length - 1) {
            const bufferedIndex = BufferHelper.bufferedInfo(videoTimes, currentTime, 0).bufferedIndex;
            const holeStart = videoTimes[lastBufferedIndex].end;
            const holeEnd = videoTimes[lastBufferedIndex + 1].start;
            if ((bufferedIndex === -1 || bufferedIndex > lastBufferedIndex) && holeEnd - holeStart < 1 && // `maxBufferHole` may be too small and setting it to 0 should not disable this feature
            currentTime - holeStart < 2) {
              const error = new Error(`nudging playhead to flush pipeline after video hole. currentTime: ${currentTime} hole: ${holeStart} -> ${holeEnd} buffered index: ${bufferedIndex}`);
              this.warn(error.message);
              this.media.currentTime += 1e-6;
              let frag = appendedFragAtPosition(currentTime, this.fragmentTracker);
              if (frag && "fragment" in frag) {
                frag = frag.fragment;
              } else if (!frag) {
                frag = void 0;
              }
              const bufferInfo = BufferHelper.bufferInfo(this.media, currentTime, 0);
              this.hls.trigger(Events.ERROR, {
                type: ErrorTypes.MEDIA_ERROR,
                details: ErrorDetails.BUFFER_SEEK_OVER_HOLE,
                fatal: false,
                error,
                reason: error.message,
                frag,
                buffer: bufferInfo.len,
                bufferInfo
              });
            }
          }
        }
      }
    }
    /**
     * Detects and attempts to fix known buffer stalling issues.
     * @param bufferInfo - The properties of the current buffer.
     * @param stalledDurationMs - The amount of time Hls.js has been stalling for.
     * @private
     */
    _tryFixBufferStall(bufferInfo, stalledDurationMs, currentTime) {
      var _this$hls3, _this$hls4;
      const {
        fragmentTracker,
        media
      } = this;
      const config3 = (_this$hls3 = this.hls) == null ? void 0 : _this$hls3.config;
      if (!media || !fragmentTracker || !config3) {
        return;
      }
      const levelDetails = (_this$hls4 = this.hls) == null ? void 0 : _this$hls4.latestLevelDetails;
      const appended = appendedFragAtPosition(currentTime, fragmentTracker);
      if (appended || levelDetails != null && levelDetails.live && currentTime < levelDetails.fragmentStart) {
        const targetTime = this._trySkipBufferHole(appended);
        if (targetTime || !this.media) {
          return;
        }
      }
      const bufferedRanges = bufferInfo.buffered;
      const adjacentTraversal = this.adjacentTraversal(bufferInfo, currentTime);
      if ((bufferedRanges && bufferedRanges.length > 1 && bufferInfo.len > config3.maxBufferHole || bufferInfo.nextStart && (bufferInfo.nextStart - currentTime < config3.maxBufferHole || adjacentTraversal)) && (stalledDurationMs > config3.highBufferWatchdogPeriod * 1e3 || this.waiting)) {
        this.warn("Trying to nudge playhead over buffer-hole");
        this._tryNudgeBuffer(bufferInfo);
      }
    }
    adjacentTraversal(bufferInfo, currentTime) {
      const fragmentTracker = this.fragmentTracker;
      const nextStart = bufferInfo.nextStart;
      if (fragmentTracker && nextStart) {
        const current = fragmentTracker.getFragAtPos(currentTime, PlaylistLevelType.MAIN);
        const next = fragmentTracker.getFragAtPos(nextStart, PlaylistLevelType.MAIN);
        if (current && next) {
          return next.sn - current.sn < 2;
        }
      }
      return false;
    }
    /**
     * Triggers a BUFFER_STALLED_ERROR event, but only once per stall period.
     * @param bufferLen - The playhead distance from the end of the current buffer segment.
     * @private
     */
    _reportStall(bufferInfo) {
      const {
        hls,
        media,
        stallReported,
        stalled
      } = this;
      if (!stallReported && stalled !== null && media && hls) {
        this.stallReported = true;
        const error = new Error(`Playback stalling at @${media.currentTime} due to low buffer (${stringify(bufferInfo)})`);
        this.warn(error.message);
        hls.trigger(Events.ERROR, {
          type: ErrorTypes.MEDIA_ERROR,
          details: ErrorDetails.BUFFER_STALLED_ERROR,
          fatal: false,
          error,
          buffer: bufferInfo.len,
          bufferInfo,
          stalled: {
            start: stalled
          }
        });
      }
    }
    /**
     * Attempts to fix buffer stalls by jumping over known gaps caused by partial fragments
     * @param appended - The fragment or part found at the current time (where playback is stalling).
     * @private
     */
    _trySkipBufferHole(appended) {
      var _this$hls5;
      const {
        fragmentTracker,
        media
      } = this;
      const config3 = (_this$hls5 = this.hls) == null ? void 0 : _this$hls5.config;
      if (!media || !fragmentTracker || !config3) {
        return 0;
      }
      const currentTime = media.currentTime;
      const bufferInfo = BufferHelper.bufferInfo(media, currentTime, 0);
      const startTime = currentTime < bufferInfo.start ? bufferInfo.start : bufferInfo.nextStart;
      if (startTime && this.hls) {
        const bufferStarved = bufferInfo.len <= config3.maxBufferHole;
        const waiting = bufferInfo.len > 0 && bufferInfo.len < 1 && media.readyState < 3;
        const gapLength = startTime - currentTime;
        if (gapLength > 0 && (bufferStarved || waiting)) {
          if (gapLength > config3.maxBufferHole) {
            let startGap = false;
            if (currentTime === 0) {
              const startFrag = fragmentTracker.getAppendedFrag(0, PlaylistLevelType.MAIN);
              if (startFrag && startTime < startFrag.end) {
                startGap = true;
              }
            }
            if (!startGap && appended) {
              var _this$hls$loadLevelOb;
              if (!((_this$hls$loadLevelOb = this.hls.loadLevelObj) != null && _this$hls$loadLevelOb.details)) {
                return 0;
              }
              const inFlightDependency = getInFlightDependency(this.hls.inFlightFragments, startTime);
              if (inFlightDependency) {
                return 0;
              }
              let moreToLoad = false;
              let pos = appended.end;
              while (pos < startTime) {
                const provisioned = appendedFragAtPosition(pos, fragmentTracker);
                if (provisioned) {
                  pos += provisioned.duration;
                } else {
                  moreToLoad = true;
                  break;
                }
              }
              if (moreToLoad) {
                return 0;
              }
            }
          }
          const targetTime = Math.max(startTime + SKIP_BUFFER_RANGE_START, currentTime + SKIP_BUFFER_HOLE_STEP_SECONDS);
          this.warn(`skipping hole, adjusting currentTime from ${currentTime} to ${targetTime}`);
          this.moved = true;
          media.currentTime = targetTime;
          if (!(appended != null && appended.gap)) {
            const error = new Error(`fragment loaded with buffer holes, seeking from ${currentTime} to ${targetTime}`);
            const errorData = {
              type: ErrorTypes.MEDIA_ERROR,
              details: ErrorDetails.BUFFER_SEEK_OVER_HOLE,
              fatal: false,
              error,
              reason: error.message,
              buffer: bufferInfo.len,
              bufferInfo
            };
            if (appended) {
              if ("fragment" in appended) {
                errorData.part = appended;
              } else {
                errorData.frag = appended;
              }
            }
            this.hls.trigger(Events.ERROR, errorData);
          }
          return targetTime;
        }
      }
      return 0;
    }
    /**
     * Attempts to fix buffer stalls by advancing the mediaElement's current time by a small amount.
     * @private
     */
    _tryNudgeBuffer(bufferInfo) {
      const {
        hls,
        media,
        nudgeRetry
      } = this;
      const config3 = hls == null ? void 0 : hls.config;
      if (!media || !config3) {
        return 0;
      }
      const currentTime = media.currentTime;
      this.nudgeRetry++;
      if (nudgeRetry < config3.nudgeMaxRetry) {
        const targetTime = currentTime + (nudgeRetry + 1) * config3.nudgeOffset;
        const error = new Error(`Nudging 'currentTime' from ${currentTime} to ${targetTime}`);
        this.warn(error.message);
        media.currentTime = targetTime;
        hls.trigger(Events.ERROR, {
          type: ErrorTypes.MEDIA_ERROR,
          details: ErrorDetails.BUFFER_NUDGE_ON_STALL,
          error,
          fatal: false,
          buffer: bufferInfo.len,
          bufferInfo
        });
      } else {
        const error = new Error(`Playhead still not moving while enough data buffered @${currentTime} after ${config3.nudgeMaxRetry} nudges`);
        this.error(error.message);
        hls.trigger(Events.ERROR, {
          type: ErrorTypes.MEDIA_ERROR,
          details: ErrorDetails.BUFFER_STALLED_ERROR,
          error,
          fatal: true,
          buffer: bufferInfo.len,
          bufferInfo
        });
      }
    }
  };
  function getInFlightDependency(inFlightFragments, currentTime) {
    const main = inFlight(inFlightFragments.main);
    if (main && main.start <= currentTime) {
      return main;
    }
    const audio = inFlight(inFlightFragments.audio);
    if (audio && audio.start <= currentTime) {
      return audio;
    }
    return null;
  }
  function inFlight(inFlightData) {
    if (!inFlightData) {
      return null;
    }
    switch (inFlightData.state) {
      case State.IDLE:
      case State.STOPPED:
      case State.ENDED:
      case State.ERROR:
        return null;
    }
    return inFlightData.frag;
  }
  function appendedFragAtPosition(pos, fragmentTracker) {
    return fragmentTracker.getAppendedFrag(pos, PlaylistLevelType.MAIN) || fragmentTracker.getPartialFragment(pos);
  }
  var MIN_CUE_DURATION = 0.25;
  function getCueClass() {
    if (typeof self === "undefined") return void 0;
    return self.VTTCue || self.TextTrackCue;
  }
  function createCueWithDataFields(Cue, startTime, endTime, data, type) {
    let cue = new Cue(startTime, endTime, "");
    try {
      cue.value = data;
      if (type) {
        cue.type = type;
      }
    } catch (e) {
      cue = new Cue(startTime, endTime, stringify(type ? _objectSpread2({
        type
      }, data) : data));
    }
    return cue;
  }
  var MAX_CUE_ENDTIME = (() => {
    const Cue = getCueClass();
    try {
      Cue && new Cue(0, Number.POSITIVE_INFINITY, "");
    } catch (e) {
      return Number.MAX_VALUE;
    }
    return Number.POSITIVE_INFINITY;
  })();
  var ID3TrackController = class {
    constructor(hls) {
      this.hls = void 0;
      this.id3Track = null;
      this.media = null;
      this.dateRangeCuesAppended = {};
      this.removeCues = true;
      this.assetCue = void 0;
      this.onEventCueEnter = () => {
        if (!this.hls) {
          return;
        }
        this.hls.trigger(Events.EVENT_CUE_ENTER, {});
      };
      this.hls = hls;
      this._registerListeners();
    }
    destroy() {
      this._unregisterListeners();
      this.id3Track = null;
      this.media = null;
      this.dateRangeCuesAppended = {};
      this.hls = this.onEventCueEnter = null;
    }
    _registerListeners() {
      const {
        hls
      } = this;
      if (hls) {
        hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);
        hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
        hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
        hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
        hls.on(Events.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this);
        hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);
        hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);
        hls.on(Events.LEVEL_PTS_UPDATED, this.onLevelPtsUpdated, this);
      }
    }
    _unregisterListeners() {
      const {
        hls
      } = this;
      if (hls) {
        hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);
        hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
        hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
        hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
        hls.off(Events.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this);
        hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);
        hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);
        hls.off(Events.LEVEL_PTS_UPDATED, this.onLevelPtsUpdated, this);
      }
    }
    // Add ID3 metatadata text track.
    onMediaAttaching(event, data) {
      var _data$overrides;
      this.media = data.media;
      if (((_data$overrides = data.overrides) == null ? void 0 : _data$overrides.cueRemoval) === false) {
        this.removeCues = false;
      }
    }
    onMediaAttached() {
      var _this$hls;
      const details = (_this$hls = this.hls) == null ? void 0 : _this$hls.latestLevelDetails;
      if (details) {
        this.updateDateRangeCues(details);
      }
    }
    onMediaDetaching(event, data) {
      this.media = null;
      const transferringMedia = !!data.transferMedia;
      if (transferringMedia) {
        return;
      }
      if (this.id3Track) {
        if (this.removeCues) {
          clearCurrentCues(this.id3Track, this.onEventCueEnter);
        }
        this.id3Track = null;
      }
      this.dateRangeCuesAppended = {};
    }
    onManifestLoading() {
      this.dateRangeCuesAppended = {};
    }
    createTrack(media) {
      const track = this.getID3Track(media.textTracks);
      track.mode = "hidden";
      return track;
    }
    getID3Track(textTracks) {
      if (!this.media) {
        return;
      }
      for (let i = 0; i < textTracks.length; i++) {
        const textTrack = textTracks[i];
        if (textTrack.kind === "metadata" && textTrack.label === "id3") {
          sendAddTrackEvent(textTrack, this.media);
          return textTrack;
        }
      }
      return this.media.addTextTrack("metadata", "id3");
    }
    onFragParsingMetadata(event, data) {
      if (!this.media || !this.hls) {
        return;
      }
      const {
        enableEmsgMetadataCues,
        enableID3MetadataCues
      } = this.hls.config;
      if (!enableEmsgMetadataCues && !enableID3MetadataCues) {
        return;
      }
      const {
        samples
      } = data;
      if (!this.id3Track) {
        this.id3Track = this.createTrack(this.media);
      }
      const Cue = getCueClass();
      if (!Cue) {
        return;
      }
      for (let i = 0; i < samples.length; i++) {
        const type = samples[i].type;
        if (type === MetadataSchema.emsg && !enableEmsgMetadataCues || !enableID3MetadataCues) {
          continue;
        }
        const frames = getId3Frames(samples[i].data);
        const startTime = samples[i].pts;
        let endTime = startTime + samples[i].duration;
        if (endTime > MAX_CUE_ENDTIME) {
          endTime = MAX_CUE_ENDTIME;
        }
        const timeDiff = endTime - startTime;
        if (timeDiff <= 0) {
          endTime = startTime + MIN_CUE_DURATION;
        }
        for (let j = 0; j < frames.length; j++) {
          const frame2 = frames[j];
          if (!isId3TimestampFrame(frame2)) {
            this.updateId3CueEnds(startTime, type);
            const cue = createCueWithDataFields(Cue, startTime, endTime, frame2, type);
            if (cue) {
              this.id3Track.addCue(cue);
            }
          }
        }
      }
    }
    updateId3CueEnds(startTime, type) {
      var _this$id3Track;
      const cues = (_this$id3Track = this.id3Track) == null ? void 0 : _this$id3Track.cues;
      if (cues) {
        for (let i = cues.length; i--; ) {
          const cue = cues[i];
          if (cue.type === type && cue.startTime < startTime && cue.endTime === MAX_CUE_ENDTIME) {
            cue.endTime = startTime;
          }
        }
      }
    }
    onBufferFlushing(event, {
      startOffset,
      endOffset,
      type
    }) {
      const {
        id3Track,
        hls
      } = this;
      if (!hls) {
        return;
      }
      const {
        config: {
          enableEmsgMetadataCues,
          enableID3MetadataCues
        }
      } = hls;
      if (id3Track && (enableEmsgMetadataCues || enableID3MetadataCues)) {
        let predicate;
        if (type === "audio") {
          predicate = (cue) => cue.type === MetadataSchema.audioId3 && enableID3MetadataCues;
        } else if (type === "video") {
          predicate = (cue) => cue.type === MetadataSchema.emsg && enableEmsgMetadataCues;
        } else {
          predicate = (cue) => cue.type === MetadataSchema.audioId3 && enableID3MetadataCues || cue.type === MetadataSchema.emsg && enableEmsgMetadataCues;
        }
        removeCuesInRange(id3Track, startOffset, endOffset, predicate);
      }
    }
    onLevelUpdated(event, {
      details
    }) {
      this.updateDateRangeCues(details, true);
    }
    onLevelPtsUpdated(event, data) {
      if (Math.abs(data.drift) > 0.01) {
        this.updateDateRangeCues(data.details);
      }
    }
    updateDateRangeCues(details, removeOldCues) {
      if (!this.hls || !this.media) {
        return;
      }
      const {
        assetPlayerId,
        timelineOffset,
        enableDateRangeMetadataCues,
        interstitialsController
      } = this.hls.config;
      if (!enableDateRangeMetadataCues) {
        return;
      }
      const Cue = getCueClass();
      if (assetPlayerId && timelineOffset && !interstitialsController) {
        const {
          fragmentStart,
          fragmentEnd
        } = details;
        let cue = this.assetCue;
        if (cue) {
          cue.startTime = fragmentStart;
          cue.endTime = fragmentEnd;
        } else if (Cue) {
          cue = this.assetCue = createCueWithDataFields(Cue, fragmentStart, fragmentEnd, {
            assetPlayerId: this.hls.config.assetPlayerId
          }, "hlsjs.interstitial.asset");
          if (cue) {
            cue.id = assetPlayerId;
            this.id3Track || (this.id3Track = this.createTrack(this.media));
            this.id3Track.addCue(cue);
            cue.addEventListener("enter", this.onEventCueEnter);
          }
        }
      }
      if (!details.hasProgramDateTime) {
        return;
      }
      const {
        id3Track
      } = this;
      const {
        dateRanges
      } = details;
      const ids = Object.keys(dateRanges);
      let dateRangeCuesAppended = this.dateRangeCuesAppended;
      if (id3Track && removeOldCues) {
        var _id3Track$cues;
        if ((_id3Track$cues = id3Track.cues) != null && _id3Track$cues.length) {
          const idsToRemove = Object.keys(dateRangeCuesAppended).filter((id3) => !ids.includes(id3));
          for (let i = idsToRemove.length; i--; ) {
            var _dateRangeCuesAppende;
            const id3 = idsToRemove[i];
            const cues = (_dateRangeCuesAppende = dateRangeCuesAppended[id3]) == null ? void 0 : _dateRangeCuesAppende.cues;
            delete dateRangeCuesAppended[id3];
            if (cues) {
              Object.keys(cues).forEach((key) => {
                const cue = cues[key];
                if (cue) {
                  cue.removeEventListener("enter", this.onEventCueEnter);
                  try {
                    id3Track.removeCue(cue);
                  } catch (e) {
                  }
                }
              });
            }
          }
        } else {
          dateRangeCuesAppended = this.dateRangeCuesAppended = {};
        }
      }
      const lastFragment = details.fragments[details.fragments.length - 1];
      if (ids.length === 0 || !isFiniteNumber(lastFragment == null ? void 0 : lastFragment.programDateTime)) {
        return;
      }
      this.id3Track || (this.id3Track = this.createTrack(this.media));
      for (let i = 0; i < ids.length; i++) {
        const id3 = ids[i];
        const dateRange = dateRanges[id3];
        const startTime = dateRange.startTime;
        const appendedDateRangeCues = dateRangeCuesAppended[id3];
        const cues = (appendedDateRangeCues == null ? void 0 : appendedDateRangeCues.cues) || {};
        let durationKnown = (appendedDateRangeCues == null ? void 0 : appendedDateRangeCues.durationKnown) || false;
        let endTime = MAX_CUE_ENDTIME;
        const {
          duration,
          endDate
        } = dateRange;
        if (endDate && duration !== null) {
          endTime = startTime + duration;
          durationKnown = true;
        } else if (dateRange.endOnNext && !durationKnown) {
          const nextDateRangeWithSameClass = ids.reduce((candidateDateRange, id4) => {
            if (id4 !== dateRange.id) {
              const otherDateRange = dateRanges[id4];
              if (otherDateRange.class === dateRange.class && otherDateRange.startDate > dateRange.startDate && (!candidateDateRange || dateRange.startDate < candidateDateRange.startDate)) {
                return otherDateRange;
              }
            }
            return candidateDateRange;
          }, null);
          if (nextDateRangeWithSameClass) {
            endTime = nextDateRangeWithSameClass.startTime;
            durationKnown = true;
          }
        }
        const attributes = Object.keys(dateRange.attr);
        for (let j = 0; j < attributes.length; j++) {
          const key = attributes[j];
          if (!isDateRangeCueAttribute(key)) {
            continue;
          }
          const cue = cues[key];
          if (cue) {
            if (durationKnown && !(appendedDateRangeCues != null && appendedDateRangeCues.durationKnown)) {
              cue.endTime = endTime;
            } else if (Math.abs(cue.startTime - startTime) > 0.01) {
              cue.startTime = startTime;
              cue.endTime = endTime;
            }
          } else if (Cue) {
            let data = dateRange.attr[key];
            if (isSCTE35Attribute(key)) {
              data = hexToArrayBuffer(data);
            }
            const payload = {
              key,
              data
            };
            const _cue = createCueWithDataFields(Cue, startTime, endTime, payload, MetadataSchema.dateRange);
            if (_cue) {
              _cue.id = id3;
              this.id3Track.addCue(_cue);
              cues[key] = _cue;
              if (interstitialsController) {
                if (key === "X-ASSET-LIST" || key === "X-ASSET-URL") {
                  _cue.addEventListener("enter", this.onEventCueEnter);
                }
              }
            }
          }
        }
        dateRangeCuesAppended[id3] = {
          cues,
          dateRange,
          durationKnown
        };
      }
    }
  };
  var LatencyController = class {
    constructor(hls) {
      this.hls = void 0;
      this.config = void 0;
      this.media = null;
      this.currentTime = 0;
      this.stallCount = 0;
      this._latency = null;
      this._targetLatencyUpdated = false;
      this.onTimeupdate = () => {
        const {
          media
        } = this;
        const levelDetails = this.levelDetails;
        if (!media || !levelDetails) {
          return;
        }
        this.currentTime = media.currentTime;
        const latency = this.computeLatency();
        if (latency === null) {
          return;
        }
        this._latency = latency;
        const {
          lowLatencyMode,
          maxLiveSyncPlaybackRate
        } = this.config;
        if (!lowLatencyMode || maxLiveSyncPlaybackRate === 1 || !levelDetails.live) {
          return;
        }
        const targetLatency = this.targetLatency;
        if (targetLatency === null) {
          return;
        }
        const distanceFromTarget = latency - targetLatency;
        const liveMinLatencyDuration = Math.min(this.maxLatency, targetLatency + levelDetails.targetduration);
        const inLiveRange = distanceFromTarget < liveMinLatencyDuration;
        if (inLiveRange && distanceFromTarget > 0.05 && this.forwardBufferLength > 1) {
          const max = Math.min(2, Math.max(1, maxLiveSyncPlaybackRate));
          const rate = Math.round(2 / (1 + Math.exp(-0.75 * distanceFromTarget - this.edgeStalled)) * 20) / 20;
          const playbackRate = Math.min(max, Math.max(1, rate));
          this.changeMediaPlaybackRate(media, playbackRate);
        } else if (media.playbackRate !== 1 && media.playbackRate !== 0) {
          this.changeMediaPlaybackRate(media, 1);
        }
      };
      this.hls = hls;
      this.config = hls.config;
      this.registerListeners();
    }
    get levelDetails() {
      var _this$hls;
      return ((_this$hls = this.hls) == null ? void 0 : _this$hls.latestLevelDetails) || null;
    }
    get latency() {
      return this._latency || 0;
    }
    get maxLatency() {
      const {
        config: config3
      } = this;
      if (config3.liveMaxLatencyDuration !== void 0) {
        return config3.liveMaxLatencyDuration;
      }
      const levelDetails = this.levelDetails;
      return levelDetails ? config3.liveMaxLatencyDurationCount * levelDetails.targetduration : 0;
    }
    get targetLatency() {
      const levelDetails = this.levelDetails;
      if (levelDetails === null || this.hls === null) {
        return null;
      }
      const {
        holdBack,
        partHoldBack,
        targetduration
      } = levelDetails;
      const {
        liveSyncDuration,
        liveSyncDurationCount,
        lowLatencyMode
      } = this.config;
      const userConfig = this.hls.userConfig;
      let targetLatency = lowLatencyMode ? partHoldBack || holdBack : holdBack;
      if (this._targetLatencyUpdated || userConfig.liveSyncDuration || userConfig.liveSyncDurationCount || targetLatency === 0) {
        targetLatency = liveSyncDuration !== void 0 ? liveSyncDuration : liveSyncDurationCount * targetduration;
      }
      const maxLiveSyncOnStallIncrease = targetduration;
      return targetLatency + Math.min(this.stallCount * this.config.liveSyncOnStallIncrease, maxLiveSyncOnStallIncrease);
    }
    set targetLatency(latency) {
      this.stallCount = 0;
      this.config.liveSyncDuration = latency;
      this._targetLatencyUpdated = true;
    }
    get liveSyncPosition() {
      const liveEdge = this.estimateLiveEdge();
      const targetLatency = this.targetLatency;
      if (liveEdge === null || targetLatency === null) {
        return null;
      }
      const levelDetails = this.levelDetails;
      if (levelDetails === null) {
        return null;
      }
      const edge = levelDetails.edge;
      const syncPosition = liveEdge - targetLatency - this.edgeStalled;
      const min = edge - levelDetails.totalduration;
      const max = edge - (this.config.lowLatencyMode && levelDetails.partTarget || levelDetails.targetduration);
      return Math.min(Math.max(min, syncPosition), max);
    }
    get drift() {
      const levelDetails = this.levelDetails;
      if (levelDetails === null) {
        return 1;
      }
      return levelDetails.drift;
    }
    get edgeStalled() {
      const levelDetails = this.levelDetails;
      if (levelDetails === null) {
        return 0;
      }
      const maxLevelUpdateAge = (this.config.lowLatencyMode && levelDetails.partTarget || levelDetails.targetduration) * 3;
      return Math.max(levelDetails.age - maxLevelUpdateAge, 0);
    }
    get forwardBufferLength() {
      const {
        media
      } = this;
      const levelDetails = this.levelDetails;
      if (!media || !levelDetails) {
        return 0;
      }
      const bufferedRanges = media.buffered.length;
      return (bufferedRanges ? media.buffered.end(bufferedRanges - 1) : levelDetails.edge) - this.currentTime;
    }
    destroy() {
      this.unregisterListeners();
      this.onMediaDetaching();
      this.hls = null;
    }
    registerListeners() {
      const {
        hls
      } = this;
      if (!hls) {
        return;
      }
      hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
      hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
      hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);
      hls.on(Events.ERROR, this.onError, this);
    }
    unregisterListeners() {
      const {
        hls
      } = this;
      if (!hls) {
        return;
      }
      hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
      hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
      hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);
      hls.off(Events.ERROR, this.onError, this);
    }
    onMediaAttached(event, data) {
      this.media = data.media;
      this.media.addEventListener("timeupdate", this.onTimeupdate);
    }
    onMediaDetaching() {
      if (this.media) {
        this.media.removeEventListener("timeupdate", this.onTimeupdate);
        this.media = null;
      }
    }
    onManifestLoading() {
      this._latency = null;
      this.stallCount = 0;
    }
    onLevelUpdated(event, {
      details
    }) {
      if (details.advanced) {
        this.onTimeupdate();
      }
      if (!details.live && this.media) {
        this.media.removeEventListener("timeupdate", this.onTimeupdate);
      }
    }
    onError(event, data) {
      var _this$levelDetails;
      if (data.details !== ErrorDetails.BUFFER_STALLED_ERROR) {
        return;
      }
      this.stallCount++;
      if (this.hls && (_this$levelDetails = this.levelDetails) != null && _this$levelDetails.live) {
        this.hls.logger.warn("[latency-controller]: Stall detected, adjusting target latency");
      }
    }
    changeMediaPlaybackRate(media, playbackRate) {
      var _this$hls2, _this$targetLatency;
      if (media.playbackRate === playbackRate) {
        return;
      }
      (_this$hls2 = this.hls) == null || _this$hls2.logger.debug(`[latency-controller]: latency=${this.latency.toFixed(3)}, targetLatency=${(_this$targetLatency = this.targetLatency) == null ? void 0 : _this$targetLatency.toFixed(3)}, forwardBufferLength=${this.forwardBufferLength.toFixed(3)}: adjusting playback rate from ${media.playbackRate} to ${playbackRate}`);
      media.playbackRate = playbackRate;
    }
    estimateLiveEdge() {
      const levelDetails = this.levelDetails;
      if (levelDetails === null) {
        return null;
      }
      return levelDetails.edge + levelDetails.age;
    }
    computeLatency() {
      const liveEdge = this.estimateLiveEdge();
      if (liveEdge === null) {
        return null;
      }
      return liveEdge - this.currentTime;
    }
  };
  var LevelController = class extends BasePlaylistController {
    constructor(hls, contentSteeringController) {
      super(hls, "level-controller");
      this._levels = [];
      this._firstLevel = -1;
      this._maxAutoLevel = -1;
      this._startLevel = void 0;
      this.currentLevel = null;
      this.currentLevelIndex = -1;
      this.manualLevelIndex = -1;
      this.steering = void 0;
      this.onParsedComplete = void 0;
      this.steering = contentSteeringController;
      this._registerListeners();
    }
    _registerListeners() {
      const {
        hls
      } = this;
      hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);
      hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);
      hls.on(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);
      hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);
      hls.on(Events.ERROR, this.onError, this);
    }
    _unregisterListeners() {
      const {
        hls
      } = this;
      hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);
      hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);
      hls.off(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);
      hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);
      hls.off(Events.ERROR, this.onError, this);
    }
    destroy() {
      this._unregisterListeners();
      this.steering = null;
      this.resetLevels();
      super.destroy();
    }
    stopLoad() {
      const levels = this._levels;
      levels.forEach((level) => {
        level.loadError = 0;
        level.fragmentError = 0;
      });
      super.stopLoad();
    }
    resetLevels() {
      this._startLevel = void 0;
      this.manualLevelIndex = -1;
      this.currentLevelIndex = -1;
      this.currentLevel = null;
      this._levels = [];
      this._maxAutoLevel = -1;
    }
    onManifestLoading(event, data) {
      this.resetLevels();
    }
    onManifestLoaded(event, data) {
      const preferManagedMediaSource = this.hls.config.preferManagedMediaSource;
      const levels = [];
      const redundantSet = {};
      const generatePathwaySet = {};
      let resolutionFound = false;
      let videoCodecFound = false;
      let audioCodecFound = false;
      data.levels.forEach((levelParsed) => {
        const attributes = levelParsed.attrs;
        let {
          audioCodec,
          videoCodec
        } = levelParsed;
        if (audioCodec) {
          levelParsed.audioCodec = audioCodec = getCodecCompatibleName(audioCodec, preferManagedMediaSource) || void 0;
        }
        if (videoCodec) {
          videoCodec = levelParsed.videoCodec = convertAVC1ToAVCOTI(videoCodec);
        }
        const {
          width,
          height,
          unknownCodecs
        } = levelParsed;
        const unknownUnsupportedCodecCount = (unknownCodecs == null ? void 0 : unknownCodecs.length) || 0;
        resolutionFound || (resolutionFound = !!(width && height));
        videoCodecFound || (videoCodecFound = !!videoCodec);
        audioCodecFound || (audioCodecFound = !!audioCodec);
        if (unknownUnsupportedCodecCount || audioCodec && !this.isAudioSupported(audioCodec) || videoCodec && !this.isVideoSupported(videoCodec)) {
          this.log(`Some or all CODECS not supported "${attributes.CODECS}"`);
          return;
        }
        const {
          CODECS,
          "FRAME-RATE": FRAMERATE,
          "HDCP-LEVEL": HDCP,
          "PATHWAY-ID": PATHWAY,
          RESOLUTION,
          "VIDEO-RANGE": VIDEO_RANGE
        } = attributes;
        const contentSteeringPrefix = `${PATHWAY || "."}-`;
        const levelKey = `${contentSteeringPrefix}${levelParsed.bitrate}-${RESOLUTION}-${FRAMERATE}-${CODECS}-${VIDEO_RANGE}-${HDCP}`;
        if (!redundantSet[levelKey]) {
          const level = this.createLevel(levelParsed);
          redundantSet[levelKey] = level;
          generatePathwaySet[levelKey] = 1;
          levels.push(level);
        } else if (redundantSet[levelKey].uri !== levelParsed.url && !levelParsed.attrs["PATHWAY-ID"]) {
          const pathwayCount = generatePathwaySet[levelKey] += 1;
          levelParsed.attrs["PATHWAY-ID"] = new Array(pathwayCount + 1).join(".");
          const level = this.createLevel(levelParsed);
          redundantSet[levelKey] = level;
          levels.push(level);
        } else {
          redundantSet[levelKey].addGroupId("audio", attributes.AUDIO);
          redundantSet[levelKey].addGroupId("text", attributes.SUBTITLES);
        }
      });
      this.filterAndSortMediaOptions(levels, data, resolutionFound, videoCodecFound, audioCodecFound);
    }
    createLevel(levelParsed) {
      const level = new Level(levelParsed);
      const supplemental = levelParsed.supplemental;
      if (supplemental != null && supplemental.videoCodec && !this.isVideoSupported(supplemental.videoCodec)) {
        const error = new Error(`SUPPLEMENTAL-CODECS not supported "${supplemental.videoCodec}"`);
        this.log(error.message);
        level.supportedResult = getUnsupportedResult(error, []);
      }
      return level;
    }
    isAudioSupported(codec) {
      return areCodecsMediaSourceSupported(codec, "audio", this.hls.config.preferManagedMediaSource);
    }
    isVideoSupported(codec) {
      return areCodecsMediaSourceSupported(codec, "video", this.hls.config.preferManagedMediaSource);
    }
    filterAndSortMediaOptions(filteredLevels, data, resolutionFound, videoCodecFound, audioCodecFound) {
      var _data$stats;
      let audioTracks = [];
      let subtitleTracks = [];
      let levels = filteredLevels;
      const statsParsing = ((_data$stats = data.stats) == null ? void 0 : _data$stats.parsing) || {};
      if ((resolutionFound || videoCodecFound) && audioCodecFound) {
        levels = levels.filter(({
          videoCodec,
          videoRange,
          width,
          height
        }) => (!!videoCodec || !!(width && height)) && isVideoRange(videoRange));
      }
      if (levels.length === 0) {
        Promise.resolve().then(() => {
          if (this.hls) {
            let message = "no level with compatible codecs found in manifest";
            let reason = message;
            if (data.levels.length) {
              reason = `one or more CODECS in variant not supported: ${stringify(data.levels.map((level) => level.attrs.CODECS).filter((value, index, array) => array.indexOf(value) === index))}`;
              this.warn(reason);
              message += ` (${reason})`;
            }
            const error = new Error(message);
            this.hls.trigger(Events.ERROR, {
              type: ErrorTypes.MEDIA_ERROR,
              details: ErrorDetails.MANIFEST_INCOMPATIBLE_CODECS_ERROR,
              fatal: true,
              url: data.url,
              error,
              reason
            });
          }
        });
        statsParsing.end = performance.now();
        return;
      }
      if (data.audioTracks) {
        audioTracks = data.audioTracks.filter((track) => !track.audioCodec || this.isAudioSupported(track.audioCodec));
        assignTrackIdsByGroup(audioTracks);
      }
      if (data.subtitles) {
        subtitleTracks = data.subtitles;
        assignTrackIdsByGroup(subtitleTracks);
      }
      const unsortedLevels = levels.slice(0);
      levels.sort((a, b) => {
        if (a.attrs["HDCP-LEVEL"] !== b.attrs["HDCP-LEVEL"]) {
          return (a.attrs["HDCP-LEVEL"] || "") > (b.attrs["HDCP-LEVEL"] || "") ? 1 : -1;
        }
        if (resolutionFound && a.height !== b.height) {
          return a.height - b.height;
        }
        if (a.frameRate !== b.frameRate) {
          return a.frameRate - b.frameRate;
        }
        if (a.videoRange !== b.videoRange) {
          return VideoRangeValues.indexOf(a.videoRange) - VideoRangeValues.indexOf(b.videoRange);
        }
        if (a.videoCodec !== b.videoCodec) {
          const valueA = videoCodecPreferenceValue(a.videoCodec);
          const valueB = videoCodecPreferenceValue(b.videoCodec);
          if (valueA !== valueB) {
            return valueB - valueA;
          }
        }
        if (a.uri === b.uri && a.codecSet !== b.codecSet) {
          const valueA = codecsSetSelectionPreferenceValue(a.codecSet);
          const valueB = codecsSetSelectionPreferenceValue(b.codecSet);
          if (valueA !== valueB) {
            return valueB - valueA;
          }
        }
        if (a.averageBitrate !== b.averageBitrate) {
          return a.averageBitrate - b.averageBitrate;
        }
        return 0;
      });
      let firstLevelInPlaylist = unsortedLevels[0];
      if (this.steering) {
        levels = this.steering.filterParsedLevels(levels);
        if (levels.length !== unsortedLevels.length) {
          for (let i = 0; i < unsortedLevels.length; i++) {
            if (unsortedLevels[i].pathwayId === levels[0].pathwayId) {
              firstLevelInPlaylist = unsortedLevels[i];
              break;
            }
          }
        }
      }
      this._levels = levels;
      for (let i = 0; i < levels.length; i++) {
        if (levels[i] === firstLevelInPlaylist) {
          var _this$hls$userConfig;
          this._firstLevel = i;
          const firstLevelBitrate = firstLevelInPlaylist.bitrate;
          const bandwidthEstimate = this.hls.bandwidthEstimate;
          this.log(`manifest loaded, ${levels.length} level(s) found, first bitrate: ${firstLevelBitrate}`);
          if (((_this$hls$userConfig = this.hls.userConfig) == null ? void 0 : _this$hls$userConfig.abrEwmaDefaultEstimate) === void 0) {
            const startingBwEstimate = Math.min(firstLevelBitrate, this.hls.config.abrEwmaDefaultEstimateMax);
            if (startingBwEstimate > bandwidthEstimate && bandwidthEstimate === this.hls.abrEwmaDefaultEstimate) {
              this.hls.bandwidthEstimate = startingBwEstimate;
            }
          }
          break;
        }
      }
      const audioOnly = audioCodecFound && !videoCodecFound;
      const config3 = this.hls.config;
      const altAudioEnabled = !!(config3.audioStreamController && config3.audioTrackController);
      const edata = {
        levels,
        audioTracks,
        subtitleTracks,
        sessionData: data.sessionData,
        sessionKeys: data.sessionKeys,
        firstLevel: this._firstLevel,
        stats: data.stats,
        audio: audioCodecFound,
        video: videoCodecFound,
        altAudio: altAudioEnabled && !audioOnly && audioTracks.some((t) => !!t.url)
      };
      statsParsing.end = performance.now();
      this.hls.trigger(Events.MANIFEST_PARSED, edata);
    }
    get levels() {
      if (this._levels.length === 0) {
        return null;
      }
      return this._levels;
    }
    get loadLevelObj() {
      return this.currentLevel;
    }
    get level() {
      return this.currentLevelIndex;
    }
    set level(newLevel) {
      const levels = this._levels;
      if (levels.length === 0) {
        return;
      }
      if (newLevel < 0 || newLevel >= levels.length) {
        const error = new Error("invalid level idx");
        const fatal = newLevel < 0;
        this.hls.trigger(Events.ERROR, {
          type: ErrorTypes.OTHER_ERROR,
          details: ErrorDetails.LEVEL_SWITCH_ERROR,
          level: newLevel,
          fatal,
          error,
          reason: error.message
        });
        if (fatal) {
          return;
        }
        newLevel = Math.min(newLevel, levels.length - 1);
      }
      const lastLevelIndex = this.currentLevelIndex;
      const lastLevel = this.currentLevel;
      const lastPathwayId = lastLevel ? lastLevel.attrs["PATHWAY-ID"] : void 0;
      const level = levels[newLevel];
      const pathwayId = level.attrs["PATHWAY-ID"];
      this.currentLevelIndex = newLevel;
      this.currentLevel = level;
      if (lastLevelIndex === newLevel && lastLevel && lastPathwayId === pathwayId) {
        return;
      }
      this.log(`Switching to level ${newLevel} (${level.height ? level.height + "p " : ""}${level.videoRange ? level.videoRange + " " : ""}${level.codecSet ? level.codecSet + " " : ""}@${level.bitrate})${pathwayId ? " with Pathway " + pathwayId : ""} from level ${lastLevelIndex}${lastPathwayId ? " with Pathway " + lastPathwayId : ""}`);
      const levelSwitchingData = {
        level: newLevel,
        attrs: level.attrs,
        details: level.details,
        bitrate: level.bitrate,
        averageBitrate: level.averageBitrate,
        maxBitrate: level.maxBitrate,
        realBitrate: level.realBitrate,
        width: level.width,
        height: level.height,
        codecSet: level.codecSet,
        audioCodec: level.audioCodec,
        videoCodec: level.videoCodec,
        audioGroups: level.audioGroups,
        subtitleGroups: level.subtitleGroups,
        loaded: level.loaded,
        loadError: level.loadError,
        fragmentError: level.fragmentError,
        name: level.name,
        id: level.id,
        uri: level.uri,
        url: level.url,
        urlId: 0,
        audioGroupIds: level.audioGroupIds,
        textGroupIds: level.textGroupIds
      };
      this.hls.trigger(Events.LEVEL_SWITCHING, levelSwitchingData);
      const levelDetails = level.details;
      if (!levelDetails || levelDetails.live) {
        const hlsUrlParameters = this.switchParams(level.uri, lastLevel == null ? void 0 : lastLevel.details, levelDetails);
        this.loadPlaylist(hlsUrlParameters);
      }
    }
    get manualLevel() {
      return this.manualLevelIndex;
    }
    set manualLevel(newLevel) {
      this.manualLevelIndex = newLevel;
      if (this._startLevel === void 0) {
        this._startLevel = newLevel;
      }
      if (newLevel !== -1) {
        this.level = newLevel;
      }
    }
    get firstLevel() {
      return this._firstLevel;
    }
    set firstLevel(newLevel) {
      this._firstLevel = newLevel;
    }
    get startLevel() {
      if (this._startLevel === void 0) {
        const configStartLevel = this.hls.config.startLevel;
        if (configStartLevel !== void 0) {
          return configStartLevel;
        }
        return this.hls.firstAutoLevel;
      }
      return this._startLevel;
    }
    set startLevel(newLevel) {
      this._startLevel = newLevel;
    }
    get pathways() {
      if (this.steering) {
        return this.steering.pathways();
      }
      return [];
    }
    get pathwayPriority() {
      if (this.steering) {
        return this.steering.pathwayPriority;
      }
      return null;
    }
    set pathwayPriority(pathwayPriority) {
      if (this.steering) {
        const pathwaysList = this.steering.pathways();
        const filteredPathwayPriority = pathwayPriority.filter((pathwayId) => {
          return pathwaysList.indexOf(pathwayId) !== -1;
        });
        if (pathwayPriority.length < 1) {
          this.warn(`pathwayPriority ${pathwayPriority} should contain at least one pathway from list: ${pathwaysList}`);
          return;
        }
        this.steering.pathwayPriority = filteredPathwayPriority;
      }
    }
    onError(event, data) {
      if (data.fatal || !data.context) {
        return;
      }
      if (data.context.type === PlaylistContextType.LEVEL && data.context.level === this.level) {
        this.checkRetry(data);
      }
    }
    // reset errors on the successful load of a fragment
    onFragBuffered(event, {
      frag
    }) {
      if (frag !== void 0 && frag.type === PlaylistLevelType.MAIN) {
        const el = frag.elementaryStreams;
        if (!Object.keys(el).some((type) => !!el[type])) {
          return;
        }
        const level = this._levels[frag.level];
        if (level != null && level.loadError) {
          this.log(`Resetting level error count of ${level.loadError} on frag buffered`);
          level.loadError = 0;
        }
      }
    }
    onLevelLoaded(event, data) {
      var _data$deliveryDirecti2;
      const {
        level,
        details
      } = data;
      const curLevel = data.levelInfo;
      if (!curLevel) {
        var _data$deliveryDirecti;
        this.warn(`Invalid level index ${level}`);
        if ((_data$deliveryDirecti = data.deliveryDirectives) != null && _data$deliveryDirecti.skip) {
          details.deltaUpdateFailed = true;
        }
        return;
      }
      if (curLevel === this.currentLevel || data.withoutMultiVariant) {
        if (curLevel.fragmentError === 0) {
          curLevel.loadError = 0;
        }
        let previousDetails = curLevel.details;
        if (previousDetails === data.details && previousDetails.advanced) {
          previousDetails = void 0;
        }
        this.playlistLoaded(level, data, previousDetails);
      } else if ((_data$deliveryDirecti2 = data.deliveryDirectives) != null && _data$deliveryDirecti2.skip) {
        details.deltaUpdateFailed = true;
      }
    }
    loadPlaylist(hlsUrlParameters) {
      super.loadPlaylist();
      if (this.shouldLoadPlaylist(this.currentLevel)) {
        this.scheduleLoading(this.currentLevel, hlsUrlParameters);
      }
    }
    loadingPlaylist(currentLevel, hlsUrlParameters) {
      super.loadingPlaylist(currentLevel, hlsUrlParameters);
      const url = this.getUrlWithDirectives(currentLevel.uri, hlsUrlParameters);
      const currentLevelIndex = this.currentLevelIndex;
      const pathwayId = currentLevel.attrs["PATHWAY-ID"];
      const details = currentLevel.details;
      const age = details == null ? void 0 : details.age;
      this.log(`Loading level index ${currentLevelIndex}${(hlsUrlParameters == null ? void 0 : hlsUrlParameters.msn) !== void 0 ? " at sn " + hlsUrlParameters.msn + " part " + hlsUrlParameters.part : ""}${pathwayId ? " Pathway " + pathwayId : ""}${age && details.live ? " age " + age.toFixed(1) + (details.type ? " " + details.type || "" : "") : ""} ${url}`);
      this.hls.trigger(Events.LEVEL_LOADING, {
        url,
        level: currentLevelIndex,
        levelInfo: currentLevel,
        pathwayId: currentLevel.attrs["PATHWAY-ID"],
        id: 0,
        // Deprecated Level urlId
        deliveryDirectives: hlsUrlParameters || null
      });
    }
    get nextLoadLevel() {
      if (this.manualLevelIndex !== -1) {
        return this.manualLevelIndex;
      } else {
        return this.hls.nextAutoLevel;
      }
    }
    set nextLoadLevel(nextLevel) {
      this.level = nextLevel;
      if (this.manualLevelIndex === -1) {
        this.hls.nextAutoLevel = nextLevel;
      }
    }
    removeLevel(levelIndex) {
      var _this$currentLevel;
      if (this._levels.length === 1) {
        return;
      }
      const levels = this._levels.filter((level, index) => {
        if (index !== levelIndex) {
          return true;
        }
        if (this.steering) {
          this.steering.removeLevel(level);
        }
        if (level === this.currentLevel) {
          this.currentLevel = null;
          this.currentLevelIndex = -1;
          if (level.details) {
            level.details.fragments.forEach((f) => f.level = -1);
          }
        }
        return false;
      });
      reassignFragmentLevelIndexes(levels);
      this._levels = levels;
      if (this.currentLevelIndex > -1 && (_this$currentLevel = this.currentLevel) != null && _this$currentLevel.details) {
        this.currentLevelIndex = this.currentLevel.details.fragments[0].level;
      }
      if (this.manualLevelIndex > -1) {
        this.manualLevelIndex = this.currentLevelIndex;
      }
      const maxLevel = levels.length - 1;
      this._firstLevel = Math.min(this._firstLevel, maxLevel);
      if (this._startLevel) {
        this._startLevel = Math.min(this._startLevel, maxLevel);
      }
      this.hls.trigger(Events.LEVELS_UPDATED, {
        levels
      });
    }
    onLevelsUpdated(event, {
      levels
    }) {
      this._levels = levels;
    }
    checkMaxAutoUpdated() {
      const {
        autoLevelCapping,
        maxAutoLevel,
        maxHdcpLevel
      } = this.hls;
      if (this._maxAutoLevel !== maxAutoLevel) {
        this._maxAutoLevel = maxAutoLevel;
        this.hls.trigger(Events.MAX_AUTO_LEVEL_UPDATED, {
          autoLevelCapping,
          levels: this.levels,
          maxAutoLevel,
          minAutoLevel: this.hls.minAutoLevel,
          maxHdcpLevel
        });
      }
    }
  };
  function assignTrackIdsByGroup(tracks) {
    const groups = {};
    tracks.forEach((track) => {
      const groupId = track.groupId || "";
      track.id = groups[groupId] = groups[groupId] || 0;
      groups[groupId]++;
    });
  }
  function getSourceBuffer() {
    return self.SourceBuffer || self.WebKitSourceBuffer;
  }
  function isMSESupported() {
    const mediaSource = getMediaSource();
    if (!mediaSource) {
      return false;
    }
    const sourceBuffer = getSourceBuffer();
    return !sourceBuffer || sourceBuffer.prototype && typeof sourceBuffer.prototype.appendBuffer === "function" && typeof sourceBuffer.prototype.remove === "function";
  }
  function isSupported() {
    if (!isMSESupported()) {
      return false;
    }
    const mediaSource = getMediaSource();
    return typeof (mediaSource == null ? void 0 : mediaSource.isTypeSupported) === "function" && (["avc1.42E01E,mp4a.40.2", "av01.0.01M.08", "vp09.00.50.08"].some((codecsForVideoContainer) => mediaSource.isTypeSupported(mimeTypeForCodec(codecsForVideoContainer, "video"))) || ["mp4a.40.2", "fLaC"].some((codecForAudioContainer) => mediaSource.isTypeSupported(mimeTypeForCodec(codecForAudioContainer, "audio"))));
  }
  function changeTypeSupported() {
    var _sourceBuffer$prototy;
    const sourceBuffer = getSourceBuffer();
    return typeof (sourceBuffer == null || (_sourceBuffer$prototy = sourceBuffer.prototype) == null ? void 0 : _sourceBuffer$prototy.changeType) === "function";
  }
  var TICK_INTERVAL = 100;
  var StreamController = class extends BaseStreamController {
    constructor(hls, fragmentTracker, keyLoader) {
      super(hls, fragmentTracker, keyLoader, "stream-controller", PlaylistLevelType.MAIN);
      this.audioCodecSwap = false;
      this.level = -1;
      this._forceStartLoad = false;
      this._hasEnoughToStart = false;
      this.altAudio = 0;
      this.audioOnly = false;
      this.fragPlaying = null;
      this.fragLastKbps = 0;
      this.couldBacktrack = false;
      this.backtrackFragment = null;
      this.audioCodecSwitch = false;
      this.videoBuffer = null;
      this.onMediaPlaying = () => {
        this.tick();
      };
      this.onMediaSeeked = () => {
        const media = this.media;
        const currentTime = media ? media.currentTime : null;
        if (currentTime === null || !isFiniteNumber(currentTime)) {
          return;
        }
        this.log(`Media seeked to ${currentTime.toFixed(3)}`);
        if (!this.getBufferedFrag(currentTime)) {
          return;
        }
        const bufferInfo = this.getFwdBufferInfoAtPos(media, currentTime, PlaylistLevelType.MAIN, 0);
        if (bufferInfo === null || bufferInfo.len === 0) {
          this.warn(`Main forward buffer length at ${currentTime} on "seeked" event ${bufferInfo ? bufferInfo.len : "empty"})`);
          return;
        }
        this.tick();
      };
      this.registerListeners();
    }
    registerListeners() {
      super.registerListeners();
      const {
        hls
      } = this;
      hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);
      hls.on(Events.LEVEL_LOADING, this.onLevelLoading, this);
      hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);
      hls.on(Events.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this);
      hls.on(Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);
      hls.on(Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this);
      hls.on(Events.BUFFER_CREATED, this.onBufferCreated, this);
      hls.on(Events.BUFFER_FLUSHED, this.onBufferFlushed, this);
      hls.on(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);
      hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);
    }
    unregisterListeners() {
      super.unregisterListeners();
      const {
        hls
      } = this;
      hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);
      hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);
      hls.off(Events.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this);
      hls.off(Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);
      hls.off(Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this);
      hls.off(Events.BUFFER_CREATED, this.onBufferCreated, this);
      hls.off(Events.BUFFER_FLUSHED, this.onBufferFlushed, this);
      hls.off(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);
      hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);
    }
    onHandlerDestroying() {
      this.onMediaPlaying = this.onMediaSeeked = null;
      this.unregisterListeners();
      super.onHandlerDestroying();
    }
    startLoad(startPosition, skipSeekToStartPosition) {
      if (this.levels) {
        const {
          lastCurrentTime,
          hls
        } = this;
        this.stopLoad();
        this.setInterval(TICK_INTERVAL);
        this.level = -1;
        if (!this.startFragRequested) {
          let startLevel = hls.startLevel;
          if (startLevel === -1) {
            if (hls.config.testBandwidth && this.levels.length > 1) {
              startLevel = 0;
              this.bitrateTest = true;
            } else {
              startLevel = hls.firstAutoLevel;
            }
          }
          hls.nextLoadLevel = startLevel;
          this.level = hls.loadLevel;
          this._hasEnoughToStart = !!skipSeekToStartPosition;
        }
        if (lastCurrentTime > 0 && startPosition === -1 && !skipSeekToStartPosition) {
          this.log(`Override startPosition with lastCurrentTime @${lastCurrentTime.toFixed(3)}`);
          startPosition = lastCurrentTime;
        }
        this.state = State.IDLE;
        this.nextLoadPosition = this.lastCurrentTime = startPosition + this.timelineOffset;
        this.startPosition = skipSeekToStartPosition ? -1 : startPosition;
        this.tick();
      } else {
        this._forceStartLoad = true;
        this.state = State.STOPPED;
      }
    }
    stopLoad() {
      this._forceStartLoad = false;
      super.stopLoad();
    }
    doTick() {
      switch (this.state) {
        case State.WAITING_LEVEL: {
          const {
            levels,
            level
          } = this;
          const currentLevel = levels == null ? void 0 : levels[level];
          const details = currentLevel == null ? void 0 : currentLevel.details;
          if (details && (!details.live || this.levelLastLoaded === currentLevel && !this.waitForLive(currentLevel))) {
            if (this.waitForCdnTuneIn(details)) {
              break;
            }
            this.state = State.IDLE;
            break;
          } else if (this.hls.nextLoadLevel !== this.level) {
            this.state = State.IDLE;
            break;
          }
          break;
        }
        case State.FRAG_LOADING_WAITING_RETRY:
          this.checkRetryDate();
          break;
      }
      if (this.state === State.IDLE) {
        this.doTickIdle();
      }
      this.onTickEnd();
    }
    onTickEnd() {
      var _this$media;
      super.onTickEnd();
      if ((_this$media = this.media) != null && _this$media.readyState && this.media.seeking === false) {
        this.lastCurrentTime = this.media.currentTime;
      }
      this.checkFragmentChanged();
    }
    doTickIdle() {
      const {
        hls,
        levelLastLoaded,
        levels,
        media
      } = this;
      if (levelLastLoaded === null || !media && !this.primaryPrefetch && (this.startFragRequested || !hls.config.startFragPrefetch)) {
        return;
      }
      if (this.altAudio && this.audioOnly) {
        return;
      }
      const level = this.buffering ? hls.nextLoadLevel : hls.loadLevel;
      if (!(levels != null && levels[level])) {
        return;
      }
      const levelInfo = levels[level];
      const bufferInfo = this.getMainFwdBufferInfo();
      if (bufferInfo === null) {
        return;
      }
      const lastDetails = this.getLevelDetails();
      if (lastDetails && this._streamEnded(bufferInfo, lastDetails)) {
        const data = {};
        if (this.altAudio === 2) {
          data.type = "video";
        }
        this.hls.trigger(Events.BUFFER_EOS, data);
        this.state = State.ENDED;
        return;
      }
      if (!this.buffering) {
        return;
      }
      if (hls.loadLevel !== level && hls.manualLevel === -1) {
        this.log(`Adapting to level ${level} from level ${this.level}`);
      }
      this.level = hls.nextLoadLevel = level;
      const levelDetails = levelInfo.details;
      if (!levelDetails || this.state === State.WAITING_LEVEL || this.waitForLive(levelInfo)) {
        this.level = level;
        this.state = State.WAITING_LEVEL;
        this.startFragRequested = false;
        return;
      }
      const bufferLen = bufferInfo.len;
      const maxBufLen = this.getMaxBufferLength(levelInfo.maxBitrate);
      if (bufferLen >= maxBufLen) {
        return;
      }
      if (this.backtrackFragment && this.backtrackFragment.start > bufferInfo.end) {
        this.backtrackFragment = null;
      }
      const targetBufferTime = this.backtrackFragment ? this.backtrackFragment.start : bufferInfo.end;
      let frag = this.getNextFragment(targetBufferTime, levelDetails);
      if (this.couldBacktrack && !this.fragPrevious && frag && isMediaFragment(frag) && this.fragmentTracker.getState(frag) !== FragmentState.OK) {
        var _this$backtrackFragme;
        const backtrackSn = ((_this$backtrackFragme = this.backtrackFragment) != null ? _this$backtrackFragme : frag).sn;
        const fragIdx = backtrackSn - levelDetails.startSN;
        const backtrackFrag = levelDetails.fragments[fragIdx - 1];
        if (backtrackFrag && frag.cc === backtrackFrag.cc) {
          frag = backtrackFrag;
          this.fragmentTracker.removeFragment(backtrackFrag);
        }
      } else if (this.backtrackFragment && bufferInfo.len) {
        this.backtrackFragment = null;
      }
      if (frag && this.isLoopLoading(frag, targetBufferTime)) {
        const gapStart = frag.gap;
        if (!gapStart) {
          const type = this.audioOnly && !this.altAudio ? ElementaryStreamTypes.AUDIO : ElementaryStreamTypes.VIDEO;
          const mediaBuffer = (type === ElementaryStreamTypes.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;
          if (mediaBuffer) {
            this.afterBufferFlushed(mediaBuffer, type, PlaylistLevelType.MAIN);
          }
        }
        frag = this.getNextFragmentLoopLoading(frag, levelDetails, bufferInfo, PlaylistLevelType.MAIN, maxBufLen);
      }
      if (!frag) {
        return;
      }
      if (frag.initSegment && !frag.initSegment.data && !this.bitrateTest) {
        frag = frag.initSegment;
      }
      this.loadFragment(frag, levelInfo, targetBufferTime);
    }
    loadFragment(frag, level, targetBufferTime) {
      const fragState = this.fragmentTracker.getState(frag);
      if (fragState === FragmentState.NOT_LOADED || fragState === FragmentState.PARTIAL) {
        if (!isMediaFragment(frag)) {
          this._loadInitSegment(frag, level);
        } else if (this.bitrateTest) {
          this.log(`Fragment ${frag.sn} of level ${frag.level} is being downloaded to test bitrate and will not be buffered`);
          this._loadBitrateTestFrag(frag, level);
        } else {
          super.loadFragment(frag, level, targetBufferTime);
        }
      } else {
        this.clearTrackerIfNeeded(frag);
      }
    }
    getBufferedFrag(position) {
      return this.fragmentTracker.getBufferedFrag(position, PlaylistLevelType.MAIN);
    }
    followingBufferedFrag(frag) {
      if (frag) {
        return this.getBufferedFrag(frag.end + 0.5);
      }
      return null;
    }
    /*
      on immediate level switch :
       - pause playback if playing
       - cancel any pending load request
       - and trigger a buffer flush
    */
    immediateLevelSwitch() {
      this.abortCurrentFrag();
      this.flushMainBuffer(0, Number.POSITIVE_INFINITY);
    }
    /**
     * try to switch ASAP without breaking video playback:
     * in order to ensure smooth but quick level switching,
     * we need to find the next flushable buffer range
     * we should take into account new segment fetch time
     */
    nextLevelSwitch() {
      const {
        levels,
        media
      } = this;
      if (media != null && media.readyState) {
        let fetchdelay;
        const fragPlayingCurrent = this.getAppendedFrag(media.currentTime);
        if (fragPlayingCurrent && fragPlayingCurrent.start > 1) {
          this.flushMainBuffer(0, fragPlayingCurrent.start - 1);
        }
        const levelDetails = this.getLevelDetails();
        if (levelDetails != null && levelDetails.live) {
          const bufferInfo = this.getMainFwdBufferInfo();
          if (!bufferInfo || bufferInfo.len < levelDetails.targetduration * 2) {
            return;
          }
        }
        if (!media.paused && levels) {
          const nextLevelId = this.hls.nextLoadLevel;
          const nextLevel = levels[nextLevelId];
          const fragLastKbps = this.fragLastKbps;
          if (fragLastKbps && this.fragCurrent) {
            fetchdelay = this.fragCurrent.duration * nextLevel.maxBitrate / (1e3 * fragLastKbps) + 1;
          } else {
            fetchdelay = 0;
          }
        } else {
          fetchdelay = 0;
        }
        const bufferedFrag = this.getBufferedFrag(media.currentTime + fetchdelay);
        if (bufferedFrag) {
          const nextBufferedFrag = this.followingBufferedFrag(bufferedFrag);
          if (nextBufferedFrag) {
            this.abortCurrentFrag();
            const maxStart = nextBufferedFrag.maxStartPTS ? nextBufferedFrag.maxStartPTS : nextBufferedFrag.start;
            const fragDuration = nextBufferedFrag.duration;
            const startPts = Math.max(bufferedFrag.end, maxStart + Math.min(Math.max(fragDuration - this.config.maxFragLookUpTolerance, fragDuration * (this.couldBacktrack ? 0.5 : 0.125)), fragDuration * (this.couldBacktrack ? 0.75 : 0.25)));
            this.flushMainBuffer(startPts, Number.POSITIVE_INFINITY);
          }
        }
      }
    }
    abortCurrentFrag() {
      const fragCurrent = this.fragCurrent;
      this.fragCurrent = null;
      this.backtrackFragment = null;
      if (fragCurrent) {
        fragCurrent.abortRequests();
        this.fragmentTracker.removeFragment(fragCurrent);
      }
      switch (this.state) {
        case State.KEY_LOADING:
        case State.FRAG_LOADING:
        case State.FRAG_LOADING_WAITING_RETRY:
        case State.PARSING:
        case State.PARSED:
          this.state = State.IDLE;
          break;
      }
      this.nextLoadPosition = this.getLoadPosition();
    }
    flushMainBuffer(startOffset, endOffset) {
      super.flushMainBuffer(startOffset, endOffset, this.altAudio === 2 ? "video" : null);
    }
    onMediaAttached(event, data) {
      super.onMediaAttached(event, data);
      const media = data.media;
      addEventListener(media, "playing", this.onMediaPlaying);
      addEventListener(media, "seeked", this.onMediaSeeked);
    }
    onMediaDetaching(event, data) {
      const {
        media
      } = this;
      if (media) {
        removeEventListener(media, "playing", this.onMediaPlaying);
        removeEventListener(media, "seeked", this.onMediaSeeked);
      }
      this.videoBuffer = null;
      this.fragPlaying = null;
      super.onMediaDetaching(event, data);
      const transferringMedia = !!data.transferMedia;
      if (transferringMedia) {
        return;
      }
      this._hasEnoughToStart = false;
    }
    onManifestLoading() {
      super.onManifestLoading();
      this.log("Trigger BUFFER_RESET");
      this.hls.trigger(Events.BUFFER_RESET, void 0);
      this.couldBacktrack = false;
      this.fragLastKbps = 0;
      this.fragPlaying = this.backtrackFragment = null;
      this.altAudio = 0;
      this.audioOnly = false;
    }
    onManifestParsed(event, data) {
      let aac = false;
      let heaac = false;
      for (let i = 0; i < data.levels.length; i++) {
        const codec = data.levels[i].audioCodec;
        if (codec) {
          aac = aac || codec.indexOf("mp4a.40.2") !== -1;
          heaac = heaac || codec.indexOf("mp4a.40.5") !== -1;
        }
      }
      this.audioCodecSwitch = aac && heaac && !changeTypeSupported();
      if (this.audioCodecSwitch) {
        this.log("Both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC");
      }
      this.levels = data.levels;
      this.startFragRequested = false;
    }
    onLevelLoading(event, data) {
      const {
        levels
      } = this;
      if (!levels || this.state !== State.IDLE) {
        return;
      }
      const level = data.levelInfo;
      if (!level.details || level.details.live && (this.levelLastLoaded !== level || level.details.expired) || this.waitForCdnTuneIn(level.details)) {
        this.state = State.WAITING_LEVEL;
      }
    }
    onLevelLoaded(event, data) {
      var _curLevel$details;
      const {
        levels,
        startFragRequested
      } = this;
      const newLevelId = data.level;
      const newDetails = data.details;
      const duration = newDetails.totalduration;
      if (!levels) {
        this.warn(`Levels were reset while loading level ${newLevelId}`);
        return;
      }
      this.log(`Level ${newLevelId} loaded [${newDetails.startSN},${newDetails.endSN}]${newDetails.lastPartSn ? `[part-${newDetails.lastPartSn}-${newDetails.lastPartIndex}]` : ""}, cc [${newDetails.startCC}, ${newDetails.endCC}] duration:${duration}`);
      const curLevel = data.levelInfo;
      const fragCurrent = this.fragCurrent;
      if (fragCurrent && (this.state === State.FRAG_LOADING || this.state === State.FRAG_LOADING_WAITING_RETRY)) {
        if (fragCurrent.level !== data.level && fragCurrent.loader) {
          this.abortCurrentFrag();
        }
      }
      let sliding = 0;
      if (newDetails.live || (_curLevel$details = curLevel.details) != null && _curLevel$details.live) {
        var _this$levelLastLoaded;
        this.checkLiveUpdate(newDetails);
        if (newDetails.deltaUpdateFailed) {
          return;
        }
        sliding = this.alignPlaylists(newDetails, curLevel.details, (_this$levelLastLoaded = this.levelLastLoaded) == null ? void 0 : _this$levelLastLoaded.details);
      }
      curLevel.details = newDetails;
      this.levelLastLoaded = curLevel;
      if (!startFragRequested) {
        this.setStartPosition(newDetails, sliding);
      }
      this.hls.trigger(Events.LEVEL_UPDATED, {
        details: newDetails,
        level: newLevelId
      });
      if (this.state === State.WAITING_LEVEL) {
        if (this.waitForCdnTuneIn(newDetails)) {
          return;
        }
        this.state = State.IDLE;
      }
      if (startFragRequested && newDetails.live) {
        this.synchronizeToLiveEdge(newDetails);
      }
      this.tick();
    }
    synchronizeToLiveEdge(levelDetails) {
      const {
        config: config3,
        media
      } = this;
      if (!media) {
        return;
      }
      const liveSyncPosition = this.hls.liveSyncPosition;
      const currentTime = this.getLoadPosition();
      const start = levelDetails.fragmentStart;
      const end = levelDetails.edge;
      const withinSlidingWindow = currentTime >= start - config3.maxFragLookUpTolerance && currentTime <= end;
      if (liveSyncPosition !== null && media.duration > liveSyncPosition && (currentTime < liveSyncPosition || !withinSlidingWindow)) {
        const maxLatency = config3.liveMaxLatencyDuration !== void 0 ? config3.liveMaxLatencyDuration : config3.liveMaxLatencyDurationCount * levelDetails.targetduration;
        if (!withinSlidingWindow && media.readyState < 4 || currentTime < end - maxLatency) {
          if (!this._hasEnoughToStart) {
            this.nextLoadPosition = liveSyncPosition;
          }
          if (media.readyState) {
            this.warn(`Playback: ${currentTime.toFixed(3)} is located too far from the end of live sliding playlist: ${end}, reset currentTime to : ${liveSyncPosition.toFixed(3)}`);
            if (this.config.liveSyncMode === "buffered") {
              var _bufferInfo$buffered;
              const bufferInfo = BufferHelper.bufferInfo(media, liveSyncPosition, 0);
              if (!((_bufferInfo$buffered = bufferInfo.buffered) != null && _bufferInfo$buffered.length)) {
                media.currentTime = liveSyncPosition;
                return;
              }
              const isLiveSyncInBuffer = bufferInfo.start <= currentTime;
              if (isLiveSyncInBuffer) {
                media.currentTime = liveSyncPosition;
                return;
              }
              const {
                nextStart
              } = BufferHelper.bufferedInfo(bufferInfo.buffered, currentTime, 0);
              if (nextStart) {
                media.currentTime = nextStart;
              }
            } else {
              media.currentTime = liveSyncPosition;
            }
          }
        }
      }
    }
    _handleFragmentLoadProgress(data) {
      var _frag$initSegment;
      const frag = data.frag;
      const {
        part,
        payload
      } = data;
      const {
        levels
      } = this;
      if (!levels) {
        this.warn(`Levels were reset while fragment load was in progress. Fragment ${frag.sn} of level ${frag.level} will not be buffered`);
        return;
      }
      const currentLevel = levels[frag.level];
      if (!currentLevel) {
        this.warn(`Level ${frag.level} not found on progress`);
        return;
      }
      const details = currentLevel.details;
      if (!details) {
        this.warn(`Dropping fragment ${frag.sn} of level ${frag.level} after level details were reset`);
        this.fragmentTracker.removeFragment(frag);
        return;
      }
      const videoCodec = currentLevel.videoCodec;
      const accurateTimeOffset = details.PTSKnown || !details.live;
      const initSegmentData = (_frag$initSegment = frag.initSegment) == null ? void 0 : _frag$initSegment.data;
      const audioCodec = this._getAudioCodec(currentLevel);
      const transmuxer = this.transmuxer = this.transmuxer || new TransmuxerInterface(this.hls, PlaylistLevelType.MAIN, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this));
      const partIndex = part ? part.index : -1;
      const partial = partIndex !== -1;
      const chunkMeta = new ChunkMetadata(frag.level, frag.sn, frag.stats.chunkCount, payload.byteLength, partIndex, partial);
      const initPTS = this.initPTS[frag.cc];
      transmuxer.push(payload, initSegmentData, audioCodec, videoCodec, frag, part, details.totalduration, accurateTimeOffset, chunkMeta, initPTS);
    }
    onAudioTrackSwitching(event, data) {
      const hls = this.hls;
      const fromAltAudio = this.altAudio === 2;
      const altAudio = useAlternateAudio(data.url, hls);
      if (!altAudio) {
        if (this.mediaBuffer !== this.media) {
          this.log("Switching on main audio, use media.buffered to schedule main fragment loading");
          this.mediaBuffer = this.media;
          const fragCurrent = this.fragCurrent;
          if (fragCurrent) {
            this.log("Switching to main audio track, cancel main fragment load");
            fragCurrent.abortRequests();
            this.fragmentTracker.removeFragment(fragCurrent);
          }
          this.resetTransmuxer();
          this.resetLoadingState();
        } else if (this.audioOnly) {
          this.resetTransmuxer();
        }
        if (fromAltAudio) {
          this.fragmentTracker.removeAllFragments();
          hls.once(Events.BUFFER_FLUSHED, () => {
            if (!this.hls) {
              return;
            }
            this.hls.trigger(Events.AUDIO_TRACK_SWITCHED, data);
          });
          hls.trigger(Events.BUFFER_FLUSHING, {
            startOffset: 0,
            endOffset: Number.POSITIVE_INFINITY,
            type: null
          });
          return;
        }
        hls.trigger(Events.AUDIO_TRACK_SWITCHED, data);
      } else {
        this.altAudio = 1;
      }
    }
    onAudioTrackSwitched(event, data) {
      const altAudio = useAlternateAudio(data.url, this.hls);
      if (altAudio) {
        const videoBuffer = this.videoBuffer;
        if (videoBuffer && this.mediaBuffer !== videoBuffer) {
          this.log("Switching on alternate audio, use video.buffered to schedule main fragment loading");
          this.mediaBuffer = videoBuffer;
        }
      }
      this.altAudio = altAudio ? 2 : 0;
      this.tick();
    }
    onBufferCreated(event, data) {
      const tracks = data.tracks;
      let mediaTrack;
      let name;
      let alternate = false;
      for (const type in tracks) {
        const track = tracks[type];
        if (track.id === "main") {
          name = type;
          mediaTrack = track;
          if (type === "video") {
            const videoTrack = tracks[type];
            if (videoTrack) {
              this.videoBuffer = videoTrack.buffer;
            }
          }
        } else {
          alternate = true;
        }
      }
      if (alternate && mediaTrack) {
        this.log(`Alternate track found, use ${name}.buffered to schedule main fragment loading`);
        this.mediaBuffer = mediaTrack.buffer;
      } else {
        this.mediaBuffer = this.media;
      }
    }
    onFragBuffered(event, data) {
      const {
        frag,
        part
      } = data;
      const bufferedMainFragment = frag.type === PlaylistLevelType.MAIN;
      if (bufferedMainFragment) {
        if (this.fragContextChanged(frag)) {
          this.warn(`Fragment ${frag.sn}${part ? " p: " + part.index : ""} of level ${frag.level} finished buffering, but was aborted. state: ${this.state}`);
          if (this.state === State.PARSED) {
            this.state = State.IDLE;
          }
          return;
        }
        const stats = part ? part.stats : frag.stats;
        this.fragLastKbps = Math.round(8 * stats.total / (stats.buffering.end - stats.loading.first));
        if (isMediaFragment(frag)) {
          this.fragPrevious = frag;
        }
        this.fragBufferedComplete(frag, part);
      }
      const media = this.media;
      if (!media) {
        return;
      }
      if (!this._hasEnoughToStart && BufferHelper.getBuffered(media).length) {
        this._hasEnoughToStart = true;
        this.seekToStartPos();
      }
      if (bufferedMainFragment) {
        this.tick();
      }
    }
    get hasEnoughToStart() {
      return this._hasEnoughToStart;
    }
    onError(event, data) {
      var _data$context;
      if (data.fatal) {
        this.state = State.ERROR;
        return;
      }
      switch (data.details) {
        case ErrorDetails.FRAG_GAP:
        case ErrorDetails.FRAG_PARSING_ERROR:
        case ErrorDetails.FRAG_DECRYPT_ERROR:
        case ErrorDetails.FRAG_LOAD_ERROR:
        case ErrorDetails.FRAG_LOAD_TIMEOUT:
        case ErrorDetails.KEY_LOAD_ERROR:
        case ErrorDetails.KEY_LOAD_TIMEOUT:
          this.onFragmentOrKeyLoadError(PlaylistLevelType.MAIN, data);
          break;
        case ErrorDetails.LEVEL_LOAD_ERROR:
        case ErrorDetails.LEVEL_LOAD_TIMEOUT:
        case ErrorDetails.LEVEL_PARSING_ERROR:
          if (!data.levelRetry && this.state === State.WAITING_LEVEL && ((_data$context = data.context) == null ? void 0 : _data$context.type) === PlaylistContextType.LEVEL) {
            this.state = State.IDLE;
          }
          break;
        case ErrorDetails.BUFFER_ADD_CODEC_ERROR:
        case ErrorDetails.BUFFER_APPEND_ERROR:
          if (data.parent !== "main") {
            return;
          }
          if (this.reduceLengthAndFlushBuffer(data)) {
            this.resetLoadingState();
          }
          break;
        case ErrorDetails.BUFFER_FULL_ERROR:
          if (data.parent !== "main") {
            return;
          }
          if (this.reduceLengthAndFlushBuffer(data)) {
            const isAssetPlayer = !this.config.interstitialsController && this.config.assetPlayerId;
            if (isAssetPlayer) {
              this._hasEnoughToStart = true;
            } else {
              this.flushMainBuffer(0, Number.POSITIVE_INFINITY);
            }
          }
          break;
        case ErrorDetails.INTERNAL_EXCEPTION:
          this.recoverWorkerError(data);
          break;
      }
    }
    onFragLoadEmergencyAborted() {
      this.state = State.IDLE;
      if (!this._hasEnoughToStart) {
        this.startFragRequested = false;
        this.nextLoadPosition = this.lastCurrentTime;
      }
      this.tickImmediate();
    }
    onBufferFlushed(event, {
      type
    }) {
      if (type !== ElementaryStreamTypes.AUDIO || !this.altAudio) {
        const mediaBuffer = (type === ElementaryStreamTypes.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;
        if (mediaBuffer) {
          this.afterBufferFlushed(mediaBuffer, type, PlaylistLevelType.MAIN);
          this.tick();
        }
      }
    }
    onLevelsUpdated(event, data) {
      if (this.level > -1 && this.fragCurrent) {
        this.level = this.fragCurrent.level;
        if (this.level === -1) {
          this.resetWhenMissingContext(this.fragCurrent);
        }
      }
      this.levels = data.levels;
    }
    swapAudioCodec() {
      this.audioCodecSwap = !this.audioCodecSwap;
    }
    /**
     * Seeks to the set startPosition if not equal to the mediaElement's current time.
     */
    seekToStartPos() {
      const {
        media
      } = this;
      if (!media) {
        return;
      }
      const currentTime = media.currentTime;
      let startPosition = this.startPosition;
      if (startPosition >= 0 && currentTime < startPosition) {
        if (media.seeking) {
          this.log(`could not seek to ${startPosition}, already seeking at ${currentTime}`);
          return;
        }
        const timelineOffset = this.timelineOffset;
        if (timelineOffset && startPosition) {
          startPosition += timelineOffset;
        }
        const details = this.getLevelDetails();
        const buffered = BufferHelper.getBuffered(media);
        const bufferStart = buffered.length ? buffered.start(0) : 0;
        const delta = bufferStart - startPosition;
        const skipTolerance = Math.max(this.config.maxBufferHole, this.config.maxFragLookUpTolerance);
        if (this.config.startOnSegmentBoundary || delta > 0 && (delta < skipTolerance || this.loadingParts && delta < 2 * ((details == null ? void 0 : details.partTarget) || 0))) {
          this.log(`adjusting start position by ${delta} to match buffer start`);
          startPosition += delta;
          this.startPosition = startPosition;
        }
        if (currentTime < startPosition) {
          this.log(`seek to target start position ${startPosition} from current time ${currentTime} buffer start ${bufferStart}`);
          media.currentTime = startPosition;
        }
      }
    }
    _getAudioCodec(currentLevel) {
      let audioCodec = this.config.defaultAudioCodec || currentLevel.audioCodec;
      if (this.audioCodecSwap && audioCodec) {
        this.log("Swapping audio codec");
        if (audioCodec.indexOf("mp4a.40.5") !== -1) {
          audioCodec = "mp4a.40.2";
        } else {
          audioCodec = "mp4a.40.5";
        }
      }
      return audioCodec;
    }
    _loadBitrateTestFrag(fragment, level) {
      fragment.bitrateTest = true;
      this._doFragLoad(fragment, level).then((data) => {
        const {
          hls
        } = this;
        const frag = data == null ? void 0 : data.frag;
        if (!frag || this.fragContextChanged(frag)) {
          return;
        }
        level.fragmentError = 0;
        this.state = State.IDLE;
        this.startFragRequested = false;
        this.bitrateTest = false;
        const stats = frag.stats;
        stats.parsing.start = stats.parsing.end = stats.buffering.start = stats.buffering.end = self.performance.now();
        hls.trigger(Events.FRAG_LOADED, data);
        frag.bitrateTest = false;
      }).catch((reason) => {
        if (this.state === State.STOPPED || this.state === State.ERROR) {
          return;
        }
        this.warn(reason);
        this.resetFragmentLoading(fragment);
      });
    }
    _handleTransmuxComplete(transmuxResult) {
      const id3 = this.playlistType;
      const {
        hls
      } = this;
      const {
        remuxResult,
        chunkMeta
      } = transmuxResult;
      const context3 = this.getCurrentContext(chunkMeta);
      if (!context3) {
        this.resetWhenMissingContext(chunkMeta);
        return;
      }
      const {
        frag,
        part,
        level
      } = context3;
      const {
        video,
        text,
        id3: id32,
        initSegment
      } = remuxResult;
      const {
        details
      } = level;
      const audio = this.altAudio ? void 0 : remuxResult.audio;
      if (this.fragContextChanged(frag)) {
        this.fragmentTracker.removeFragment(frag);
        return;
      }
      this.state = State.PARSING;
      if (initSegment) {
        const tracks = initSegment.tracks;
        if (tracks) {
          const mapFragment = frag.initSegment || frag;
          if (this.unhandledEncryptionError(initSegment, frag)) {
            return;
          }
          this._bufferInitSegment(level, tracks, mapFragment, chunkMeta);
          hls.trigger(Events.FRAG_PARSING_INIT_SEGMENT, {
            frag: mapFragment,
            id: id3,
            tracks
          });
        }
        const baseTime = initSegment.initPTS;
        const timescale = initSegment.timescale;
        const initPTS = this.initPTS[frag.cc];
        if (isFiniteNumber(baseTime) && (!initPTS || initPTS.baseTime !== baseTime || initPTS.timescale !== timescale)) {
          const trackId = initSegment.trackId;
          this.initPTS[frag.cc] = {
            baseTime,
            timescale,
            trackId
          };
          hls.trigger(Events.INIT_PTS_FOUND, {
            frag,
            id: id3,
            initPTS: baseTime,
            timescale,
            trackId
          });
        }
      }
      if (video && details) {
        if (audio && video.type === "audiovideo") {
          this.logMuxedErr(frag);
        }
        const prevFrag = details.fragments[frag.sn - 1 - details.startSN];
        const isFirstFragment = frag.sn === details.startSN;
        const isFirstInDiscontinuity = !prevFrag || frag.cc > prevFrag.cc;
        if (remuxResult.independent !== false) {
          const {
            startPTS,
            endPTS,
            startDTS,
            endDTS
          } = video;
          if (part) {
            part.elementaryStreams[video.type] = {
              startPTS,
              endPTS,
              startDTS,
              endDTS
            };
          } else {
            if (video.firstKeyFrame && video.independent && chunkMeta.id === 1 && !isFirstInDiscontinuity) {
              this.couldBacktrack = true;
            }
            if (video.dropped && video.independent) {
              const bufferInfo = this.getMainFwdBufferInfo();
              const targetBufferTime = (bufferInfo ? bufferInfo.end : this.getLoadPosition()) + this.config.maxBufferHole;
              const startTime = video.firstKeyFramePTS ? video.firstKeyFramePTS : startPTS;
              if (!isFirstFragment && targetBufferTime < startTime - this.config.maxBufferHole && !isFirstInDiscontinuity) {
                this.backtrack(frag);
                return;
              } else if (isFirstInDiscontinuity) {
                frag.gap = true;
              }
              frag.setElementaryStreamInfo(video.type, frag.start, endPTS, frag.start, endDTS, true);
            } else if (isFirstFragment && startPTS - (details.appliedTimelineOffset || 0) > MAX_START_GAP_JUMP) {
              frag.gap = true;
            }
          }
          frag.setElementaryStreamInfo(video.type, startPTS, endPTS, startDTS, endDTS);
          if (this.backtrackFragment) {
            this.backtrackFragment = frag;
          }
          this.bufferFragmentData(video, frag, part, chunkMeta, isFirstFragment || isFirstInDiscontinuity);
        } else if (isFirstFragment || isFirstInDiscontinuity) {
          frag.gap = true;
        } else {
          this.backtrack(frag);
          return;
        }
      }
      if (audio) {
        const {
          startPTS,
          endPTS,
          startDTS,
          endDTS
        } = audio;
        if (part) {
          part.elementaryStreams[ElementaryStreamTypes.AUDIO] = {
            startPTS,
            endPTS,
            startDTS,
            endDTS
          };
        }
        frag.setElementaryStreamInfo(ElementaryStreamTypes.AUDIO, startPTS, endPTS, startDTS, endDTS);
        this.bufferFragmentData(audio, frag, part, chunkMeta);
      }
      if (details && id32 != null && id32.samples.length) {
        const emittedID3 = {
          id: id3,
          frag,
          details,
          samples: id32.samples
        };
        hls.trigger(Events.FRAG_PARSING_METADATA, emittedID3);
      }
      if (details && text) {
        const emittedText = {
          id: id3,
          frag,
          details,
          samples: text.samples
        };
        hls.trigger(Events.FRAG_PARSING_USERDATA, emittedText);
      }
    }
    logMuxedErr(frag) {
      this.warn(`${isMediaFragment(frag) ? "Media" : "Init"} segment with muxed audiovideo where only video expected: ${frag.url}`);
    }
    _bufferInitSegment(currentLevel, tracks, frag, chunkMeta) {
      if (this.state !== State.PARSING) {
        return;
      }
      this.audioOnly = !!tracks.audio && !tracks.video;
      if (this.altAudio && !this.audioOnly) {
        delete tracks.audio;
        if (tracks.audiovideo) {
          this.logMuxedErr(frag);
        }
      }
      const {
        audio,
        video,
        audiovideo
      } = tracks;
      if (audio) {
        const levelCodec = currentLevel.audioCodec;
        let audioCodec = pickMostCompleteCodecName(audio.codec, levelCodec);
        if (audioCodec === "mp4a") {
          audioCodec = "mp4a.40.5";
        }
        const ua = navigator.userAgent.toLowerCase();
        if (this.audioCodecSwitch) {
          if (audioCodec) {
            if (audioCodec.indexOf("mp4a.40.5") !== -1) {
              audioCodec = "mp4a.40.2";
            } else {
              audioCodec = "mp4a.40.5";
            }
          }
          const audioMetadata = audio.metadata;
          if (audioMetadata && "channelCount" in audioMetadata && (audioMetadata.channelCount || 1) !== 1 && ua.indexOf("firefox") === -1) {
            audioCodec = "mp4a.40.5";
          }
        }
        if (audioCodec && audioCodec.indexOf("mp4a.40.5") !== -1 && ua.indexOf("android") !== -1 && audio.container !== "audio/mpeg") {
          audioCodec = "mp4a.40.2";
          this.log(`Android: force audio codec to ${audioCodec}`);
        }
        if (levelCodec && levelCodec !== audioCodec) {
          this.log(`Swapping manifest audio codec "${levelCodec}" for "${audioCodec}"`);
        }
        audio.levelCodec = audioCodec;
        audio.id = PlaylistLevelType.MAIN;
        this.log(`Init audio buffer, container:${audio.container}, codecs[selected/level/parsed]=[${audioCodec || ""}/${levelCodec || ""}/${audio.codec}]`);
        delete tracks.audiovideo;
      }
      if (video) {
        video.levelCodec = currentLevel.videoCodec;
        video.id = PlaylistLevelType.MAIN;
        const parsedVideoCodec = video.codec;
        if ((parsedVideoCodec == null ? void 0 : parsedVideoCodec.length) === 4) {
          switch (parsedVideoCodec) {
            case "hvc1":
            case "hev1":
              video.codec = "hvc1.1.6.L120.90";
              break;
            case "av01":
              video.codec = "av01.0.04M.08";
              break;
            case "avc1":
              video.codec = "avc1.42e01e";
              break;
          }
        }
        this.log(`Init video buffer, container:${video.container}, codecs[level/parsed]=[${currentLevel.videoCodec || ""}/${parsedVideoCodec}]${video.codec !== parsedVideoCodec ? " parsed-corrected=" + video.codec : ""}${video.supplemental ? " supplemental=" + video.supplemental : ""}`);
        delete tracks.audiovideo;
      }
      if (audiovideo) {
        this.log(`Init audiovideo buffer, container:${audiovideo.container}, codecs[level/parsed]=[${currentLevel.codecs}/${audiovideo.codec}]`);
        delete tracks.video;
        delete tracks.audio;
      }
      const trackTypes = Object.keys(tracks);
      if (trackTypes.length) {
        this.hls.trigger(Events.BUFFER_CODECS, tracks);
        if (!this.hls) {
          return;
        }
        trackTypes.forEach((trackName) => {
          const track = tracks[trackName];
          const initSegment = track.initSegment;
          if (initSegment != null && initSegment.byteLength) {
            this.hls.trigger(Events.BUFFER_APPENDING, {
              type: trackName,
              data: initSegment,
              frag,
              part: null,
              chunkMeta,
              parent: frag.type
            });
          }
        });
      }
      this.tickImmediate();
    }
    getMainFwdBufferInfo() {
      const bufferOutput = this.mediaBuffer && this.altAudio === 2 ? this.mediaBuffer : this.media;
      return this.getFwdBufferInfo(bufferOutput, PlaylistLevelType.MAIN);
    }
    get maxBufferLength() {
      const {
        levels,
        level
      } = this;
      const levelInfo = levels == null ? void 0 : levels[level];
      if (!levelInfo) {
        return this.config.maxBufferLength;
      }
      return this.getMaxBufferLength(levelInfo.maxBitrate);
    }
    backtrack(frag) {
      this.couldBacktrack = true;
      this.backtrackFragment = frag;
      this.resetTransmuxer();
      this.flushBufferGap(frag);
      this.fragmentTracker.removeFragment(frag);
      this.fragPrevious = null;
      this.nextLoadPosition = frag.start;
      this.state = State.IDLE;
    }
    checkFragmentChanged() {
      const video = this.media;
      let fragPlayingCurrent = null;
      if (video && video.readyState > 1 && video.seeking === false) {
        const currentTime = video.currentTime;
        if (BufferHelper.isBuffered(video, currentTime)) {
          fragPlayingCurrent = this.getAppendedFrag(currentTime);
        } else if (BufferHelper.isBuffered(video, currentTime + 0.1)) {
          fragPlayingCurrent = this.getAppendedFrag(currentTime + 0.1);
        }
        if (fragPlayingCurrent) {
          this.backtrackFragment = null;
          const fragPlaying = this.fragPlaying;
          const fragCurrentLevel = fragPlayingCurrent.level;
          if (!fragPlaying || fragPlayingCurrent.sn !== fragPlaying.sn || fragPlaying.level !== fragCurrentLevel) {
            this.fragPlaying = fragPlayingCurrent;
            this.hls.trigger(Events.FRAG_CHANGED, {
              frag: fragPlayingCurrent
            });
            if (!fragPlaying || fragPlaying.level !== fragCurrentLevel) {
              this.hls.trigger(Events.LEVEL_SWITCHED, {
                level: fragCurrentLevel
              });
            }
          }
        }
      }
    }
    get nextLevel() {
      const frag = this.nextBufferedFrag;
      if (frag) {
        return frag.level;
      }
      return -1;
    }
    get currentFrag() {
      var _this$media2;
      if (this.fragPlaying) {
        return this.fragPlaying;
      }
      const currentTime = ((_this$media2 = this.media) == null ? void 0 : _this$media2.currentTime) || this.lastCurrentTime;
      if (isFiniteNumber(currentTime)) {
        return this.getAppendedFrag(currentTime);
      }
      return null;
    }
    get currentProgramDateTime() {
      var _this$media3;
      const currentTime = ((_this$media3 = this.media) == null ? void 0 : _this$media3.currentTime) || this.lastCurrentTime;
      if (isFiniteNumber(currentTime)) {
        const details = this.getLevelDetails();
        const frag = this.currentFrag || (details ? findFragmentByPTS(null, details.fragments, currentTime) : null);
        if (frag) {
          const programDateTime = frag.programDateTime;
          if (programDateTime !== null) {
            const epocMs = programDateTime + (currentTime - frag.start) * 1e3;
            return new Date(epocMs);
          }
        }
      }
      return null;
    }
    get currentLevel() {
      const frag = this.currentFrag;
      if (frag) {
        return frag.level;
      }
      return -1;
    }
    get nextBufferedFrag() {
      const frag = this.currentFrag;
      if (frag) {
        return this.followingBufferedFrag(frag);
      }
      return null;
    }
    get forceStartLoad() {
      return this._forceStartLoad;
    }
  };
  var KeyLoader = class extends Logger {
    constructor(config3, logger2) {
      super("key-loader", logger2);
      this.config = void 0;
      this.keyIdToKeyInfo = {};
      this.emeController = null;
      this.config = config3;
    }
    abort(type) {
      for (const id3 in this.keyIdToKeyInfo) {
        const loader = this.keyIdToKeyInfo[id3].loader;
        if (loader) {
          var _loader$context;
          if (type && type !== ((_loader$context = loader.context) == null ? void 0 : _loader$context.frag.type)) {
            return;
          }
          loader.abort();
        }
      }
    }
    detach() {
      for (const id3 in this.keyIdToKeyInfo) {
        const keyInfo = this.keyIdToKeyInfo[id3];
        if (keyInfo.mediaKeySessionContext || keyInfo.decryptdata.isCommonEncryption) {
          delete this.keyIdToKeyInfo[id3];
        }
      }
    }
    destroy() {
      this.detach();
      for (const id3 in this.keyIdToKeyInfo) {
        const loader = this.keyIdToKeyInfo[id3].loader;
        if (loader) {
          loader.destroy();
        }
      }
      this.keyIdToKeyInfo = {};
    }
    createKeyLoadError(frag, details = ErrorDetails.KEY_LOAD_ERROR, error, networkDetails, response) {
      return new LoadError({
        type: ErrorTypes.NETWORK_ERROR,
        details,
        fatal: false,
        frag,
        response,
        error,
        networkDetails
      });
    }
    loadClear(loadingFrag, encryptedFragments, startFragRequested) {
      if (this.emeController && this.config.emeEnabled && !this.emeController.getSelectedKeySystemFormats().length) {
        if (encryptedFragments.length) {
          for (let i = 0, l = encryptedFragments.length; i < l; i++) {
            const frag = encryptedFragments[i];
            if (loadingFrag.cc <= frag.cc && (!isMediaFragment(loadingFrag) || !isMediaFragment(frag) || loadingFrag.sn < frag.sn) || !startFragRequested && i == l - 1) {
              return this.emeController.selectKeySystemFormat(frag).then((keySystemFormat) => {
                if (!this.emeController) {
                  return;
                }
                frag.setKeyFormat(keySystemFormat);
                const keySystem = keySystemFormatToKeySystemDomain(keySystemFormat);
                if (keySystem) {
                  return this.emeController.getKeySystemAccess([keySystem]);
                }
              });
            }
          }
        }
        if (this.config.requireKeySystemAccessOnStart) {
          const keySystemsInConfig = getKeySystemsForConfig(this.config);
          if (keySystemsInConfig.length) {
            return this.emeController.getKeySystemAccess(keySystemsInConfig);
          }
        }
      }
      return null;
    }
    load(frag) {
      if (!frag.decryptdata && frag.encrypted && this.emeController && this.config.emeEnabled) {
        return this.emeController.selectKeySystemFormat(frag).then((keySystemFormat) => {
          return this.loadInternal(frag, keySystemFormat);
        });
      }
      return this.loadInternal(frag);
    }
    loadInternal(frag, keySystemFormat) {
      var _keyInfo, _keyInfo2;
      if (keySystemFormat) {
        frag.setKeyFormat(keySystemFormat);
      }
      const decryptdata = frag.decryptdata;
      if (!decryptdata) {
        const error = new Error(keySystemFormat ? `Expected frag.decryptdata to be defined after setting format ${keySystemFormat}` : `Missing decryption data on fragment in onKeyLoading (emeEnabled with controller: ${this.emeController && this.config.emeEnabled})`);
        return Promise.reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, error));
      }
      const uri = decryptdata.uri;
      if (!uri) {
        return Promise.reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, new Error(`Invalid key URI: "${uri}"`)));
      }
      const id3 = getKeyId(decryptdata);
      let keyInfo = this.keyIdToKeyInfo[id3];
      if ((_keyInfo = keyInfo) != null && _keyInfo.decryptdata.key) {
        decryptdata.key = keyInfo.decryptdata.key;
        return Promise.resolve({
          frag,
          keyInfo
        });
      }
      if (this.emeController && (_keyInfo2 = keyInfo) != null && _keyInfo2.keyLoadPromise) {
        const keyStatus = this.emeController.getKeyStatus(keyInfo.decryptdata);
        switch (keyStatus) {
          case "usable":
          case "usable-in-future":
            return keyInfo.keyLoadPromise.then((keyLoadedData) => {
              const {
                keyInfo: keyInfo2
              } = keyLoadedData;
              decryptdata.key = keyInfo2.decryptdata.key;
              return {
                frag,
                keyInfo: keyInfo2
              };
            });
        }
      }
      this.log(`${this.keyIdToKeyInfo[id3] ? "Rel" : "L"}oading${decryptdata.keyId ? " keyId: " + arrayToHex(decryptdata.keyId) : ""} URI: ${decryptdata.uri} from ${frag.type} ${frag.level}`);
      keyInfo = this.keyIdToKeyInfo[id3] = {
        decryptdata,
        keyLoadPromise: null,
        loader: null,
        mediaKeySessionContext: null
      };
      switch (decryptdata.method) {
        case "SAMPLE-AES":
        case "SAMPLE-AES-CENC":
        case "SAMPLE-AES-CTR":
          if (decryptdata.keyFormat === "identity") {
            return this.loadKeyHTTP(keyInfo, frag);
          }
          return this.loadKeyEME(keyInfo, frag);
        case "AES-128":
        case "AES-256":
        case "AES-256-CTR":
          return this.loadKeyHTTP(keyInfo, frag);
        default:
          return Promise.reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, new Error(`Key supplied with unsupported METHOD: "${decryptdata.method}"`)));
      }
    }
    loadKeyEME(keyInfo, frag) {
      const keyLoadedData = {
        frag,
        keyInfo
      };
      if (this.emeController && this.config.emeEnabled) {
        var _frag$initSegment;
        if (!keyInfo.decryptdata.keyId && (_frag$initSegment = frag.initSegment) != null && _frag$initSegment.data) {
          const keyIds = parseKeyIdsFromTenc(frag.initSegment.data);
          if (keyIds.length) {
            const keyId = keyIds[0];
            if (keyId.some((b) => b !== 0)) {
              this.log(`Using keyId found in init segment ${arrayToHex(keyId)}`);
              keyInfo.decryptdata.keyId = keyId;
              LevelKey.setKeyIdForUri(keyInfo.decryptdata.uri, keyId);
            }
          }
        }
        const keySessionContextPromise = this.emeController.loadKey(keyLoadedData);
        return (keyInfo.keyLoadPromise = keySessionContextPromise.then((keySessionContext) => {
          keyInfo.mediaKeySessionContext = keySessionContext;
          return keyLoadedData;
        })).catch((error) => {
          keyInfo.keyLoadPromise = null;
          if ("data" in error) {
            error.data.frag = frag;
          }
          throw error;
        });
      }
      return Promise.resolve(keyLoadedData);
    }
    loadKeyHTTP(keyInfo, frag) {
      const config3 = this.config;
      const Loader = config3.loader;
      const keyLoader = new Loader(config3);
      frag.keyLoader = keyInfo.loader = keyLoader;
      return keyInfo.keyLoadPromise = new Promise((resolve, reject) => {
        const loaderContext = {
          keyInfo,
          frag,
          responseType: "arraybuffer",
          url: keyInfo.decryptdata.uri
        };
        const loadPolicy = config3.keyLoadPolicy.default;
        const loaderConfig = {
          loadPolicy,
          timeout: loadPolicy.maxLoadTimeMs,
          maxRetry: 0,
          retryDelay: 0,
          maxRetryDelay: 0
        };
        const loaderCallbacks = {
          onSuccess: (response, stats, context3, networkDetails) => {
            const {
              frag: frag2,
              keyInfo: keyInfo2
            } = context3;
            const id3 = getKeyId(keyInfo2.decryptdata);
            if (!frag2.decryptdata || keyInfo2 !== this.keyIdToKeyInfo[id3]) {
              return reject(this.createKeyLoadError(frag2, ErrorDetails.KEY_LOAD_ERROR, new Error("after key load, decryptdata unset or changed"), networkDetails));
            }
            keyInfo2.decryptdata.key = frag2.decryptdata.key = new Uint8Array(response.data);
            frag2.keyLoader = null;
            keyInfo2.loader = null;
            resolve({
              frag: frag2,
              keyInfo: keyInfo2
            });
          },
          onError: (response, context3, networkDetails, stats) => {
            this.resetLoader(context3);
            reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, new Error(`HTTP Error ${response.code} loading key ${response.text}`), networkDetails, _objectSpread2({
              url: loaderContext.url,
              data: void 0
            }, response)));
          },
          onTimeout: (stats, context3, networkDetails) => {
            this.resetLoader(context3);
            reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_TIMEOUT, new Error("key loading timed out"), networkDetails));
          },
          onAbort: (stats, context3, networkDetails) => {
            this.resetLoader(context3);
            reject(this.createKeyLoadError(frag, ErrorDetails.INTERNAL_ABORTED, new Error("key loading aborted"), networkDetails));
          }
        };
        keyLoader.load(loaderContext, loaderConfig, loaderCallbacks);
      });
    }
    resetLoader(context3) {
      const {
        frag,
        keyInfo,
        url: uri
      } = context3;
      const loader = keyInfo.loader;
      if (frag.keyLoader === loader) {
        frag.keyLoader = null;
        keyInfo.loader = null;
      }
      const id3 = getKeyId(keyInfo.decryptdata) || uri;
      delete this.keyIdToKeyInfo[id3];
      if (loader) {
        loader.destroy();
      }
    }
  };
  function getKeyId(decryptdata) {
    if (decryptdata.keyFormat !== KeySystemFormats.FAIRPLAY) {
      const keyId = decryptdata.keyId;
      if (keyId) {
        return arrayToHex(keyId);
      }
    }
    return decryptdata.uri;
  }
  function mapContextToLevelType(context3) {
    const {
      type
    } = context3;
    switch (type) {
      case PlaylistContextType.AUDIO_TRACK:
        return PlaylistLevelType.AUDIO;
      case PlaylistContextType.SUBTITLE_TRACK:
        return PlaylistLevelType.SUBTITLE;
      default:
        return PlaylistLevelType.MAIN;
    }
  }
  function getResponseUrl(response, context3) {
    let url = response.url;
    if (url === void 0 || url.indexOf("data:") === 0) {
      url = context3.url;
    }
    return url;
  }
  var PlaylistLoader = class {
    constructor(hls) {
      this.hls = void 0;
      this.loaders = /* @__PURE__ */ Object.create(null);
      this.variableList = null;
      this.onManifestLoaded = this.checkAutostartLoad;
      this.hls = hls;
      this.registerListeners();
    }
    startLoad(startPosition) {
    }
    stopLoad() {
      this.destroyInternalLoaders();
    }
    registerListeners() {
      const {
        hls
      } = this;
      hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.on(Events.LEVEL_LOADING, this.onLevelLoading, this);
      hls.on(Events.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this);
      hls.on(Events.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this);
      hls.on(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);
    }
    unregisterListeners() {
      const {
        hls
      } = this;
      hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.off(Events.LEVEL_LOADING, this.onLevelLoading, this);
      hls.off(Events.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this);
      hls.off(Events.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this);
      hls.off(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);
    }
    /**
     * Returns defaults or configured loader-type overloads (pLoader and loader config params)
     */
    createInternalLoader(context3) {
      const config3 = this.hls.config;
      const PLoader = config3.pLoader;
      const Loader = config3.loader;
      const InternalLoader = PLoader || Loader;
      const loader = new InternalLoader(config3);
      this.loaders[context3.type] = loader;
      return loader;
    }
    getInternalLoader(context3) {
      return this.loaders[context3.type];
    }
    resetInternalLoader(contextType) {
      if (this.loaders[contextType]) {
        delete this.loaders[contextType];
      }
    }
    /**
     * Call `destroy` on all internal loader instances mapped (one per context type)
     */
    destroyInternalLoaders() {
      for (const contextType in this.loaders) {
        const loader = this.loaders[contextType];
        if (loader) {
          loader.destroy();
        }
        this.resetInternalLoader(contextType);
      }
    }
    destroy() {
      this.variableList = null;
      this.unregisterListeners();
      this.destroyInternalLoaders();
    }
    onManifestLoading(event, data) {
      const {
        url
      } = data;
      this.variableList = null;
      this.load({
        id: null,
        level: 0,
        responseType: "text",
        type: PlaylistContextType.MANIFEST,
        url,
        deliveryDirectives: null,
        levelOrTrack: null
      });
    }
    onLevelLoading(event, data) {
      const {
        id: id3,
        level,
        pathwayId,
        url,
        deliveryDirectives,
        levelInfo
      } = data;
      this.load({
        id: id3,
        level,
        pathwayId,
        responseType: "text",
        type: PlaylistContextType.LEVEL,
        url,
        deliveryDirectives,
        levelOrTrack: levelInfo
      });
    }
    onAudioTrackLoading(event, data) {
      const {
        id: id3,
        groupId,
        url,
        deliveryDirectives,
        track
      } = data;
      this.load({
        id: id3,
        groupId,
        level: null,
        responseType: "text",
        type: PlaylistContextType.AUDIO_TRACK,
        url,
        deliveryDirectives,
        levelOrTrack: track
      });
    }
    onSubtitleTrackLoading(event, data) {
      const {
        id: id3,
        groupId,
        url,
        deliveryDirectives,
        track
      } = data;
      this.load({
        id: id3,
        groupId,
        level: null,
        responseType: "text",
        type: PlaylistContextType.SUBTITLE_TRACK,
        url,
        deliveryDirectives,
        levelOrTrack: track
      });
    }
    onLevelsUpdated(event, data) {
      const loader = this.loaders[PlaylistContextType.LEVEL];
      if (loader) {
        const context3 = loader.context;
        if (context3 && !data.levels.some((lvl) => lvl === context3.levelOrTrack)) {
          loader.abort();
          delete this.loaders[PlaylistContextType.LEVEL];
        }
      }
    }
    load(context3) {
      var _context$deliveryDire;
      const config3 = this.hls.config;
      let loader = this.getInternalLoader(context3);
      if (loader) {
        const logger2 = this.hls.logger;
        const loaderContext = loader.context;
        if (loaderContext && loaderContext.levelOrTrack === context3.levelOrTrack && (loaderContext.url === context3.url || loaderContext.deliveryDirectives && !context3.deliveryDirectives)) {
          if (loaderContext.url === context3.url) {
            logger2.log(`[playlist-loader]: ignore ${context3.url} ongoing request`);
          } else {
            logger2.log(`[playlist-loader]: ignore ${context3.url} in favor of ${loaderContext.url}`);
          }
          return;
        }
        logger2.log(`[playlist-loader]: aborting previous loader for type: ${context3.type}`);
        loader.abort();
      }
      let loadPolicy;
      if (context3.type === PlaylistContextType.MANIFEST) {
        loadPolicy = config3.manifestLoadPolicy.default;
      } else {
        loadPolicy = _extends4({}, config3.playlistLoadPolicy.default, {
          timeoutRetry: null,
          errorRetry: null
        });
      }
      loader = this.createInternalLoader(context3);
      if (isFiniteNumber((_context$deliveryDire = context3.deliveryDirectives) == null ? void 0 : _context$deliveryDire.part)) {
        let levelDetails;
        if (context3.type === PlaylistContextType.LEVEL && context3.level !== null) {
          levelDetails = this.hls.levels[context3.level].details;
        } else if (context3.type === PlaylistContextType.AUDIO_TRACK && context3.id !== null) {
          levelDetails = this.hls.audioTracks[context3.id].details;
        } else if (context3.type === PlaylistContextType.SUBTITLE_TRACK && context3.id !== null) {
          levelDetails = this.hls.subtitleTracks[context3.id].details;
        }
        if (levelDetails) {
          const partTarget = levelDetails.partTarget;
          const targetDuration = levelDetails.targetduration;
          if (partTarget && targetDuration) {
            const maxLowLatencyPlaylistRefresh = Math.max(partTarget * 3, targetDuration * 0.8) * 1e3;
            loadPolicy = _extends4({}, loadPolicy, {
              maxTimeToFirstByteMs: Math.min(maxLowLatencyPlaylistRefresh, loadPolicy.maxTimeToFirstByteMs),
              maxLoadTimeMs: Math.min(maxLowLatencyPlaylistRefresh, loadPolicy.maxTimeToFirstByteMs)
            });
          }
        }
      }
      const legacyRetryCompatibility = loadPolicy.errorRetry || loadPolicy.timeoutRetry || {};
      const loaderConfig = {
        loadPolicy,
        timeout: loadPolicy.maxLoadTimeMs,
        maxRetry: legacyRetryCompatibility.maxNumRetry || 0,
        retryDelay: legacyRetryCompatibility.retryDelayMs || 0,
        maxRetryDelay: legacyRetryCompatibility.maxRetryDelayMs || 0
      };
      const loaderCallbacks = {
        onSuccess: (response, stats, context4, networkDetails) => {
          const loader2 = this.getInternalLoader(context4);
          this.resetInternalLoader(context4.type);
          const string = response.data;
          stats.parsing.start = performance.now();
          if (M3U8Parser.isMediaPlaylist(string) || context4.type !== PlaylistContextType.MANIFEST) {
            this.handleTrackOrLevelPlaylist(response, stats, context4, networkDetails || null, loader2);
          } else {
            this.handleMasterPlaylist(response, stats, context4, networkDetails);
          }
        },
        onError: (response, context4, networkDetails, stats) => {
          this.handleNetworkError(context4, networkDetails, false, response, stats);
        },
        onTimeout: (stats, context4, networkDetails) => {
          this.handleNetworkError(context4, networkDetails, true, void 0, stats);
        }
      };
      loader.load(context3, loaderConfig, loaderCallbacks);
    }
    checkAutostartLoad() {
      if (!this.hls) {
        return;
      }
      const {
        config: {
          autoStartLoad,
          startPosition
        },
        forceStartLoad
      } = this.hls;
      if (autoStartLoad || forceStartLoad) {
        this.hls.logger.log(`${autoStartLoad ? "auto" : "force"} startLoad with configured startPosition ${startPosition}`);
        this.hls.startLoad(startPosition);
      }
    }
    handleMasterPlaylist(response, stats, context3, networkDetails) {
      const hls = this.hls;
      const string = response.data;
      const url = getResponseUrl(response, context3);
      const parsedResult = M3U8Parser.parseMasterPlaylist(string, url);
      if (parsedResult.playlistParsingError) {
        stats.parsing.end = performance.now();
        this.handleManifestParsingError(response, context3, parsedResult.playlistParsingError, networkDetails, stats);
        return;
      }
      const {
        contentSteering,
        levels,
        sessionData,
        sessionKeys,
        startTimeOffset,
        variableList
      } = parsedResult;
      this.variableList = variableList;
      levels.forEach((levelParsed) => {
        const {
          unknownCodecs
        } = levelParsed;
        if (unknownCodecs) {
          const {
            preferManagedMediaSource
          } = this.hls.config;
          let {
            audioCodec,
            videoCodec
          } = levelParsed;
          for (let i = unknownCodecs.length; i--; ) {
            const unknownCodec = unknownCodecs[i];
            if (areCodecsMediaSourceSupported(unknownCodec, "audio", preferManagedMediaSource)) {
              levelParsed.audioCodec = audioCodec = audioCodec ? `${audioCodec},${unknownCodec}` : unknownCodec;
              sampleEntryCodesISO.audio[audioCodec.substring(0, 4)] = 2;
              unknownCodecs.splice(i, 1);
            } else if (areCodecsMediaSourceSupported(unknownCodec, "video", preferManagedMediaSource)) {
              levelParsed.videoCodec = videoCodec = videoCodec ? `${videoCodec},${unknownCodec}` : unknownCodec;
              sampleEntryCodesISO.video[videoCodec.substring(0, 4)] = 2;
              unknownCodecs.splice(i, 1);
            }
          }
        }
      });
      const {
        AUDIO: audioTracks = [],
        SUBTITLES: subtitles,
        "CLOSED-CAPTIONS": captions
      } = M3U8Parser.parseMasterPlaylistMedia(string, url, parsedResult);
      if (audioTracks.length) {
        const embeddedAudioFound = audioTracks.some((audioTrack) => !audioTrack.url);
        if (!embeddedAudioFound && levels[0].audioCodec && !levels[0].attrs.AUDIO) {
          this.hls.logger.log("[playlist-loader]: audio codec signaled in quality level, but no embedded audio track signaled, create one");
          audioTracks.unshift({
            type: "main",
            name: "main",
            groupId: "main",
            default: false,
            autoselect: false,
            forced: false,
            id: -1,
            attrs: new AttrList({}),
            bitrate: 0,
            url: ""
          });
        }
      }
      hls.trigger(Events.MANIFEST_LOADED, {
        levels,
        audioTracks,
        subtitles,
        captions,
        contentSteering,
        url,
        stats,
        networkDetails,
        sessionData,
        sessionKeys,
        startTimeOffset,
        variableList
      });
    }
    handleTrackOrLevelPlaylist(response, stats, context3, networkDetails, loader) {
      const hls = this.hls;
      const {
        id: id3,
        level,
        type
      } = context3;
      const url = getResponseUrl(response, context3);
      const levelId = isFiniteNumber(level) ? level : isFiniteNumber(id3) ? id3 : 0;
      const levelType = mapContextToLevelType(context3);
      const levelDetails = M3U8Parser.parseLevelPlaylist(response.data, url, levelId, levelType, 0, this.variableList);
      if (type === PlaylistContextType.MANIFEST) {
        const singleLevel = {
          attrs: new AttrList({}),
          bitrate: 0,
          details: levelDetails,
          name: "",
          url
        };
        levelDetails.requestScheduled = stats.loading.start + computeReloadInterval(levelDetails, 0);
        hls.trigger(Events.MANIFEST_LOADED, {
          levels: [singleLevel],
          audioTracks: [],
          url,
          stats,
          networkDetails,
          sessionData: null,
          sessionKeys: null,
          contentSteering: null,
          startTimeOffset: null,
          variableList: null
        });
      }
      stats.parsing.end = performance.now();
      context3.levelDetails = levelDetails;
      this.handlePlaylistLoaded(levelDetails, response, stats, context3, networkDetails, loader);
    }
    handleManifestParsingError(response, context3, error, networkDetails, stats) {
      this.hls.trigger(Events.ERROR, {
        type: ErrorTypes.NETWORK_ERROR,
        details: ErrorDetails.MANIFEST_PARSING_ERROR,
        fatal: context3.type === PlaylistContextType.MANIFEST,
        url: response.url,
        err: error,
        error,
        reason: error.message,
        response,
        context: context3,
        networkDetails,
        stats
      });
    }
    handleNetworkError(context3, networkDetails, timeout = false, response, stats) {
      let message = `A network ${timeout ? "timeout" : "error" + (response ? " (status " + response.code + ")" : "")} occurred while loading ${context3.type}`;
      if (context3.type === PlaylistContextType.LEVEL) {
        message += `: ${context3.level} id: ${context3.id}`;
      } else if (context3.type === PlaylistContextType.AUDIO_TRACK || context3.type === PlaylistContextType.SUBTITLE_TRACK) {
        message += ` id: ${context3.id} group-id: "${context3.groupId}"`;
      }
      const error = new Error(message);
      this.hls.logger.warn(`[playlist-loader]: ${message}`);
      let details = ErrorDetails.UNKNOWN;
      let fatal = false;
      const loader = this.getInternalLoader(context3);
      switch (context3.type) {
        case PlaylistContextType.MANIFEST:
          details = timeout ? ErrorDetails.MANIFEST_LOAD_TIMEOUT : ErrorDetails.MANIFEST_LOAD_ERROR;
          fatal = true;
          break;
        case PlaylistContextType.LEVEL:
          details = timeout ? ErrorDetails.LEVEL_LOAD_TIMEOUT : ErrorDetails.LEVEL_LOAD_ERROR;
          fatal = false;
          break;
        case PlaylistContextType.AUDIO_TRACK:
          details = timeout ? ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT : ErrorDetails.AUDIO_TRACK_LOAD_ERROR;
          fatal = false;
          break;
        case PlaylistContextType.SUBTITLE_TRACK:
          details = timeout ? ErrorDetails.SUBTITLE_TRACK_LOAD_TIMEOUT : ErrorDetails.SUBTITLE_LOAD_ERROR;
          fatal = false;
          break;
      }
      if (loader) {
        this.resetInternalLoader(context3.type);
      }
      const errorData = {
        type: ErrorTypes.NETWORK_ERROR,
        details,
        fatal,
        url: context3.url,
        loader,
        context: context3,
        error,
        networkDetails,
        stats
      };
      if (response) {
        const url = (networkDetails == null ? void 0 : networkDetails.url) || context3.url;
        errorData.response = _objectSpread2({
          url,
          data: void 0
        }, response);
      }
      this.hls.trigger(Events.ERROR, errorData);
    }
    handlePlaylistLoaded(levelDetails, response, stats, context3, networkDetails, loader) {
      const hls = this.hls;
      const {
        type,
        level,
        levelOrTrack,
        id: id3,
        groupId,
        deliveryDirectives
      } = context3;
      const url = getResponseUrl(response, context3);
      const parent = mapContextToLevelType(context3);
      let levelIndex = typeof context3.level === "number" && parent === PlaylistLevelType.MAIN ? level : void 0;
      const error = levelDetails.playlistParsingError;
      if (error) {
        this.hls.logger.warn(`${error} ${levelDetails.url}`);
        if (!hls.config.ignorePlaylistParsingErrors) {
          hls.trigger(Events.ERROR, {
            type: ErrorTypes.NETWORK_ERROR,
            details: ErrorDetails.LEVEL_PARSING_ERROR,
            fatal: false,
            url,
            error,
            reason: error.message,
            response,
            context: context3,
            level: levelIndex,
            parent,
            networkDetails,
            stats
          });
          return;
        }
        levelDetails.playlistParsingError = null;
      }
      if (!levelDetails.fragments.length) {
        const _error = levelDetails.playlistParsingError = new Error("No Segments found in Playlist");
        hls.trigger(Events.ERROR, {
          type: ErrorTypes.NETWORK_ERROR,
          details: ErrorDetails.LEVEL_EMPTY_ERROR,
          fatal: false,
          url,
          error: _error,
          reason: _error.message,
          response,
          context: context3,
          level: levelIndex,
          parent,
          networkDetails,
          stats
        });
        return;
      }
      if (levelDetails.live && loader) {
        if (loader.getCacheAge) {
          levelDetails.ageHeader = loader.getCacheAge() || 0;
        }
        if (!loader.getCacheAge || isNaN(levelDetails.ageHeader)) {
          levelDetails.ageHeader = 0;
        }
      }
      switch (type) {
        case PlaylistContextType.MANIFEST:
        case PlaylistContextType.LEVEL:
          if (levelIndex) {
            if (!levelOrTrack) {
              levelIndex = 0;
            } else {
              if (levelOrTrack !== hls.levels[levelIndex]) {
                const updatedIndex = hls.levels.indexOf(levelOrTrack);
                if (updatedIndex > -1) {
                  levelIndex = updatedIndex;
                }
              }
            }
          }
          hls.trigger(Events.LEVEL_LOADED, {
            details: levelDetails,
            levelInfo: levelOrTrack || hls.levels[0],
            level: levelIndex || 0,
            id: id3 || 0,
            stats,
            networkDetails,
            deliveryDirectives,
            withoutMultiVariant: type === PlaylistContextType.MANIFEST
          });
          break;
        case PlaylistContextType.AUDIO_TRACK:
          hls.trigger(Events.AUDIO_TRACK_LOADED, {
            details: levelDetails,
            track: levelOrTrack,
            id: id3 || 0,
            groupId: groupId || "",
            stats,
            networkDetails,
            deliveryDirectives
          });
          break;
        case PlaylistContextType.SUBTITLE_TRACK:
          hls.trigger(Events.SUBTITLE_TRACK_LOADED, {
            details: levelDetails,
            track: levelOrTrack,
            id: id3 || 0,
            groupId: groupId || "",
            stats,
            networkDetails,
            deliveryDirectives
          });
          break;
      }
    }
  };
  var Hls = class _Hls {
    /**
     * Get the video-dev/hls.js package version.
     */
    static get version() {
      return version;
    }
    /**
     * Check if the required MediaSource Extensions are available.
     */
    static isMSESupported() {
      return isMSESupported();
    }
    /**
     * Check if MediaSource Extensions are available and isTypeSupported checks pass for any baseline codecs.
     */
    static isSupported() {
      return isSupported();
    }
    /**
     * Get the MediaSource global used for MSE playback (ManagedMediaSource, MediaSource, or WebKitMediaSource).
     */
    static getMediaSource() {
      return getMediaSource();
    }
    static get Events() {
      return Events;
    }
    static get MetadataSchema() {
      return MetadataSchema;
    }
    static get ErrorTypes() {
      return ErrorTypes;
    }
    static get ErrorDetails() {
      return ErrorDetails;
    }
    /**
     * Get the default configuration applied to new instances.
     */
    static get DefaultConfig() {
      if (!_Hls.defaultConfig) {
        return hlsDefaultConfig;
      }
      return _Hls.defaultConfig;
    }
    /**
     * Replace the default configuration applied to new instances.
     */
    static set DefaultConfig(defaultConfig2) {
      _Hls.defaultConfig = defaultConfig2;
    }
    /**
     * Creates an instance of an HLS client that can attach to exactly one `HTMLMediaElement`.
     * @param userConfig - Configuration options applied over `Hls.DefaultConfig`
     */
    constructor(userConfig = {}) {
      this.config = void 0;
      this.userConfig = void 0;
      this.logger = void 0;
      this.coreComponents = void 0;
      this.networkControllers = void 0;
      this._emitter = new EventEmitter();
      this._autoLevelCapping = -1;
      this._maxHdcpLevel = null;
      this.abrController = void 0;
      this.bufferController = void 0;
      this.capLevelController = void 0;
      this.latencyController = void 0;
      this.levelController = void 0;
      this.streamController = void 0;
      this.audioStreamController = void 0;
      this.subtititleStreamController = void 0;
      this.audioTrackController = void 0;
      this.subtitleTrackController = void 0;
      this.interstitialsController = void 0;
      this.gapController = void 0;
      this.emeController = void 0;
      this.cmcdController = void 0;
      this._media = null;
      this._url = null;
      this._sessionId = void 0;
      this.triggeringException = void 0;
      this.started = false;
      const logger2 = this.logger = enableLogs(userConfig.debug || false, "Hls instance", userConfig.assetPlayerId);
      const config3 = this.config = mergeConfig(_Hls.DefaultConfig, userConfig, logger2);
      this.userConfig = userConfig;
      if (config3.progressive) {
        enableStreamingMode(config3, logger2);
      }
      const {
        abrController: _AbrController,
        bufferController: _BufferController,
        capLevelController: _CapLevelController,
        errorController: _ErrorController,
        fpsController: _FpsController
      } = config3;
      const errorController = new _ErrorController(this);
      const abrController = this.abrController = new _AbrController(this);
      const fragmentTracker = new FragmentTracker(this);
      const _InterstitialsController = config3.interstitialsController;
      const interstitialsController = _InterstitialsController ? this.interstitialsController = new _InterstitialsController(this, _Hls) : null;
      const bufferController = this.bufferController = new _BufferController(this, fragmentTracker);
      const capLevelController = this.capLevelController = new _CapLevelController(this);
      const fpsController = new _FpsController(this);
      const playListLoader = new PlaylistLoader(this);
      const _ContentSteeringController = config3.contentSteeringController;
      const contentSteering = _ContentSteeringController ? new _ContentSteeringController(this) : null;
      const levelController = this.levelController = new LevelController(this, contentSteering);
      const id3TrackController = new ID3TrackController(this);
      const keyLoader = new KeyLoader(this.config, this.logger);
      const streamController = this.streamController = new StreamController(this, fragmentTracker, keyLoader);
      const gapController = this.gapController = new GapController(this, fragmentTracker);
      capLevelController.setStreamController(streamController);
      fpsController.setStreamController(streamController);
      const networkControllers = [playListLoader, levelController, streamController];
      if (interstitialsController) {
        networkControllers.splice(1, 0, interstitialsController);
      }
      if (contentSteering) {
        networkControllers.splice(1, 0, contentSteering);
      }
      this.networkControllers = networkControllers;
      const coreComponents = [abrController, bufferController, gapController, capLevelController, fpsController, id3TrackController, fragmentTracker];
      this.audioTrackController = this.createController(config3.audioTrackController, networkControllers);
      const AudioStreamControllerClass = config3.audioStreamController;
      if (AudioStreamControllerClass) {
        networkControllers.push(this.audioStreamController = new AudioStreamControllerClass(this, fragmentTracker, keyLoader));
      }
      this.subtitleTrackController = this.createController(config3.subtitleTrackController, networkControllers);
      const SubtitleStreamControllerClass = config3.subtitleStreamController;
      if (SubtitleStreamControllerClass) {
        networkControllers.push(this.subtititleStreamController = new SubtitleStreamControllerClass(this, fragmentTracker, keyLoader));
      }
      this.createController(config3.timelineController, coreComponents);
      keyLoader.emeController = this.emeController = this.createController(config3.emeController, coreComponents);
      this.cmcdController = this.createController(config3.cmcdController, coreComponents);
      this.latencyController = this.createController(LatencyController, coreComponents);
      this.coreComponents = coreComponents;
      networkControllers.push(errorController);
      const onErrorOut = errorController.onErrorOut;
      if (typeof onErrorOut === "function") {
        this.on(Events.ERROR, onErrorOut, errorController);
      }
      this.on(Events.MANIFEST_LOADED, playListLoader.onManifestLoaded, playListLoader);
    }
    createController(ControllerClass, components) {
      if (ControllerClass) {
        const controllerInstance = new ControllerClass(this);
        if (components) {
          components.push(controllerInstance);
        }
        return controllerInstance;
      }
      return null;
    }
    // Delegate the EventEmitter through the public API of Hls.js
    on(event, listener, context3 = this) {
      this._emitter.on(event, listener, context3);
    }
    once(event, listener, context3 = this) {
      this._emitter.once(event, listener, context3);
    }
    removeAllListeners(event) {
      this._emitter.removeAllListeners(event);
    }
    off(event, listener, context3 = this, once) {
      this._emitter.off(event, listener, context3, once);
    }
    listeners(event) {
      return this._emitter.listeners(event);
    }
    emit(event, name, eventObject) {
      return this._emitter.emit(event, name, eventObject);
    }
    trigger(event, eventObject) {
      if (this.config.debug) {
        return this.emit(event, event, eventObject);
      } else {
        try {
          return this.emit(event, event, eventObject);
        } catch (error) {
          this.logger.error("An internal error happened while handling event " + event + '. Error message: "' + error.message + '". Here is a stacktrace:', error);
          if (!this.triggeringException) {
            this.triggeringException = true;
            const fatal = event === Events.ERROR;
            this.trigger(Events.ERROR, {
              type: ErrorTypes.OTHER_ERROR,
              details: ErrorDetails.INTERNAL_EXCEPTION,
              fatal,
              event,
              error
            });
            this.triggeringException = false;
          }
        }
      }
      return false;
    }
    listenerCount(event) {
      return this._emitter.listenerCount(event);
    }
    /**
     * Dispose of the instance
     */
    destroy() {
      this.logger.log("destroy");
      this.trigger(Events.DESTROYING, void 0);
      this.detachMedia();
      this.removeAllListeners();
      this._autoLevelCapping = -1;
      this._url = null;
      this.networkControllers.forEach((component) => component.destroy());
      this.networkControllers.length = 0;
      this.coreComponents.forEach((component) => component.destroy());
      this.coreComponents.length = 0;
      const config3 = this.config;
      config3.xhrSetup = config3.fetchSetup = void 0;
      this.userConfig = null;
    }
    /**
     * Attaches Hls.js to a media element
     */
    attachMedia(data) {
      if (!data || "media" in data && !data.media) {
        const error = new Error(`attachMedia failed: invalid argument (${data})`);
        this.trigger(Events.ERROR, {
          type: ErrorTypes.OTHER_ERROR,
          details: ErrorDetails.ATTACH_MEDIA_ERROR,
          fatal: true,
          error
        });
        return;
      }
      this.logger.log(`attachMedia`);
      if (this._media) {
        this.logger.warn(`media must be detached before attaching`);
        this.detachMedia();
      }
      const attachMediaSource = "media" in data;
      const media = attachMediaSource ? data.media : data;
      const attachingData = attachMediaSource ? data : {
        media
      };
      this._media = media;
      this.trigger(Events.MEDIA_ATTACHING, attachingData);
    }
    /**
     * Detach Hls.js from the media
     */
    detachMedia() {
      this.logger.log("detachMedia");
      this.trigger(Events.MEDIA_DETACHING, {});
      this._media = null;
    }
    /**
     * Detach HTMLMediaElement, MediaSource, and SourceBuffers without reset, for attaching to another instance
     */
    transferMedia() {
      this._media = null;
      const transferMedia = this.bufferController.transferMedia();
      this.trigger(Events.MEDIA_DETACHING, {
        transferMedia
      });
      return transferMedia;
    }
    /**
     * Set the source URL. Can be relative or absolute.
     */
    loadSource(url) {
      this.stopLoad();
      const media = this.media;
      const loadedSource = this._url;
      const loadingSource = this._url = urlToolkitExports.buildAbsoluteURL(self.location.href, url, {
        alwaysNormalize: true
      });
      this._autoLevelCapping = -1;
      this._maxHdcpLevel = null;
      this.logger.log(`loadSource:${loadingSource}`);
      if (media && loadedSource && (loadedSource !== loadingSource || this.bufferController.hasSourceTypes())) {
        this.detachMedia();
        this.attachMedia(media);
      }
      this.trigger(Events.MANIFEST_LOADING, {
        url
      });
    }
    /**
     * Gets the currently loaded URL
     */
    get url() {
      return this._url;
    }
    /**
     * Whether or not enough has been buffered to seek to start position or use `media.currentTime` to determine next load position
     */
    get hasEnoughToStart() {
      return this.streamController.hasEnoughToStart;
    }
    /**
     * Get the startPosition set on startLoad(position) or on autostart with config.startPosition
     */
    get startPosition() {
      return this.streamController.startPositionValue;
    }
    /**
     * Start loading data from the stream source.
     * Depending on default config, client starts loading automatically when a source is set.
     *
     * @param startPosition - Set the start position to stream from.
     * Defaults to -1 (None: starts from earliest point)
     */
    startLoad(startPosition = -1, skipSeekToStartPosition) {
      this.logger.log(`startLoad(${startPosition + (skipSeekToStartPosition ? ", <skip seek to start>" : "")})`);
      this.started = true;
      this.resumeBuffering();
      for (let i = 0; i < this.networkControllers.length; i++) {
        this.networkControllers[i].startLoad(startPosition, skipSeekToStartPosition);
        if (!this.started || !this.networkControllers) {
          break;
        }
      }
    }
    /**
     * Stop loading of any stream data.
     */
    stopLoad() {
      this.logger.log("stopLoad");
      this.started = false;
      for (let i = 0; i < this.networkControllers.length; i++) {
        this.networkControllers[i].stopLoad();
        if (this.started || !this.networkControllers) {
          break;
        }
      }
    }
    /**
     * Returns whether loading, toggled with `startLoad()` and `stopLoad()`, is active or not`.
     */
    get loadingEnabled() {
      return this.started;
    }
    /**
     * Returns state of fragment loading toggled by calling `pauseBuffering()` and `resumeBuffering()`.
     */
    get bufferingEnabled() {
      return this.streamController.bufferingEnabled;
    }
    /**
     * Resumes stream controller segment loading after `pauseBuffering` has been called.
     */
    resumeBuffering() {
      if (!this.bufferingEnabled) {
        this.logger.log(`resume buffering`);
        this.networkControllers.forEach((controller) => {
          if (controller.resumeBuffering) {
            controller.resumeBuffering();
          }
        });
      }
    }
    /**
     * Prevents stream controller from loading new segments until `resumeBuffering` is called.
     * This allows for media buffering to be paused without interupting playlist loading.
     */
    pauseBuffering() {
      if (this.bufferingEnabled) {
        this.logger.log(`pause buffering`);
        this.networkControllers.forEach((controller) => {
          if (controller.pauseBuffering) {
            controller.pauseBuffering();
          }
        });
      }
    }
    get inFlightFragments() {
      const inFlightData = {
        [PlaylistLevelType.MAIN]: this.streamController.inFlightFrag
      };
      if (this.audioStreamController) {
        inFlightData[PlaylistLevelType.AUDIO] = this.audioStreamController.inFlightFrag;
      }
      if (this.subtititleStreamController) {
        inFlightData[PlaylistLevelType.SUBTITLE] = this.subtititleStreamController.inFlightFrag;
      }
      return inFlightData;
    }
    /**
     * Swap through possible audio codecs in the stream (for example to switch from stereo to 5.1)
     */
    swapAudioCodec() {
      this.logger.log("swapAudioCodec");
      this.streamController.swapAudioCodec();
    }
    /**
     * When the media-element fails, this allows to detach and then re-attach it
     * as one call (convenience method).
     *
     * Automatic recovery of media-errors by this process is configurable.
     */
    recoverMediaError() {
      this.logger.log("recoverMediaError");
      const media = this._media;
      const time2 = media == null ? void 0 : media.currentTime;
      this.detachMedia();
      if (media) {
        this.attachMedia(media);
        if (time2) {
          this.startLoad(time2);
        }
      }
    }
    removeLevel(levelIndex) {
      this.levelController.removeLevel(levelIndex);
    }
    /**
     * @returns a UUID for this player instance
     */
    get sessionId() {
      let _sessionId = this._sessionId;
      if (!_sessionId) {
        _sessionId = this._sessionId = uuid();
      }
      return _sessionId;
    }
    /**
     * @returns an array of levels (variants) sorted by HDCP-LEVEL, RESOLUTION (height), FRAME-RATE, CODECS, VIDEO-RANGE, and BANDWIDTH
     */
    get levels() {
      const levels = this.levelController.levels;
      return levels ? levels : [];
    }
    /**
     * @returns LevelDetails of last loaded level (variant) or `null` prior to loading a media playlist.
     */
    get latestLevelDetails() {
      return this.streamController.getLevelDetails() || null;
    }
    /**
     * @returns Level object of selected level (variant) or `null` prior to selecting a level or once the level is removed.
     */
    get loadLevelObj() {
      return this.levelController.loadLevelObj;
    }
    /**
     * Index of quality level (variant) currently played
     */
    get currentLevel() {
      return this.streamController.currentLevel;
    }
    /**
     * Set quality level index immediately. This will flush the current buffer to replace the quality asap. That means playback will interrupt at least shortly to re-buffer and re-sync eventually. Set to -1 for automatic level selection.
     */
    set currentLevel(newLevel) {
      this.logger.log(`set currentLevel:${newLevel}`);
      this.levelController.manualLevel = newLevel;
      this.streamController.immediateLevelSwitch();
    }
    /**
     * Index of next quality level loaded as scheduled by stream controller.
     */
    get nextLevel() {
      return this.streamController.nextLevel;
    }
    /**
     * Set quality level index for next loaded data.
     * This will switch the video quality asap, without interrupting playback.
     * May abort current loading of data, and flush parts of buffer (outside currently played fragment region).
     * @param newLevel - Pass -1 for automatic level selection
     */
    set nextLevel(newLevel) {
      this.logger.log(`set nextLevel:${newLevel}`);
      this.levelController.manualLevel = newLevel;
      this.streamController.nextLevelSwitch();
    }
    /**
     * Return the quality level of the currently or last (of none is loaded currently) segment
     */
    get loadLevel() {
      return this.levelController.level;
    }
    /**
     * Set quality level index for next loaded data in a conservative way.
     * This will switch the quality without flushing, but interrupt current loading.
     * Thus the moment when the quality switch will appear in effect will only be after the already existing buffer.
     * @param newLevel - Pass -1 for automatic level selection
     */
    set loadLevel(newLevel) {
      this.logger.log(`set loadLevel:${newLevel}`);
      this.levelController.manualLevel = newLevel;
    }
    /**
     * get next quality level loaded
     */
    get nextLoadLevel() {
      return this.levelController.nextLoadLevel;
    }
    /**
     * Set quality level of next loaded segment in a fully "non-destructive" way.
     * Same as `loadLevel` but will wait for next switch (until current loading is done).
     */
    set nextLoadLevel(level) {
      this.levelController.nextLoadLevel = level;
    }
    /**
     * Return "first level": like a default level, if not set,
     * falls back to index of first level referenced in manifest
     */
    get firstLevel() {
      return Math.max(this.levelController.firstLevel, this.minAutoLevel);
    }
    /**
     * Sets "first-level", see getter.
     */
    set firstLevel(newLevel) {
      this.logger.log(`set firstLevel:${newLevel}`);
      this.levelController.firstLevel = newLevel;
    }
    /**
     * Return the desired start level for the first fragment that will be loaded.
     * The default value of -1 indicates automatic start level selection.
     * Setting hls.nextAutoLevel without setting a startLevel will result in
     * the nextAutoLevel value being used for one fragment load.
     */
    get startLevel() {
      const startLevel = this.levelController.startLevel;
      if (startLevel === -1 && this.abrController.forcedAutoLevel > -1) {
        return this.abrController.forcedAutoLevel;
      }
      return startLevel;
    }
    /**
     * set  start level (level of first fragment that will be played back)
     * if not overrided by user, first level appearing in manifest will be used as start level
     * if -1 : automatic start level selection, playback will start from level matching download bandwidth
     * (determined from download of first segment)
     */
    set startLevel(newLevel) {
      this.logger.log(`set startLevel:${newLevel}`);
      if (newLevel !== -1) {
        newLevel = Math.max(newLevel, this.minAutoLevel);
      }
      this.levelController.startLevel = newLevel;
    }
    /**
     * Whether level capping is enabled.
     * Default value is set via `config.capLevelToPlayerSize`.
     */
    get capLevelToPlayerSize() {
      return this.config.capLevelToPlayerSize;
    }
    /**
     * Enables or disables level capping. If disabled after previously enabled, `nextLevelSwitch` will be immediately called.
     */
    set capLevelToPlayerSize(shouldStartCapping) {
      const newCapLevelToPlayerSize = !!shouldStartCapping;
      if (newCapLevelToPlayerSize !== this.config.capLevelToPlayerSize) {
        if (newCapLevelToPlayerSize) {
          this.capLevelController.startCapping();
        } else {
          this.capLevelController.stopCapping();
          this.autoLevelCapping = -1;
          this.streamController.nextLevelSwitch();
        }
        this.config.capLevelToPlayerSize = newCapLevelToPlayerSize;
      }
    }
    /**
     * Capping/max level value that should be used by automatic level selection algorithm (`ABRController`)
     */
    get autoLevelCapping() {
      return this._autoLevelCapping;
    }
    /**
     * Returns the current bandwidth estimate in bits per second, when available. Otherwise, `NaN` is returned.
     */
    get bandwidthEstimate() {
      const {
        bwEstimator
      } = this.abrController;
      if (!bwEstimator) {
        return NaN;
      }
      return bwEstimator.getEstimate();
    }
    set bandwidthEstimate(abrEwmaDefaultEstimate) {
      this.abrController.resetEstimator(abrEwmaDefaultEstimate);
    }
    get abrEwmaDefaultEstimate() {
      const {
        bwEstimator
      } = this.abrController;
      if (!bwEstimator) {
        return NaN;
      }
      return bwEstimator.defaultEstimate;
    }
    /**
     * get time to first byte estimate
     * @type {number}
     */
    get ttfbEstimate() {
      const {
        bwEstimator
      } = this.abrController;
      if (!bwEstimator) {
        return NaN;
      }
      return bwEstimator.getEstimateTTFB();
    }
    /**
     * Capping/max level value that should be used by automatic level selection algorithm (`ABRController`)
     */
    set autoLevelCapping(newLevel) {
      if (this._autoLevelCapping !== newLevel) {
        this.logger.log(`set autoLevelCapping:${newLevel}`);
        this._autoLevelCapping = newLevel;
        this.levelController.checkMaxAutoUpdated();
      }
    }
    get maxHdcpLevel() {
      return this._maxHdcpLevel;
    }
    set maxHdcpLevel(value) {
      if (isHdcpLevel(value) && this._maxHdcpLevel !== value) {
        this._maxHdcpLevel = value;
        this.levelController.checkMaxAutoUpdated();
      }
    }
    /**
     * True when automatic level selection enabled
     */
    get autoLevelEnabled() {
      return this.levelController.manualLevel === -1;
    }
    /**
     * Level set manually (if any)
     */
    get manualLevel() {
      return this.levelController.manualLevel;
    }
    /**
     * min level selectable in auto mode according to config.minAutoBitrate
     */
    get minAutoLevel() {
      const {
        levels,
        config: {
          minAutoBitrate
        }
      } = this;
      if (!levels) return 0;
      const len = levels.length;
      for (let i = 0; i < len; i++) {
        if (levels[i].maxBitrate >= minAutoBitrate) {
          return i;
        }
      }
      return 0;
    }
    /**
     * max level selectable in auto mode according to autoLevelCapping
     */
    get maxAutoLevel() {
      const {
        levels,
        autoLevelCapping,
        maxHdcpLevel
      } = this;
      let maxAutoLevel;
      if (autoLevelCapping === -1 && levels != null && levels.length) {
        maxAutoLevel = levels.length - 1;
      } else {
        maxAutoLevel = autoLevelCapping;
      }
      if (maxHdcpLevel) {
        for (let i = maxAutoLevel; i--; ) {
          const hdcpLevel = levels[i].attrs["HDCP-LEVEL"];
          if (hdcpLevel && hdcpLevel <= maxHdcpLevel) {
            return i;
          }
        }
      }
      return maxAutoLevel;
    }
    get firstAutoLevel() {
      return this.abrController.firstAutoLevel;
    }
    /**
     * next automatically selected quality level
     */
    get nextAutoLevel() {
      return this.abrController.nextAutoLevel;
    }
    /**
     * this setter is used to force next auto level.
     * this is useful to force a switch down in auto mode:
     * in case of load error on level N, hls.js can set nextAutoLevel to N-1 for example)
     * forced value is valid for one fragment. upon successful frag loading at forced level,
     * this value will be resetted to -1 by ABR controller.
     */
    set nextAutoLevel(nextLevel) {
      this.abrController.nextAutoLevel = nextLevel;
    }
    /**
     * get the datetime value relative to media.currentTime for the active level Program Date Time if present
     */
    get playingDate() {
      return this.streamController.currentProgramDateTime;
    }
    get mainForwardBufferInfo() {
      return this.streamController.getMainFwdBufferInfo();
    }
    get maxBufferLength() {
      return this.streamController.maxBufferLength;
    }
    /**
     * Find and select the best matching audio track, making a level switch when a Group change is necessary.
     * Updates `hls.config.audioPreference`. Returns the selected track, or null when no matching track is found.
     */
    setAudioOption(audioOption) {
      var _this$audioTrackContr;
      return ((_this$audioTrackContr = this.audioTrackController) == null ? void 0 : _this$audioTrackContr.setAudioOption(audioOption)) || null;
    }
    /**
     * Find and select the best matching subtitle track, making a level switch when a Group change is necessary.
     * Updates `hls.config.subtitlePreference`. Returns the selected track, or null when no matching track is found.
     */
    setSubtitleOption(subtitleOption) {
      var _this$subtitleTrackCo;
      return ((_this$subtitleTrackCo = this.subtitleTrackController) == null ? void 0 : _this$subtitleTrackCo.setSubtitleOption(subtitleOption)) || null;
    }
    /**
     * Get the complete list of audio tracks across all media groups
     */
    get allAudioTracks() {
      const audioTrackController = this.audioTrackController;
      return audioTrackController ? audioTrackController.allAudioTracks : [];
    }
    /**
     * Get the list of selectable audio tracks
     */
    get audioTracks() {
      const audioTrackController = this.audioTrackController;
      return audioTrackController ? audioTrackController.audioTracks : [];
    }
    /**
     * index of the selected audio track (index in audio track lists)
     */
    get audioTrack() {
      const audioTrackController = this.audioTrackController;
      return audioTrackController ? audioTrackController.audioTrack : -1;
    }
    /**
     * selects an audio track, based on its index in audio track lists
     */
    set audioTrack(audioTrackId) {
      const audioTrackController = this.audioTrackController;
      if (audioTrackController) {
        audioTrackController.audioTrack = audioTrackId;
      }
    }
    /**
     * get the complete list of subtitle tracks across all media groups
     */
    get allSubtitleTracks() {
      const subtitleTrackController = this.subtitleTrackController;
      return subtitleTrackController ? subtitleTrackController.allSubtitleTracks : [];
    }
    /**
     * get alternate subtitle tracks list from playlist
     */
    get subtitleTracks() {
      const subtitleTrackController = this.subtitleTrackController;
      return subtitleTrackController ? subtitleTrackController.subtitleTracks : [];
    }
    /**
     * index of the selected subtitle track (index in subtitle track lists)
     */
    get subtitleTrack() {
      const subtitleTrackController = this.subtitleTrackController;
      return subtitleTrackController ? subtitleTrackController.subtitleTrack : -1;
    }
    get media() {
      return this._media;
    }
    /**
     * select an subtitle track, based on its index in subtitle track lists
     */
    set subtitleTrack(subtitleTrackId) {
      const subtitleTrackController = this.subtitleTrackController;
      if (subtitleTrackController) {
        subtitleTrackController.subtitleTrack = subtitleTrackId;
      }
    }
    /**
     * Whether subtitle display is enabled or not
     */
    get subtitleDisplay() {
      const subtitleTrackController = this.subtitleTrackController;
      return subtitleTrackController ? subtitleTrackController.subtitleDisplay : false;
    }
    /**
     * Enable/disable subtitle display rendering
     */
    set subtitleDisplay(value) {
      const subtitleTrackController = this.subtitleTrackController;
      if (subtitleTrackController) {
        subtitleTrackController.subtitleDisplay = value;
      }
    }
    /**
     * get mode for Low-Latency HLS loading
     */
    get lowLatencyMode() {
      return this.config.lowLatencyMode;
    }
    /**
     * Enable/disable Low-Latency HLS part playlist and segment loading, and start live streams at playlist PART-HOLD-BACK rather than HOLD-BACK.
     */
    set lowLatencyMode(mode) {
      this.config.lowLatencyMode = mode;
    }
    /**
     * Position (in seconds) of live sync point (ie edge of live position minus safety delay defined by ```hls.config.liveSyncDuration```)
     * @returns null prior to loading live Playlist
     */
    get liveSyncPosition() {
      return this.latencyController.liveSyncPosition;
    }
    /**
     * Estimated position (in seconds) of live edge (ie edge of live playlist plus time sync playlist advanced)
     * @returns 0 before first playlist is loaded
     */
    get latency() {
      return this.latencyController.latency;
    }
    /**
     * maximum distance from the edge before the player seeks forward to ```hls.liveSyncPosition```
     * configured using ```liveMaxLatencyDurationCount``` (multiple of target duration) or ```liveMaxLatencyDuration```
     * @returns 0 before first playlist is loaded
     */
    get maxLatency() {
      return this.latencyController.maxLatency;
    }
    /**
     * target distance from the edge as calculated by the latency controller
     */
    get targetLatency() {
      return this.latencyController.targetLatency;
    }
    set targetLatency(latency) {
      this.latencyController.targetLatency = latency;
    }
    /**
     * the rate at which the edge of the current live playlist is advancing or 1 if there is none
     */
    get drift() {
      return this.latencyController.drift;
    }
    /**
     * set to true when startLoad is called before MANIFEST_PARSED event
     */
    get forceStartLoad() {
      return this.streamController.forceStartLoad;
    }
    /**
     * ContentSteering pathways getter
     */
    get pathways() {
      return this.levelController.pathways;
    }
    /**
     * ContentSteering pathwayPriority getter/setter
     */
    get pathwayPriority() {
      return this.levelController.pathwayPriority;
    }
    set pathwayPriority(pathwayPriority) {
      this.levelController.pathwayPriority = pathwayPriority;
    }
    /**
     * returns true when all SourceBuffers are buffered to the end
     */
    get bufferedToEnd() {
      var _this$bufferControlle;
      return !!((_this$bufferControlle = this.bufferController) != null && _this$bufferControlle.bufferedToEnd);
    }
    /**
     * returns Interstitials Program Manager
     */
    get interstitialsManager() {
      var _this$interstitialsCo;
      return ((_this$interstitialsCo = this.interstitialsController) == null ? void 0 : _this$interstitialsCo.interstitialsManager) || null;
    }
    /**
     * returns mediaCapabilities.decodingInfo for a variant/rendition
     */
    getMediaDecodingInfo(level, audioTracks = this.allAudioTracks) {
      const audioTracksByGroup = getAudioTracksByGroup(audioTracks);
      return getMediaDecodingInfoPromise(level, audioTracksByGroup, navigator.mediaCapabilities);
    }
  };
  Hls.defaultConfig = void 0;

  // frontend/src/components/SplitText/SplitText.jsx
  var import_react2 = __toESM(require_react());

  // node_modules/gsap/gsap-core.js
  function _assertThisInitialized(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }
  var _config = {
    autoSleep: 120,
    force3D: "auto",
    nullTargetWarn: 1,
    units: {
      lineHeight: ""
    }
  };
  var _defaults = {
    duration: 0.5,
    overwrite: false,
    delay: 0
  };
  var _suppressOverwrites;
  var _reverting;
  var _context;
  var _bigNum = 1e8;
  var _tinyNum = 1 / _bigNum;
  var _2PI = Math.PI * 2;
  var _HALF_PI = _2PI / 4;
  var _gsID = 0;
  var _sqrt = Math.sqrt;
  var _cos = Math.cos;
  var _sin = Math.sin;
  var _isString = function _isString2(value) {
    return typeof value === "string";
  };
  var _isFunction = function _isFunction2(value) {
    return typeof value === "function";
  };
  var _isNumber = function _isNumber2(value) {
    return typeof value === "number";
  };
  var _isUndefined = function _isUndefined2(value) {
    return typeof value === "undefined";
  };
  var _isObject = function _isObject2(value) {
    return typeof value === "object";
  };
  var _isNotFalse = function _isNotFalse2(value) {
    return value !== false;
  };
  var _windowExists = function _windowExists2() {
    return typeof window !== "undefined";
  };
  var _isFuncOrString = function _isFuncOrString2(value) {
    return _isFunction(value) || _isString(value);
  };
  var _isTypedArray = typeof ArrayBuffer === "function" && ArrayBuffer.isView || function() {
  };
  var _isArray = Array.isArray;
  var _strictNumExp = /(?:-?\.?\d|\.)+/gi;
  var _numExp = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g;
  var _numWithUnitExp = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g;
  var _complexStringNumExp = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi;
  var _relExp = /[+-]=-?[.\d]+/;
  var _delimitedValueExp = /[^,'"\[\]\s]+/gi;
  var _unitExp = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i;
  var _globalTimeline;
  var _win;
  var _coreInitted;
  var _doc;
  var _globals = {};
  var _installScope = {};
  var _coreReady;
  var _install = function _install2(scope) {
    return (_installScope = _merge(scope, _globals)) && gsap;
  };
  var _missingPlugin = function _missingPlugin2(property, value) {
    return console.warn("Invalid property", property, "set to", value, "Missing plugin? gsap.registerPlugin()");
  };
  var _warn = function _warn2(message, suppress) {
    return !suppress && console.warn(message);
  };
  var _addGlobal = function _addGlobal2(name, obj) {
    return name && (_globals[name] = obj) && _installScope && (_installScope[name] = obj) || _globals;
  };
  var _emptyFunc = function _emptyFunc2() {
    return 0;
  };
  var _startAtRevertConfig = {
    suppressEvents: true,
    isStart: true,
    kill: false
  };
  var _revertConfigNoKill = {
    suppressEvents: true,
    kill: false
  };
  var _revertConfig = {
    suppressEvents: true
  };
  var _reservedProps = {};
  var _lazyTweens = [];
  var _lazyLookup = {};
  var _lastRenderedFrame;
  var _plugins = {};
  var _effects = {};
  var _nextGCFrame = 30;
  var _harnessPlugins = [];
  var _callbackNames = "";
  var _harness = function _harness2(targets) {
    var target = targets[0], harnessPlugin, i;
    _isObject(target) || _isFunction(target) || (targets = [targets]);
    if (!(harnessPlugin = (target._gsap || {}).harness)) {
      i = _harnessPlugins.length;
      while (i-- && !_harnessPlugins[i].targetTest(target)) {
      }
      harnessPlugin = _harnessPlugins[i];
    }
    i = targets.length;
    while (i--) {
      targets[i] && (targets[i]._gsap || (targets[i]._gsap = new GSCache(targets[i], harnessPlugin))) || targets.splice(i, 1);
    }
    return targets;
  };
  var _getCache = function _getCache2(target) {
    return target._gsap || _harness(toArray(target))[0]._gsap;
  };
  var _getProperty = function _getProperty2(target, property, v) {
    return (v = target[property]) && _isFunction(v) ? target[property]() : _isUndefined(v) && target.getAttribute && target.getAttribute(property) || v;
  };
  var _forEachName = function _forEachName2(names, func) {
    return (names = names.split(",")).forEach(func) || names;
  };
  var _round = function _round2(value) {
    return Math.round(value * 1e5) / 1e5 || 0;
  };
  var _roundPrecise = function _roundPrecise2(value) {
    return Math.round(value * 1e7) / 1e7 || 0;
  };
  var _parseRelative = function _parseRelative2(start, value) {
    var operator = value.charAt(0), end = parseFloat(value.substr(2));
    start = parseFloat(start);
    return operator === "+" ? start + end : operator === "-" ? start - end : operator === "*" ? start * end : start / end;
  };
  var _arrayContainsAny = function _arrayContainsAny2(toSearch, toFind) {
    var l = toFind.length, i = 0;
    for (; toSearch.indexOf(toFind[i]) < 0 && ++i < l; ) {
    }
    return i < l;
  };
  var _lazyRender = function _lazyRender2() {
    var l = _lazyTweens.length, a = _lazyTweens.slice(0), i, tween;
    _lazyLookup = {};
    _lazyTweens.length = 0;
    for (i = 0; i < l; i++) {
      tween = a[i];
      tween && tween._lazy && (tween.render(tween._lazy[0], tween._lazy[1], true)._lazy = 0);
    }
  };
  var _isRevertWorthy = function _isRevertWorthy2(animation) {
    return !!(animation._initted || animation._startAt || animation.add);
  };
  var _lazySafeRender = function _lazySafeRender2(animation, time2, suppressEvents, force) {
    _lazyTweens.length && !_reverting && _lazyRender();
    animation.render(time2, suppressEvents, force || !!(_reverting && time2 < 0 && _isRevertWorthy(animation)));
    _lazyTweens.length && !_reverting && _lazyRender();
  };
  var _numericIfPossible = function _numericIfPossible2(value) {
    var n = parseFloat(value);
    return (n || n === 0) && (value + "").match(_delimitedValueExp).length < 2 ? n : _isString(value) ? value.trim() : value;
  };
  var _passThrough = function _passThrough2(p) {
    return p;
  };
  var _setDefaults = function _setDefaults2(obj, defaults3) {
    for (var p in defaults3) {
      p in obj || (obj[p] = defaults3[p]);
    }
    return obj;
  };
  var _setKeyframeDefaults = function _setKeyframeDefaults2(excludeDuration) {
    return function(obj, defaults3) {
      for (var p in defaults3) {
        p in obj || p === "duration" && excludeDuration || p === "ease" || (obj[p] = defaults3[p]);
      }
    };
  };
  var _merge = function _merge2(base, toMerge) {
    for (var p in toMerge) {
      base[p] = toMerge[p];
    }
    return base;
  };
  var _mergeDeep = function _mergeDeep2(base, toMerge) {
    for (var p in toMerge) {
      p !== "__proto__" && p !== "constructor" && p !== "prototype" && (base[p] = _isObject(toMerge[p]) ? _mergeDeep2(base[p] || (base[p] = {}), toMerge[p]) : toMerge[p]);
    }
    return base;
  };
  var _copyExcluding = function _copyExcluding2(obj, excluding) {
    var copy = {}, p;
    for (p in obj) {
      p in excluding || (copy[p] = obj[p]);
    }
    return copy;
  };
  var _inheritDefaults = function _inheritDefaults2(vars) {
    var parent = vars.parent || _globalTimeline, func = vars.keyframes ? _setKeyframeDefaults(_isArray(vars.keyframes)) : _setDefaults;
    if (_isNotFalse(vars.inherit)) {
      while (parent) {
        func(vars, parent.vars.defaults);
        parent = parent.parent || parent._dp;
      }
    }
    return vars;
  };
  var _arraysMatch = function _arraysMatch2(a1, a2) {
    var i = a1.length, match = i === a2.length;
    while (match && i-- && a1[i] === a2[i]) {
    }
    return i < 0;
  };
  var _addLinkedListItem = function _addLinkedListItem2(parent, child, firstProp, lastProp, sortBy) {
    if (firstProp === void 0) {
      firstProp = "_first";
    }
    if (lastProp === void 0) {
      lastProp = "_last";
    }
    var prev = parent[lastProp], t;
    if (sortBy) {
      t = child[sortBy];
      while (prev && prev[sortBy] > t) {
        prev = prev._prev;
      }
    }
    if (prev) {
      child._next = prev._next;
      prev._next = child;
    } else {
      child._next = parent[firstProp];
      parent[firstProp] = child;
    }
    if (child._next) {
      child._next._prev = child;
    } else {
      parent[lastProp] = child;
    }
    child._prev = prev;
    child.parent = child._dp = parent;
    return child;
  };
  var _removeLinkedListItem = function _removeLinkedListItem2(parent, child, firstProp, lastProp) {
    if (firstProp === void 0) {
      firstProp = "_first";
    }
    if (lastProp === void 0) {
      lastProp = "_last";
    }
    var prev = child._prev, next = child._next;
    if (prev) {
      prev._next = next;
    } else if (parent[firstProp] === child) {
      parent[firstProp] = next;
    }
    if (next) {
      next._prev = prev;
    } else if (parent[lastProp] === child) {
      parent[lastProp] = prev;
    }
    child._next = child._prev = child.parent = null;
  };
  var _removeFromParent = function _removeFromParent2(child, onlyIfParentHasAutoRemove) {
    child.parent && (!onlyIfParentHasAutoRemove || child.parent.autoRemoveChildren) && child.parent.remove && child.parent.remove(child);
    child._act = 0;
  };
  var _uncache = function _uncache2(animation, child) {
    if (animation && (!child || child._end > animation._dur || child._start < 0)) {
      var a = animation;
      while (a) {
        a._dirty = 1;
        a = a.parent;
      }
    }
    return animation;
  };
  var _recacheAncestors = function _recacheAncestors2(animation) {
    var parent = animation.parent;
    while (parent && parent.parent) {
      parent._dirty = 1;
      parent.totalDuration();
      parent = parent.parent;
    }
    return animation;
  };
  var _rewindStartAt = function _rewindStartAt2(tween, totalTime, suppressEvents, force) {
    return tween._startAt && (_reverting ? tween._startAt.revert(_revertConfigNoKill) : tween.vars.immediateRender && !tween.vars.autoRevert || tween._startAt.render(totalTime, true, force));
  };
  var _hasNoPausedAncestors = function _hasNoPausedAncestors2(animation) {
    return !animation || animation._ts && _hasNoPausedAncestors2(animation.parent);
  };
  var _elapsedCycleDuration = function _elapsedCycleDuration2(animation) {
    return animation._repeat ? _animationCycle(animation._tTime, animation = animation.duration() + animation._rDelay) * animation : 0;
  };
  var _animationCycle = function _animationCycle2(tTime, cycleDuration) {
    var whole = Math.floor(tTime = _roundPrecise(tTime / cycleDuration));
    return tTime && whole === tTime ? whole - 1 : whole;
  };
  var _parentToChildTotalTime = function _parentToChildTotalTime2(parentTime, child) {
    return (parentTime - child._start) * child._ts + (child._ts >= 0 ? 0 : child._dirty ? child.totalDuration() : child._tDur);
  };
  var _setEnd = function _setEnd2(animation) {
    return animation._end = _roundPrecise(animation._start + (animation._tDur / Math.abs(animation._ts || animation._rts || _tinyNum) || 0));
  };
  var _alignPlayhead = function _alignPlayhead2(animation, totalTime) {
    var parent = animation._dp;
    if (parent && parent.smoothChildTiming && animation._ts) {
      animation._start = _roundPrecise(parent._time - (animation._ts > 0 ? totalTime / animation._ts : ((animation._dirty ? animation.totalDuration() : animation._tDur) - totalTime) / -animation._ts));
      _setEnd(animation);
      parent._dirty || _uncache(parent, animation);
    }
    return animation;
  };
  var _postAddChecks = function _postAddChecks2(timeline2, child) {
    var t;
    if (child._time || !child._dur && child._initted || child._start < timeline2._time && (child._dur || !child.add)) {
      t = _parentToChildTotalTime(timeline2.rawTime(), child);
      if (!child._dur || _clamp(0, child.totalDuration(), t) - child._tTime > _tinyNum) {
        child.render(t, true);
      }
    }
    if (_uncache(timeline2, child)._dp && timeline2._initted && timeline2._time >= timeline2._dur && timeline2._ts) {
      if (timeline2._dur < timeline2.duration()) {
        t = timeline2;
        while (t._dp) {
          t.rawTime() >= 0 && t.totalTime(t._tTime);
          t = t._dp;
        }
      }
      timeline2._zTime = -_tinyNum;
    }
  };
  var _addToTimeline = function _addToTimeline2(timeline2, child, position, skipChecks) {
    child.parent && _removeFromParent(child);
    child._start = _roundPrecise((_isNumber(position) ? position : position || timeline2 !== _globalTimeline ? _parsePosition(timeline2, position, child) : timeline2._time) + child._delay);
    child._end = _roundPrecise(child._start + (child.totalDuration() / Math.abs(child.timeScale()) || 0));
    _addLinkedListItem(timeline2, child, "_first", "_last", timeline2._sort ? "_start" : 0);
    _isFromOrFromStart(child) || (timeline2._recent = child);
    skipChecks || _postAddChecks(timeline2, child);
    timeline2._ts < 0 && _alignPlayhead(timeline2, timeline2._tTime);
    return timeline2;
  };
  var _scrollTrigger = function _scrollTrigger2(animation, trigger) {
    return (_globals.ScrollTrigger || _missingPlugin("scrollTrigger", trigger)) && _globals.ScrollTrigger.create(trigger, animation);
  };
  var _attemptInitTween = function _attemptInitTween2(tween, time2, force, suppressEvents, tTime) {
    _initTween(tween, time2, tTime);
    if (!tween._initted) {
      return 1;
    }
    if (!force && tween._pt && !_reverting && (tween._dur && tween.vars.lazy !== false || !tween._dur && tween.vars.lazy) && _lastRenderedFrame !== _ticker.frame) {
      _lazyTweens.push(tween);
      tween._lazy = [tTime, suppressEvents];
      return 1;
    }
  };
  var _parentPlayheadIsBeforeStart = function _parentPlayheadIsBeforeStart2(_ref) {
    var parent = _ref.parent;
    return parent && parent._ts && parent._initted && !parent._lock && (parent.rawTime() < 0 || _parentPlayheadIsBeforeStart2(parent));
  };
  var _isFromOrFromStart = function _isFromOrFromStart2(_ref2) {
    var data = _ref2.data;
    return data === "isFromStart" || data === "isStart";
  };
  var _renderZeroDurationTween = function _renderZeroDurationTween2(tween, totalTime, suppressEvents, force) {
    var prevRatio = tween.ratio, ratio = totalTime < 0 || !totalTime && (!tween._start && _parentPlayheadIsBeforeStart(tween) && !(!tween._initted && _isFromOrFromStart(tween)) || (tween._ts < 0 || tween._dp._ts < 0) && !_isFromOrFromStart(tween)) ? 0 : 1, repeatDelay = tween._rDelay, tTime = 0, pt, iteration, prevIteration;
    if (repeatDelay && tween._repeat) {
      tTime = _clamp(0, tween._tDur, totalTime);
      iteration = _animationCycle(tTime, repeatDelay);
      tween._yoyo && iteration & 1 && (ratio = 1 - ratio);
      if (iteration !== _animationCycle(tween._tTime, repeatDelay)) {
        prevRatio = 1 - ratio;
        tween.vars.repeatRefresh && tween._initted && tween.invalidate();
      }
    }
    if (ratio !== prevRatio || _reverting || force || tween._zTime === _tinyNum || !totalTime && tween._zTime) {
      if (!tween._initted && _attemptInitTween(tween, totalTime, force, suppressEvents, tTime)) {
        return;
      }
      prevIteration = tween._zTime;
      tween._zTime = totalTime || (suppressEvents ? _tinyNum : 0);
      suppressEvents || (suppressEvents = totalTime && !prevIteration);
      tween.ratio = ratio;
      tween._from && (ratio = 1 - ratio);
      tween._time = 0;
      tween._tTime = tTime;
      pt = tween._pt;
      while (pt) {
        pt.r(ratio, pt.d);
        pt = pt._next;
      }
      totalTime < 0 && _rewindStartAt(tween, totalTime, suppressEvents, true);
      tween._onUpdate && !suppressEvents && _callback(tween, "onUpdate");
      tTime && tween._repeat && !suppressEvents && tween.parent && _callback(tween, "onRepeat");
      if ((totalTime >= tween._tDur || totalTime < 0) && tween.ratio === ratio) {
        ratio && _removeFromParent(tween, 1);
        if (!suppressEvents && !_reverting) {
          _callback(tween, ratio ? "onComplete" : "onReverseComplete", true);
          tween._prom && tween._prom();
        }
      }
    } else if (!tween._zTime) {
      tween._zTime = totalTime;
    }
  };
  var _findNextPauseTween = function _findNextPauseTween2(animation, prevTime, time2) {
    var child;
    if (time2 > prevTime) {
      child = animation._first;
      while (child && child._start <= time2) {
        if (child.data === "isPause" && child._start > prevTime) {
          return child;
        }
        child = child._next;
      }
    } else {
      child = animation._last;
      while (child && child._start >= time2) {
        if (child.data === "isPause" && child._start < prevTime) {
          return child;
        }
        child = child._prev;
      }
    }
  };
  var _setDuration = function _setDuration2(animation, duration, skipUncache, leavePlayhead) {
    var repeat = animation._repeat, dur = _roundPrecise(duration) || 0, totalProgress = animation._tTime / animation._tDur;
    totalProgress && !leavePlayhead && (animation._time *= dur / animation._dur);
    animation._dur = dur;
    animation._tDur = !repeat ? dur : repeat < 0 ? 1e10 : _roundPrecise(dur * (repeat + 1) + animation._rDelay * repeat);
    totalProgress > 0 && !leavePlayhead && _alignPlayhead(animation, animation._tTime = animation._tDur * totalProgress);
    animation.parent && _setEnd(animation);
    skipUncache || _uncache(animation.parent, animation);
    return animation;
  };
  var _onUpdateTotalDuration = function _onUpdateTotalDuration2(animation) {
    return animation instanceof Timeline ? _uncache(animation) : _setDuration(animation, animation._dur);
  };
  var _zeroPosition = {
    _start: 0,
    endTime: _emptyFunc,
    totalDuration: _emptyFunc
  };
  var _parsePosition = function _parsePosition2(animation, position, percentAnimation) {
    var labels = animation.labels, recent = animation._recent || _zeroPosition, clippedDuration = animation.duration() >= _bigNum ? recent.endTime(false) : animation._dur, i, offset, isPercent;
    if (_isString(position) && (isNaN(position) || position in labels)) {
      offset = position.charAt(0);
      isPercent = position.substr(-1) === "%";
      i = position.indexOf("=");
      if (offset === "<" || offset === ">") {
        i >= 0 && (position = position.replace(/=/, ""));
        return (offset === "<" ? recent._start : recent.endTime(recent._repeat >= 0)) + (parseFloat(position.substr(1)) || 0) * (isPercent ? (i < 0 ? recent : percentAnimation).totalDuration() / 100 : 1);
      }
      if (i < 0) {
        position in labels || (labels[position] = clippedDuration);
        return labels[position];
      }
      offset = parseFloat(position.charAt(i - 1) + position.substr(i + 1));
      if (isPercent && percentAnimation) {
        offset = offset / 100 * (_isArray(percentAnimation) ? percentAnimation[0] : percentAnimation).totalDuration();
      }
      return i > 1 ? _parsePosition2(animation, position.substr(0, i - 1), percentAnimation) + offset : clippedDuration + offset;
    }
    return position == null ? clippedDuration : +position;
  };
  var _createTweenType = function _createTweenType2(type, params, timeline2) {
    var isLegacy = _isNumber(params[1]), varsIndex = (isLegacy ? 2 : 1) + (type < 2 ? 0 : 1), vars = params[varsIndex], irVars, parent;
    isLegacy && (vars.duration = params[1]);
    vars.parent = timeline2;
    if (type) {
      irVars = vars;
      parent = timeline2;
      while (parent && !("immediateRender" in irVars)) {
        irVars = parent.vars.defaults || {};
        parent = _isNotFalse(parent.vars.inherit) && parent.parent;
      }
      vars.immediateRender = _isNotFalse(irVars.immediateRender);
      type < 2 ? vars.runBackwards = 1 : vars.startAt = params[varsIndex - 1];
    }
    return new Tween(params[0], vars, params[varsIndex + 1]);
  };
  var _conditionalReturn = function _conditionalReturn2(value, func) {
    return value || value === 0 ? func(value) : func;
  };
  var _clamp = function _clamp2(min, max, value) {
    return value < min ? min : value > max ? max : value;
  };
  var getUnit = function getUnit2(value, v) {
    return !_isString(value) || !(v = _unitExp.exec(value)) ? "" : v[1];
  };
  var clamp = function clamp2(min, max, value) {
    return _conditionalReturn(value, function(v) {
      return _clamp(min, max, v);
    });
  };
  var _slice = [].slice;
  var _isArrayLike = function _isArrayLike2(value, nonEmpty) {
    return value && _isObject(value) && "length" in value && (!nonEmpty && !value.length || value.length - 1 in value && _isObject(value[0])) && !value.nodeType && value !== _win;
  };
  var _flatten = function _flatten2(ar, leaveStrings, accumulator) {
    if (accumulator === void 0) {
      accumulator = [];
    }
    return ar.forEach(function(value) {
      var _accumulator;
      return _isString(value) && !leaveStrings || _isArrayLike(value, 1) ? (_accumulator = accumulator).push.apply(_accumulator, toArray(value)) : accumulator.push(value);
    }) || accumulator;
  };
  var toArray = function toArray2(value, scope, leaveStrings) {
    return _context && !scope && _context.selector ? _context.selector(value) : _isString(value) && !leaveStrings && (_coreInitted || !_wake()) ? _slice.call((scope || _doc).querySelectorAll(value), 0) : _isArray(value) ? _flatten(value, leaveStrings) : _isArrayLike(value) ? _slice.call(value, 0) : value ? [value] : [];
  };
  var selector = function selector2(value) {
    value = toArray(value)[0] || _warn("Invalid scope") || {};
    return function(v) {
      var el = value.current || value.nativeElement || value;
      return toArray(v, el.querySelectorAll ? el : el === value ? _warn("Invalid scope") || _doc.createElement("div") : value);
    };
  };
  var shuffle = function shuffle2(a) {
    return a.sort(function() {
      return 0.5 - Math.random();
    });
  };
  var distribute = function distribute2(v) {
    if (_isFunction(v)) {
      return v;
    }
    var vars = _isObject(v) ? v : {
      each: v
    }, ease2 = _parseEase(vars.ease), from = vars.from || 0, base = parseFloat(vars.base) || 0, cache = {}, isDecimal = from > 0 && from < 1, ratios = isNaN(from) || isDecimal, axis = vars.axis, ratioX = from, ratioY = from;
    if (_isString(from)) {
      ratioX = ratioY = {
        center: 0.5,
        edges: 0.5,
        end: 1
      }[from] || 0;
    } else if (!isDecimal && ratios) {
      ratioX = from[0];
      ratioY = from[1];
    }
    return function(i, target, a) {
      var l = (a || vars).length, distances = cache[l], originX, originY, x, y, d, j, max, min, wrapAt;
      if (!distances) {
        wrapAt = vars.grid === "auto" ? 0 : (vars.grid || [1, _bigNum])[1];
        if (!wrapAt) {
          max = -_bigNum;
          while (max < (max = a[wrapAt++].getBoundingClientRect().left) && wrapAt < l) {
          }
          wrapAt < l && wrapAt--;
        }
        distances = cache[l] = [];
        originX = ratios ? Math.min(wrapAt, l) * ratioX - 0.5 : from % wrapAt;
        originY = wrapAt === _bigNum ? 0 : ratios ? l * ratioY / wrapAt - 0.5 : from / wrapAt | 0;
        max = 0;
        min = _bigNum;
        for (j = 0; j < l; j++) {
          x = j % wrapAt - originX;
          y = originY - (j / wrapAt | 0);
          distances[j] = d = !axis ? _sqrt(x * x + y * y) : Math.abs(axis === "y" ? y : x);
          d > max && (max = d);
          d < min && (min = d);
        }
        from === "random" && shuffle(distances);
        distances.max = max - min;
        distances.min = min;
        distances.v = l = (parseFloat(vars.amount) || parseFloat(vars.each) * (wrapAt > l ? l - 1 : !axis ? Math.max(wrapAt, l / wrapAt) : axis === "y" ? l / wrapAt : wrapAt) || 0) * (from === "edges" ? -1 : 1);
        distances.b = l < 0 ? base - l : base;
        distances.u = getUnit(vars.amount || vars.each) || 0;
        ease2 = ease2 && l < 0 ? _invertEase(ease2) : ease2;
      }
      l = (distances[i] - distances.min) / distances.max || 0;
      return _roundPrecise(distances.b + (ease2 ? ease2(l) : l) * distances.v) + distances.u;
    };
  };
  var _roundModifier = function _roundModifier2(v) {
    var p = Math.pow(10, ((v + "").split(".")[1] || "").length);
    return function(raw) {
      var n = _roundPrecise(Math.round(parseFloat(raw) / v) * v * p);
      return (n - n % 1) / p + (_isNumber(raw) ? 0 : getUnit(raw));
    };
  };
  var snap = function snap2(snapTo, value) {
    var isArray = _isArray(snapTo), radius, is2D;
    if (!isArray && _isObject(snapTo)) {
      radius = isArray = snapTo.radius || _bigNum;
      if (snapTo.values) {
        snapTo = toArray(snapTo.values);
        if (is2D = !_isNumber(snapTo[0])) {
          radius *= radius;
        }
      } else {
        snapTo = _roundModifier(snapTo.increment);
      }
    }
    return _conditionalReturn(value, !isArray ? _roundModifier(snapTo) : _isFunction(snapTo) ? function(raw) {
      is2D = snapTo(raw);
      return Math.abs(is2D - raw) <= radius ? is2D : raw;
    } : function(raw) {
      var x = parseFloat(is2D ? raw.x : raw), y = parseFloat(is2D ? raw.y : 0), min = _bigNum, closest = 0, i = snapTo.length, dx, dy;
      while (i--) {
        if (is2D) {
          dx = snapTo[i].x - x;
          dy = snapTo[i].y - y;
          dx = dx * dx + dy * dy;
        } else {
          dx = Math.abs(snapTo[i] - x);
        }
        if (dx < min) {
          min = dx;
          closest = i;
        }
      }
      closest = !radius || min <= radius ? snapTo[closest] : raw;
      return is2D || closest === raw || _isNumber(raw) ? closest : closest + getUnit(raw);
    });
  };
  var random = function random2(min, max, roundingIncrement, returnFunction) {
    return _conditionalReturn(_isArray(min) ? !max : roundingIncrement === true ? !!(roundingIncrement = 0) : !returnFunction, function() {
      return _isArray(min) ? min[~~(Math.random() * min.length)] : (roundingIncrement = roundingIncrement || 1e-5) && (returnFunction = roundingIncrement < 1 ? Math.pow(10, (roundingIncrement + "").length - 2) : 1) && Math.floor(Math.round((min - roundingIncrement / 2 + Math.random() * (max - min + roundingIncrement * 0.99)) / roundingIncrement) * roundingIncrement * returnFunction) / returnFunction;
    });
  };
  var pipe = function pipe2() {
    for (var _len = arguments.length, functions = new Array(_len), _key = 0; _key < _len; _key++) {
      functions[_key] = arguments[_key];
    }
    return function(value) {
      return functions.reduce(function(v, f) {
        return f(v);
      }, value);
    };
  };
  var unitize = function unitize2(func, unit) {
    return function(value) {
      return func(parseFloat(value)) + (unit || getUnit(value));
    };
  };
  var normalize = function normalize2(min, max, value) {
    return mapRange(min, max, 0, 1, value);
  };
  var _wrapArray = function _wrapArray2(a, wrapper, value) {
    return _conditionalReturn(value, function(index) {
      return a[~~wrapper(index)];
    });
  };
  var wrap = function wrap2(min, max, value) {
    var range = max - min;
    return _isArray(min) ? _wrapArray(min, wrap2(0, min.length), max) : _conditionalReturn(value, function(value2) {
      return (range + (value2 - min) % range) % range + min;
    });
  };
  var wrapYoyo = function wrapYoyo2(min, max, value) {
    var range = max - min, total = range * 2;
    return _isArray(min) ? _wrapArray(min, wrapYoyo2(0, min.length - 1), max) : _conditionalReturn(value, function(value2) {
      value2 = (total + (value2 - min) % total) % total || 0;
      return min + (value2 > range ? total - value2 : value2);
    });
  };
  var _replaceRandom = function _replaceRandom2(value) {
    var prev = 0, s = "", i, nums, end, isArray;
    while (~(i = value.indexOf("random(", prev))) {
      end = value.indexOf(")", i);
      isArray = value.charAt(i + 7) === "[";
      nums = value.substr(i + 7, end - i - 7).match(isArray ? _delimitedValueExp : _strictNumExp);
      s += value.substr(prev, i - prev) + random(isArray ? nums : +nums[0], isArray ? 0 : +nums[1], +nums[2] || 1e-5);
      prev = end + 1;
    }
    return s + value.substr(prev, value.length - prev);
  };
  var mapRange = function mapRange2(inMin, inMax, outMin, outMax, value) {
    var inRange = inMax - inMin, outRange = outMax - outMin;
    return _conditionalReturn(value, function(value2) {
      return outMin + ((value2 - inMin) / inRange * outRange || 0);
    });
  };
  var interpolate = function interpolate2(start, end, progress2, mutate) {
    var func = isNaN(start + end) ? 0 : function(p2) {
      return (1 - p2) * start + p2 * end;
    };
    if (!func) {
      var isString = _isString(start), master = {}, p, i, interpolators, l, il;
      progress2 === true && (mutate = 1) && (progress2 = null);
      if (isString) {
        start = {
          p: start
        };
        end = {
          p: end
        };
      } else if (_isArray(start) && !_isArray(end)) {
        interpolators = [];
        l = start.length;
        il = l - 2;
        for (i = 1; i < l; i++) {
          interpolators.push(interpolate2(start[i - 1], start[i]));
        }
        l--;
        func = function func2(p2) {
          p2 *= l;
          var i2 = Math.min(il, ~~p2);
          return interpolators[i2](p2 - i2);
        };
        progress2 = end;
      } else if (!mutate) {
        start = _merge(_isArray(start) ? [] : {}, start);
      }
      if (!interpolators) {
        for (p in end) {
          _addPropTween.call(master, start, p, "get", end[p]);
        }
        func = function func2(p2) {
          return _renderPropTweens(p2, master) || (isString ? start.p : start);
        };
      }
    }
    return _conditionalReturn(progress2, func);
  };
  var _getLabelInDirection = function _getLabelInDirection2(timeline2, fromTime, backward) {
    var labels = timeline2.labels, min = _bigNum, p, distance2, label;
    for (p in labels) {
      distance2 = labels[p] - fromTime;
      if (distance2 < 0 === !!backward && distance2 && min > (distance2 = Math.abs(distance2))) {
        label = p;
        min = distance2;
      }
    }
    return label;
  };
  var _callback = function _callback2(animation, type, executeLazyFirst) {
    var v = animation.vars, callback = v[type], prevContext = _context, context3 = animation._ctx, params, scope, result;
    if (!callback) {
      return;
    }
    params = v[type + "Params"];
    scope = v.callbackScope || animation;
    executeLazyFirst && _lazyTweens.length && _lazyRender();
    context3 && (_context = context3);
    result = params ? callback.apply(scope, params) : callback.call(scope);
    _context = prevContext;
    return result;
  };
  var _interrupt = function _interrupt2(animation) {
    _removeFromParent(animation);
    animation.scrollTrigger && animation.scrollTrigger.kill(!!_reverting);
    animation.progress() < 1 && _callback(animation, "onInterrupt");
    return animation;
  };
  var _quickTween;
  var _registerPluginQueue = [];
  var _createPlugin = function _createPlugin2(config3) {
    if (!config3) return;
    config3 = !config3.name && config3["default"] || config3;
    if (_windowExists() || config3.headless) {
      var name = config3.name, isFunc = _isFunction(config3), Plugin = name && !isFunc && config3.init ? function() {
        this._props = [];
      } : config3, instanceDefaults = {
        init: _emptyFunc,
        render: _renderPropTweens,
        add: _addPropTween,
        kill: _killPropTweensOf,
        modifier: _addPluginModifier,
        rawVars: 0
      }, statics = {
        targetTest: 0,
        get: 0,
        getSetter: _getSetter,
        aliases: {},
        register: 0
      };
      _wake();
      if (config3 !== Plugin) {
        if (_plugins[name]) {
          return;
        }
        _setDefaults(Plugin, _setDefaults(_copyExcluding(config3, instanceDefaults), statics));
        _merge(Plugin.prototype, _merge(instanceDefaults, _copyExcluding(config3, statics)));
        _plugins[Plugin.prop = name] = Plugin;
        if (config3.targetTest) {
          _harnessPlugins.push(Plugin);
          _reservedProps[name] = 1;
        }
        name = (name === "css" ? "CSS" : name.charAt(0).toUpperCase() + name.substr(1)) + "Plugin";
      }
      _addGlobal(name, Plugin);
      config3.register && config3.register(gsap, Plugin, PropTween);
    } else {
      _registerPluginQueue.push(config3);
    }
  };
  var _255 = 255;
  var _colorLookup = {
    aqua: [0, _255, _255],
    lime: [0, _255, 0],
    silver: [192, 192, 192],
    black: [0, 0, 0],
    maroon: [128, 0, 0],
    teal: [0, 128, 128],
    blue: [0, 0, _255],
    navy: [0, 0, 128],
    white: [_255, _255, _255],
    olive: [128, 128, 0],
    yellow: [_255, _255, 0],
    orange: [_255, 165, 0],
    gray: [128, 128, 128],
    purple: [128, 0, 128],
    green: [0, 128, 0],
    red: [_255, 0, 0],
    pink: [_255, 192, 203],
    cyan: [0, _255, _255],
    transparent: [_255, _255, _255, 0]
  };
  var _hue = function _hue2(h, m1, m2) {
    h += h < 0 ? 1 : h > 1 ? -1 : 0;
    return (h * 6 < 1 ? m1 + (m2 - m1) * h * 6 : h < 0.5 ? m2 : h * 3 < 2 ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) * _255 + 0.5 | 0;
  };
  var splitColor = function splitColor2(v, toHSL, forceAlpha) {
    var a = !v ? _colorLookup.black : _isNumber(v) ? [v >> 16, v >> 8 & _255, v & _255] : 0, r, g, b, h, s, l, max, min, d, wasHSL;
    if (!a) {
      if (v.substr(-1) === ",") {
        v = v.substr(0, v.length - 1);
      }
      if (_colorLookup[v]) {
        a = _colorLookup[v];
      } else if (v.charAt(0) === "#") {
        if (v.length < 6) {
          r = v.charAt(1);
          g = v.charAt(2);
          b = v.charAt(3);
          v = "#" + r + r + g + g + b + b + (v.length === 5 ? v.charAt(4) + v.charAt(4) : "");
        }
        if (v.length === 9) {
          a = parseInt(v.substr(1, 6), 16);
          return [a >> 16, a >> 8 & _255, a & _255, parseInt(v.substr(7), 16) / 255];
        }
        v = parseInt(v.substr(1), 16);
        a = [v >> 16, v >> 8 & _255, v & _255];
      } else if (v.substr(0, 3) === "hsl") {
        a = wasHSL = v.match(_strictNumExp);
        if (!toHSL) {
          h = +a[0] % 360 / 360;
          s = +a[1] / 100;
          l = +a[2] / 100;
          g = l <= 0.5 ? l * (s + 1) : l + s - l * s;
          r = l * 2 - g;
          a.length > 3 && (a[3] *= 1);
          a[0] = _hue(h + 1 / 3, r, g);
          a[1] = _hue(h, r, g);
          a[2] = _hue(h - 1 / 3, r, g);
        } else if (~v.indexOf("=")) {
          a = v.match(_numExp);
          forceAlpha && a.length < 4 && (a[3] = 1);
          return a;
        }
      } else {
        a = v.match(_strictNumExp) || _colorLookup.transparent;
      }
      a = a.map(Number);
    }
    if (toHSL && !wasHSL) {
      r = a[0] / _255;
      g = a[1] / _255;
      b = a[2] / _255;
      max = Math.max(r, g, b);
      min = Math.min(r, g, b);
      l = (max + min) / 2;
      if (max === min) {
        h = s = 0;
      } else {
        d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        h = max === r ? (g - b) / d + (g < b ? 6 : 0) : max === g ? (b - r) / d + 2 : (r - g) / d + 4;
        h *= 60;
      }
      a[0] = ~~(h + 0.5);
      a[1] = ~~(s * 100 + 0.5);
      a[2] = ~~(l * 100 + 0.5);
    }
    forceAlpha && a.length < 4 && (a[3] = 1);
    return a;
  };
  var _colorOrderData = function _colorOrderData2(v) {
    var values = [], c = [], i = -1;
    v.split(_colorExp).forEach(function(v2) {
      var a = v2.match(_numWithUnitExp) || [];
      values.push.apply(values, a);
      c.push(i += a.length + 1);
    });
    values.c = c;
    return values;
  };
  var _formatColors = function _formatColors2(s, toHSL, orderMatchData) {
    var result = "", colors = (s + result).match(_colorExp), type = toHSL ? "hsla(" : "rgba(", i = 0, c, shell, d, l;
    if (!colors) {
      return s;
    }
    colors = colors.map(function(color2) {
      return (color2 = splitColor(color2, toHSL, 1)) && type + (toHSL ? color2[0] + "," + color2[1] + "%," + color2[2] + "%," + color2[3] : color2.join(",")) + ")";
    });
    if (orderMatchData) {
      d = _colorOrderData(s);
      c = orderMatchData.c;
      if (c.join(result) !== d.c.join(result)) {
        shell = s.replace(_colorExp, "1").split(_numWithUnitExp);
        l = shell.length - 1;
        for (; i < l; i++) {
          result += shell[i] + (~c.indexOf(i) ? colors.shift() || type + "0,0,0,0)" : (d.length ? d : colors.length ? colors : orderMatchData).shift());
        }
      }
    }
    if (!shell) {
      shell = s.split(_colorExp);
      l = shell.length - 1;
      for (; i < l; i++) {
        result += shell[i] + colors[i];
      }
    }
    return result + shell[l];
  };
  var _colorExp = (function() {
    var s = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b", p;
    for (p in _colorLookup) {
      s += "|" + p + "\\b";
    }
    return new RegExp(s + ")", "gi");
  })();
  var _hslExp = /hsl[a]?\(/;
  var _colorStringFilter = function _colorStringFilter2(a) {
    var combined = a.join(" "), toHSL;
    _colorExp.lastIndex = 0;
    if (_colorExp.test(combined)) {
      toHSL = _hslExp.test(combined);
      a[1] = _formatColors(a[1], toHSL);
      a[0] = _formatColors(a[0], toHSL, _colorOrderData(a[1]));
      return true;
    }
  };
  var _tickerActive;
  var _ticker = (function() {
    var _getTime3 = Date.now, _lagThreshold = 500, _adjustedLag = 33, _startTime = _getTime3(), _lastUpdate = _startTime, _gap = 1e3 / 240, _nextTime = _gap, _listeners3 = [], _id, _req, _raf, _self, _delta, _i2, _tick = function _tick2(v) {
      var elapsed = _getTime3() - _lastUpdate, manual = v === true, overlap, dispatch, time2, frame2;
      (elapsed > _lagThreshold || elapsed < 0) && (_startTime += elapsed - _adjustedLag);
      _lastUpdate += elapsed;
      time2 = _lastUpdate - _startTime;
      overlap = time2 - _nextTime;
      if (overlap > 0 || manual) {
        frame2 = ++_self.frame;
        _delta = time2 - _self.time * 1e3;
        _self.time = time2 = time2 / 1e3;
        _nextTime += overlap + (overlap >= _gap ? 4 : _gap - overlap);
        dispatch = 1;
      }
      manual || (_id = _req(_tick2));
      if (dispatch) {
        for (_i2 = 0; _i2 < _listeners3.length; _i2++) {
          _listeners3[_i2](time2, _delta, frame2, v);
        }
      }
    };
    _self = {
      time: 0,
      frame: 0,
      tick: function tick() {
        _tick(true);
      },
      deltaRatio: function deltaRatio(fps) {
        return _delta / (1e3 / (fps || 60));
      },
      wake: function wake() {
        if (_coreReady) {
          if (!_coreInitted && _windowExists()) {
            _win = _coreInitted = window;
            _doc = _win.document || {};
            _globals.gsap = gsap;
            (_win.gsapVersions || (_win.gsapVersions = [])).push(gsap.version);
            _install(_installScope || _win.GreenSockGlobals || !_win.gsap && _win || {});
            _registerPluginQueue.forEach(_createPlugin);
          }
          _raf = typeof requestAnimationFrame !== "undefined" && requestAnimationFrame;
          _id && _self.sleep();
          _req = _raf || function(f) {
            return setTimeout(f, _nextTime - _self.time * 1e3 + 1 | 0);
          };
          _tickerActive = 1;
          _tick(2);
        }
      },
      sleep: function sleep() {
        (_raf ? cancelAnimationFrame : clearTimeout)(_id);
        _tickerActive = 0;
        _req = _emptyFunc;
      },
      lagSmoothing: function lagSmoothing(threshold, adjustedLag) {
        _lagThreshold = threshold || Infinity;
        _adjustedLag = Math.min(adjustedLag || 33, _lagThreshold);
      },
      fps: function fps(_fps) {
        _gap = 1e3 / (_fps || 240);
        _nextTime = _self.time * 1e3 + _gap;
      },
      add: function add(callback, once, prioritize) {
        var func = once ? function(t, d, f, v) {
          callback(t, d, f, v);
          _self.remove(func);
        } : callback;
        _self.remove(callback);
        _listeners3[prioritize ? "unshift" : "push"](func);
        _wake();
        return func;
      },
      remove: function remove(callback, i) {
        ~(i = _listeners3.indexOf(callback)) && _listeners3.splice(i, 1) && _i2 >= i && _i2--;
      },
      _listeners: _listeners3
    };
    return _self;
  })();
  var _wake = function _wake2() {
    return !_tickerActive && _ticker.wake();
  };
  var _easeMap = {};
  var _customEaseExp = /^[\d.\-M][\d.\-,\s]/;
  var _quotesExp = /["']/g;
  var _parseObjectInString = function _parseObjectInString2(value) {
    var obj = {}, split = value.substr(1, value.length - 3).split(":"), key = split[0], i = 1, l = split.length, index, val, parsedVal;
    for (; i < l; i++) {
      val = split[i];
      index = i !== l - 1 ? val.lastIndexOf(",") : val.length;
      parsedVal = val.substr(0, index);
      obj[key] = isNaN(parsedVal) ? parsedVal.replace(_quotesExp, "").trim() : +parsedVal;
      key = val.substr(index + 1).trim();
    }
    return obj;
  };
  var _valueInParentheses = function _valueInParentheses2(value) {
    var open = value.indexOf("(") + 1, close = value.indexOf(")"), nested = value.indexOf("(", open);
    return value.substring(open, ~nested && nested < close ? value.indexOf(")", close + 1) : close);
  };
  var _configEaseFromString = function _configEaseFromString2(name) {
    var split = (name + "").split("("), ease2 = _easeMap[split[0]];
    return ease2 && split.length > 1 && ease2.config ? ease2.config.apply(null, ~name.indexOf("{") ? [_parseObjectInString(split[1])] : _valueInParentheses(name).split(",").map(_numericIfPossible)) : _easeMap._CE && _customEaseExp.test(name) ? _easeMap._CE("", name) : ease2;
  };
  var _invertEase = function _invertEase2(ease2) {
    return function(p) {
      return 1 - ease2(1 - p);
    };
  };
  var _propagateYoyoEase = function _propagateYoyoEase2(timeline2, isYoyo) {
    var child = timeline2._first, ease2;
    while (child) {
      if (child instanceof Timeline) {
        _propagateYoyoEase2(child, isYoyo);
      } else if (child.vars.yoyoEase && (!child._yoyo || !child._repeat) && child._yoyo !== isYoyo) {
        if (child.timeline) {
          _propagateYoyoEase2(child.timeline, isYoyo);
        } else {
          ease2 = child._ease;
          child._ease = child._yEase;
          child._yEase = ease2;
          child._yoyo = isYoyo;
        }
      }
      child = child._next;
    }
  };
  var _parseEase = function _parseEase2(ease2, defaultEase) {
    return !ease2 ? defaultEase : (_isFunction(ease2) ? ease2 : _easeMap[ease2] || _configEaseFromString(ease2)) || defaultEase;
  };
  var _insertEase = function _insertEase2(names, easeIn2, easeOut2, easeInOut2) {
    if (easeOut2 === void 0) {
      easeOut2 = function easeOut3(p) {
        return 1 - easeIn2(1 - p);
      };
    }
    if (easeInOut2 === void 0) {
      easeInOut2 = function easeInOut3(p) {
        return p < 0.5 ? easeIn2(p * 2) / 2 : 1 - easeIn2((1 - p) * 2) / 2;
      };
    }
    var ease2 = {
      easeIn: easeIn2,
      easeOut: easeOut2,
      easeInOut: easeInOut2
    }, lowercaseName;
    _forEachName(names, function(name) {
      _easeMap[name] = _globals[name] = ease2;
      _easeMap[lowercaseName = name.toLowerCase()] = easeOut2;
      for (var p in ease2) {
        _easeMap[lowercaseName + (p === "easeIn" ? ".in" : p === "easeOut" ? ".out" : ".inOut")] = _easeMap[name + "." + p] = ease2[p];
      }
    });
    return ease2;
  };
  var _easeInOutFromOut = function _easeInOutFromOut2(easeOut2) {
    return function(p) {
      return p < 0.5 ? (1 - easeOut2(1 - p * 2)) / 2 : 0.5 + easeOut2((p - 0.5) * 2) / 2;
    };
  };
  var _configElastic = function _configElastic2(type, amplitude, period) {
    var p1 = amplitude >= 1 ? amplitude : 1, p2 = (period || (type ? 0.3 : 0.45)) / (amplitude < 1 ? amplitude : 1), p3 = p2 / _2PI * (Math.asin(1 / p1) || 0), easeOut2 = function easeOut3(p) {
      return p === 1 ? 1 : p1 * Math.pow(2, -10 * p) * _sin((p - p3) * p2) + 1;
    }, ease2 = type === "out" ? easeOut2 : type === "in" ? function(p) {
      return 1 - easeOut2(1 - p);
    } : _easeInOutFromOut(easeOut2);
    p2 = _2PI / p2;
    ease2.config = function(amplitude2, period2) {
      return _configElastic2(type, amplitude2, period2);
    };
    return ease2;
  };
  var _configBack = function _configBack2(type, overshoot) {
    if (overshoot === void 0) {
      overshoot = 1.70158;
    }
    var easeOut2 = function easeOut3(p) {
      return p ? --p * p * ((overshoot + 1) * p + overshoot) + 1 : 0;
    }, ease2 = type === "out" ? easeOut2 : type === "in" ? function(p) {
      return 1 - easeOut2(1 - p);
    } : _easeInOutFromOut(easeOut2);
    ease2.config = function(overshoot2) {
      return _configBack2(type, overshoot2);
    };
    return ease2;
  };
  _forEachName("Linear,Quad,Cubic,Quart,Quint,Strong", function(name, i) {
    var power = i < 5 ? i + 1 : i;
    _insertEase(name + ",Power" + (power - 1), i ? function(p) {
      return Math.pow(p, power);
    } : function(p) {
      return p;
    }, function(p) {
      return 1 - Math.pow(1 - p, power);
    }, function(p) {
      return p < 0.5 ? Math.pow(p * 2, power) / 2 : 1 - Math.pow((1 - p) * 2, power) / 2;
    });
  });
  _easeMap.Linear.easeNone = _easeMap.none = _easeMap.Linear.easeIn;
  _insertEase("Elastic", _configElastic("in"), _configElastic("out"), _configElastic());
  (function(n, c) {
    var n1 = 1 / c, n2 = 2 * n1, n3 = 2.5 * n1, easeOut2 = function easeOut3(p) {
      return p < n1 ? n * p * p : p < n2 ? n * Math.pow(p - 1.5 / c, 2) + 0.75 : p < n3 ? n * (p -= 2.25 / c) * p + 0.9375 : n * Math.pow(p - 2.625 / c, 2) + 0.984375;
    };
    _insertEase("Bounce", function(p) {
      return 1 - easeOut2(1 - p);
    }, easeOut2);
  })(7.5625, 2.75);
  _insertEase("Expo", function(p) {
    return Math.pow(2, 10 * (p - 1)) * p + p * p * p * p * p * p * (1 - p);
  });
  _insertEase("Circ", function(p) {
    return -(_sqrt(1 - p * p) - 1);
  });
  _insertEase("Sine", function(p) {
    return p === 1 ? 1 : -_cos(p * _HALF_PI) + 1;
  });
  _insertEase("Back", _configBack("in"), _configBack("out"), _configBack());
  _easeMap.SteppedEase = _easeMap.steps = _globals.SteppedEase = {
    config: function config(steps, immediateStart) {
      if (steps === void 0) {
        steps = 1;
      }
      var p1 = 1 / steps, p2 = steps + (immediateStart ? 0 : 1), p3 = immediateStart ? 1 : 0, max = 1 - _tinyNum;
      return function(p) {
        return ((p2 * _clamp(0, max, p) | 0) + p3) * p1;
      };
    }
  };
  _defaults.ease = _easeMap["quad.out"];
  _forEachName("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function(name) {
    return _callbackNames += name + "," + name + "Params,";
  });
  var GSCache = function GSCache2(target, harness) {
    this.id = _gsID++;
    target._gsap = this;
    this.target = target;
    this.harness = harness;
    this.get = harness ? harness.get : _getProperty;
    this.set = harness ? harness.getSetter : _getSetter;
  };
  var Animation = /* @__PURE__ */ (function() {
    function Animation2(vars) {
      this.vars = vars;
      this._delay = +vars.delay || 0;
      if (this._repeat = vars.repeat === Infinity ? -2 : vars.repeat || 0) {
        this._rDelay = vars.repeatDelay || 0;
        this._yoyo = !!vars.yoyo || !!vars.yoyoEase;
      }
      this._ts = 1;
      _setDuration(this, +vars.duration, 1, 1);
      this.data = vars.data;
      if (_context) {
        this._ctx = _context;
        _context.data.push(this);
      }
      _tickerActive || _ticker.wake();
    }
    var _proto = Animation2.prototype;
    _proto.delay = function delay2(value) {
      if (value || value === 0) {
        this.parent && this.parent.smoothChildTiming && this.startTime(this._start + value - this._delay);
        this._delay = value;
        return this;
      }
      return this._delay;
    };
    _proto.duration = function duration(value) {
      return arguments.length ? this.totalDuration(this._repeat > 0 ? value + (value + this._rDelay) * this._repeat : value) : this.totalDuration() && this._dur;
    };
    _proto.totalDuration = function totalDuration(value) {
      if (!arguments.length) {
        return this._tDur;
      }
      this._dirty = 0;
      return _setDuration(this, this._repeat < 0 ? value : (value - this._repeat * this._rDelay) / (this._repeat + 1));
    };
    _proto.totalTime = function totalTime(_totalTime, suppressEvents) {
      _wake();
      if (!arguments.length) {
        return this._tTime;
      }
      var parent = this._dp;
      if (parent && parent.smoothChildTiming && this._ts) {
        _alignPlayhead(this, _totalTime);
        !parent._dp || parent.parent || _postAddChecks(parent, this);
        while (parent && parent.parent) {
          if (parent.parent._time !== parent._start + (parent._ts >= 0 ? parent._tTime / parent._ts : (parent.totalDuration() - parent._tTime) / -parent._ts)) {
            parent.totalTime(parent._tTime, true);
          }
          parent = parent.parent;
        }
        if (!this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && _totalTime < this._tDur || this._ts < 0 && _totalTime > 0 || !this._tDur && !_totalTime)) {
          _addToTimeline(this._dp, this, this._start - this._delay);
        }
      }
      if (this._tTime !== _totalTime || !this._dur && !suppressEvents || this._initted && Math.abs(this._zTime) === _tinyNum || !_totalTime && !this._initted && (this.add || this._ptLookup)) {
        this._ts || (this._pTime = _totalTime);
        _lazySafeRender(this, _totalTime, suppressEvents);
      }
      return this;
    };
    _proto.time = function time2(value, suppressEvents) {
      return arguments.length ? this.totalTime(Math.min(this.totalDuration(), value + _elapsedCycleDuration(this)) % (this._dur + this._rDelay) || (value ? this._dur : 0), suppressEvents) : this._time;
    };
    _proto.totalProgress = function totalProgress(value, suppressEvents) {
      return arguments.length ? this.totalTime(this.totalDuration() * value, suppressEvents) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() >= 0 && this._initted ? 1 : 0;
    };
    _proto.progress = function progress2(value, suppressEvents) {
      return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - value : value) + _elapsedCycleDuration(this), suppressEvents) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0;
    };
    _proto.iteration = function iteration(value, suppressEvents) {
      var cycleDuration = this.duration() + this._rDelay;
      return arguments.length ? this.totalTime(this._time + (value - 1) * cycleDuration, suppressEvents) : this._repeat ? _animationCycle(this._tTime, cycleDuration) + 1 : 1;
    };
    _proto.timeScale = function timeScale(value, suppressEvents) {
      if (!arguments.length) {
        return this._rts === -_tinyNum ? 0 : this._rts;
      }
      if (this._rts === value) {
        return this;
      }
      var tTime = this.parent && this._ts ? _parentToChildTotalTime(this.parent._time, this) : this._tTime;
      this._rts = +value || 0;
      this._ts = this._ps || value === -_tinyNum ? 0 : this._rts;
      this.totalTime(_clamp(-Math.abs(this._delay), this.totalDuration(), tTime), suppressEvents !== false);
      _setEnd(this);
      return _recacheAncestors(this);
    };
    _proto.paused = function paused(value) {
      if (!arguments.length) {
        return this._ps;
      }
      if (this._ps !== value) {
        this._ps = value;
        if (value) {
          this._pTime = this._tTime || Math.max(-this._delay, this.rawTime());
          this._ts = this._act = 0;
        } else {
          _wake();
          this._ts = this._rts;
          this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== _tinyNum && (this._tTime -= _tinyNum));
        }
      }
      return this;
    };
    _proto.startTime = function startTime(value) {
      if (arguments.length) {
        this._start = value;
        var parent = this.parent || this._dp;
        parent && (parent._sort || !this.parent) && _addToTimeline(parent, this, value - this._delay);
        return this;
      }
      return this._start;
    };
    _proto.endTime = function endTime(includeRepeats) {
      return this._start + (_isNotFalse(includeRepeats) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1);
    };
    _proto.rawTime = function rawTime(wrapRepeats) {
      var parent = this.parent || this._dp;
      return !parent ? this._tTime : wrapRepeats && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : !this._ts ? this._tTime : _parentToChildTotalTime(parent.rawTime(wrapRepeats), this);
    };
    _proto.revert = function revert(config3) {
      if (config3 === void 0) {
        config3 = _revertConfig;
      }
      var prevIsReverting = _reverting;
      _reverting = config3;
      if (_isRevertWorthy(this)) {
        this.timeline && this.timeline.revert(config3);
        this.totalTime(-0.01, config3.suppressEvents);
      }
      this.data !== "nested" && config3.kill !== false && this.kill();
      _reverting = prevIsReverting;
      return this;
    };
    _proto.globalTime = function globalTime(rawTime) {
      var animation = this, time2 = arguments.length ? rawTime : animation.rawTime();
      while (animation) {
        time2 = animation._start + time2 / (Math.abs(animation._ts) || 1);
        animation = animation._dp;
      }
      return !this.parent && this._sat ? this._sat.globalTime(rawTime) : time2;
    };
    _proto.repeat = function repeat(value) {
      if (arguments.length) {
        this._repeat = value === Infinity ? -2 : value;
        return _onUpdateTotalDuration(this);
      }
      return this._repeat === -2 ? Infinity : this._repeat;
    };
    _proto.repeatDelay = function repeatDelay(value) {
      if (arguments.length) {
        var time2 = this._time;
        this._rDelay = value;
        _onUpdateTotalDuration(this);
        return time2 ? this.time(time2) : this;
      }
      return this._rDelay;
    };
    _proto.yoyo = function yoyo(value) {
      if (arguments.length) {
        this._yoyo = value;
        return this;
      }
      return this._yoyo;
    };
    _proto.seek = function seek(position, suppressEvents) {
      return this.totalTime(_parsePosition(this, position), _isNotFalse(suppressEvents));
    };
    _proto.restart = function restart(includeDelay, suppressEvents) {
      this.play().totalTime(includeDelay ? -this._delay : 0, _isNotFalse(suppressEvents));
      this._dur || (this._zTime = -_tinyNum);
      return this;
    };
    _proto.play = function play(from, suppressEvents) {
      from != null && this.seek(from, suppressEvents);
      return this.reversed(false).paused(false);
    };
    _proto.reverse = function reverse(from, suppressEvents) {
      from != null && this.seek(from || this.totalDuration(), suppressEvents);
      return this.reversed(true).paused(false);
    };
    _proto.pause = function pause(atTime, suppressEvents) {
      atTime != null && this.seek(atTime, suppressEvents);
      return this.paused(true);
    };
    _proto.resume = function resume() {
      return this.paused(false);
    };
    _proto.reversed = function reversed(value) {
      if (arguments.length) {
        !!value !== this.reversed() && this.timeScale(-this._rts || (value ? -_tinyNum : 0));
        return this;
      }
      return this._rts < 0;
    };
    _proto.invalidate = function invalidate() {
      this._initted = this._act = 0;
      this._zTime = -_tinyNum;
      return this;
    };
    _proto.isActive = function isActive() {
      var parent = this.parent || this._dp, start = this._start, rawTime;
      return !!(!parent || this._ts && this._initted && parent.isActive() && (rawTime = parent.rawTime(true)) >= start && rawTime < this.endTime(true) - _tinyNum);
    };
    _proto.eventCallback = function eventCallback(type, callback, params) {
      var vars = this.vars;
      if (arguments.length > 1) {
        if (!callback) {
          delete vars[type];
        } else {
          vars[type] = callback;
          params && (vars[type + "Params"] = params);
          type === "onUpdate" && (this._onUpdate = callback);
        }
        return this;
      }
      return vars[type];
    };
    _proto.then = function then(onFulfilled) {
      var self2 = this;
      return new Promise(function(resolve) {
        var f = _isFunction(onFulfilled) ? onFulfilled : _passThrough, _resolve = function _resolve2() {
          var _then = self2.then;
          self2.then = null;
          _isFunction(f) && (f = f(self2)) && (f.then || f === self2) && (self2.then = _then);
          resolve(f);
          self2.then = _then;
        };
        if (self2._initted && self2.totalProgress() === 1 && self2._ts >= 0 || !self2._tTime && self2._ts < 0) {
          _resolve();
        } else {
          self2._prom = _resolve;
        }
      });
    };
    _proto.kill = function kill() {
      _interrupt(this);
    };
    return Animation2;
  })();
  _setDefaults(Animation.prototype, {
    _time: 0,
    _start: 0,
    _end: 0,
    _tTime: 0,
    _tDur: 0,
    _dirty: 0,
    _repeat: 0,
    _yoyo: false,
    parent: null,
    _initted: false,
    _rDelay: 0,
    _ts: 1,
    _dp: 0,
    ratio: 0,
    _zTime: -_tinyNum,
    _prom: 0,
    _ps: false,
    _rts: 1
  });
  var Timeline = /* @__PURE__ */ (function(_Animation) {
    _inheritsLoose(Timeline2, _Animation);
    function Timeline2(vars, position) {
      var _this;
      if (vars === void 0) {
        vars = {};
      }
      _this = _Animation.call(this, vars) || this;
      _this.labels = {};
      _this.smoothChildTiming = !!vars.smoothChildTiming;
      _this.autoRemoveChildren = !!vars.autoRemoveChildren;
      _this._sort = _isNotFalse(vars.sortChildren);
      _globalTimeline && _addToTimeline(vars.parent || _globalTimeline, _assertThisInitialized(_this), position);
      vars.reversed && _this.reverse();
      vars.paused && _this.paused(true);
      vars.scrollTrigger && _scrollTrigger(_assertThisInitialized(_this), vars.scrollTrigger);
      return _this;
    }
    var _proto2 = Timeline2.prototype;
    _proto2.to = function to(targets, vars, position) {
      _createTweenType(0, arguments, this);
      return this;
    };
    _proto2.from = function from(targets, vars, position) {
      _createTweenType(1, arguments, this);
      return this;
    };
    _proto2.fromTo = function fromTo(targets, fromVars, toVars, position) {
      _createTweenType(2, arguments, this);
      return this;
    };
    _proto2.set = function set(targets, vars, position) {
      vars.duration = 0;
      vars.parent = this;
      _inheritDefaults(vars).repeatDelay || (vars.repeat = 0);
      vars.immediateRender = !!vars.immediateRender;
      new Tween(targets, vars, _parsePosition(this, position), 1);
      return this;
    };
    _proto2.call = function call(callback, params, position) {
      return _addToTimeline(this, Tween.delayedCall(0, callback, params), position);
    };
    _proto2.staggerTo = function staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
      vars.duration = duration;
      vars.stagger = vars.stagger || stagger;
      vars.onComplete = onCompleteAll;
      vars.onCompleteParams = onCompleteAllParams;
      vars.parent = this;
      new Tween(targets, vars, _parsePosition(this, position));
      return this;
    };
    _proto2.staggerFrom = function staggerFrom(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
      vars.runBackwards = 1;
      _inheritDefaults(vars).immediateRender = _isNotFalse(vars.immediateRender);
      return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams);
    };
    _proto2.staggerFromTo = function staggerFromTo(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams) {
      toVars.startAt = fromVars;
      _inheritDefaults(toVars).immediateRender = _isNotFalse(toVars.immediateRender);
      return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams);
    };
    _proto2.render = function render4(totalTime, suppressEvents, force) {
      var prevTime = this._time, tDur = this._dirty ? this.totalDuration() : this._tDur, dur = this._dur, tTime = totalTime <= 0 ? 0 : _roundPrecise(totalTime), crossingStart = this._zTime < 0 !== totalTime < 0 && (this._initted || !dur), time2, child, next, iteration, cycleDuration, prevPaused, pauseTween, timeScale, prevStart, prevIteration, yoyo, isYoyo;
      this !== _globalTimeline && tTime > tDur && totalTime >= 0 && (tTime = tDur);
      if (tTime !== this._tTime || force || crossingStart) {
        if (prevTime !== this._time && dur) {
          tTime += this._time - prevTime;
          totalTime += this._time - prevTime;
        }
        time2 = tTime;
        prevStart = this._start;
        timeScale = this._ts;
        prevPaused = !timeScale;
        if (crossingStart) {
          dur || (prevTime = this._zTime);
          (totalTime || !suppressEvents) && (this._zTime = totalTime);
        }
        if (this._repeat) {
          yoyo = this._yoyo;
          cycleDuration = dur + this._rDelay;
          if (this._repeat < -1 && totalTime < 0) {
            return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
          }
          time2 = _roundPrecise(tTime % cycleDuration);
          if (tTime === tDur) {
            iteration = this._repeat;
            time2 = dur;
          } else {
            prevIteration = _roundPrecise(tTime / cycleDuration);
            iteration = ~~prevIteration;
            if (iteration && iteration === prevIteration) {
              time2 = dur;
              iteration--;
            }
            time2 > dur && (time2 = dur);
          }
          prevIteration = _animationCycle(this._tTime, cycleDuration);
          !prevTime && this._tTime && prevIteration !== iteration && this._tTime - prevIteration * cycleDuration - this._dur <= 0 && (prevIteration = iteration);
          if (yoyo && iteration & 1) {
            time2 = dur - time2;
            isYoyo = 1;
          }
          if (iteration !== prevIteration && !this._lock) {
            var rewinding = yoyo && prevIteration & 1, doesWrap = rewinding === (yoyo && iteration & 1);
            iteration < prevIteration && (rewinding = !rewinding);
            prevTime = rewinding ? 0 : tTime % dur ? dur : tTime;
            this._lock = 1;
            this.render(prevTime || (isYoyo ? 0 : _roundPrecise(iteration * cycleDuration)), suppressEvents, !dur)._lock = 0;
            this._tTime = tTime;
            !suppressEvents && this.parent && _callback(this, "onRepeat");
            this.vars.repeatRefresh && !isYoyo && (this.invalidate()._lock = 1);
            if (prevTime && prevTime !== this._time || prevPaused !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) {
              return this;
            }
            dur = this._dur;
            tDur = this._tDur;
            if (doesWrap) {
              this._lock = 2;
              prevTime = rewinding ? dur : -1e-4;
              this.render(prevTime, true);
              this.vars.repeatRefresh && !isYoyo && this.invalidate();
            }
            this._lock = 0;
            if (!this._ts && !prevPaused) {
              return this;
            }
            _propagateYoyoEase(this, isYoyo);
          }
        }
        if (this._hasPause && !this._forcing && this._lock < 2) {
          pauseTween = _findNextPauseTween(this, _roundPrecise(prevTime), _roundPrecise(time2));
          if (pauseTween) {
            tTime -= time2 - (time2 = pauseTween._start);
          }
        }
        this._tTime = tTime;
        this._time = time2;
        this._act = !timeScale;
        if (!this._initted) {
          this._onUpdate = this.vars.onUpdate;
          this._initted = 1;
          this._zTime = totalTime;
          prevTime = 0;
        }
        if (!prevTime && tTime && !suppressEvents && !prevIteration) {
          _callback(this, "onStart");
          if (this._tTime !== tTime) {
            return this;
          }
        }
        if (time2 >= prevTime && totalTime >= 0) {
          child = this._first;
          while (child) {
            next = child._next;
            if ((child._act || time2 >= child._start) && child._ts && pauseTween !== child) {
              if (child.parent !== this) {
                return this.render(totalTime, suppressEvents, force);
              }
              child.render(child._ts > 0 ? (time2 - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (time2 - child._start) * child._ts, suppressEvents, force);
              if (time2 !== this._time || !this._ts && !prevPaused) {
                pauseTween = 0;
                next && (tTime += this._zTime = -_tinyNum);
                break;
              }
            }
            child = next;
          }
        } else {
          child = this._last;
          var adjustedTime = totalTime < 0 ? totalTime : time2;
          while (child) {
            next = child._prev;
            if ((child._act || adjustedTime <= child._end) && child._ts && pauseTween !== child) {
              if (child.parent !== this) {
                return this.render(totalTime, suppressEvents, force);
              }
              child.render(child._ts > 0 ? (adjustedTime - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (adjustedTime - child._start) * child._ts, suppressEvents, force || _reverting && _isRevertWorthy(child));
              if (time2 !== this._time || !this._ts && !prevPaused) {
                pauseTween = 0;
                next && (tTime += this._zTime = adjustedTime ? -_tinyNum : _tinyNum);
                break;
              }
            }
            child = next;
          }
        }
        if (pauseTween && !suppressEvents) {
          this.pause();
          pauseTween.render(time2 >= prevTime ? 0 : -_tinyNum)._zTime = time2 >= prevTime ? 1 : -1;
          if (this._ts) {
            this._start = prevStart;
            _setEnd(this);
            return this.render(totalTime, suppressEvents, force);
          }
        }
        this._onUpdate && !suppressEvents && _callback(this, "onUpdate", true);
        if (tTime === tDur && this._tTime >= this.totalDuration() || !tTime && prevTime) {
          if (prevStart === this._start || Math.abs(timeScale) !== Math.abs(this._ts)) {
            if (!this._lock) {
              (totalTime || !dur) && (tTime === tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1);
              if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime || !tDur)) {
                _callback(this, tTime === tDur && totalTime >= 0 ? "onComplete" : "onReverseComplete", true);
                this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
              }
            }
          }
        }
      }
      return this;
    };
    _proto2.add = function add(child, position) {
      var _this2 = this;
      _isNumber(position) || (position = _parsePosition(this, position, child));
      if (!(child instanceof Animation)) {
        if (_isArray(child)) {
          child.forEach(function(obj) {
            return _this2.add(obj, position);
          });
          return this;
        }
        if (_isString(child)) {
          return this.addLabel(child, position);
        }
        if (_isFunction(child)) {
          child = Tween.delayedCall(0, child);
        } else {
          return this;
        }
      }
      return this !== child ? _addToTimeline(this, child, position) : this;
    };
    _proto2.getChildren = function getChildren(nested, tweens, timelines, ignoreBeforeTime) {
      if (nested === void 0) {
        nested = true;
      }
      if (tweens === void 0) {
        tweens = true;
      }
      if (timelines === void 0) {
        timelines = true;
      }
      if (ignoreBeforeTime === void 0) {
        ignoreBeforeTime = -_bigNum;
      }
      var a = [], child = this._first;
      while (child) {
        if (child._start >= ignoreBeforeTime) {
          if (child instanceof Tween) {
            tweens && a.push(child);
          } else {
            timelines && a.push(child);
            nested && a.push.apply(a, child.getChildren(true, tweens, timelines));
          }
        }
        child = child._next;
      }
      return a;
    };
    _proto2.getById = function getById2(id3) {
      var animations2 = this.getChildren(1, 1, 1), i = animations2.length;
      while (i--) {
        if (animations2[i].vars.id === id3) {
          return animations2[i];
        }
      }
    };
    _proto2.remove = function remove(child) {
      if (_isString(child)) {
        return this.removeLabel(child);
      }
      if (_isFunction(child)) {
        return this.killTweensOf(child);
      }
      child.parent === this && _removeLinkedListItem(this, child);
      if (child === this._recent) {
        this._recent = this._last;
      }
      return _uncache(this);
    };
    _proto2.totalTime = function totalTime(_totalTime2, suppressEvents) {
      if (!arguments.length) {
        return this._tTime;
      }
      this._forcing = 1;
      if (!this._dp && this._ts) {
        this._start = _roundPrecise(_ticker.time - (this._ts > 0 ? _totalTime2 / this._ts : (this.totalDuration() - _totalTime2) / -this._ts));
      }
      _Animation.prototype.totalTime.call(this, _totalTime2, suppressEvents);
      this._forcing = 0;
      return this;
    };
    _proto2.addLabel = function addLabel(label, position) {
      this.labels[label] = _parsePosition(this, position);
      return this;
    };
    _proto2.removeLabel = function removeLabel(label) {
      delete this.labels[label];
      return this;
    };
    _proto2.addPause = function addPause(position, callback, params) {
      var t = Tween.delayedCall(0, callback || _emptyFunc, params);
      t.data = "isPause";
      this._hasPause = 1;
      return _addToTimeline(this, t, _parsePosition(this, position));
    };
    _proto2.removePause = function removePause(position) {
      var child = this._first;
      position = _parsePosition(this, position);
      while (child) {
        if (child._start === position && child.data === "isPause") {
          _removeFromParent(child);
        }
        child = child._next;
      }
    };
    _proto2.killTweensOf = function killTweensOf(targets, props, onlyActive) {
      var tweens = this.getTweensOf(targets, onlyActive), i = tweens.length;
      while (i--) {
        _overwritingTween !== tweens[i] && tweens[i].kill(targets, props);
      }
      return this;
    };
    _proto2.getTweensOf = function getTweensOf2(targets, onlyActive) {
      var a = [], parsedTargets = toArray(targets), child = this._first, isGlobalTime = _isNumber(onlyActive), children;
      while (child) {
        if (child instanceof Tween) {
          if (_arrayContainsAny(child._targets, parsedTargets) && (isGlobalTime ? (!_overwritingTween || child._initted && child._ts) && child.globalTime(0) <= onlyActive && child.globalTime(child.totalDuration()) > onlyActive : !onlyActive || child.isActive())) {
            a.push(child);
          }
        } else if ((children = child.getTweensOf(parsedTargets, onlyActive)).length) {
          a.push.apply(a, children);
        }
        child = child._next;
      }
      return a;
    };
    _proto2.tweenTo = function tweenTo(position, vars) {
      vars = vars || {};
      var tl = this, endTime = _parsePosition(tl, position), _vars = vars, startAt = _vars.startAt, _onStart = _vars.onStart, onStartParams = _vars.onStartParams, immediateRender = _vars.immediateRender, initted, tween = Tween.to(tl, _setDefaults({
        ease: vars.ease || "none",
        lazy: false,
        immediateRender: false,
        time: endTime,
        overwrite: "auto",
        duration: vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale()) || _tinyNum,
        onStart: function onStart() {
          tl.pause();
          if (!initted) {
            var duration = vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale());
            tween._dur !== duration && _setDuration(tween, duration, 0, 1).render(tween._time, true, true);
            initted = 1;
          }
          _onStart && _onStart.apply(tween, onStartParams || []);
        }
      }, vars));
      return immediateRender ? tween.render(0) : tween;
    };
    _proto2.tweenFromTo = function tweenFromTo(fromPosition, toPosition, vars) {
      return this.tweenTo(toPosition, _setDefaults({
        startAt: {
          time: _parsePosition(this, fromPosition)
        }
      }, vars));
    };
    _proto2.recent = function recent() {
      return this._recent;
    };
    _proto2.nextLabel = function nextLabel(afterTime) {
      if (afterTime === void 0) {
        afterTime = this._time;
      }
      return _getLabelInDirection(this, _parsePosition(this, afterTime));
    };
    _proto2.previousLabel = function previousLabel(beforeTime) {
      if (beforeTime === void 0) {
        beforeTime = this._time;
      }
      return _getLabelInDirection(this, _parsePosition(this, beforeTime), 1);
    };
    _proto2.currentLabel = function currentLabel(value) {
      return arguments.length ? this.seek(value, true) : this.previousLabel(this._time + _tinyNum);
    };
    _proto2.shiftChildren = function shiftChildren(amount, adjustLabels, ignoreBeforeTime) {
      if (ignoreBeforeTime === void 0) {
        ignoreBeforeTime = 0;
      }
      var child = this._first, labels = this.labels, p;
      while (child) {
        if (child._start >= ignoreBeforeTime) {
          child._start += amount;
          child._end += amount;
        }
        child = child._next;
      }
      if (adjustLabels) {
        for (p in labels) {
          if (labels[p] >= ignoreBeforeTime) {
            labels[p] += amount;
          }
        }
      }
      return _uncache(this);
    };
    _proto2.invalidate = function invalidate(soft) {
      var child = this._first;
      this._lock = 0;
      while (child) {
        child.invalidate(soft);
        child = child._next;
      }
      return _Animation.prototype.invalidate.call(this, soft);
    };
    _proto2.clear = function clear(includeLabels) {
      if (includeLabels === void 0) {
        includeLabels = true;
      }
      var child = this._first, next;
      while (child) {
        next = child._next;
        this.remove(child);
        child = next;
      }
      this._dp && (this._time = this._tTime = this._pTime = 0);
      includeLabels && (this.labels = {});
      return _uncache(this);
    };
    _proto2.totalDuration = function totalDuration(value) {
      var max = 0, self2 = this, child = self2._last, prevStart = _bigNum, prev, start, parent;
      if (arguments.length) {
        return self2.timeScale((self2._repeat < 0 ? self2.duration() : self2.totalDuration()) / (self2.reversed() ? -value : value));
      }
      if (self2._dirty) {
        parent = self2.parent;
        while (child) {
          prev = child._prev;
          child._dirty && child.totalDuration();
          start = child._start;
          if (start > prevStart && self2._sort && child._ts && !self2._lock) {
            self2._lock = 1;
            _addToTimeline(self2, child, start - child._delay, 1)._lock = 0;
          } else {
            prevStart = start;
          }
          if (start < 0 && child._ts) {
            max -= start;
            if (!parent && !self2._dp || parent && parent.smoothChildTiming) {
              self2._start += start / self2._ts;
              self2._time -= start;
              self2._tTime -= start;
            }
            self2.shiftChildren(-start, false, -Infinity);
            prevStart = 0;
          }
          child._end > max && child._ts && (max = child._end);
          child = prev;
        }
        _setDuration(self2, self2 === _globalTimeline && self2._time > max ? self2._time : max, 1, 1);
        self2._dirty = 0;
      }
      return self2._tDur;
    };
    Timeline2.updateRoot = function updateRoot(time2) {
      if (_globalTimeline._ts) {
        _lazySafeRender(_globalTimeline, _parentToChildTotalTime(time2, _globalTimeline));
        _lastRenderedFrame = _ticker.frame;
      }
      if (_ticker.frame >= _nextGCFrame) {
        _nextGCFrame += _config.autoSleep || 120;
        var child = _globalTimeline._first;
        if (!child || !child._ts) {
          if (_config.autoSleep && _ticker._listeners.length < 2) {
            while (child && !child._ts) {
              child = child._next;
            }
            child || _ticker.sleep();
          }
        }
      }
    };
    return Timeline2;
  })(Animation);
  _setDefaults(Timeline.prototype, {
    _lock: 0,
    _hasPause: 0,
    _forcing: 0
  });
  var _addComplexStringPropTween = function _addComplexStringPropTween2(target, prop, start, end, setter, stringFilter, funcParam) {
    var pt = new PropTween(this._pt, target, prop, 0, 1, _renderComplexString, null, setter), index = 0, matchIndex = 0, result, startNums, color2, endNum, chunk, startNum, hasRandom, a;
    pt.b = start;
    pt.e = end;
    start += "";
    end += "";
    if (hasRandom = ~end.indexOf("random(")) {
      end = _replaceRandom(end);
    }
    if (stringFilter) {
      a = [start, end];
      stringFilter(a, target, prop);
      start = a[0];
      end = a[1];
    }
    startNums = start.match(_complexStringNumExp) || [];
    while (result = _complexStringNumExp.exec(end)) {
      endNum = result[0];
      chunk = end.substring(index, result.index);
      if (color2) {
        color2 = (color2 + 1) % 5;
      } else if (chunk.substr(-5) === "rgba(") {
        color2 = 1;
      }
      if (endNum !== startNums[matchIndex++]) {
        startNum = parseFloat(startNums[matchIndex - 1]) || 0;
        pt._pt = {
          _next: pt._pt,
          p: chunk || matchIndex === 1 ? chunk : ",",
          //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
          s: startNum,
          c: endNum.charAt(1) === "=" ? _parseRelative(startNum, endNum) - startNum : parseFloat(endNum) - startNum,
          m: color2 && color2 < 4 ? Math.round : 0
        };
        index = _complexStringNumExp.lastIndex;
      }
    }
    pt.c = index < end.length ? end.substring(index, end.length) : "";
    pt.fp = funcParam;
    if (_relExp.test(end) || hasRandom) {
      pt.e = 0;
    }
    this._pt = pt;
    return pt;
  };
  var _addPropTween = function _addPropTween2(target, prop, start, end, index, targets, modifier, stringFilter, funcParam, optional) {
    _isFunction(end) && (end = end(index || 0, target, targets));
    var currentValue = target[prop], parsedStart = start !== "get" ? start : !_isFunction(currentValue) ? currentValue : funcParam ? target[prop.indexOf("set") || !_isFunction(target["get" + prop.substr(3)]) ? prop : "get" + prop.substr(3)](funcParam) : target[prop](), setter = !_isFunction(currentValue) ? _setterPlain : funcParam ? _setterFuncWithParam : _setterFunc, pt;
    if (_isString(end)) {
      if (~end.indexOf("random(")) {
        end = _replaceRandom(end);
      }
      if (end.charAt(1) === "=") {
        pt = _parseRelative(parsedStart, end) + (getUnit(parsedStart) || 0);
        if (pt || pt === 0) {
          end = pt;
        }
      }
    }
    if (!optional || parsedStart !== end || _forceAllPropTweens) {
      if (!isNaN(parsedStart * end) && end !== "") {
        pt = new PropTween(this._pt, target, prop, +parsedStart || 0, end - (parsedStart || 0), typeof currentValue === "boolean" ? _renderBoolean : _renderPlain, 0, setter);
        funcParam && (pt.fp = funcParam);
        modifier && pt.modifier(modifier, this, target);
        return this._pt = pt;
      }
      !currentValue && !(prop in target) && _missingPlugin(prop, end);
      return _addComplexStringPropTween.call(this, target, prop, parsedStart, end, setter, stringFilter || _config.stringFilter, funcParam);
    }
  };
  var _processVars = function _processVars2(vars, index, target, targets, tween) {
    _isFunction(vars) && (vars = _parseFuncOrString(vars, tween, index, target, targets));
    if (!_isObject(vars) || vars.style && vars.nodeType || _isArray(vars) || _isTypedArray(vars)) {
      return _isString(vars) ? _parseFuncOrString(vars, tween, index, target, targets) : vars;
    }
    var copy = {}, p;
    for (p in vars) {
      copy[p] = _parseFuncOrString(vars[p], tween, index, target, targets);
    }
    return copy;
  };
  var _checkPlugin = function _checkPlugin2(property, vars, tween, index, target, targets) {
    var plugin, pt, ptLookup, i;
    if (_plugins[property] && (plugin = new _plugins[property]()).init(target, plugin.rawVars ? vars[property] : _processVars(vars[property], index, target, targets, tween), tween, index, targets) !== false) {
      tween._pt = pt = new PropTween(tween._pt, target, property, 0, 1, plugin.render, plugin, 0, plugin.priority);
      if (tween !== _quickTween) {
        ptLookup = tween._ptLookup[tween._targets.indexOf(target)];
        i = plugin._props.length;
        while (i--) {
          ptLookup[plugin._props[i]] = pt;
        }
      }
    }
    return plugin;
  };
  var _overwritingTween;
  var _forceAllPropTweens;
  var _initTween = function _initTween2(tween, time2, tTime) {
    var vars = tween.vars, ease2 = vars.ease, startAt = vars.startAt, immediateRender = vars.immediateRender, lazy = vars.lazy, onUpdate = vars.onUpdate, runBackwards = vars.runBackwards, yoyoEase = vars.yoyoEase, keyframes2 = vars.keyframes, autoRevert = vars.autoRevert, dur = tween._dur, prevStartAt = tween._startAt, targets = tween._targets, parent = tween.parent, fullTargets = parent && parent.data === "nested" ? parent.vars.targets : targets, autoOverwrite = tween._overwrite === "auto" && !_suppressOverwrites, tl = tween.timeline, cleanVars, i, p, pt, target, hasPriority, gsData, harness, plugin, ptLookup, index, harnessVars, overwritten;
    tl && (!keyframes2 || !ease2) && (ease2 = "none");
    tween._ease = _parseEase(ease2, _defaults.ease);
    tween._yEase = yoyoEase ? _invertEase(_parseEase(yoyoEase === true ? ease2 : yoyoEase, _defaults.ease)) : 0;
    if (yoyoEase && tween._yoyo && !tween._repeat) {
      yoyoEase = tween._yEase;
      tween._yEase = tween._ease;
      tween._ease = yoyoEase;
    }
    tween._from = !tl && !!vars.runBackwards;
    if (!tl || keyframes2 && !vars.stagger) {
      harness = targets[0] ? _getCache(targets[0]).harness : 0;
      harnessVars = harness && vars[harness.prop];
      cleanVars = _copyExcluding(vars, _reservedProps);
      if (prevStartAt) {
        prevStartAt._zTime < 0 && prevStartAt.progress(1);
        time2 < 0 && runBackwards && immediateRender && !autoRevert ? prevStartAt.render(-1, true) : prevStartAt.revert(runBackwards && dur ? _revertConfigNoKill : _startAtRevertConfig);
        prevStartAt._lazy = 0;
      }
      if (startAt) {
        _removeFromParent(tween._startAt = Tween.set(targets, _setDefaults({
          data: "isStart",
          overwrite: false,
          parent,
          immediateRender: true,
          lazy: !prevStartAt && _isNotFalse(lazy),
          startAt: null,
          delay: 0,
          onUpdate: onUpdate && function() {
            return _callback(tween, "onUpdate");
          },
          stagger: 0
        }, startAt)));
        tween._startAt._dp = 0;
        tween._startAt._sat = tween;
        time2 < 0 && (_reverting || !immediateRender && !autoRevert) && tween._startAt.revert(_revertConfigNoKill);
        if (immediateRender) {
          if (dur && time2 <= 0 && tTime <= 0) {
            time2 && (tween._zTime = time2);
            return;
          }
        }
      } else if (runBackwards && dur) {
        if (!prevStartAt) {
          time2 && (immediateRender = false);
          p = _setDefaults({
            overwrite: false,
            data: "isFromStart",
            //we tag the tween with as "isFromStart" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a "from()" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.
            lazy: immediateRender && !prevStartAt && _isNotFalse(lazy),
            immediateRender,
            //zero-duration tweens render immediately by default, but if we're not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we'd have to render(-1) immediately after)
            stagger: 0,
            parent
            //ensures that nested tweens that had a stagger are handled properly, like gsap.from(".class", {y: gsap.utils.wrap([-100,100]), stagger: 0.5})
          }, cleanVars);
          harnessVars && (p[harness.prop] = harnessVars);
          _removeFromParent(tween._startAt = Tween.set(targets, p));
          tween._startAt._dp = 0;
          tween._startAt._sat = tween;
          time2 < 0 && (_reverting ? tween._startAt.revert(_revertConfigNoKill) : tween._startAt.render(-1, true));
          tween._zTime = time2;
          if (!immediateRender) {
            _initTween2(tween._startAt, _tinyNum, _tinyNum);
          } else if (!time2) {
            return;
          }
        }
      }
      tween._pt = tween._ptCache = 0;
      lazy = dur && _isNotFalse(lazy) || lazy && !dur;
      for (i = 0; i < targets.length; i++) {
        target = targets[i];
        gsData = target._gsap || _harness(targets)[i]._gsap;
        tween._ptLookup[i] = ptLookup = {};
        _lazyLookup[gsData.id] && _lazyTweens.length && _lazyRender();
        index = fullTargets === targets ? i : fullTargets.indexOf(target);
        if (harness && (plugin = new harness()).init(target, harnessVars || cleanVars, tween, index, fullTargets) !== false) {
          tween._pt = pt = new PropTween(tween._pt, target, plugin.name, 0, 1, plugin.render, plugin, 0, plugin.priority);
          plugin._props.forEach(function(name) {
            ptLookup[name] = pt;
          });
          plugin.priority && (hasPriority = 1);
        }
        if (!harness || harnessVars) {
          for (p in cleanVars) {
            if (_plugins[p] && (plugin = _checkPlugin(p, cleanVars, tween, index, target, fullTargets))) {
              plugin.priority && (hasPriority = 1);
            } else {
              ptLookup[p] = pt = _addPropTween.call(tween, target, p, "get", cleanVars[p], index, fullTargets, 0, vars.stringFilter);
            }
          }
        }
        tween._op && tween._op[i] && tween.kill(target, tween._op[i]);
        if (autoOverwrite && tween._pt) {
          _overwritingTween = tween;
          _globalTimeline.killTweensOf(target, ptLookup, tween.globalTime(time2));
          overwritten = !tween.parent;
          _overwritingTween = 0;
        }
        tween._pt && lazy && (_lazyLookup[gsData.id] = 1);
      }
      hasPriority && _sortPropTweensByPriority(tween);
      tween._onInit && tween._onInit(tween);
    }
    tween._onUpdate = onUpdate;
    tween._initted = (!tween._op || tween._pt) && !overwritten;
    keyframes2 && time2 <= 0 && tl.render(_bigNum, true, true);
  };
  var _updatePropTweens = function _updatePropTweens2(tween, property, value, start, startIsRelative, ratio, time2, skipRecursion) {
    var ptCache = (tween._pt && tween._ptCache || (tween._ptCache = {}))[property], pt, rootPT, lookup, i;
    if (!ptCache) {
      ptCache = tween._ptCache[property] = [];
      lookup = tween._ptLookup;
      i = tween._targets.length;
      while (i--) {
        pt = lookup[i][property];
        if (pt && pt.d && pt.d._pt) {
          pt = pt.d._pt;
          while (pt && pt.p !== property && pt.fp !== property) {
            pt = pt._next;
          }
        }
        if (!pt) {
          _forceAllPropTweens = 1;
          tween.vars[property] = "+=0";
          _initTween(tween, time2);
          _forceAllPropTweens = 0;
          return skipRecursion ? _warn(property + " not eligible for reset") : 1;
        }
        ptCache.push(pt);
      }
    }
    i = ptCache.length;
    while (i--) {
      rootPT = ptCache[i];
      pt = rootPT._pt || rootPT;
      pt.s = (start || start === 0) && !startIsRelative ? start : pt.s + (start || 0) + ratio * pt.c;
      pt.c = value - pt.s;
      rootPT.e && (rootPT.e = _round(value) + getUnit(rootPT.e));
      rootPT.b && (rootPT.b = pt.s + getUnit(rootPT.b));
    }
  };
  var _addAliasesToVars = function _addAliasesToVars2(targets, vars) {
    var harness = targets[0] ? _getCache(targets[0]).harness : 0, propertyAliases = harness && harness.aliases, copy, p, i, aliases;
    if (!propertyAliases) {
      return vars;
    }
    copy = _merge({}, vars);
    for (p in propertyAliases) {
      if (p in copy) {
        aliases = propertyAliases[p].split(",");
        i = aliases.length;
        while (i--) {
          copy[aliases[i]] = copy[p];
        }
      }
    }
    return copy;
  };
  var _parseKeyframe = function _parseKeyframe2(prop, obj, allProps, easeEach) {
    var ease2 = obj.ease || easeEach || "power1.inOut", p, a;
    if (_isArray(obj)) {
      a = allProps[prop] || (allProps[prop] = []);
      obj.forEach(function(value, i) {
        return a.push({
          t: i / (obj.length - 1) * 100,
          v: value,
          e: ease2
        });
      });
    } else {
      for (p in obj) {
        a = allProps[p] || (allProps[p] = []);
        p === "ease" || a.push({
          t: parseFloat(prop),
          v: obj[p],
          e: ease2
        });
      }
    }
  };
  var _parseFuncOrString = function _parseFuncOrString2(value, tween, i, target, targets) {
    return _isFunction(value) ? value.call(tween, i, target, targets) : _isString(value) && ~value.indexOf("random(") ? _replaceRandom(value) : value;
  };
  var _staggerTweenProps = _callbackNames + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert";
  var _staggerPropsToSkip = {};
  _forEachName(_staggerTweenProps + ",id,stagger,delay,duration,paused,scrollTrigger", function(name) {
    return _staggerPropsToSkip[name] = 1;
  });
  var Tween = /* @__PURE__ */ (function(_Animation2) {
    _inheritsLoose(Tween2, _Animation2);
    function Tween2(targets, vars, position, skipInherit) {
      var _this3;
      if (typeof vars === "number") {
        position.duration = vars;
        vars = position;
        position = null;
      }
      _this3 = _Animation2.call(this, skipInherit ? vars : _inheritDefaults(vars)) || this;
      var _this3$vars = _this3.vars, duration = _this3$vars.duration, delay2 = _this3$vars.delay, immediateRender = _this3$vars.immediateRender, stagger = _this3$vars.stagger, overwrite = _this3$vars.overwrite, keyframes2 = _this3$vars.keyframes, defaults3 = _this3$vars.defaults, scrollTrigger = _this3$vars.scrollTrigger, yoyoEase = _this3$vars.yoyoEase, parent = vars.parent || _globalTimeline, parsedTargets = (_isArray(targets) || _isTypedArray(targets) ? _isNumber(targets[0]) : "length" in vars) ? [targets] : toArray(targets), tl, i, copy, l, p, curTarget, staggerFunc, staggerVarsToMerge;
      _this3._targets = parsedTargets.length ? _harness(parsedTargets) : _warn("GSAP target " + targets + " not found. https://gsap.com", !_config.nullTargetWarn) || [];
      _this3._ptLookup = [];
      _this3._overwrite = overwrite;
      if (keyframes2 || stagger || _isFuncOrString(duration) || _isFuncOrString(delay2)) {
        vars = _this3.vars;
        tl = _this3.timeline = new Timeline({
          data: "nested",
          defaults: defaults3 || {},
          targets: parent && parent.data === "nested" ? parent.vars.targets : parsedTargets
        });
        tl.kill();
        tl.parent = tl._dp = _assertThisInitialized(_this3);
        tl._start = 0;
        if (stagger || _isFuncOrString(duration) || _isFuncOrString(delay2)) {
          l = parsedTargets.length;
          staggerFunc = stagger && distribute(stagger);
          if (_isObject(stagger)) {
            for (p in stagger) {
              if (~_staggerTweenProps.indexOf(p)) {
                staggerVarsToMerge || (staggerVarsToMerge = {});
                staggerVarsToMerge[p] = stagger[p];
              }
            }
          }
          for (i = 0; i < l; i++) {
            copy = _copyExcluding(vars, _staggerPropsToSkip);
            copy.stagger = 0;
            yoyoEase && (copy.yoyoEase = yoyoEase);
            staggerVarsToMerge && _merge(copy, staggerVarsToMerge);
            curTarget = parsedTargets[i];
            copy.duration = +_parseFuncOrString(duration, _assertThisInitialized(_this3), i, curTarget, parsedTargets);
            copy.delay = (+_parseFuncOrString(delay2, _assertThisInitialized(_this3), i, curTarget, parsedTargets) || 0) - _this3._delay;
            if (!stagger && l === 1 && copy.delay) {
              _this3._delay = delay2 = copy.delay;
              _this3._start += delay2;
              copy.delay = 0;
            }
            tl.to(curTarget, copy, staggerFunc ? staggerFunc(i, curTarget, parsedTargets) : 0);
            tl._ease = _easeMap.none;
          }
          tl.duration() ? duration = delay2 = 0 : _this3.timeline = 0;
        } else if (keyframes2) {
          _inheritDefaults(_setDefaults(tl.vars.defaults, {
            ease: "none"
          }));
          tl._ease = _parseEase(keyframes2.ease || vars.ease || "none");
          var time2 = 0, a, kf, v;
          if (_isArray(keyframes2)) {
            keyframes2.forEach(function(frame2) {
              return tl.to(parsedTargets, frame2, ">");
            });
            tl.duration();
          } else {
            copy = {};
            for (p in keyframes2) {
              p === "ease" || p === "easeEach" || _parseKeyframe(p, keyframes2[p], copy, keyframes2.easeEach);
            }
            for (p in copy) {
              a = copy[p].sort(function(a2, b) {
                return a2.t - b.t;
              });
              time2 = 0;
              for (i = 0; i < a.length; i++) {
                kf = a[i];
                v = {
                  ease: kf.e,
                  duration: (kf.t - (i ? a[i - 1].t : 0)) / 100 * duration
                };
                v[p] = kf.v;
                tl.to(parsedTargets, v, time2);
                time2 += v.duration;
              }
            }
            tl.duration() < duration && tl.to({}, {
              duration: duration - tl.duration()
            });
          }
        }
        duration || _this3.duration(duration = tl.duration());
      } else {
        _this3.timeline = 0;
      }
      if (overwrite === true && !_suppressOverwrites) {
        _overwritingTween = _assertThisInitialized(_this3);
        _globalTimeline.killTweensOf(parsedTargets);
        _overwritingTween = 0;
      }
      _addToTimeline(parent, _assertThisInitialized(_this3), position);
      vars.reversed && _this3.reverse();
      vars.paused && _this3.paused(true);
      if (immediateRender || !duration && !keyframes2 && _this3._start === _roundPrecise(parent._time) && _isNotFalse(immediateRender) && _hasNoPausedAncestors(_assertThisInitialized(_this3)) && parent.data !== "nested") {
        _this3._tTime = -_tinyNum;
        _this3.render(Math.max(0, -delay2) || 0);
      }
      scrollTrigger && _scrollTrigger(_assertThisInitialized(_this3), scrollTrigger);
      return _this3;
    }
    var _proto3 = Tween2.prototype;
    _proto3.render = function render4(totalTime, suppressEvents, force) {
      var prevTime = this._time, tDur = this._tDur, dur = this._dur, isNegative = totalTime < 0, tTime = totalTime > tDur - _tinyNum && !isNegative ? tDur : totalTime < _tinyNum ? 0 : totalTime, time2, pt, iteration, cycleDuration, prevIteration, isYoyo, ratio, timeline2, yoyoEase;
      if (!dur) {
        _renderZeroDurationTween(this, totalTime, suppressEvents, force);
      } else if (tTime !== this._tTime || !totalTime || force || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== isNegative || this._lazy) {
        time2 = tTime;
        timeline2 = this.timeline;
        if (this._repeat) {
          cycleDuration = dur + this._rDelay;
          if (this._repeat < -1 && isNegative) {
            return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
          }
          time2 = _roundPrecise(tTime % cycleDuration);
          if (tTime === tDur) {
            iteration = this._repeat;
            time2 = dur;
          } else {
            prevIteration = _roundPrecise(tTime / cycleDuration);
            iteration = ~~prevIteration;
            if (iteration && iteration === prevIteration) {
              time2 = dur;
              iteration--;
            } else if (time2 > dur) {
              time2 = dur;
            }
          }
          isYoyo = this._yoyo && iteration & 1;
          if (isYoyo) {
            yoyoEase = this._yEase;
            time2 = dur - time2;
          }
          prevIteration = _animationCycle(this._tTime, cycleDuration);
          if (time2 === prevTime && !force && this._initted && iteration === prevIteration) {
            this._tTime = tTime;
            return this;
          }
          if (iteration !== prevIteration) {
            timeline2 && this._yEase && _propagateYoyoEase(timeline2, isYoyo);
            if (this.vars.repeatRefresh && !isYoyo && !this._lock && time2 !== cycleDuration && this._initted) {
              this._lock = force = 1;
              this.render(_roundPrecise(cycleDuration * iteration), true).invalidate()._lock = 0;
            }
          }
        }
        if (!this._initted) {
          if (_attemptInitTween(this, isNegative ? totalTime : time2, force, suppressEvents, tTime)) {
            this._tTime = 0;
            return this;
          }
          if (prevTime !== this._time && !(force && this.vars.repeatRefresh && iteration !== prevIteration)) {
            return this;
          }
          if (dur !== this._dur) {
            return this.render(totalTime, suppressEvents, force);
          }
        }
        this._tTime = tTime;
        this._time = time2;
        if (!this._act && this._ts) {
          this._act = 1;
          this._lazy = 0;
        }
        this.ratio = ratio = (yoyoEase || this._ease)(time2 / dur);
        if (this._from) {
          this.ratio = ratio = 1 - ratio;
        }
        if (!prevTime && tTime && !suppressEvents && !prevIteration) {
          _callback(this, "onStart");
          if (this._tTime !== tTime) {
            return this;
          }
        }
        pt = this._pt;
        while (pt) {
          pt.r(ratio, pt.d);
          pt = pt._next;
        }
        timeline2 && timeline2.render(totalTime < 0 ? totalTime : timeline2._dur * timeline2._ease(time2 / this._dur), suppressEvents, force) || this._startAt && (this._zTime = totalTime);
        if (this._onUpdate && !suppressEvents) {
          isNegative && _rewindStartAt(this, totalTime, suppressEvents, force);
          _callback(this, "onUpdate");
        }
        this._repeat && iteration !== prevIteration && this.vars.onRepeat && !suppressEvents && this.parent && _callback(this, "onRepeat");
        if ((tTime === this._tDur || !tTime) && this._tTime === tTime) {
          isNegative && !this._onUpdate && _rewindStartAt(this, totalTime, true, true);
          (totalTime || !dur) && (tTime === this._tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1);
          if (!suppressEvents && !(isNegative && !prevTime) && (tTime || prevTime || isYoyo)) {
            _callback(this, tTime === tDur ? "onComplete" : "onReverseComplete", true);
            this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
          }
        }
      }
      return this;
    };
    _proto3.targets = function targets() {
      return this._targets;
    };
    _proto3.invalidate = function invalidate(soft) {
      (!soft || !this.vars.runBackwards) && (this._startAt = 0);
      this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0;
      this._ptLookup = [];
      this.timeline && this.timeline.invalidate(soft);
      return _Animation2.prototype.invalidate.call(this, soft);
    };
    _proto3.resetTo = function resetTo(property, value, start, startIsRelative, skipRecursion) {
      _tickerActive || _ticker.wake();
      this._ts || this.play();
      var time2 = Math.min(this._dur, (this._dp._time - this._start) * this._ts), ratio;
      this._initted || _initTween(this, time2);
      ratio = this._ease(time2 / this._dur);
      if (_updatePropTweens(this, property, value, start, startIsRelative, ratio, time2, skipRecursion)) {
        return this.resetTo(property, value, start, startIsRelative, 1);
      }
      _alignPlayhead(this, 0);
      this.parent || _addLinkedListItem(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0);
      return this.render(0);
    };
    _proto3.kill = function kill(targets, vars) {
      if (vars === void 0) {
        vars = "all";
      }
      if (!targets && (!vars || vars === "all")) {
        this._lazy = this._pt = 0;
        this.parent ? _interrupt(this) : this.scrollTrigger && this.scrollTrigger.kill(!!_reverting);
        return this;
      }
      if (this.timeline) {
        var tDur = this.timeline.totalDuration();
        this.timeline.killTweensOf(targets, vars, _overwritingTween && _overwritingTween.vars.overwrite !== true)._first || _interrupt(this);
        this.parent && tDur !== this.timeline.totalDuration() && _setDuration(this, this._dur * this.timeline._tDur / tDur, 0, 1);
        return this;
      }
      var parsedTargets = this._targets, killingTargets = targets ? toArray(targets) : parsedTargets, propTweenLookup = this._ptLookup, firstPT = this._pt, overwrittenProps, curLookup, curOverwriteProps, props, p, pt, i;
      if ((!vars || vars === "all") && _arraysMatch(parsedTargets, killingTargets)) {
        vars === "all" && (this._pt = 0);
        return _interrupt(this);
      }
      overwrittenProps = this._op = this._op || [];
      if (vars !== "all") {
        if (_isString(vars)) {
          p = {};
          _forEachName(vars, function(name) {
            return p[name] = 1;
          });
          vars = p;
        }
        vars = _addAliasesToVars(parsedTargets, vars);
      }
      i = parsedTargets.length;
      while (i--) {
        if (~killingTargets.indexOf(parsedTargets[i])) {
          curLookup = propTweenLookup[i];
          if (vars === "all") {
            overwrittenProps[i] = vars;
            props = curLookup;
            curOverwriteProps = {};
          } else {
            curOverwriteProps = overwrittenProps[i] = overwrittenProps[i] || {};
            props = vars;
          }
          for (p in props) {
            pt = curLookup && curLookup[p];
            if (pt) {
              if (!("kill" in pt.d) || pt.d.kill(p) === true) {
                _removeLinkedListItem(this, pt, "_pt");
              }
              delete curLookup[p];
            }
            if (curOverwriteProps !== "all") {
              curOverwriteProps[p] = 1;
            }
          }
        }
      }
      this._initted && !this._pt && firstPT && _interrupt(this);
      return this;
    };
    Tween2.to = function to(targets, vars) {
      return new Tween2(targets, vars, arguments[2]);
    };
    Tween2.from = function from(targets, vars) {
      return _createTweenType(1, arguments);
    };
    Tween2.delayedCall = function delayedCall(delay2, callback, params, scope) {
      return new Tween2(callback, 0, {
        immediateRender: false,
        lazy: false,
        overwrite: false,
        delay: delay2,
        onComplete: callback,
        onReverseComplete: callback,
        onCompleteParams: params,
        onReverseCompleteParams: params,
        callbackScope: scope
      });
    };
    Tween2.fromTo = function fromTo(targets, fromVars, toVars) {
      return _createTweenType(2, arguments);
    };
    Tween2.set = function set(targets, vars) {
      vars.duration = 0;
      vars.repeatDelay || (vars.repeat = 0);
      return new Tween2(targets, vars);
    };
    Tween2.killTweensOf = function killTweensOf(targets, props, onlyActive) {
      return _globalTimeline.killTweensOf(targets, props, onlyActive);
    };
    return Tween2;
  })(Animation);
  _setDefaults(Tween.prototype, {
    _targets: [],
    _lazy: 0,
    _startAt: 0,
    _op: 0,
    _onInit: 0
  });
  _forEachName("staggerTo,staggerFrom,staggerFromTo", function(name) {
    Tween[name] = function() {
      var tl = new Timeline(), params = _slice.call(arguments, 0);
      params.splice(name === "staggerFromTo" ? 5 : 4, 0, 0);
      return tl[name].apply(tl, params);
    };
  });
  var _setterPlain = function _setterPlain2(target, property, value) {
    return target[property] = value;
  };
  var _setterFunc = function _setterFunc2(target, property, value) {
    return target[property](value);
  };
  var _setterFuncWithParam = function _setterFuncWithParam2(target, property, value, data) {
    return target[property](data.fp, value);
  };
  var _setterAttribute = function _setterAttribute2(target, property, value) {
    return target.setAttribute(property, value);
  };
  var _getSetter = function _getSetter2(target, property) {
    return _isFunction(target[property]) ? _setterFunc : _isUndefined(target[property]) && target.setAttribute ? _setterAttribute : _setterPlain;
  };
  var _renderPlain = function _renderPlain2(ratio, data) {
    return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 1e6) / 1e6, data);
  };
  var _renderBoolean = function _renderBoolean2(ratio, data) {
    return data.set(data.t, data.p, !!(data.s + data.c * ratio), data);
  };
  var _renderComplexString = function _renderComplexString2(ratio, data) {
    var pt = data._pt, s = "";
    if (!ratio && data.b) {
      s = data.b;
    } else if (ratio === 1 && data.e) {
      s = data.e;
    } else {
      while (pt) {
        s = pt.p + (pt.m ? pt.m(pt.s + pt.c * ratio) : Math.round((pt.s + pt.c * ratio) * 1e4) / 1e4) + s;
        pt = pt._next;
      }
      s += data.c;
    }
    data.set(data.t, data.p, s, data);
  };
  var _renderPropTweens = function _renderPropTweens2(ratio, data) {
    var pt = data._pt;
    while (pt) {
      pt.r(ratio, pt.d);
      pt = pt._next;
    }
  };
  var _addPluginModifier = function _addPluginModifier2(modifier, tween, target, property) {
    var pt = this._pt, next;
    while (pt) {
      next = pt._next;
      pt.p === property && pt.modifier(modifier, tween, target);
      pt = next;
    }
  };
  var _killPropTweensOf = function _killPropTweensOf2(property) {
    var pt = this._pt, hasNonDependentRemaining, next;
    while (pt) {
      next = pt._next;
      if (pt.p === property && !pt.op || pt.op === property) {
        _removeLinkedListItem(this, pt, "_pt");
      } else if (!pt.dep) {
        hasNonDependentRemaining = 1;
      }
      pt = next;
    }
    return !hasNonDependentRemaining;
  };
  var _setterWithModifier = function _setterWithModifier2(target, property, value, data) {
    data.mSet(target, property, data.m.call(data.tween, value, data.mt), data);
  };
  var _sortPropTweensByPriority = function _sortPropTweensByPriority2(parent) {
    var pt = parent._pt, next, pt2, first, last;
    while (pt) {
      next = pt._next;
      pt2 = first;
      while (pt2 && pt2.pr > pt.pr) {
        pt2 = pt2._next;
      }
      if (pt._prev = pt2 ? pt2._prev : last) {
        pt._prev._next = pt;
      } else {
        first = pt;
      }
      if (pt._next = pt2) {
        pt2._prev = pt;
      } else {
        last = pt;
      }
      pt = next;
    }
    parent._pt = first;
  };
  var PropTween = /* @__PURE__ */ (function() {
    function PropTween2(next, target, prop, start, change, renderer, data, setter, priority) {
      this.t = target;
      this.s = start;
      this.c = change;
      this.p = prop;
      this.r = renderer || _renderPlain;
      this.d = data || this;
      this.set = setter || _setterPlain;
      this.pr = priority || 0;
      this._next = next;
      if (next) {
        next._prev = this;
      }
    }
    var _proto4 = PropTween2.prototype;
    _proto4.modifier = function modifier(func, tween, target) {
      this.mSet = this.mSet || this.set;
      this.set = _setterWithModifier;
      this.m = func;
      this.mt = target;
      this.tween = tween;
    };
    return PropTween2;
  })();
  _forEachName(_callbackNames + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function(name) {
    return _reservedProps[name] = 1;
  });
  _globals.TweenMax = _globals.TweenLite = Tween;
  _globals.TimelineLite = _globals.TimelineMax = Timeline;
  _globalTimeline = new Timeline({
    sortChildren: false,
    defaults: _defaults,
    autoRemoveChildren: true,
    id: "root",
    smoothChildTiming: true
  });
  _config.stringFilter = _colorStringFilter;
  var _media = [];
  var _listeners = {};
  var _emptyArray = [];
  var _lastMediaTime = 0;
  var _contextID = 0;
  var _dispatch = function _dispatch2(type) {
    return (_listeners[type] || _emptyArray).map(function(f) {
      return f();
    });
  };
  var _onMediaChange = function _onMediaChange2() {
    var time2 = Date.now(), matches = [];
    if (time2 - _lastMediaTime > 2) {
      _dispatch("matchMediaInit");
      _media.forEach(function(c) {
        var queries = c.queries, conditions = c.conditions, match, p, anyMatch, toggled;
        for (p in queries) {
          match = _win.matchMedia(queries[p]).matches;
          match && (anyMatch = 1);
          if (match !== conditions[p]) {
            conditions[p] = match;
            toggled = 1;
          }
        }
        if (toggled) {
          c.revert();
          anyMatch && matches.push(c);
        }
      });
      _dispatch("matchMediaRevert");
      matches.forEach(function(c) {
        return c.onMatch(c, function(func) {
          return c.add(null, func);
        });
      });
      _lastMediaTime = time2;
      _dispatch("matchMedia");
    }
  };
  var Context = /* @__PURE__ */ (function() {
    function Context2(func, scope) {
      this.selector = scope && selector(scope);
      this.data = [];
      this._r = [];
      this.isReverted = false;
      this.id = _contextID++;
      func && this.add(func);
    }
    var _proto5 = Context2.prototype;
    _proto5.add = function add(name, func, scope) {
      if (_isFunction(name)) {
        scope = func;
        func = name;
        name = _isFunction;
      }
      var self2 = this, f = function f2() {
        var prev = _context, prevSelector = self2.selector, result;
        prev && prev !== self2 && prev.data.push(self2);
        scope && (self2.selector = selector(scope));
        _context = self2;
        result = func.apply(self2, arguments);
        _isFunction(result) && self2._r.push(result);
        _context = prev;
        self2.selector = prevSelector;
        self2.isReverted = false;
        return result;
      };
      self2.last = f;
      return name === _isFunction ? f(self2, function(func2) {
        return self2.add(null, func2);
      }) : name ? self2[name] = f : f;
    };
    _proto5.ignore = function ignore(func) {
      var prev = _context;
      _context = null;
      func(this);
      _context = prev;
    };
    _proto5.getTweens = function getTweens() {
      var a = [];
      this.data.forEach(function(e) {
        return e instanceof Context2 ? a.push.apply(a, e.getTweens()) : e instanceof Tween && !(e.parent && e.parent.data === "nested") && a.push(e);
      });
      return a;
    };
    _proto5.clear = function clear() {
      this._r.length = this.data.length = 0;
    };
    _proto5.kill = function kill(revert, matchMedia3) {
      var _this4 = this;
      if (revert) {
        (function() {
          var tweens = _this4.getTweens(), i2 = _this4.data.length, t;
          while (i2--) {
            t = _this4.data[i2];
            if (t.data === "isFlip") {
              t.revert();
              t.getChildren(true, true, false).forEach(function(tween) {
                return tweens.splice(tweens.indexOf(tween), 1);
              });
            }
          }
          tweens.map(function(t2) {
            return {
              g: t2._dur || t2._delay || t2._sat && !t2._sat.vars.immediateRender ? t2.globalTime(0) : -Infinity,
              t: t2
            };
          }).sort(function(a, b) {
            return b.g - a.g || -Infinity;
          }).forEach(function(o) {
            return o.t.revert(revert);
          });
          i2 = _this4.data.length;
          while (i2--) {
            t = _this4.data[i2];
            if (t instanceof Timeline) {
              if (t.data !== "nested") {
                t.scrollTrigger && t.scrollTrigger.revert();
                t.kill();
              }
            } else {
              !(t instanceof Tween) && t.revert && t.revert(revert);
            }
          }
          _this4._r.forEach(function(f) {
            return f(revert, _this4);
          });
          _this4.isReverted = true;
        })();
      } else {
        this.data.forEach(function(e) {
          return e.kill && e.kill();
        });
      }
      this.clear();
      if (matchMedia3) {
        var i = _media.length;
        while (i--) {
          _media[i].id === this.id && _media.splice(i, 1);
        }
      }
    };
    _proto5.revert = function revert(config3) {
      this.kill(config3 || {});
    };
    return Context2;
  })();
  var MatchMedia = /* @__PURE__ */ (function() {
    function MatchMedia2(scope) {
      this.contexts = [];
      this.scope = scope;
      _context && _context.data.push(this);
    }
    var _proto6 = MatchMedia2.prototype;
    _proto6.add = function add(conditions, func, scope) {
      _isObject(conditions) || (conditions = {
        matches: conditions
      });
      var context3 = new Context(0, scope || this.scope), cond = context3.conditions = {}, mq, p, active;
      _context && !context3.selector && (context3.selector = _context.selector);
      this.contexts.push(context3);
      func = context3.add("onMatch", func);
      context3.queries = conditions;
      for (p in conditions) {
        if (p === "all") {
          active = 1;
        } else {
          mq = _win.matchMedia(conditions[p]);
          if (mq) {
            _media.indexOf(context3) < 0 && _media.push(context3);
            (cond[p] = mq.matches) && (active = 1);
            mq.addListener ? mq.addListener(_onMediaChange) : mq.addEventListener("change", _onMediaChange);
          }
        }
      }
      active && func(context3, function(f) {
        return context3.add(null, f);
      });
      return this;
    };
    _proto6.revert = function revert(config3) {
      this.kill(config3 || {});
    };
    _proto6.kill = function kill(revert) {
      this.contexts.forEach(function(c) {
        return c.kill(revert, true);
      });
    };
    return MatchMedia2;
  })();
  var _gsap = {
    registerPlugin: function registerPlugin() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      args.forEach(function(config3) {
        return _createPlugin(config3);
      });
    },
    timeline: function timeline(vars) {
      return new Timeline(vars);
    },
    getTweensOf: function getTweensOf(targets, onlyActive) {
      return _globalTimeline.getTweensOf(targets, onlyActive);
    },
    getProperty: function getProperty(target, property, unit, uncache) {
      _isString(target) && (target = toArray(target)[0]);
      var getter = _getCache(target || {}).get, format2 = unit ? _passThrough : _numericIfPossible;
      unit === "native" && (unit = "");
      return !target ? target : !property ? function(property2, unit2, uncache2) {
        return format2((_plugins[property2] && _plugins[property2].get || getter)(target, property2, unit2, uncache2));
      } : format2((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));
    },
    quickSetter: function quickSetter(target, property, unit) {
      target = toArray(target);
      if (target.length > 1) {
        var setters = target.map(function(t) {
          return gsap.quickSetter(t, property, unit);
        }), l = setters.length;
        return function(value) {
          var i = l;
          while (i--) {
            setters[i](value);
          }
        };
      }
      target = target[0] || {};
      var Plugin = _plugins[property], cache = _getCache(target), p = cache.harness && (cache.harness.aliases || {})[property] || property, setter = Plugin ? function(value) {
        var p2 = new Plugin();
        _quickTween._pt = 0;
        p2.init(target, unit ? value + unit : value, _quickTween, 0, [target]);
        p2.render(1, p2);
        _quickTween._pt && _renderPropTweens(1, _quickTween);
      } : cache.set(target, p);
      return Plugin ? setter : function(value) {
        return setter(target, p, unit ? value + unit : value, cache, 1);
      };
    },
    quickTo: function quickTo(target, property, vars) {
      var _setDefaults22;
      var tween = gsap.to(target, _setDefaults((_setDefaults22 = {}, _setDefaults22[property] = "+=0.1", _setDefaults22.paused = true, _setDefaults22.stagger = 0, _setDefaults22), vars || {})), func = function func2(value, start, startIsRelative) {
        return tween.resetTo(property, value, start, startIsRelative);
      };
      func.tween = tween;
      return func;
    },
    isTweening: function isTweening(targets) {
      return _globalTimeline.getTweensOf(targets, true).length > 0;
    },
    defaults: function defaults2(value) {
      value && value.ease && (value.ease = _parseEase(value.ease, _defaults.ease));
      return _mergeDeep(_defaults, value || {});
    },
    config: function config2(value) {
      return _mergeDeep(_config, value || {});
    },
    registerEffect: function registerEffect(_ref3) {
      var name = _ref3.name, effect = _ref3.effect, plugins = _ref3.plugins, defaults3 = _ref3.defaults, extendTimeline = _ref3.extendTimeline;
      (plugins || "").split(",").forEach(function(pluginName) {
        return pluginName && !_plugins[pluginName] && !_globals[pluginName] && _warn(name + " effect requires " + pluginName + " plugin.");
      });
      _effects[name] = function(targets, vars, tl) {
        return effect(toArray(targets), _setDefaults(vars || {}, defaults3), tl);
      };
      if (extendTimeline) {
        Timeline.prototype[name] = function(targets, vars, position) {
          return this.add(_effects[name](targets, _isObject(vars) ? vars : (position = vars) && {}, this), position);
        };
      }
    },
    registerEase: function registerEase(name, ease2) {
      _easeMap[name] = _parseEase(ease2);
    },
    parseEase: function parseEase(ease2, defaultEase) {
      return arguments.length ? _parseEase(ease2, defaultEase) : _easeMap;
    },
    getById: function getById(id3) {
      return _globalTimeline.getById(id3);
    },
    exportRoot: function exportRoot(vars, includeDelayedCalls) {
      if (vars === void 0) {
        vars = {};
      }
      var tl = new Timeline(vars), child, next;
      tl.smoothChildTiming = _isNotFalse(vars.smoothChildTiming);
      _globalTimeline.remove(tl);
      tl._dp = 0;
      tl._time = tl._tTime = _globalTimeline._time;
      child = _globalTimeline._first;
      while (child) {
        next = child._next;
        if (includeDelayedCalls || !(!child._dur && child instanceof Tween && child.vars.onComplete === child._targets[0])) {
          _addToTimeline(tl, child, child._start - child._delay);
        }
        child = next;
      }
      _addToTimeline(_globalTimeline, tl, 0);
      return tl;
    },
    context: function context(func, scope) {
      return func ? new Context(func, scope) : _context;
    },
    matchMedia: function matchMedia2(scope) {
      return new MatchMedia(scope);
    },
    matchMediaRefresh: function matchMediaRefresh() {
      return _media.forEach(function(c) {
        var cond = c.conditions, found, p;
        for (p in cond) {
          if (cond[p]) {
            cond[p] = false;
            found = 1;
          }
        }
        found && c.revert();
      }) || _onMediaChange();
    },
    addEventListener: function addEventListener2(type, callback) {
      var a = _listeners[type] || (_listeners[type] = []);
      ~a.indexOf(callback) || a.push(callback);
    },
    removeEventListener: function removeEventListener2(type, callback) {
      var a = _listeners[type], i = a && a.indexOf(callback);
      i >= 0 && a.splice(i, 1);
    },
    utils: {
      wrap,
      wrapYoyo,
      distribute,
      random,
      snap,
      normalize,
      getUnit,
      clamp,
      splitColor,
      toArray,
      selector,
      mapRange,
      pipe,
      unitize,
      interpolate,
      shuffle
    },
    install: _install,
    effects: _effects,
    ticker: _ticker,
    updateRoot: Timeline.updateRoot,
    plugins: _plugins,
    globalTimeline: _globalTimeline,
    core: {
      PropTween,
      globals: _addGlobal,
      Tween,
      Timeline,
      Animation,
      getCache: _getCache,
      _removeLinkedListItem,
      reverting: function reverting() {
        return _reverting;
      },
      context: function context2(toAdd) {
        if (toAdd && _context) {
          _context.data.push(toAdd);
          toAdd._ctx = _context;
        }
        return _context;
      },
      suppressOverwrites: function suppressOverwrites(value) {
        return _suppressOverwrites = value;
      }
    }
  };
  _forEachName("to,from,fromTo,delayedCall,set,killTweensOf", function(name) {
    return _gsap[name] = Tween[name];
  });
  _ticker.add(Timeline.updateRoot);
  _quickTween = _gsap.to({}, {
    duration: 0
  });
  var _getPluginPropTween = function _getPluginPropTween2(plugin, prop) {
    var pt = plugin._pt;
    while (pt && pt.p !== prop && pt.op !== prop && pt.fp !== prop) {
      pt = pt._next;
    }
    return pt;
  };
  var _addModifiers = function _addModifiers2(tween, modifiers) {
    var targets = tween._targets, p, i, pt;
    for (p in modifiers) {
      i = targets.length;
      while (i--) {
        pt = tween._ptLookup[i][p];
        if (pt && (pt = pt.d)) {
          if (pt._pt) {
            pt = _getPluginPropTween(pt, p);
          }
          pt && pt.modifier && pt.modifier(modifiers[p], tween, targets[i], p);
        }
      }
    }
  };
  var _buildModifierPlugin = function _buildModifierPlugin2(name, modifier) {
    return {
      name,
      headless: 1,
      rawVars: 1,
      //don't pre-process function-based values or "random()" strings.
      init: function init5(target, vars, tween) {
        tween._onInit = function(tween2) {
          var temp, p;
          if (_isString(vars)) {
            temp = {};
            _forEachName(vars, function(name2) {
              return temp[name2] = 1;
            });
            vars = temp;
          }
          if (modifier) {
            temp = {};
            for (p in vars) {
              temp[p] = modifier(vars[p]);
            }
            vars = temp;
          }
          _addModifiers(tween2, vars);
        };
      }
    };
  };
  var gsap = _gsap.registerPlugin({
    name: "attr",
    init: function init(target, vars, tween, index, targets) {
      var p, pt, v;
      this.tween = tween;
      for (p in vars) {
        v = target.getAttribute(p) || "";
        pt = this.add(target, "setAttribute", (v || 0) + "", vars[p], index, targets, 0, 0, p);
        pt.op = p;
        pt.b = v;
        this._props.push(p);
      }
    },
    render: function render(ratio, data) {
      var pt = data._pt;
      while (pt) {
        _reverting ? pt.set(pt.t, pt.p, pt.b, pt) : pt.r(ratio, pt.d);
        pt = pt._next;
      }
    }
  }, {
    name: "endArray",
    headless: 1,
    init: function init2(target, value) {
      var i = value.length;
      while (i--) {
        this.add(target, i, target[i] || 0, value[i], 0, 0, 0, 0, 0, 1);
      }
    }
  }, _buildModifierPlugin("roundProps", _roundModifier), _buildModifierPlugin("modifiers"), _buildModifierPlugin("snap", snap)) || _gsap;
  Tween.version = Timeline.version = gsap.version = "3.13.0";
  _coreReady = 1;
  _windowExists() && _wake();
  var Power0 = _easeMap.Power0;
  var Power1 = _easeMap.Power1;
  var Power2 = _easeMap.Power2;
  var Power3 = _easeMap.Power3;
  var Power4 = _easeMap.Power4;
  var Linear = _easeMap.Linear;
  var Quad = _easeMap.Quad;
  var Cubic = _easeMap.Cubic;
  var Quart = _easeMap.Quart;
  var Quint = _easeMap.Quint;
  var Strong = _easeMap.Strong;
  var Elastic = _easeMap.Elastic;
  var Back = _easeMap.Back;
  var SteppedEase = _easeMap.SteppedEase;
  var Bounce = _easeMap.Bounce;
  var Sine = _easeMap.Sine;
  var Expo = _easeMap.Expo;
  var Circ = _easeMap.Circ;

  // node_modules/gsap/CSSPlugin.js
  var _win2;
  var _doc2;
  var _docElement;
  var _pluginInitted;
  var _tempDiv;
  var _tempDivStyler;
  var _recentSetterPlugin;
  var _reverting2;
  var _windowExists3 = function _windowExists4() {
    return typeof window !== "undefined";
  };
  var _transformProps = {};
  var _RAD2DEG = 180 / Math.PI;
  var _DEG2RAD = Math.PI / 180;
  var _atan2 = Math.atan2;
  var _bigNum2 = 1e8;
  var _capsExp = /([A-Z])/g;
  var _horizontalExp = /(left|right|width|margin|padding|x)/i;
  var _complexExp = /[\s,\(]\S/;
  var _propertyAliases = {
    autoAlpha: "opacity,visibility",
    scale: "scaleX,scaleY",
    alpha: "opacity"
  };
  var _renderCSSProp = function _renderCSSProp2(ratio, data) {
    return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 1e4) / 1e4 + data.u, data);
  };
  var _renderPropWithEnd = function _renderPropWithEnd2(ratio, data) {
    return data.set(data.t, data.p, ratio === 1 ? data.e : Math.round((data.s + data.c * ratio) * 1e4) / 1e4 + data.u, data);
  };
  var _renderCSSPropWithBeginning = function _renderCSSPropWithBeginning2(ratio, data) {
    return data.set(data.t, data.p, ratio ? Math.round((data.s + data.c * ratio) * 1e4) / 1e4 + data.u : data.b, data);
  };
  var _renderRoundedCSSProp = function _renderRoundedCSSProp2(ratio, data) {
    var value = data.s + data.c * ratio;
    data.set(data.t, data.p, ~~(value + (value < 0 ? -0.5 : 0.5)) + data.u, data);
  };
  var _renderNonTweeningValue = function _renderNonTweeningValue2(ratio, data) {
    return data.set(data.t, data.p, ratio ? data.e : data.b, data);
  };
  var _renderNonTweeningValueOnlyAtEnd = function _renderNonTweeningValueOnlyAtEnd2(ratio, data) {
    return data.set(data.t, data.p, ratio !== 1 ? data.b : data.e, data);
  };
  var _setterCSSStyle = function _setterCSSStyle2(target, property, value) {
    return target.style[property] = value;
  };
  var _setterCSSProp = function _setterCSSProp2(target, property, value) {
    return target.style.setProperty(property, value);
  };
  var _setterTransform = function _setterTransform2(target, property, value) {
    return target._gsap[property] = value;
  };
  var _setterScale = function _setterScale2(target, property, value) {
    return target._gsap.scaleX = target._gsap.scaleY = value;
  };
  var _setterScaleWithRender = function _setterScaleWithRender2(target, property, value, data, ratio) {
    var cache = target._gsap;
    cache.scaleX = cache.scaleY = value;
    cache.renderTransform(ratio, cache);
  };
  var _setterTransformWithRender = function _setterTransformWithRender2(target, property, value, data, ratio) {
    var cache = target._gsap;
    cache[property] = value;
    cache.renderTransform(ratio, cache);
  };
  var _transformProp = "transform";
  var _transformOriginProp = _transformProp + "Origin";
  var _saveStyle = function _saveStyle2(property, isNotCSS) {
    var _this = this;
    var target = this.target, style = target.style, cache = target._gsap;
    if (property in _transformProps && style) {
      this.tfm = this.tfm || {};
      if (property !== "transform") {
        property = _propertyAliases[property] || property;
        ~property.indexOf(",") ? property.split(",").forEach(function(a) {
          return _this.tfm[a] = _get(target, a);
        }) : this.tfm[property] = cache.x ? cache[property] : _get(target, property);
        property === _transformOriginProp && (this.tfm.zOrigin = cache.zOrigin);
      } else {
        return _propertyAliases.transform.split(",").forEach(function(p) {
          return _saveStyle2.call(_this, p, isNotCSS);
        });
      }
      if (this.props.indexOf(_transformProp) >= 0) {
        return;
      }
      if (cache.svg) {
        this.svgo = target.getAttribute("data-svg-origin");
        this.props.push(_transformOriginProp, isNotCSS, "");
      }
      property = _transformProp;
    }
    (style || isNotCSS) && this.props.push(property, isNotCSS, style[property]);
  };
  var _removeIndependentTransforms = function _removeIndependentTransforms2(style) {
    if (style.translate) {
      style.removeProperty("translate");
      style.removeProperty("scale");
      style.removeProperty("rotate");
    }
  };
  var _revertStyle = function _revertStyle2() {
    var props = this.props, target = this.target, style = target.style, cache = target._gsap, i, p;
    for (i = 0; i < props.length; i += 3) {
      if (!props[i + 1]) {
        props[i + 2] ? style[props[i]] = props[i + 2] : style.removeProperty(props[i].substr(0, 2) === "--" ? props[i] : props[i].replace(_capsExp, "-$1").toLowerCase());
      } else if (props[i + 1] === 2) {
        target[props[i]](props[i + 2]);
      } else {
        target[props[i]] = props[i + 2];
      }
    }
    if (this.tfm) {
      for (p in this.tfm) {
        cache[p] = this.tfm[p];
      }
      if (cache.svg) {
        cache.renderTransform();
        target.setAttribute("data-svg-origin", this.svgo || "");
      }
      i = _reverting2();
      if ((!i || !i.isStart) && !style[_transformProp]) {
        _removeIndependentTransforms(style);
        if (cache.zOrigin && style[_transformOriginProp]) {
          style[_transformOriginProp] += " " + cache.zOrigin + "px";
          cache.zOrigin = 0;
          cache.renderTransform();
        }
        cache.uncache = 1;
      }
    }
  };
  var _getStyleSaver = function _getStyleSaver2(target, properties) {
    var saver = {
      target,
      props: [],
      revert: _revertStyle,
      save: _saveStyle
    };
    target._gsap || gsap.core.getCache(target);
    properties && target.style && target.nodeType && properties.split(",").forEach(function(p) {
      return saver.save(p);
    });
    return saver;
  };
  var _supports3D;
  var _createElement = function _createElement2(type, ns) {
    var e = _doc2.createElementNS ? _doc2.createElementNS((ns || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), type) : _doc2.createElement(type);
    return e && e.style ? e : _doc2.createElement(type);
  };
  var _getComputedProperty = function _getComputedProperty2(target, property, skipPrefixFallback) {
    var cs = getComputedStyle(target);
    return cs[property] || cs.getPropertyValue(property.replace(_capsExp, "-$1").toLowerCase()) || cs.getPropertyValue(property) || !skipPrefixFallback && _getComputedProperty2(target, _checkPropPrefix(property) || property, 1) || "";
  };
  var _prefixes = "O,Moz,ms,Ms,Webkit".split(",");
  var _checkPropPrefix = function _checkPropPrefix2(property, element, preferPrefix) {
    var e = element || _tempDiv, s = e.style, i = 5;
    if (property in s && !preferPrefix) {
      return property;
    }
    property = property.charAt(0).toUpperCase() + property.substr(1);
    while (i-- && !(_prefixes[i] + property in s)) {
    }
    return i < 0 ? null : (i === 3 ? "ms" : i >= 0 ? _prefixes[i] : "") + property;
  };
  var _initCore = function _initCore2() {
    if (_windowExists3() && window.document) {
      _win2 = window;
      _doc2 = _win2.document;
      _docElement = _doc2.documentElement;
      _tempDiv = _createElement("div") || {
        style: {}
      };
      _tempDivStyler = _createElement("div");
      _transformProp = _checkPropPrefix(_transformProp);
      _transformOriginProp = _transformProp + "Origin";
      _tempDiv.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0";
      _supports3D = !!_checkPropPrefix("perspective");
      _reverting2 = gsap.core.reverting;
      _pluginInitted = 1;
    }
  };
  var _getReparentedCloneBBox = function _getReparentedCloneBBox2(target) {
    var owner = target.ownerSVGElement, svg = _createElement("svg", owner && owner.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), clone = target.cloneNode(true), bbox;
    clone.style.display = "block";
    svg.appendChild(clone);
    _docElement.appendChild(svg);
    try {
      bbox = clone.getBBox();
    } catch (e) {
    }
    svg.removeChild(clone);
    _docElement.removeChild(svg);
    return bbox;
  };
  var _getAttributeFallbacks = function _getAttributeFallbacks2(target, attributesArray) {
    var i = attributesArray.length;
    while (i--) {
      if (target.hasAttribute(attributesArray[i])) {
        return target.getAttribute(attributesArray[i]);
      }
    }
  };
  var _getBBox = function _getBBox2(target) {
    var bounds, cloned;
    try {
      bounds = target.getBBox();
    } catch (error) {
      bounds = _getReparentedCloneBBox(target);
      cloned = 1;
    }
    bounds && (bounds.width || bounds.height) || cloned || (bounds = _getReparentedCloneBBox(target));
    return bounds && !bounds.width && !bounds.x && !bounds.y ? {
      x: +_getAttributeFallbacks(target, ["x", "cx", "x1"]) || 0,
      y: +_getAttributeFallbacks(target, ["y", "cy", "y1"]) || 0,
      width: 0,
      height: 0
    } : bounds;
  };
  var _isSVG = function _isSVG2(e) {
    return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && _getBBox(e));
  };
  var _removeProperty = function _removeProperty2(target, property) {
    if (property) {
      var style = target.style, first2Chars;
      if (property in _transformProps && property !== _transformOriginProp) {
        property = _transformProp;
      }
      if (style.removeProperty) {
        first2Chars = property.substr(0, 2);
        if (first2Chars === "ms" || property.substr(0, 6) === "webkit") {
          property = "-" + property;
        }
        style.removeProperty(first2Chars === "--" ? property : property.replace(_capsExp, "-$1").toLowerCase());
      } else {
        style.removeAttribute(property);
      }
    }
  };
  var _addNonTweeningPT = function _addNonTweeningPT2(plugin, target, property, beginning, end, onlySetAtEnd) {
    var pt = new PropTween(plugin._pt, target, property, 0, 1, onlySetAtEnd ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue);
    plugin._pt = pt;
    pt.b = beginning;
    pt.e = end;
    plugin._props.push(property);
    return pt;
  };
  var _nonConvertibleUnits = {
    deg: 1,
    rad: 1,
    turn: 1
  };
  var _nonStandardLayouts = {
    grid: 1,
    flex: 1
  };
  var _convertToUnit = function _convertToUnit2(target, property, value, unit) {
    var curValue = parseFloat(value) || 0, curUnit = (value + "").trim().substr((curValue + "").length) || "px", style = _tempDiv.style, horizontal = _horizontalExp.test(property), isRootSVG = target.tagName.toLowerCase() === "svg", measureProperty = (isRootSVG ? "client" : "offset") + (horizontal ? "Width" : "Height"), amount = 100, toPixels = unit === "px", toPercent = unit === "%", px2, parent, cache, isSVG;
    if (unit === curUnit || !curValue || _nonConvertibleUnits[unit] || _nonConvertibleUnits[curUnit]) {
      return curValue;
    }
    curUnit !== "px" && !toPixels && (curValue = _convertToUnit2(target, property, value, "px"));
    isSVG = target.getCTM && _isSVG(target);
    if ((toPercent || curUnit === "%") && (_transformProps[property] || ~property.indexOf("adius"))) {
      px2 = isSVG ? target.getBBox()[horizontal ? "width" : "height"] : target[measureProperty];
      return _round(toPercent ? curValue / px2 * amount : curValue / 100 * px2);
    }
    style[horizontal ? "width" : "height"] = amount + (toPixels ? curUnit : unit);
    parent = unit !== "rem" && ~property.indexOf("adius") || unit === "em" && target.appendChild && !isRootSVG ? target : target.parentNode;
    if (isSVG) {
      parent = (target.ownerSVGElement || {}).parentNode;
    }
    if (!parent || parent === _doc2 || !parent.appendChild) {
      parent = _doc2.body;
    }
    cache = parent._gsap;
    if (cache && toPercent && cache.width && horizontal && cache.time === _ticker.time && !cache.uncache) {
      return _round(curValue / cache.width * amount);
    } else {
      if (toPercent && (property === "height" || property === "width")) {
        var v = target.style[property];
        target.style[property] = amount + unit;
        px2 = target[measureProperty];
        v ? target.style[property] = v : _removeProperty(target, property);
      } else {
        (toPercent || curUnit === "%") && !_nonStandardLayouts[_getComputedProperty(parent, "display")] && (style.position = _getComputedProperty(target, "position"));
        parent === target && (style.position = "static");
        parent.appendChild(_tempDiv);
        px2 = _tempDiv[measureProperty];
        parent.removeChild(_tempDiv);
        style.position = "absolute";
      }
      if (horizontal && toPercent) {
        cache = _getCache(parent);
        cache.time = _ticker.time;
        cache.width = parent[measureProperty];
      }
    }
    return _round(toPixels ? px2 * curValue / amount : px2 && curValue ? amount / px2 * curValue : 0);
  };
  var _get = function _get2(target, property, unit, uncache) {
    var value;
    _pluginInitted || _initCore();
    if (property in _propertyAliases && property !== "transform") {
      property = _propertyAliases[property];
      if (~property.indexOf(",")) {
        property = property.split(",")[0];
      }
    }
    if (_transformProps[property] && property !== "transform") {
      value = _parseTransform(target, uncache);
      value = property !== "transformOrigin" ? value[property] : value.svg ? value.origin : _firstTwoOnly(_getComputedProperty(target, _transformOriginProp)) + " " + value.zOrigin + "px";
    } else {
      value = target.style[property];
      if (!value || value === "auto" || uncache || ~(value + "").indexOf("calc(")) {
        value = _specialProps[property] && _specialProps[property](target, property, unit) || _getComputedProperty(target, property) || _getProperty(target, property) || (property === "opacity" ? 1 : 0);
      }
    }
    return unit && !~(value + "").trim().indexOf(" ") ? _convertToUnit(target, property, value, unit) + unit : value;
  };
  var _tweenComplexCSSString = function _tweenComplexCSSString2(target, prop, start, end) {
    if (!start || start === "none") {
      var p = _checkPropPrefix(prop, target, 1), s = p && _getComputedProperty(target, p, 1);
      if (s && s !== start) {
        prop = p;
        start = s;
      } else if (prop === "borderColor") {
        start = _getComputedProperty(target, "borderTopColor");
      }
    }
    var pt = new PropTween(this._pt, target.style, prop, 0, 1, _renderComplexString), index = 0, matchIndex = 0, a, result, startValues, startNum, color2, startValue, endValue, endNum, chunk, endUnit, startUnit, endValues;
    pt.b = start;
    pt.e = end;
    start += "";
    end += "";
    if (end.substring(0, 6) === "var(--") {
      end = _getComputedProperty(target, end.substring(4, end.indexOf(")")));
    }
    if (end === "auto") {
      startValue = target.style[prop];
      target.style[prop] = end;
      end = _getComputedProperty(target, prop) || end;
      startValue ? target.style[prop] = startValue : _removeProperty(target, prop);
    }
    a = [start, end];
    _colorStringFilter(a);
    start = a[0];
    end = a[1];
    startValues = start.match(_numWithUnitExp) || [];
    endValues = end.match(_numWithUnitExp) || [];
    if (endValues.length) {
      while (result = _numWithUnitExp.exec(end)) {
        endValue = result[0];
        chunk = end.substring(index, result.index);
        if (color2) {
          color2 = (color2 + 1) % 5;
        } else if (chunk.substr(-5) === "rgba(" || chunk.substr(-5) === "hsla(") {
          color2 = 1;
        }
        if (endValue !== (startValue = startValues[matchIndex++] || "")) {
          startNum = parseFloat(startValue) || 0;
          startUnit = startValue.substr((startNum + "").length);
          endValue.charAt(1) === "=" && (endValue = _parseRelative(startNum, endValue) + startUnit);
          endNum = parseFloat(endValue);
          endUnit = endValue.substr((endNum + "").length);
          index = _numWithUnitExp.lastIndex - endUnit.length;
          if (!endUnit) {
            endUnit = endUnit || _config.units[prop] || startUnit;
            if (index === end.length) {
              end += endUnit;
              pt.e += endUnit;
            }
          }
          if (startUnit !== endUnit) {
            startNum = _convertToUnit(target, prop, startValue, endUnit) || 0;
          }
          pt._pt = {
            _next: pt._pt,
            p: chunk || matchIndex === 1 ? chunk : ",",
            //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
            s: startNum,
            c: endNum - startNum,
            m: color2 && color2 < 4 || prop === "zIndex" ? Math.round : 0
          };
        }
      }
      pt.c = index < end.length ? end.substring(index, end.length) : "";
    } else {
      pt.r = prop === "display" && end === "none" ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue;
    }
    _relExp.test(end) && (pt.e = 0);
    this._pt = pt;
    return pt;
  };
  var _keywordToPercent = {
    top: "0%",
    bottom: "100%",
    left: "0%",
    right: "100%",
    center: "50%"
  };
  var _convertKeywordsToPercentages = function _convertKeywordsToPercentages2(value) {
    var split = value.split(" "), x = split[0], y = split[1] || "50%";
    if (x === "top" || x === "bottom" || y === "left" || y === "right") {
      value = x;
      x = y;
      y = value;
    }
    split[0] = _keywordToPercent[x] || x;
    split[1] = _keywordToPercent[y] || y;
    return split.join(" ");
  };
  var _renderClearProps = function _renderClearProps2(ratio, data) {
    if (data.tween && data.tween._time === data.tween._dur) {
      var target = data.t, style = target.style, props = data.u, cache = target._gsap, prop, clearTransforms, i;
      if (props === "all" || props === true) {
        style.cssText = "";
        clearTransforms = 1;
      } else {
        props = props.split(",");
        i = props.length;
        while (--i > -1) {
          prop = props[i];
          if (_transformProps[prop]) {
            clearTransforms = 1;
            prop = prop === "transformOrigin" ? _transformOriginProp : _transformProp;
          }
          _removeProperty(target, prop);
        }
      }
      if (clearTransforms) {
        _removeProperty(target, _transformProp);
        if (cache) {
          cache.svg && target.removeAttribute("transform");
          style.scale = style.rotate = style.translate = "none";
          _parseTransform(target, 1);
          cache.uncache = 1;
          _removeIndependentTransforms(style);
        }
      }
    }
  };
  var _specialProps = {
    clearProps: function clearProps(plugin, target, property, endValue, tween) {
      if (tween.data !== "isFromStart") {
        var pt = plugin._pt = new PropTween(plugin._pt, target, property, 0, 0, _renderClearProps);
        pt.u = endValue;
        pt.pr = -10;
        pt.tween = tween;
        plugin._props.push(property);
        return 1;
      }
    }
    /* className feature (about 0.4kb gzipped).
    , className(plugin, target, property, endValue, tween) {
    	let _renderClassName = (ratio, data) => {
    			data.css.render(ratio, data.css);
    			if (!ratio || ratio === 1) {
    				let inline = data.rmv,
    					target = data.t,
    					p;
    				target.setAttribute("class", ratio ? data.e : data.b);
    				for (p in inline) {
    					_removeProperty(target, p);
    				}
    			}
    		},
    		_getAllStyles = (target) => {
    			let styles = {},
    				computed = getComputedStyle(target),
    				p;
    			for (p in computed) {
    				if (isNaN(p) && p !== "cssText" && p !== "length") {
    					styles[p] = computed[p];
    				}
    			}
    			_setDefaults(styles, _parseTransform(target, 1));
    			return styles;
    		},
    		startClassList = target.getAttribute("class"),
    		style = target.style,
    		cssText = style.cssText,
    		cache = target._gsap,
    		classPT = cache.classPT,
    		inlineToRemoveAtEnd = {},
    		data = {t:target, plugin:plugin, rmv:inlineToRemoveAtEnd, b:startClassList, e:(endValue.charAt(1) !== "=") ? endValue : startClassList.replace(new RegExp("(?:\\s|^)" + endValue.substr(2) + "(?![\\w-])"), "") + ((endValue.charAt(0) === "+") ? " " + endValue.substr(2) : "")},
    		changingVars = {},
    		startVars = _getAllStyles(target),
    		transformRelated = /(transform|perspective)/i,
    		endVars, p;
    	if (classPT) {
    		classPT.r(1, classPT.d);
    		_removeLinkedListItem(classPT.d.plugin, classPT, "_pt");
    	}
    	target.setAttribute("class", data.e);
    	endVars = _getAllStyles(target, true);
    	target.setAttribute("class", startClassList);
    	for (p in endVars) {
    		if (endVars[p] !== startVars[p] && !transformRelated.test(p)) {
    			changingVars[p] = endVars[p];
    			if (!style[p] && style[p] !== "0") {
    				inlineToRemoveAtEnd[p] = 1;
    			}
    		}
    	}
    	cache.classPT = plugin._pt = new PropTween(plugin._pt, target, "className", 0, 0, _renderClassName, data, 0, -11);
    	if (style.cssText !== cssText) { //only apply if things change. Otherwise, in cases like a background-image that's pulled dynamically, it could cause a refresh. See https://gsap.com/forums/topic/20368-possible-gsap-bug-switching-classnames-in-chrome/.
    		style.cssText = cssText; //we recorded cssText before we swapped classes and ran _getAllStyles() because in cases when a className tween is overwritten, we remove all the related tweening properties from that class change (otherwise class-specific stuff can't override properties we've directly set on the target's style object due to specificity).
    	}
    	_parseTransform(target, true); //to clear the caching of transforms
    	data.css = new gsap.plugins.css();
    	data.css.init(target, changingVars, tween);
    	plugin._props.push(...data.css._props);
    	return 1;
    }
    */
  };
  var _identity2DMatrix = [1, 0, 0, 1, 0, 0];
  var _rotationalProperties = {};
  var _isNullTransform = function _isNullTransform2(value) {
    return value === "matrix(1, 0, 0, 1, 0, 0)" || value === "none" || !value;
  };
  var _getComputedTransformMatrixAsArray = function _getComputedTransformMatrixAsArray2(target) {
    var matrixString = _getComputedProperty(target, _transformProp);
    return _isNullTransform(matrixString) ? _identity2DMatrix : matrixString.substr(7).match(_numExp).map(_round);
  };
  var _getMatrix = function _getMatrix2(target, force2D) {
    var cache = target._gsap || _getCache(target), style = target.style, matrix = _getComputedTransformMatrixAsArray(target), parent, nextSibling, temp, addedToDOM;
    if (cache.svg && target.getAttribute("transform")) {
      temp = target.transform.baseVal.consolidate().matrix;
      matrix = [temp.a, temp.b, temp.c, temp.d, temp.e, temp.f];
      return matrix.join(",") === "1,0,0,1,0,0" ? _identity2DMatrix : matrix;
    } else if (matrix === _identity2DMatrix && !target.offsetParent && target !== _docElement && !cache.svg) {
      temp = style.display;
      style.display = "block";
      parent = target.parentNode;
      if (!parent || !target.offsetParent && !target.getBoundingClientRect().width) {
        addedToDOM = 1;
        nextSibling = target.nextElementSibling;
        _docElement.appendChild(target);
      }
      matrix = _getComputedTransformMatrixAsArray(target);
      temp ? style.display = temp : _removeProperty(target, "display");
      if (addedToDOM) {
        nextSibling ? parent.insertBefore(target, nextSibling) : parent ? parent.appendChild(target) : _docElement.removeChild(target);
      }
    }
    return force2D && matrix.length > 6 ? [matrix[0], matrix[1], matrix[4], matrix[5], matrix[12], matrix[13]] : matrix;
  };
  var _applySVGOrigin = function _applySVGOrigin2(target, origin, originIsAbsolute, smooth, matrixArray, pluginToAddPropTweensTo) {
    var cache = target._gsap, matrix = matrixArray || _getMatrix(target, true), xOriginOld = cache.xOrigin || 0, yOriginOld = cache.yOrigin || 0, xOffsetOld = cache.xOffset || 0, yOffsetOld = cache.yOffset || 0, a = matrix[0], b = matrix[1], c = matrix[2], d = matrix[3], tx = matrix[4], ty = matrix[5], originSplit = origin.split(" "), xOrigin = parseFloat(originSplit[0]) || 0, yOrigin = parseFloat(originSplit[1]) || 0, bounds, determinant, x, y;
    if (!originIsAbsolute) {
      bounds = _getBBox(target);
      xOrigin = bounds.x + (~originSplit[0].indexOf("%") ? xOrigin / 100 * bounds.width : xOrigin);
      yOrigin = bounds.y + (~(originSplit[1] || originSplit[0]).indexOf("%") ? yOrigin / 100 * bounds.height : yOrigin);
    } else if (matrix !== _identity2DMatrix && (determinant = a * d - b * c)) {
      x = xOrigin * (d / determinant) + yOrigin * (-c / determinant) + (c * ty - d * tx) / determinant;
      y = xOrigin * (-b / determinant) + yOrigin * (a / determinant) - (a * ty - b * tx) / determinant;
      xOrigin = x;
      yOrigin = y;
    }
    if (smooth || smooth !== false && cache.smooth) {
      tx = xOrigin - xOriginOld;
      ty = yOrigin - yOriginOld;
      cache.xOffset = xOffsetOld + (tx * a + ty * c) - tx;
      cache.yOffset = yOffsetOld + (tx * b + ty * d) - ty;
    } else {
      cache.xOffset = cache.yOffset = 0;
    }
    cache.xOrigin = xOrigin;
    cache.yOrigin = yOrigin;
    cache.smooth = !!smooth;
    cache.origin = origin;
    cache.originIsAbsolute = !!originIsAbsolute;
    target.style[_transformOriginProp] = "0px 0px";
    if (pluginToAddPropTweensTo) {
      _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOrigin", xOriginOld, xOrigin);
      _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOrigin", yOriginOld, yOrigin);
      _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOffset", xOffsetOld, cache.xOffset);
      _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOffset", yOffsetOld, cache.yOffset);
    }
    target.setAttribute("data-svg-origin", xOrigin + " " + yOrigin);
  };
  var _parseTransform = function _parseTransform2(target, uncache) {
    var cache = target._gsap || new GSCache(target);
    if ("x" in cache && !uncache && !cache.uncache) {
      return cache;
    }
    var style = target.style, invertedScaleX = cache.scaleX < 0, px2 = "px", deg = "deg", cs = getComputedStyle(target), origin = _getComputedProperty(target, _transformOriginProp) || "0", x, y, z, scaleX2, scaleY2, rotation, rotationX, rotationY, skewX, skewY, perspective, xOrigin, yOrigin, matrix, angle, cos, sin, a, b, c, d, a12, a22, t1, t2, t3, a13, a23, a33, a42, a43, a32;
    x = y = z = rotation = rotationX = rotationY = skewX = skewY = perspective = 0;
    scaleX2 = scaleY2 = 1;
    cache.svg = !!(target.getCTM && _isSVG(target));
    if (cs.translate) {
      if (cs.translate !== "none" || cs.scale !== "none" || cs.rotate !== "none") {
        style[_transformProp] = (cs.translate !== "none" ? "translate3d(" + (cs.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (cs.rotate !== "none" ? "rotate(" + cs.rotate + ") " : "") + (cs.scale !== "none" ? "scale(" + cs.scale.split(" ").join(",") + ") " : "") + (cs[_transformProp] !== "none" ? cs[_transformProp] : "");
      }
      style.scale = style.rotate = style.translate = "none";
    }
    matrix = _getMatrix(target, cache.svg);
    if (cache.svg) {
      if (cache.uncache) {
        t2 = target.getBBox();
        origin = cache.xOrigin - t2.x + "px " + (cache.yOrigin - t2.y) + "px";
        t1 = "";
      } else {
        t1 = !uncache && target.getAttribute("data-svg-origin");
      }
      _applySVGOrigin(target, t1 || origin, !!t1 || cache.originIsAbsolute, cache.smooth !== false, matrix);
    }
    xOrigin = cache.xOrigin || 0;
    yOrigin = cache.yOrigin || 0;
    if (matrix !== _identity2DMatrix) {
      a = matrix[0];
      b = matrix[1];
      c = matrix[2];
      d = matrix[3];
      x = a12 = matrix[4];
      y = a22 = matrix[5];
      if (matrix.length === 6) {
        scaleX2 = Math.sqrt(a * a + b * b);
        scaleY2 = Math.sqrt(d * d + c * c);
        rotation = a || b ? _atan2(b, a) * _RAD2DEG : 0;
        skewX = c || d ? _atan2(c, d) * _RAD2DEG + rotation : 0;
        skewX && (scaleY2 *= Math.abs(Math.cos(skewX * _DEG2RAD)));
        if (cache.svg) {
          x -= xOrigin - (xOrigin * a + yOrigin * c);
          y -= yOrigin - (xOrigin * b + yOrigin * d);
        }
      } else {
        a32 = matrix[6];
        a42 = matrix[7];
        a13 = matrix[8];
        a23 = matrix[9];
        a33 = matrix[10];
        a43 = matrix[11];
        x = matrix[12];
        y = matrix[13];
        z = matrix[14];
        angle = _atan2(a32, a33);
        rotationX = angle * _RAD2DEG;
        if (angle) {
          cos = Math.cos(-angle);
          sin = Math.sin(-angle);
          t1 = a12 * cos + a13 * sin;
          t2 = a22 * cos + a23 * sin;
          t3 = a32 * cos + a33 * sin;
          a13 = a12 * -sin + a13 * cos;
          a23 = a22 * -sin + a23 * cos;
          a33 = a32 * -sin + a33 * cos;
          a43 = a42 * -sin + a43 * cos;
          a12 = t1;
          a22 = t2;
          a32 = t3;
        }
        angle = _atan2(-c, a33);
        rotationY = angle * _RAD2DEG;
        if (angle) {
          cos = Math.cos(-angle);
          sin = Math.sin(-angle);
          t1 = a * cos - a13 * sin;
          t2 = b * cos - a23 * sin;
          t3 = c * cos - a33 * sin;
          a43 = d * sin + a43 * cos;
          a = t1;
          b = t2;
          c = t3;
        }
        angle = _atan2(b, a);
        rotation = angle * _RAD2DEG;
        if (angle) {
          cos = Math.cos(angle);
          sin = Math.sin(angle);
          t1 = a * cos + b * sin;
          t2 = a12 * cos + a22 * sin;
          b = b * cos - a * sin;
          a22 = a22 * cos - a12 * sin;
          a = t1;
          a12 = t2;
        }
        if (rotationX && Math.abs(rotationX) + Math.abs(rotation) > 359.9) {
          rotationX = rotation = 0;
          rotationY = 180 - rotationY;
        }
        scaleX2 = _round(Math.sqrt(a * a + b * b + c * c));
        scaleY2 = _round(Math.sqrt(a22 * a22 + a32 * a32));
        angle = _atan2(a12, a22);
        skewX = Math.abs(angle) > 2e-4 ? angle * _RAD2DEG : 0;
        perspective = a43 ? 1 / (a43 < 0 ? -a43 : a43) : 0;
      }
      if (cache.svg) {
        t1 = target.getAttribute("transform");
        cache.forceCSS = target.setAttribute("transform", "") || !_isNullTransform(_getComputedProperty(target, _transformProp));
        t1 && target.setAttribute("transform", t1);
      }
    }
    if (Math.abs(skewX) > 90 && Math.abs(skewX) < 270) {
      if (invertedScaleX) {
        scaleX2 *= -1;
        skewX += rotation <= 0 ? 180 : -180;
        rotation += rotation <= 0 ? 180 : -180;
      } else {
        scaleY2 *= -1;
        skewX += skewX <= 0 ? 180 : -180;
      }
    }
    uncache = uncache || cache.uncache;
    cache.x = x - ((cache.xPercent = x && (!uncache && cache.xPercent || (Math.round(target.offsetWidth / 2) === Math.round(-x) ? -50 : 0))) ? target.offsetWidth * cache.xPercent / 100 : 0) + px2;
    cache.y = y - ((cache.yPercent = y && (!uncache && cache.yPercent || (Math.round(target.offsetHeight / 2) === Math.round(-y) ? -50 : 0))) ? target.offsetHeight * cache.yPercent / 100 : 0) + px2;
    cache.z = z + px2;
    cache.scaleX = _round(scaleX2);
    cache.scaleY = _round(scaleY2);
    cache.rotation = _round(rotation) + deg;
    cache.rotationX = _round(rotationX) + deg;
    cache.rotationY = _round(rotationY) + deg;
    cache.skewX = skewX + deg;
    cache.skewY = skewY + deg;
    cache.transformPerspective = perspective + px2;
    if (cache.zOrigin = parseFloat(origin.split(" ")[2]) || !uncache && cache.zOrigin || 0) {
      style[_transformOriginProp] = _firstTwoOnly(origin);
    }
    cache.xOffset = cache.yOffset = 0;
    cache.force3D = _config.force3D;
    cache.renderTransform = cache.svg ? _renderSVGTransforms : _supports3D ? _renderCSSTransforms : _renderNon3DTransforms;
    cache.uncache = 0;
    return cache;
  };
  var _firstTwoOnly = function _firstTwoOnly2(value) {
    return (value = value.split(" "))[0] + " " + value[1];
  };
  var _addPxTranslate = function _addPxTranslate2(target, start, value) {
    var unit = getUnit(start);
    return _round(parseFloat(start) + parseFloat(_convertToUnit(target, "x", value + "px", unit))) + unit;
  };
  var _renderNon3DTransforms = function _renderNon3DTransforms2(ratio, cache) {
    cache.z = "0px";
    cache.rotationY = cache.rotationX = "0deg";
    cache.force3D = 0;
    _renderCSSTransforms(ratio, cache);
  };
  var _zeroDeg = "0deg";
  var _zeroPx = "0px";
  var _endParenthesis = ") ";
  var _renderCSSTransforms = function _renderCSSTransforms2(ratio, cache) {
    var _ref = cache || this, xPercent = _ref.xPercent, yPercent = _ref.yPercent, x = _ref.x, y = _ref.y, z = _ref.z, rotation = _ref.rotation, rotationY = _ref.rotationY, rotationX = _ref.rotationX, skewX = _ref.skewX, skewY = _ref.skewY, scaleX2 = _ref.scaleX, scaleY2 = _ref.scaleY, transformPerspective = _ref.transformPerspective, force3D = _ref.force3D, target = _ref.target, zOrigin = _ref.zOrigin, transforms = "", use3D = force3D === "auto" && ratio && ratio !== 1 || force3D === true;
    if (zOrigin && (rotationX !== _zeroDeg || rotationY !== _zeroDeg)) {
      var angle = parseFloat(rotationY) * _DEG2RAD, a13 = Math.sin(angle), a33 = Math.cos(angle), cos;
      angle = parseFloat(rotationX) * _DEG2RAD;
      cos = Math.cos(angle);
      x = _addPxTranslate(target, x, a13 * cos * -zOrigin);
      y = _addPxTranslate(target, y, -Math.sin(angle) * -zOrigin);
      z = _addPxTranslate(target, z, a33 * cos * -zOrigin + zOrigin);
    }
    if (transformPerspective !== _zeroPx) {
      transforms += "perspective(" + transformPerspective + _endParenthesis;
    }
    if (xPercent || yPercent) {
      transforms += "translate(" + xPercent + "%, " + yPercent + "%) ";
    }
    if (use3D || x !== _zeroPx || y !== _zeroPx || z !== _zeroPx) {
      transforms += z !== _zeroPx || use3D ? "translate3d(" + x + ", " + y + ", " + z + ") " : "translate(" + x + ", " + y + _endParenthesis;
    }
    if (rotation !== _zeroDeg) {
      transforms += "rotate(" + rotation + _endParenthesis;
    }
    if (rotationY !== _zeroDeg) {
      transforms += "rotateY(" + rotationY + _endParenthesis;
    }
    if (rotationX !== _zeroDeg) {
      transforms += "rotateX(" + rotationX + _endParenthesis;
    }
    if (skewX !== _zeroDeg || skewY !== _zeroDeg) {
      transforms += "skew(" + skewX + ", " + skewY + _endParenthesis;
    }
    if (scaleX2 !== 1 || scaleY2 !== 1) {
      transforms += "scale(" + scaleX2 + ", " + scaleY2 + _endParenthesis;
    }
    target.style[_transformProp] = transforms || "translate(0, 0)";
  };
  var _renderSVGTransforms = function _renderSVGTransforms2(ratio, cache) {
    var _ref2 = cache || this, xPercent = _ref2.xPercent, yPercent = _ref2.yPercent, x = _ref2.x, y = _ref2.y, rotation = _ref2.rotation, skewX = _ref2.skewX, skewY = _ref2.skewY, scaleX2 = _ref2.scaleX, scaleY2 = _ref2.scaleY, target = _ref2.target, xOrigin = _ref2.xOrigin, yOrigin = _ref2.yOrigin, xOffset = _ref2.xOffset, yOffset = _ref2.yOffset, forceCSS = _ref2.forceCSS, tx = parseFloat(x), ty = parseFloat(y), a11, a21, a12, a22, temp;
    rotation = parseFloat(rotation);
    skewX = parseFloat(skewX);
    skewY = parseFloat(skewY);
    if (skewY) {
      skewY = parseFloat(skewY);
      skewX += skewY;
      rotation += skewY;
    }
    if (rotation || skewX) {
      rotation *= _DEG2RAD;
      skewX *= _DEG2RAD;
      a11 = Math.cos(rotation) * scaleX2;
      a21 = Math.sin(rotation) * scaleX2;
      a12 = Math.sin(rotation - skewX) * -scaleY2;
      a22 = Math.cos(rotation - skewX) * scaleY2;
      if (skewX) {
        skewY *= _DEG2RAD;
        temp = Math.tan(skewX - skewY);
        temp = Math.sqrt(1 + temp * temp);
        a12 *= temp;
        a22 *= temp;
        if (skewY) {
          temp = Math.tan(skewY);
          temp = Math.sqrt(1 + temp * temp);
          a11 *= temp;
          a21 *= temp;
        }
      }
      a11 = _round(a11);
      a21 = _round(a21);
      a12 = _round(a12);
      a22 = _round(a22);
    } else {
      a11 = scaleX2;
      a22 = scaleY2;
      a21 = a12 = 0;
    }
    if (tx && !~(x + "").indexOf("px") || ty && !~(y + "").indexOf("px")) {
      tx = _convertToUnit(target, "x", x, "px");
      ty = _convertToUnit(target, "y", y, "px");
    }
    if (xOrigin || yOrigin || xOffset || yOffset) {
      tx = _round(tx + xOrigin - (xOrigin * a11 + yOrigin * a12) + xOffset);
      ty = _round(ty + yOrigin - (xOrigin * a21 + yOrigin * a22) + yOffset);
    }
    if (xPercent || yPercent) {
      temp = target.getBBox();
      tx = _round(tx + xPercent / 100 * temp.width);
      ty = _round(ty + yPercent / 100 * temp.height);
    }
    temp = "matrix(" + a11 + "," + a21 + "," + a12 + "," + a22 + "," + tx + "," + ty + ")";
    target.setAttribute("transform", temp);
    forceCSS && (target.style[_transformProp] = temp);
  };
  var _addRotationalPropTween = function _addRotationalPropTween2(plugin, target, property, startNum, endValue) {
    var cap = 360, isString = _isString(endValue), endNum = parseFloat(endValue) * (isString && ~endValue.indexOf("rad") ? _RAD2DEG : 1), change = endNum - startNum, finalValue = startNum + change + "deg", direction, pt;
    if (isString) {
      direction = endValue.split("_")[1];
      if (direction === "short") {
        change %= cap;
        if (change !== change % (cap / 2)) {
          change += change < 0 ? cap : -cap;
        }
      }
      if (direction === "cw" && change < 0) {
        change = (change + cap * _bigNum2) % cap - ~~(change / cap) * cap;
      } else if (direction === "ccw" && change > 0) {
        change = (change - cap * _bigNum2) % cap - ~~(change / cap) * cap;
      }
    }
    plugin._pt = pt = new PropTween(plugin._pt, target, property, startNum, change, _renderPropWithEnd);
    pt.e = finalValue;
    pt.u = "deg";
    plugin._props.push(property);
    return pt;
  };
  var _assign = function _assign2(target, source) {
    for (var p in source) {
      target[p] = source[p];
    }
    return target;
  };
  var _addRawTransformPTs = function _addRawTransformPTs2(plugin, transforms, target) {
    var startCache = _assign({}, target._gsap), exclude = "perspective,force3D,transformOrigin,svgOrigin", style = target.style, endCache, p, startValue, endValue, startNum, endNum, startUnit, endUnit;
    if (startCache.svg) {
      startValue = target.getAttribute("transform");
      target.setAttribute("transform", "");
      style[_transformProp] = transforms;
      endCache = _parseTransform(target, 1);
      _removeProperty(target, _transformProp);
      target.setAttribute("transform", startValue);
    } else {
      startValue = getComputedStyle(target)[_transformProp];
      style[_transformProp] = transforms;
      endCache = _parseTransform(target, 1);
      style[_transformProp] = startValue;
    }
    for (p in _transformProps) {
      startValue = startCache[p];
      endValue = endCache[p];
      if (startValue !== endValue && exclude.indexOf(p) < 0) {
        startUnit = getUnit(startValue);
        endUnit = getUnit(endValue);
        startNum = startUnit !== endUnit ? _convertToUnit(target, p, startValue, endUnit) : parseFloat(startValue);
        endNum = parseFloat(endValue);
        plugin._pt = new PropTween(plugin._pt, endCache, p, startNum, endNum - startNum, _renderCSSProp);
        plugin._pt.u = endUnit || 0;
        plugin._props.push(p);
      }
    }
    _assign(endCache, startCache);
  };
  _forEachName("padding,margin,Width,Radius", function(name, index) {
    var t = "Top", r = "Right", b = "Bottom", l = "Left", props = (index < 3 ? [t, r, b, l] : [t + l, t + r, b + r, b + l]).map(function(side) {
      return index < 2 ? name + side : "border" + side + name;
    });
    _specialProps[index > 1 ? "border" + name : name] = function(plugin, target, property, endValue, tween) {
      var a, vars;
      if (arguments.length < 4) {
        a = props.map(function(prop) {
          return _get(plugin, prop, property);
        });
        vars = a.join(" ");
        return vars.split(a[0]).length === 5 ? a[0] : vars;
      }
      a = (endValue + "").split(" ");
      vars = {};
      props.forEach(function(prop, i) {
        return vars[prop] = a[i] = a[i] || a[(i - 1) / 2 | 0];
      });
      plugin.init(target, vars, tween);
    };
  });
  var CSSPlugin = {
    name: "css",
    register: _initCore,
    targetTest: function targetTest(target) {
      return target.style && target.nodeType;
    },
    init: function init3(target, vars, tween, index, targets) {
      var props = this._props, style = target.style, startAt = tween.vars.startAt, startValue, endValue, endNum, startNum, type, specialProp, p, startUnit, endUnit, relative, isTransformRelated, transformPropTween, cache, smooth, hasPriority, inlineProps;
      _pluginInitted || _initCore();
      this.styles = this.styles || _getStyleSaver(target);
      inlineProps = this.styles.props;
      this.tween = tween;
      for (p in vars) {
        if (p === "autoRound") {
          continue;
        }
        endValue = vars[p];
        if (_plugins[p] && _checkPlugin(p, vars, tween, index, target, targets)) {
          continue;
        }
        type = typeof endValue;
        specialProp = _specialProps[p];
        if (type === "function") {
          endValue = endValue.call(tween, index, target, targets);
          type = typeof endValue;
        }
        if (type === "string" && ~endValue.indexOf("random(")) {
          endValue = _replaceRandom(endValue);
        }
        if (specialProp) {
          specialProp(this, target, p, endValue, tween) && (hasPriority = 1);
        } else if (p.substr(0, 2) === "--") {
          startValue = (getComputedStyle(target).getPropertyValue(p) + "").trim();
          endValue += "";
          _colorExp.lastIndex = 0;
          if (!_colorExp.test(startValue)) {
            startUnit = getUnit(startValue);
            endUnit = getUnit(endValue);
          }
          endUnit ? startUnit !== endUnit && (startValue = _convertToUnit(target, p, startValue, endUnit) + endUnit) : startUnit && (endValue += startUnit);
          this.add(style, "setProperty", startValue, endValue, index, targets, 0, 0, p);
          props.push(p);
          inlineProps.push(p, 0, style[p]);
        } else if (type !== "undefined") {
          if (startAt && p in startAt) {
            startValue = typeof startAt[p] === "function" ? startAt[p].call(tween, index, target, targets) : startAt[p];
            _isString(startValue) && ~startValue.indexOf("random(") && (startValue = _replaceRandom(startValue));
            getUnit(startValue + "") || startValue === "auto" || (startValue += _config.units[p] || getUnit(_get(target, p)) || "");
            (startValue + "").charAt(1) === "=" && (startValue = _get(target, p));
          } else {
            startValue = _get(target, p);
          }
          startNum = parseFloat(startValue);
          relative = type === "string" && endValue.charAt(1) === "=" && endValue.substr(0, 2);
          relative && (endValue = endValue.substr(2));
          endNum = parseFloat(endValue);
          if (p in _propertyAliases) {
            if (p === "autoAlpha") {
              if (startNum === 1 && _get(target, "visibility") === "hidden" && endNum) {
                startNum = 0;
              }
              inlineProps.push("visibility", 0, style.visibility);
              _addNonTweeningPT(this, style, "visibility", startNum ? "inherit" : "hidden", endNum ? "inherit" : "hidden", !endNum);
            }
            if (p !== "scale" && p !== "transform") {
              p = _propertyAliases[p];
              ~p.indexOf(",") && (p = p.split(",")[0]);
            }
          }
          isTransformRelated = p in _transformProps;
          if (isTransformRelated) {
            this.styles.save(p);
            if (type === "string" && endValue.substring(0, 6) === "var(--") {
              endValue = _getComputedProperty(target, endValue.substring(4, endValue.indexOf(")")));
              endNum = parseFloat(endValue);
            }
            if (!transformPropTween) {
              cache = target._gsap;
              cache.renderTransform && !vars.parseTransform || _parseTransform(target, vars.parseTransform);
              smooth = vars.smoothOrigin !== false && cache.smooth;
              transformPropTween = this._pt = new PropTween(this._pt, style, _transformProp, 0, 1, cache.renderTransform, cache, 0, -1);
              transformPropTween.dep = 1;
            }
            if (p === "scale") {
              this._pt = new PropTween(this._pt, cache, "scaleY", cache.scaleY, (relative ? _parseRelative(cache.scaleY, relative + endNum) : endNum) - cache.scaleY || 0, _renderCSSProp);
              this._pt.u = 0;
              props.push("scaleY", p);
              p += "X";
            } else if (p === "transformOrigin") {
              inlineProps.push(_transformOriginProp, 0, style[_transformOriginProp]);
              endValue = _convertKeywordsToPercentages(endValue);
              if (cache.svg) {
                _applySVGOrigin(target, endValue, 0, smooth, 0, this);
              } else {
                endUnit = parseFloat(endValue.split(" ")[2]) || 0;
                endUnit !== cache.zOrigin && _addNonTweeningPT(this, cache, "zOrigin", cache.zOrigin, endUnit);
                _addNonTweeningPT(this, style, p, _firstTwoOnly(startValue), _firstTwoOnly(endValue));
              }
              continue;
            } else if (p === "svgOrigin") {
              _applySVGOrigin(target, endValue, 1, smooth, 0, this);
              continue;
            } else if (p in _rotationalProperties) {
              _addRotationalPropTween(this, cache, p, startNum, relative ? _parseRelative(startNum, relative + endValue) : endValue);
              continue;
            } else if (p === "smoothOrigin") {
              _addNonTweeningPT(this, cache, "smooth", cache.smooth, endValue);
              continue;
            } else if (p === "force3D") {
              cache[p] = endValue;
              continue;
            } else if (p === "transform") {
              _addRawTransformPTs(this, endValue, target);
              continue;
            }
          } else if (!(p in style)) {
            p = _checkPropPrefix(p) || p;
          }
          if (isTransformRelated || (endNum || endNum === 0) && (startNum || startNum === 0) && !_complexExp.test(endValue) && p in style) {
            startUnit = (startValue + "").substr((startNum + "").length);
            endNum || (endNum = 0);
            endUnit = getUnit(endValue) || (p in _config.units ? _config.units[p] : startUnit);
            startUnit !== endUnit && (startNum = _convertToUnit(target, p, startValue, endUnit));
            this._pt = new PropTween(this._pt, isTransformRelated ? cache : style, p, startNum, (relative ? _parseRelative(startNum, relative + endNum) : endNum) - startNum, !isTransformRelated && (endUnit === "px" || p === "zIndex") && vars.autoRound !== false ? _renderRoundedCSSProp : _renderCSSProp);
            this._pt.u = endUnit || 0;
            if (startUnit !== endUnit && endUnit !== "%") {
              this._pt.b = startValue;
              this._pt.r = _renderCSSPropWithBeginning;
            }
          } else if (!(p in style)) {
            if (p in target) {
              this.add(target, p, startValue || target[p], relative ? relative + endValue : endValue, index, targets);
            } else if (p !== "parseTransform") {
              _missingPlugin(p, endValue);
              continue;
            }
          } else {
            _tweenComplexCSSString.call(this, target, p, startValue, relative ? relative + endValue : endValue);
          }
          isTransformRelated || (p in style ? inlineProps.push(p, 0, style[p]) : typeof target[p] === "function" ? inlineProps.push(p, 2, target[p]()) : inlineProps.push(p, 1, startValue || target[p]));
          props.push(p);
        }
      }
      hasPriority && _sortPropTweensByPriority(this);
    },
    render: function render2(ratio, data) {
      if (data.tween._time || !_reverting2()) {
        var pt = data._pt;
        while (pt) {
          pt.r(ratio, pt.d);
          pt = pt._next;
        }
      } else {
        data.styles.revert();
      }
    },
    get: _get,
    aliases: _propertyAliases,
    getSetter: function getSetter(target, property, plugin) {
      var p = _propertyAliases[property];
      p && p.indexOf(",") < 0 && (property = p);
      return property in _transformProps && property !== _transformOriginProp && (target._gsap.x || _get(target, "x")) ? plugin && _recentSetterPlugin === plugin ? property === "scale" ? _setterScale : _setterTransform : (_recentSetterPlugin = plugin || {}) && (property === "scale" ? _setterScaleWithRender : _setterTransformWithRender) : target.style && !_isUndefined(target.style[property]) ? _setterCSSStyle : ~property.indexOf("-") ? _setterCSSProp : _getSetter(target, property);
    },
    core: {
      _removeProperty,
      _getMatrix
    }
  };
  gsap.utils.checkPrefix = _checkPropPrefix;
  gsap.core.getStyleSaver = _getStyleSaver;
  (function(positionAndScale, rotation, others, aliases) {
    var all = _forEachName(positionAndScale + "," + rotation + "," + others, function(name) {
      _transformProps[name] = 1;
    });
    _forEachName(rotation, function(name) {
      _config.units[name] = "deg";
      _rotationalProperties[name] = 1;
    });
    _propertyAliases[all[13]] = positionAndScale + "," + rotation;
    _forEachName(aliases, function(name) {
      var split = name.split(":");
      _propertyAliases[split[1]] = all[split[0]];
    });
  })("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");
  _forEachName("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function(name) {
    _config.units[name] = "px";
  });
  gsap.registerPlugin(CSSPlugin);

  // node_modules/gsap/index.js
  var gsapWithCSS = gsap.registerPlugin(CSSPlugin) || gsap;
  var TweenMaxWithCSS = gsapWithCSS.core.Tween;

  // node_modules/gsap/Observer.js
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }
  var gsap2;
  var _coreInitted2;
  var _clamp3;
  var _win3;
  var _doc3;
  var _docEl;
  var _body;
  var _isTouch;
  var _pointerType;
  var ScrollTrigger;
  var _root;
  var _normalizer;
  var _eventTypes;
  var _context2;
  var _getGSAP = function _getGSAP2() {
    return gsap2 || typeof window !== "undefined" && (gsap2 = window.gsap) && gsap2.registerPlugin && gsap2;
  };
  var _startup = 1;
  var _observers = [];
  var _scrollers = [];
  var _proxies = [];
  var _getTime = Date.now;
  var _bridge = function _bridge2(name, value) {
    return value;
  };
  var _integrate = function _integrate2() {
    var core = ScrollTrigger.core, data = core.bridge || {}, scrollers = core._scrollers, proxies = core._proxies;
    scrollers.push.apply(scrollers, _scrollers);
    proxies.push.apply(proxies, _proxies);
    _scrollers = scrollers;
    _proxies = proxies;
    _bridge = function _bridge3(name, value) {
      return data[name](value);
    };
  };
  var _getProxyProp = function _getProxyProp2(element, property) {
    return ~_proxies.indexOf(element) && _proxies[_proxies.indexOf(element) + 1][property];
  };
  var _isViewport = function _isViewport2(el) {
    return !!~_root.indexOf(el);
  };
  var _addListener = function _addListener2(element, type, func, passive, capture) {
    return element.addEventListener(type, func, {
      passive: passive !== false,
      capture: !!capture
    });
  };
  var _removeListener = function _removeListener2(element, type, func, capture) {
    return element.removeEventListener(type, func, !!capture);
  };
  var _scrollLeft = "scrollLeft";
  var _scrollTop = "scrollTop";
  var _onScroll = function _onScroll2() {
    return _normalizer && _normalizer.isPressed || _scrollers.cache++;
  };
  var _scrollCacheFunc = function _scrollCacheFunc2(f, doNotCache) {
    var cachingFunc = function cachingFunc2(value) {
      if (value || value === 0) {
        _startup && (_win3.history.scrollRestoration = "manual");
        var isNormalizing = _normalizer && _normalizer.isPressed;
        value = cachingFunc2.v = Math.round(value) || (_normalizer && _normalizer.iOS ? 1 : 0);
        f(value);
        cachingFunc2.cacheID = _scrollers.cache;
        isNormalizing && _bridge("ss", value);
      } else if (doNotCache || _scrollers.cache !== cachingFunc2.cacheID || _bridge("ref")) {
        cachingFunc2.cacheID = _scrollers.cache;
        cachingFunc2.v = f();
      }
      return cachingFunc2.v + cachingFunc2.offset;
    };
    cachingFunc.offset = 0;
    return f && cachingFunc;
  };
  var _horizontal = {
    s: _scrollLeft,
    p: "left",
    p2: "Left",
    os: "right",
    os2: "Right",
    d: "width",
    d2: "Width",
    a: "x",
    sc: _scrollCacheFunc(function(value) {
      return arguments.length ? _win3.scrollTo(value, _vertical.sc()) : _win3.pageXOffset || _doc3[_scrollLeft] || _docEl[_scrollLeft] || _body[_scrollLeft] || 0;
    })
  };
  var _vertical = {
    s: _scrollTop,
    p: "top",
    p2: "Top",
    os: "bottom",
    os2: "Bottom",
    d: "height",
    d2: "Height",
    a: "y",
    op: _horizontal,
    sc: _scrollCacheFunc(function(value) {
      return arguments.length ? _win3.scrollTo(_horizontal.sc(), value) : _win3.pageYOffset || _doc3[_scrollTop] || _docEl[_scrollTop] || _body[_scrollTop] || 0;
    })
  };
  var _getTarget = function _getTarget2(t, self2) {
    return (self2 && self2._ctx && self2._ctx.selector || gsap2.utils.toArray)(t)[0] || (typeof t === "string" && gsap2.config().nullTargetWarn !== false ? console.warn("Element not found:", t) : null);
  };
  var _isWithin = function _isWithin2(element, list) {
    var i = list.length;
    while (i--) {
      if (list[i] === element || list[i].contains(element)) {
        return true;
      }
    }
    return false;
  };
  var _getScrollFunc = function _getScrollFunc2(element, _ref) {
    var s = _ref.s, sc = _ref.sc;
    _isViewport(element) && (element = _doc3.scrollingElement || _docEl);
    var i = _scrollers.indexOf(element), offset = sc === _vertical.sc ? 1 : 2;
    !~i && (i = _scrollers.push(element) - 1);
    _scrollers[i + offset] || _addListener(element, "scroll", _onScroll);
    var prev = _scrollers[i + offset], func = prev || (_scrollers[i + offset] = _scrollCacheFunc(_getProxyProp(element, s), true) || (_isViewport(element) ? sc : _scrollCacheFunc(function(value) {
      return arguments.length ? element[s] = value : element[s];
    })));
    func.target = element;
    prev || (func.smooth = gsap2.getProperty(element, "scrollBehavior") === "smooth");
    return func;
  };
  var _getVelocityProp = function _getVelocityProp2(value, minTimeRefresh, useDelta) {
    var v1 = value, v2 = value, t1 = _getTime(), t2 = t1, min = minTimeRefresh || 50, dropToZeroTime = Math.max(500, min * 3), update = function update2(value2, force) {
      var t = _getTime();
      if (force || t - t1 > min) {
        v2 = v1;
        v1 = value2;
        t2 = t1;
        t1 = t;
      } else if (useDelta) {
        v1 += value2;
      } else {
        v1 = v2 + (value2 - v2) / (t - t2) * (t1 - t2);
      }
    }, reset = function reset2() {
      v2 = v1 = useDelta ? 0 : v1;
      t2 = t1 = 0;
    }, getVelocity2 = function getVelocity3(latestValue) {
      var tOld = t2, vOld = v2, t = _getTime();
      (latestValue || latestValue === 0) && latestValue !== v1 && update(latestValue);
      return t1 === t2 || t - t2 > dropToZeroTime ? 0 : (v1 + (useDelta ? vOld : -vOld)) / ((useDelta ? t : t1) - tOld) * 1e3;
    };
    return {
      update,
      reset,
      getVelocity: getVelocity2
    };
  };
  var _getEvent = function _getEvent2(e, preventDefault) {
    preventDefault && !e._gsapAllow && e.preventDefault();
    return e.changedTouches ? e.changedTouches[0] : e;
  };
  var _getAbsoluteMax = function _getAbsoluteMax2(a) {
    var max = Math.max.apply(Math, a), min = Math.min.apply(Math, a);
    return Math.abs(max) >= Math.abs(min) ? max : min;
  };
  var _setScrollTrigger = function _setScrollTrigger2() {
    ScrollTrigger = gsap2.core.globals().ScrollTrigger;
    ScrollTrigger && ScrollTrigger.core && _integrate();
  };
  var _initCore3 = function _initCore4(core) {
    gsap2 = core || _getGSAP();
    if (!_coreInitted2 && gsap2 && typeof document !== "undefined" && document.body) {
      _win3 = window;
      _doc3 = document;
      _docEl = _doc3.documentElement;
      _body = _doc3.body;
      _root = [_win3, _doc3, _docEl, _body];
      _clamp3 = gsap2.utils.clamp;
      _context2 = gsap2.core.context || function() {
      };
      _pointerType = "onpointerenter" in _body ? "pointer" : "mouse";
      _isTouch = Observer.isTouch = _win3.matchMedia && _win3.matchMedia("(hover: none), (pointer: coarse)").matches ? 1 : "ontouchstart" in _win3 || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0;
      _eventTypes = Observer.eventTypes = ("ontouchstart" in _docEl ? "touchstart,touchmove,touchcancel,touchend" : !("onpointerdown" in _docEl) ? "mousedown,mousemove,mouseup,mouseup" : "pointerdown,pointermove,pointercancel,pointerup").split(",");
      setTimeout(function() {
        return _startup = 0;
      }, 500);
      _setScrollTrigger();
      _coreInitted2 = 1;
    }
    return _coreInitted2;
  };
  _horizontal.op = _vertical;
  _scrollers.cache = 0;
  var Observer = /* @__PURE__ */ (function() {
    function Observer2(vars) {
      this.init(vars);
    }
    var _proto = Observer2.prototype;
    _proto.init = function init5(vars) {
      _coreInitted2 || _initCore3(gsap2) || console.warn("Please gsap.registerPlugin(Observer)");
      ScrollTrigger || _setScrollTrigger();
      var tolerance = vars.tolerance, dragMinimum = vars.dragMinimum, type = vars.type, target = vars.target, lineHeight = vars.lineHeight, debounce = vars.debounce, preventDefault = vars.preventDefault, onStop = vars.onStop, onStopDelay = vars.onStopDelay, ignore = vars.ignore, wheelSpeed = vars.wheelSpeed, event = vars.event, onDragStart = vars.onDragStart, onDragEnd = vars.onDragEnd, onDrag = vars.onDrag, onPress = vars.onPress, onRelease = vars.onRelease, onRight = vars.onRight, onLeft = vars.onLeft, onUp = vars.onUp, onDown = vars.onDown, onChangeX = vars.onChangeX, onChangeY = vars.onChangeY, onChange = vars.onChange, onToggleX = vars.onToggleX, onToggleY = vars.onToggleY, onHover = vars.onHover, onHoverEnd = vars.onHoverEnd, onMove = vars.onMove, ignoreCheck = vars.ignoreCheck, isNormalizer = vars.isNormalizer, onGestureStart = vars.onGestureStart, onGestureEnd = vars.onGestureEnd, onWheel = vars.onWheel, onEnable = vars.onEnable, onDisable = vars.onDisable, onClick = vars.onClick, scrollSpeed = vars.scrollSpeed, capture = vars.capture, allowClicks = vars.allowClicks, lockAxis = vars.lockAxis, onLockAxis = vars.onLockAxis;
      this.target = target = _getTarget(target) || _docEl;
      this.vars = vars;
      ignore && (ignore = gsap2.utils.toArray(ignore));
      tolerance = tolerance || 1e-9;
      dragMinimum = dragMinimum || 0;
      wheelSpeed = wheelSpeed || 1;
      scrollSpeed = scrollSpeed || 1;
      type = type || "wheel,touch,pointer";
      debounce = debounce !== false;
      lineHeight || (lineHeight = parseFloat(_win3.getComputedStyle(_body).lineHeight) || 22);
      var id3, onStopDelayedCall, dragged, moved, wheeled, locked, axis, self2 = this, prevDeltaX = 0, prevDeltaY = 0, passive = vars.passive || !preventDefault && vars.passive !== false, scrollFuncX = _getScrollFunc(target, _horizontal), scrollFuncY = _getScrollFunc(target, _vertical), scrollX = scrollFuncX(), scrollY = scrollFuncY(), limitToTouch = ~type.indexOf("touch") && !~type.indexOf("pointer") && _eventTypes[0] === "pointerdown", isViewport = _isViewport(target), ownerDoc = target.ownerDocument || _doc3, deltaX = [0, 0, 0], deltaY = [0, 0, 0], onClickTime = 0, clickCapture = function clickCapture2() {
        return onClickTime = _getTime();
      }, _ignoreCheck = function _ignoreCheck2(e, isPointerOrTouch) {
        return (self2.event = e) && ignore && _isWithin(e.target, ignore) || isPointerOrTouch && limitToTouch && e.pointerType !== "touch" || ignoreCheck && ignoreCheck(e, isPointerOrTouch);
      }, onStopFunc = function onStopFunc2() {
        self2._vx.reset();
        self2._vy.reset();
        onStopDelayedCall.pause();
        onStop && onStop(self2);
      }, update = function update2() {
        var dx = self2.deltaX = _getAbsoluteMax(deltaX), dy = self2.deltaY = _getAbsoluteMax(deltaY), changedX = Math.abs(dx) >= tolerance, changedY = Math.abs(dy) >= tolerance;
        onChange && (changedX || changedY) && onChange(self2, dx, dy, deltaX, deltaY);
        if (changedX) {
          onRight && self2.deltaX > 0 && onRight(self2);
          onLeft && self2.deltaX < 0 && onLeft(self2);
          onChangeX && onChangeX(self2);
          onToggleX && self2.deltaX < 0 !== prevDeltaX < 0 && onToggleX(self2);
          prevDeltaX = self2.deltaX;
          deltaX[0] = deltaX[1] = deltaX[2] = 0;
        }
        if (changedY) {
          onDown && self2.deltaY > 0 && onDown(self2);
          onUp && self2.deltaY < 0 && onUp(self2);
          onChangeY && onChangeY(self2);
          onToggleY && self2.deltaY < 0 !== prevDeltaY < 0 && onToggleY(self2);
          prevDeltaY = self2.deltaY;
          deltaY[0] = deltaY[1] = deltaY[2] = 0;
        }
        if (moved || dragged) {
          onMove && onMove(self2);
          if (dragged) {
            onDragStart && dragged === 1 && onDragStart(self2);
            onDrag && onDrag(self2);
            dragged = 0;
          }
          moved = false;
        }
        locked && !(locked = false) && onLockAxis && onLockAxis(self2);
        if (wheeled) {
          onWheel(self2);
          wheeled = false;
        }
        id3 = 0;
      }, onDelta = function onDelta2(x, y, index) {
        deltaX[index] += x;
        deltaY[index] += y;
        self2._vx.update(x);
        self2._vy.update(y);
        debounce ? id3 || (id3 = requestAnimationFrame(update)) : update();
      }, onTouchOrPointerDelta = function onTouchOrPointerDelta2(x, y) {
        if (lockAxis && !axis) {
          self2.axis = axis = Math.abs(x) > Math.abs(y) ? "x" : "y";
          locked = true;
        }
        if (axis !== "y") {
          deltaX[2] += x;
          self2._vx.update(x, true);
        }
        if (axis !== "x") {
          deltaY[2] += y;
          self2._vy.update(y, true);
        }
        debounce ? id3 || (id3 = requestAnimationFrame(update)) : update();
      }, _onDrag = function _onDrag2(e) {
        if (_ignoreCheck(e, 1)) {
          return;
        }
        e = _getEvent(e, preventDefault);
        var x = e.clientX, y = e.clientY, dx = x - self2.x, dy = y - self2.y, isDragging2 = self2.isDragging;
        self2.x = x;
        self2.y = y;
        if (isDragging2 || (dx || dy) && (Math.abs(self2.startX - x) >= dragMinimum || Math.abs(self2.startY - y) >= dragMinimum)) {
          dragged = isDragging2 ? 2 : 1;
          isDragging2 || (self2.isDragging = true);
          onTouchOrPointerDelta(dx, dy);
        }
      }, _onPress = self2.onPress = function(e) {
        if (_ignoreCheck(e, 1) || e && e.button) {
          return;
        }
        self2.axis = axis = null;
        onStopDelayedCall.pause();
        self2.isPressed = true;
        e = _getEvent(e);
        prevDeltaX = prevDeltaY = 0;
        self2.startX = self2.x = e.clientX;
        self2.startY = self2.y = e.clientY;
        self2._vx.reset();
        self2._vy.reset();
        _addListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, passive, true);
        self2.deltaX = self2.deltaY = 0;
        onPress && onPress(self2);
      }, _onRelease = self2.onRelease = function(e) {
        if (_ignoreCheck(e, 1)) {
          return;
        }
        _removeListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, true);
        var isTrackingDrag = !isNaN(self2.y - self2.startY), wasDragging = self2.isDragging, isDragNotClick = wasDragging && (Math.abs(self2.x - self2.startX) > 3 || Math.abs(self2.y - self2.startY) > 3), eventData = _getEvent(e);
        if (!isDragNotClick && isTrackingDrag) {
          self2._vx.reset();
          self2._vy.reset();
          if (preventDefault && allowClicks) {
            gsap2.delayedCall(0.08, function() {
              if (_getTime() - onClickTime > 300 && !e.defaultPrevented) {
                if (e.target.click) {
                  e.target.click();
                } else if (ownerDoc.createEvent) {
                  var syntheticEvent = ownerDoc.createEvent("MouseEvents");
                  syntheticEvent.initMouseEvent("click", true, true, _win3, 1, eventData.screenX, eventData.screenY, eventData.clientX, eventData.clientY, false, false, false, false, 0, null);
                  e.target.dispatchEvent(syntheticEvent);
                }
              }
            });
          }
        }
        self2.isDragging = self2.isGesturing = self2.isPressed = false;
        onStop && wasDragging && !isNormalizer && onStopDelayedCall.restart(true);
        dragged && update();
        onDragEnd && wasDragging && onDragEnd(self2);
        onRelease && onRelease(self2, isDragNotClick);
      }, _onGestureStart = function _onGestureStart2(e) {
        return e.touches && e.touches.length > 1 && (self2.isGesturing = true) && onGestureStart(e, self2.isDragging);
      }, _onGestureEnd = function _onGestureEnd2() {
        return (self2.isGesturing = false) || onGestureEnd(self2);
      }, onScroll = function onScroll2(e) {
        if (_ignoreCheck(e)) {
          return;
        }
        var x = scrollFuncX(), y = scrollFuncY();
        onDelta((x - scrollX) * scrollSpeed, (y - scrollY) * scrollSpeed, 1);
        scrollX = x;
        scrollY = y;
        onStop && onStopDelayedCall.restart(true);
      }, _onWheel = function _onWheel2(e) {
        if (_ignoreCheck(e)) {
          return;
        }
        e = _getEvent(e, preventDefault);
        onWheel && (wheeled = true);
        var multiplier = (e.deltaMode === 1 ? lineHeight : e.deltaMode === 2 ? _win3.innerHeight : 1) * wheelSpeed;
        onDelta(e.deltaX * multiplier, e.deltaY * multiplier, 0);
        onStop && !isNormalizer && onStopDelayedCall.restart(true);
      }, _onMove = function _onMove2(e) {
        if (_ignoreCheck(e)) {
          return;
        }
        var x = e.clientX, y = e.clientY, dx = x - self2.x, dy = y - self2.y;
        self2.x = x;
        self2.y = y;
        moved = true;
        onStop && onStopDelayedCall.restart(true);
        (dx || dy) && onTouchOrPointerDelta(dx, dy);
      }, _onHover = function _onHover2(e) {
        self2.event = e;
        onHover(self2);
      }, _onHoverEnd = function _onHoverEnd2(e) {
        self2.event = e;
        onHoverEnd(self2);
      }, _onClick = function _onClick2(e) {
        return _ignoreCheck(e) || _getEvent(e, preventDefault) && onClick(self2);
      };
      onStopDelayedCall = self2._dc = gsap2.delayedCall(onStopDelay || 0.25, onStopFunc).pause();
      self2.deltaX = self2.deltaY = 0;
      self2._vx = _getVelocityProp(0, 50, true);
      self2._vy = _getVelocityProp(0, 50, true);
      self2.scrollX = scrollFuncX;
      self2.scrollY = scrollFuncY;
      self2.isDragging = self2.isGesturing = self2.isPressed = false;
      _context2(this);
      self2.enable = function(e) {
        if (!self2.isEnabled) {
          _addListener(isViewport ? ownerDoc : target, "scroll", _onScroll);
          type.indexOf("scroll") >= 0 && _addListener(isViewport ? ownerDoc : target, "scroll", onScroll, passive, capture);
          type.indexOf("wheel") >= 0 && _addListener(target, "wheel", _onWheel, passive, capture);
          if (type.indexOf("touch") >= 0 && _isTouch || type.indexOf("pointer") >= 0) {
            _addListener(target, _eventTypes[0], _onPress, passive, capture);
            _addListener(ownerDoc, _eventTypes[2], _onRelease);
            _addListener(ownerDoc, _eventTypes[3], _onRelease);
            allowClicks && _addListener(target, "click", clickCapture, true, true);
            onClick && _addListener(target, "click", _onClick);
            onGestureStart && _addListener(ownerDoc, "gesturestart", _onGestureStart);
            onGestureEnd && _addListener(ownerDoc, "gestureend", _onGestureEnd);
            onHover && _addListener(target, _pointerType + "enter", _onHover);
            onHoverEnd && _addListener(target, _pointerType + "leave", _onHoverEnd);
            onMove && _addListener(target, _pointerType + "move", _onMove);
          }
          self2.isEnabled = true;
          self2.isDragging = self2.isGesturing = self2.isPressed = moved = dragged = false;
          self2._vx.reset();
          self2._vy.reset();
          scrollX = scrollFuncX();
          scrollY = scrollFuncY();
          e && e.type && _onPress(e);
          onEnable && onEnable(self2);
        }
        return self2;
      };
      self2.disable = function() {
        if (self2.isEnabled) {
          _observers.filter(function(o) {
            return o !== self2 && _isViewport(o.target);
          }).length || _removeListener(isViewport ? ownerDoc : target, "scroll", _onScroll);
          if (self2.isPressed) {
            self2._vx.reset();
            self2._vy.reset();
            _removeListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, true);
          }
          _removeListener(isViewport ? ownerDoc : target, "scroll", onScroll, capture);
          _removeListener(target, "wheel", _onWheel, capture);
          _removeListener(target, _eventTypes[0], _onPress, capture);
          _removeListener(ownerDoc, _eventTypes[2], _onRelease);
          _removeListener(ownerDoc, _eventTypes[3], _onRelease);
          _removeListener(target, "click", clickCapture, true);
          _removeListener(target, "click", _onClick);
          _removeListener(ownerDoc, "gesturestart", _onGestureStart);
          _removeListener(ownerDoc, "gestureend", _onGestureEnd);
          _removeListener(target, _pointerType + "enter", _onHover);
          _removeListener(target, _pointerType + "leave", _onHoverEnd);
          _removeListener(target, _pointerType + "move", _onMove);
          self2.isEnabled = self2.isPressed = self2.isDragging = false;
          onDisable && onDisable(self2);
        }
      };
      self2.kill = self2.revert = function() {
        self2.disable();
        var i = _observers.indexOf(self2);
        i >= 0 && _observers.splice(i, 1);
        _normalizer === self2 && (_normalizer = 0);
      };
      _observers.push(self2);
      isNormalizer && _isViewport(target) && (_normalizer = self2);
      self2.enable(event);
    };
    _createClass(Observer2, [{
      key: "velocityX",
      get: function get() {
        return this._vx.getVelocity();
      }
    }, {
      key: "velocityY",
      get: function get() {
        return this._vy.getVelocity();
      }
    }]);
    return Observer2;
  })();
  Observer.version = "3.13.0";
  Observer.create = function(vars) {
    return new Observer(vars);
  };
  Observer.register = _initCore3;
  Observer.getAll = function() {
    return _observers.slice();
  };
  Observer.getById = function(id3) {
    return _observers.filter(function(o) {
      return o.vars.id === id3;
    })[0];
  };
  _getGSAP() && gsap2.registerPlugin(Observer);

  // node_modules/gsap/ScrollTrigger.js
  var gsap3;
  var _coreInitted3;
  var _win4;
  var _doc4;
  var _docEl2;
  var _body2;
  var _root2;
  var _resizeDelay;
  var _toArray;
  var _clamp4;
  var _time2;
  var _syncInterval;
  var _refreshing;
  var _pointerIsDown;
  var _transformProp2;
  var _i;
  var _prevWidth;
  var _prevHeight;
  var _autoRefresh;
  var _sort;
  var _suppressOverwrites2;
  var _ignoreResize;
  var _normalizer2;
  var _ignoreMobileResize;
  var _baseScreenHeight;
  var _baseScreenWidth;
  var _fixIOSBug;
  var _context3;
  var _scrollRestoration;
  var _div100vh;
  var _100vh;
  var _isReverted;
  var _clampingMax;
  var _limitCallbacks;
  var _startup2 = 1;
  var _getTime2 = Date.now;
  var _time1 = _getTime2();
  var _lastScrollTime = 0;
  var _enabled = 0;
  var _parseClamp = function _parseClamp2(value, type, self2) {
    var clamp4 = _isString3(value) && (value.substr(0, 6) === "clamp(" || value.indexOf("max") > -1);
    self2["_" + type + "Clamp"] = clamp4;
    return clamp4 ? value.substr(6, value.length - 7) : value;
  };
  var _keepClamp = function _keepClamp2(value, clamp4) {
    return clamp4 && (!_isString3(value) || value.substr(0, 6) !== "clamp(") ? "clamp(" + value + ")" : value;
  };
  var _rafBugFix = function _rafBugFix2() {
    return _enabled && requestAnimationFrame(_rafBugFix2);
  };
  var _pointerDownHandler = function _pointerDownHandler2() {
    return _pointerIsDown = 1;
  };
  var _pointerUpHandler = function _pointerUpHandler2() {
    return _pointerIsDown = 0;
  };
  var _passThrough3 = function _passThrough4(v) {
    return v;
  };
  var _round3 = function _round4(value) {
    return Math.round(value * 1e5) / 1e5 || 0;
  };
  var _windowExists5 = function _windowExists6() {
    return typeof window !== "undefined";
  };
  var _getGSAP3 = function _getGSAP4() {
    return gsap3 || _windowExists5() && (gsap3 = window.gsap) && gsap3.registerPlugin && gsap3;
  };
  var _isViewport3 = function _isViewport4(e) {
    return !!~_root2.indexOf(e);
  };
  var _getViewportDimension = function _getViewportDimension2(dimensionProperty) {
    return (dimensionProperty === "Height" ? _100vh : _win4["inner" + dimensionProperty]) || _docEl2["client" + dimensionProperty] || _body2["client" + dimensionProperty];
  };
  var _getBoundsFunc = function _getBoundsFunc2(element) {
    return _getProxyProp(element, "getBoundingClientRect") || (_isViewport3(element) ? function() {
      _winOffsets.width = _win4.innerWidth;
      _winOffsets.height = _100vh;
      return _winOffsets;
    } : function() {
      return _getBounds(element);
    });
  };
  var _getSizeFunc = function _getSizeFunc2(scroller, isViewport, _ref) {
    var d = _ref.d, d2 = _ref.d2, a = _ref.a;
    return (a = _getProxyProp(scroller, "getBoundingClientRect")) ? function() {
      return a()[d];
    } : function() {
      return (isViewport ? _getViewportDimension(d2) : scroller["client" + d2]) || 0;
    };
  };
  var _getOffsetsFunc = function _getOffsetsFunc2(element, isViewport) {
    return !isViewport || ~_proxies.indexOf(element) ? _getBoundsFunc(element) : function() {
      return _winOffsets;
    };
  };
  var _maxScroll = function _maxScroll2(element, _ref2) {
    var s = _ref2.s, d2 = _ref2.d2, d = _ref2.d, a = _ref2.a;
    return Math.max(0, (s = "scroll" + d2) && (a = _getProxyProp(element, s)) ? a() - _getBoundsFunc(element)()[d] : _isViewport3(element) ? (_docEl2[s] || _body2[s]) - _getViewportDimension(d2) : element[s] - element["offset" + d2]);
  };
  var _iterateAutoRefresh = function _iterateAutoRefresh2(func, events) {
    for (var i = 0; i < _autoRefresh.length; i += 3) {
      (!events || ~events.indexOf(_autoRefresh[i + 1])) && func(_autoRefresh[i], _autoRefresh[i + 1], _autoRefresh[i + 2]);
    }
  };
  var _isString3 = function _isString4(value) {
    return typeof value === "string";
  };
  var _isFunction3 = function _isFunction4(value) {
    return typeof value === "function";
  };
  var _isNumber3 = function _isNumber4(value) {
    return typeof value === "number";
  };
  var _isObject3 = function _isObject4(value) {
    return typeof value === "object";
  };
  var _endAnimation = function _endAnimation2(animation, reversed, pause) {
    return animation && animation.progress(reversed ? 0 : 1) && pause && animation.pause();
  };
  var _callback3 = function _callback4(self2, func) {
    if (self2.enabled) {
      var result = self2._ctx ? self2._ctx.add(function() {
        return func(self2);
      }) : func(self2);
      result && result.totalTime && (self2.callbackAnimation = result);
    }
  };
  var _abs = Math.abs;
  var _left = "left";
  var _top = "top";
  var _right = "right";
  var _bottom = "bottom";
  var _width = "width";
  var _height = "height";
  var _Right = "Right";
  var _Left = "Left";
  var _Top = "Top";
  var _Bottom = "Bottom";
  var _padding = "padding";
  var _margin = "margin";
  var _Width = "Width";
  var _Height = "Height";
  var _px = "px";
  var _getComputedStyle = function _getComputedStyle2(element) {
    return _win4.getComputedStyle(element);
  };
  var _makePositionable = function _makePositionable2(element) {
    var position = _getComputedStyle(element).position;
    element.style.position = position === "absolute" || position === "fixed" ? position : "relative";
  };
  var _setDefaults3 = function _setDefaults4(obj, defaults3) {
    for (var p in defaults3) {
      p in obj || (obj[p] = defaults3[p]);
    }
    return obj;
  };
  var _getBounds = function _getBounds2(element, withoutTransforms) {
    var tween = withoutTransforms && _getComputedStyle(element)[_transformProp2] !== "matrix(1, 0, 0, 1, 0, 0)" && gsap3.to(element, {
      x: 0,
      y: 0,
      xPercent: 0,
      yPercent: 0,
      rotation: 0,
      rotationX: 0,
      rotationY: 0,
      scale: 1,
      skewX: 0,
      skewY: 0
    }).progress(1), bounds = element.getBoundingClientRect();
    tween && tween.progress(0).kill();
    return bounds;
  };
  var _getSize = function _getSize2(element, _ref3) {
    var d2 = _ref3.d2;
    return element["offset" + d2] || element["client" + d2] || 0;
  };
  var _getLabelRatioArray = function _getLabelRatioArray2(timeline2) {
    var a = [], labels = timeline2.labels, duration = timeline2.duration(), p;
    for (p in labels) {
      a.push(labels[p] / duration);
    }
    return a;
  };
  var _getClosestLabel = function _getClosestLabel2(animation) {
    return function(value) {
      return gsap3.utils.snap(_getLabelRatioArray(animation), value);
    };
  };
  var _snapDirectional = function _snapDirectional2(snapIncrementOrArray) {
    var snap3 = gsap3.utils.snap(snapIncrementOrArray), a = Array.isArray(snapIncrementOrArray) && snapIncrementOrArray.slice(0).sort(function(a2, b) {
      return a2 - b;
    });
    return a ? function(value, direction, threshold) {
      if (threshold === void 0) {
        threshold = 1e-3;
      }
      var i;
      if (!direction) {
        return snap3(value);
      }
      if (direction > 0) {
        value -= threshold;
        for (i = 0; i < a.length; i++) {
          if (a[i] >= value) {
            return a[i];
          }
        }
        return a[i - 1];
      } else {
        i = a.length;
        value += threshold;
        while (i--) {
          if (a[i] <= value) {
            return a[i];
          }
        }
      }
      return a[0];
    } : function(value, direction, threshold) {
      if (threshold === void 0) {
        threshold = 1e-3;
      }
      var snapped = snap3(value);
      return !direction || Math.abs(snapped - value) < threshold || snapped - value < 0 === direction < 0 ? snapped : snap3(direction < 0 ? value - snapIncrementOrArray : value + snapIncrementOrArray);
    };
  };
  var _getLabelAtDirection = function _getLabelAtDirection2(timeline2) {
    return function(value, st) {
      return _snapDirectional(_getLabelRatioArray(timeline2))(value, st.direction);
    };
  };
  var _multiListener = function _multiListener2(func, element, types, callback) {
    return types.split(",").forEach(function(type) {
      return func(element, type, callback);
    });
  };
  var _addListener3 = function _addListener4(element, type, func, nonPassive, capture) {
    return element.addEventListener(type, func, {
      passive: !nonPassive,
      capture: !!capture
    });
  };
  var _removeListener3 = function _removeListener4(element, type, func, capture) {
    return element.removeEventListener(type, func, !!capture);
  };
  var _wheelListener = function _wheelListener2(func, el, scrollFunc) {
    scrollFunc = scrollFunc && scrollFunc.wheelHandler;
    if (scrollFunc) {
      func(el, "wheel", scrollFunc);
      func(el, "touchmove", scrollFunc);
    }
  };
  var _markerDefaults = {
    startColor: "green",
    endColor: "red",
    indent: 0,
    fontSize: "16px",
    fontWeight: "normal"
  };
  var _defaults2 = {
    toggleActions: "play",
    anticipatePin: 0
  };
  var _keywords = {
    top: 0,
    left: 0,
    center: 0.5,
    bottom: 1,
    right: 1
  };
  var _offsetToPx = function _offsetToPx2(value, size) {
    if (_isString3(value)) {
      var eqIndex = value.indexOf("="), relative = ~eqIndex ? +(value.charAt(eqIndex - 1) + 1) * parseFloat(value.substr(eqIndex + 1)) : 0;
      if (~eqIndex) {
        value.indexOf("%") > eqIndex && (relative *= size / 100);
        value = value.substr(0, eqIndex - 1);
      }
      value = relative + (value in _keywords ? _keywords[value] * size : ~value.indexOf("%") ? parseFloat(value) * size / 100 : parseFloat(value) || 0);
    }
    return value;
  };
  var _createMarker = function _createMarker2(type, name, container2, direction, _ref4, offset, matchWidthEl, containerAnimation) {
    var startColor = _ref4.startColor, endColor = _ref4.endColor, fontSize = _ref4.fontSize, indent = _ref4.indent, fontWeight = _ref4.fontWeight;
    var e = _doc4.createElement("div"), useFixedPosition = _isViewport3(container2) || _getProxyProp(container2, "pinType") === "fixed", isScroller = type.indexOf("scroller") !== -1, parent = useFixedPosition ? _body2 : container2, isStart = type.indexOf("start") !== -1, color2 = isStart ? startColor : endColor, css = "border-color:" + color2 + ";font-size:" + fontSize + ";color:" + color2 + ";font-weight:" + fontWeight + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";
    css += "position:" + ((isScroller || containerAnimation) && useFixedPosition ? "fixed;" : "absolute;");
    (isScroller || containerAnimation || !useFixedPosition) && (css += (direction === _vertical ? _right : _bottom) + ":" + (offset + parseFloat(indent)) + "px;");
    matchWidthEl && (css += "box-sizing:border-box;text-align:left;width:" + matchWidthEl.offsetWidth + "px;");
    e._isStart = isStart;
    e.setAttribute("class", "gsap-marker-" + type + (name ? " marker-" + name : ""));
    e.style.cssText = css;
    e.innerText = name || name === 0 ? type + "-" + name : type;
    parent.children[0] ? parent.insertBefore(e, parent.children[0]) : parent.appendChild(e);
    e._offset = e["offset" + direction.op.d2];
    _positionMarker(e, 0, direction, isStart);
    return e;
  };
  var _positionMarker = function _positionMarker2(marker, start, direction, flipped) {
    var vars = {
      display: "block"
    }, side = direction[flipped ? "os2" : "p2"], oppositeSide = direction[flipped ? "p2" : "os2"];
    marker._isFlipped = flipped;
    vars[direction.a + "Percent"] = flipped ? -100 : 0;
    vars[direction.a] = flipped ? "1px" : 0;
    vars["border" + side + _Width] = 1;
    vars["border" + oppositeSide + _Width] = 0;
    vars[direction.p] = start + "px";
    gsap3.set(marker, vars);
  };
  var _triggers = [];
  var _ids = {};
  var _rafID;
  var _sync = function _sync2() {
    return _getTime2() - _lastScrollTime > 34 && (_rafID || (_rafID = requestAnimationFrame(_updateAll)));
  };
  var _onScroll3 = function _onScroll4() {
    if (!_normalizer2 || !_normalizer2.isPressed || _normalizer2.startX > _body2.clientWidth) {
      _scrollers.cache++;
      if (_normalizer2) {
        _rafID || (_rafID = requestAnimationFrame(_updateAll));
      } else {
        _updateAll();
      }
      _lastScrollTime || _dispatch3("scrollStart");
      _lastScrollTime = _getTime2();
    }
  };
  var _setBaseDimensions = function _setBaseDimensions2() {
    _baseScreenWidth = _win4.innerWidth;
    _baseScreenHeight = _win4.innerHeight;
  };
  var _onResize = function _onResize2(force) {
    _scrollers.cache++;
    (force === true || !_refreshing && !_ignoreResize && !_doc4.fullscreenElement && !_doc4.webkitFullscreenElement && (!_ignoreMobileResize || _baseScreenWidth !== _win4.innerWidth || Math.abs(_win4.innerHeight - _baseScreenHeight) > _win4.innerHeight * 0.25)) && _resizeDelay.restart(true);
  };
  var _listeners2 = {};
  var _emptyArray2 = [];
  var _softRefresh = function _softRefresh2() {
    return _removeListener3(ScrollTrigger2, "scrollEnd", _softRefresh2) || _refreshAll(true);
  };
  var _dispatch3 = function _dispatch4(type) {
    return _listeners2[type] && _listeners2[type].map(function(f) {
      return f();
    }) || _emptyArray2;
  };
  var _savedStyles = [];
  var _revertRecorded = function _revertRecorded2(media) {
    for (var i = 0; i < _savedStyles.length; i += 5) {
      if (!media || _savedStyles[i + 4] && _savedStyles[i + 4].query === media) {
        _savedStyles[i].style.cssText = _savedStyles[i + 1];
        _savedStyles[i].getBBox && _savedStyles[i].setAttribute("transform", _savedStyles[i + 2] || "");
        _savedStyles[i + 3].uncache = 1;
      }
    }
  };
  var _revertAll = function _revertAll2(kill, media) {
    var trigger;
    for (_i = 0; _i < _triggers.length; _i++) {
      trigger = _triggers[_i];
      if (trigger && (!media || trigger._ctx === media)) {
        if (kill) {
          trigger.kill(1);
        } else {
          trigger.revert(true, true);
        }
      }
    }
    _isReverted = true;
    media && _revertRecorded(media);
    media || _dispatch3("revert");
  };
  var _clearScrollMemory = function _clearScrollMemory2(scrollRestoration, force) {
    _scrollers.cache++;
    (force || !_refreshingAll) && _scrollers.forEach(function(obj) {
      return _isFunction3(obj) && obj.cacheID++ && (obj.rec = 0);
    });
    _isString3(scrollRestoration) && (_win4.history.scrollRestoration = _scrollRestoration = scrollRestoration);
  };
  var _refreshingAll;
  var _refreshID = 0;
  var _queueRefreshID;
  var _queueRefreshAll = function _queueRefreshAll2() {
    if (_queueRefreshID !== _refreshID) {
      var id3 = _queueRefreshID = _refreshID;
      requestAnimationFrame(function() {
        return id3 === _refreshID && _refreshAll(true);
      });
    }
  };
  var _refresh100vh = function _refresh100vh2() {
    _body2.appendChild(_div100vh);
    _100vh = !_normalizer2 && _div100vh.offsetHeight || _win4.innerHeight;
    _body2.removeChild(_div100vh);
  };
  var _hideAllMarkers = function _hideAllMarkers2(hide) {
    return _toArray(".gsap-marker-start, .gsap-marker-end, .gsap-marker-scroller-start, .gsap-marker-scroller-end").forEach(function(el) {
      return el.style.display = hide ? "none" : "block";
    });
  };
  var _refreshAll = function _refreshAll2(force, skipRevert) {
    _docEl2 = _doc4.documentElement;
    _body2 = _doc4.body;
    _root2 = [_win4, _doc4, _docEl2, _body2];
    if (_lastScrollTime && !force && !_isReverted) {
      _addListener3(ScrollTrigger2, "scrollEnd", _softRefresh);
      return;
    }
    _refresh100vh();
    _refreshingAll = ScrollTrigger2.isRefreshing = true;
    _scrollers.forEach(function(obj) {
      return _isFunction3(obj) && ++obj.cacheID && (obj.rec = obj());
    });
    var refreshInits = _dispatch3("refreshInit");
    _sort && ScrollTrigger2.sort();
    skipRevert || _revertAll();
    _scrollers.forEach(function(obj) {
      if (_isFunction3(obj)) {
        obj.smooth && (obj.target.style.scrollBehavior = "auto");
        obj(0);
      }
    });
    _triggers.slice(0).forEach(function(t) {
      return t.refresh();
    });
    _isReverted = false;
    _triggers.forEach(function(t) {
      if (t._subPinOffset && t.pin) {
        var prop = t.vars.horizontal ? "offsetWidth" : "offsetHeight", original = t.pin[prop];
        t.revert(true, 1);
        t.adjustPinSpacing(t.pin[prop] - original);
        t.refresh();
      }
    });
    _clampingMax = 1;
    _hideAllMarkers(true);
    _triggers.forEach(function(t) {
      var max = _maxScroll(t.scroller, t._dir), endClamp = t.vars.end === "max" || t._endClamp && t.end > max, startClamp = t._startClamp && t.start >= max;
      (endClamp || startClamp) && t.setPositions(startClamp ? max - 1 : t.start, endClamp ? Math.max(startClamp ? max : t.start + 1, max) : t.end, true);
    });
    _hideAllMarkers(false);
    _clampingMax = 0;
    refreshInits.forEach(function(result) {
      return result && result.render && result.render(-1);
    });
    _scrollers.forEach(function(obj) {
      if (_isFunction3(obj)) {
        obj.smooth && requestAnimationFrame(function() {
          return obj.target.style.scrollBehavior = "smooth";
        });
        obj.rec && obj(obj.rec);
      }
    });
    _clearScrollMemory(_scrollRestoration, 1);
    _resizeDelay.pause();
    _refreshID++;
    _refreshingAll = 2;
    _updateAll(2);
    _triggers.forEach(function(t) {
      return _isFunction3(t.vars.onRefresh) && t.vars.onRefresh(t);
    });
    _refreshingAll = ScrollTrigger2.isRefreshing = false;
    _dispatch3("refresh");
  };
  var _lastScroll = 0;
  var _direction = 1;
  var _primary;
  var _updateAll = function _updateAll2(force) {
    if (force === 2 || !_refreshingAll && !_isReverted) {
      ScrollTrigger2.isUpdating = true;
      _primary && _primary.update(0);
      var l = _triggers.length, time2 = _getTime2(), recordVelocity = time2 - _time1 >= 50, scroll2 = l && _triggers[0].scroll();
      _direction = _lastScroll > scroll2 ? -1 : 1;
      _refreshingAll || (_lastScroll = scroll2);
      if (recordVelocity) {
        if (_lastScrollTime && !_pointerIsDown && time2 - _lastScrollTime > 200) {
          _lastScrollTime = 0;
          _dispatch3("scrollEnd");
        }
        _time2 = _time1;
        _time1 = time2;
      }
      if (_direction < 0) {
        _i = l;
        while (_i-- > 0) {
          _triggers[_i] && _triggers[_i].update(0, recordVelocity);
        }
        _direction = 1;
      } else {
        for (_i = 0; _i < l; _i++) {
          _triggers[_i] && _triggers[_i].update(0, recordVelocity);
        }
      }
      ScrollTrigger2.isUpdating = false;
    }
    _rafID = 0;
  };
  var _propNamesToCopy = [_left, _top, _bottom, _right, _margin + _Bottom, _margin + _Right, _margin + _Top, _margin + _Left, "display", "flexShrink", "float", "zIndex", "gridColumnStart", "gridColumnEnd", "gridRowStart", "gridRowEnd", "gridArea", "justifySelf", "alignSelf", "placeSelf", "order"];
  var _stateProps = _propNamesToCopy.concat([_width, _height, "boxSizing", "max" + _Width, "max" + _Height, "position", _margin, _padding, _padding + _Top, _padding + _Right, _padding + _Bottom, _padding + _Left]);
  var _swapPinOut = function _swapPinOut2(pin, spacer, state) {
    _setState(state);
    var cache = pin._gsap;
    if (cache.spacerIsNative) {
      _setState(cache.spacerState);
    } else if (pin._gsap.swappedIn) {
      var parent = spacer.parentNode;
      if (parent) {
        parent.insertBefore(pin, spacer);
        parent.removeChild(spacer);
      }
    }
    pin._gsap.swappedIn = false;
  };
  var _swapPinIn = function _swapPinIn2(pin, spacer, cs, spacerState) {
    if (!pin._gsap.swappedIn) {
      var i = _propNamesToCopy.length, spacerStyle = spacer.style, pinStyle = pin.style, p;
      while (i--) {
        p = _propNamesToCopy[i];
        spacerStyle[p] = cs[p];
      }
      spacerStyle.position = cs.position === "absolute" ? "absolute" : "relative";
      cs.display === "inline" && (spacerStyle.display = "inline-block");
      pinStyle[_bottom] = pinStyle[_right] = "auto";
      spacerStyle.flexBasis = cs.flexBasis || "auto";
      spacerStyle.overflow = "visible";
      spacerStyle.boxSizing = "border-box";
      spacerStyle[_width] = _getSize(pin, _horizontal) + _px;
      spacerStyle[_height] = _getSize(pin, _vertical) + _px;
      spacerStyle[_padding] = pinStyle[_margin] = pinStyle[_top] = pinStyle[_left] = "0";
      _setState(spacerState);
      pinStyle[_width] = pinStyle["max" + _Width] = cs[_width];
      pinStyle[_height] = pinStyle["max" + _Height] = cs[_height];
      pinStyle[_padding] = cs[_padding];
      if (pin.parentNode !== spacer) {
        pin.parentNode.insertBefore(spacer, pin);
        spacer.appendChild(pin);
      }
      pin._gsap.swappedIn = true;
    }
  };
  var _capsExp2 = /([A-Z])/g;
  var _setState = function _setState2(state) {
    if (state) {
      var style = state.t.style, l = state.length, i = 0, p, value;
      (state.t._gsap || gsap3.core.getCache(state.t)).uncache = 1;
      for (; i < l; i += 2) {
        value = state[i + 1];
        p = state[i];
        if (value) {
          style[p] = value;
        } else if (style[p]) {
          style.removeProperty(p.replace(_capsExp2, "-$1").toLowerCase());
        }
      }
    }
  };
  var _getState = function _getState2(element) {
    var l = _stateProps.length, style = element.style, state = [], i = 0;
    for (; i < l; i++) {
      state.push(_stateProps[i], style[_stateProps[i]]);
    }
    state.t = element;
    return state;
  };
  var _copyState = function _copyState2(state, override, omitOffsets) {
    var result = [], l = state.length, i = omitOffsets ? 8 : 0, p;
    for (; i < l; i += 2) {
      p = state[i];
      result.push(p, p in override ? override[p] : state[i + 1]);
    }
    result.t = state.t;
    return result;
  };
  var _winOffsets = {
    left: 0,
    top: 0
  };
  var _parsePosition3 = function _parsePosition4(value, trigger, scrollerSize, direction, scroll2, marker, markerScroller, self2, scrollerBounds, borderWidth, useFixedPosition, scrollerMax, containerAnimation, clampZeroProp) {
    _isFunction3(value) && (value = value(self2));
    if (_isString3(value) && value.substr(0, 3) === "max") {
      value = scrollerMax + (value.charAt(4) === "=" ? _offsetToPx("0" + value.substr(3), scrollerSize) : 0);
    }
    var time2 = containerAnimation ? containerAnimation.time() : 0, p1, p2, element;
    containerAnimation && containerAnimation.seek(0);
    isNaN(value) || (value = +value);
    if (!_isNumber3(value)) {
      _isFunction3(trigger) && (trigger = trigger(self2));
      var offsets = (value || "0").split(" "), bounds, localOffset, globalOffset, display;
      element = _getTarget(trigger, self2) || _body2;
      bounds = _getBounds(element) || {};
      if ((!bounds || !bounds.left && !bounds.top) && _getComputedStyle(element).display === "none") {
        display = element.style.display;
        element.style.display = "block";
        bounds = _getBounds(element);
        display ? element.style.display = display : element.style.removeProperty("display");
      }
      localOffset = _offsetToPx(offsets[0], bounds[direction.d]);
      globalOffset = _offsetToPx(offsets[1] || "0", scrollerSize);
      value = bounds[direction.p] - scrollerBounds[direction.p] - borderWidth + localOffset + scroll2 - globalOffset;
      markerScroller && _positionMarker(markerScroller, globalOffset, direction, scrollerSize - globalOffset < 20 || markerScroller._isStart && globalOffset > 20);
      scrollerSize -= scrollerSize - globalOffset;
    } else {
      containerAnimation && (value = gsap3.utils.mapRange(containerAnimation.scrollTrigger.start, containerAnimation.scrollTrigger.end, 0, scrollerMax, value));
      markerScroller && _positionMarker(markerScroller, scrollerSize, direction, true);
    }
    if (clampZeroProp) {
      self2[clampZeroProp] = value || -1e-3;
      value < 0 && (value = 0);
    }
    if (marker) {
      var position = value + scrollerSize, isStart = marker._isStart;
      p1 = "scroll" + direction.d2;
      _positionMarker(marker, position, direction, isStart && position > 20 || !isStart && (useFixedPosition ? Math.max(_body2[p1], _docEl2[p1]) : marker.parentNode[p1]) <= position + 1);
      if (useFixedPosition) {
        scrollerBounds = _getBounds(markerScroller);
        useFixedPosition && (marker.style[direction.op.p] = scrollerBounds[direction.op.p] - direction.op.m - marker._offset + _px);
      }
    }
    if (containerAnimation && element) {
      p1 = _getBounds(element);
      containerAnimation.seek(scrollerMax);
      p2 = _getBounds(element);
      containerAnimation._caScrollDist = p1[direction.p] - p2[direction.p];
      value = value / containerAnimation._caScrollDist * scrollerMax;
    }
    containerAnimation && containerAnimation.seek(time2);
    return containerAnimation ? value : Math.round(value);
  };
  var _prefixExp = /(webkit|moz|length|cssText|inset)/i;
  var _reparent = function _reparent2(element, parent, top, left) {
    if (element.parentNode !== parent) {
      var style = element.style, p, cs;
      if (parent === _body2) {
        element._stOrig = style.cssText;
        cs = _getComputedStyle(element);
        for (p in cs) {
          if (!+p && !_prefixExp.test(p) && cs[p] && typeof style[p] === "string" && p !== "0") {
            style[p] = cs[p];
          }
        }
        style.top = top;
        style.left = left;
      } else {
        style.cssText = element._stOrig;
      }
      gsap3.core.getCache(element).uncache = 1;
      parent.appendChild(element);
    }
  };
  var _interruptionTracker = function _interruptionTracker2(getValueFunc, initialValue, onInterrupt) {
    var last1 = initialValue, last2 = last1;
    return function(value) {
      var current = Math.round(getValueFunc());
      if (current !== last1 && current !== last2 && Math.abs(current - last1) > 3 && Math.abs(current - last2) > 3) {
        value = current;
        onInterrupt && onInterrupt();
      }
      last2 = last1;
      last1 = Math.round(value);
      return last1;
    };
  };
  var _shiftMarker = function _shiftMarker2(marker, direction, value) {
    var vars = {};
    vars[direction.p] = "+=" + value;
    gsap3.set(marker, vars);
  };
  var _getTweenCreator = function _getTweenCreator2(scroller, direction) {
    var getScroll = _getScrollFunc(scroller, direction), prop = "_scroll" + direction.p2, getTween = function getTween2(scrollTo, vars, initialValue, change1, change2) {
      var tween = getTween2.tween, onComplete = vars.onComplete, modifiers = {};
      initialValue = initialValue || getScroll();
      var checkForInterruption = _interruptionTracker(getScroll, initialValue, function() {
        tween.kill();
        getTween2.tween = 0;
      });
      change2 = change1 && change2 || 0;
      change1 = change1 || scrollTo - initialValue;
      tween && tween.kill();
      vars[prop] = scrollTo;
      vars.inherit = false;
      vars.modifiers = modifiers;
      modifiers[prop] = function() {
        return checkForInterruption(initialValue + change1 * tween.ratio + change2 * tween.ratio * tween.ratio);
      };
      vars.onUpdate = function() {
        _scrollers.cache++;
        getTween2.tween && _updateAll();
      };
      vars.onComplete = function() {
        getTween2.tween = 0;
        onComplete && onComplete.call(tween);
      };
      tween = getTween2.tween = gsap3.to(scroller, vars);
      return tween;
    };
    scroller[prop] = getScroll;
    getScroll.wheelHandler = function() {
      return getTween.tween && getTween.tween.kill() && (getTween.tween = 0);
    };
    _addListener3(scroller, "wheel", getScroll.wheelHandler);
    ScrollTrigger2.isTouch && _addListener3(scroller, "touchmove", getScroll.wheelHandler);
    return getTween;
  };
  var ScrollTrigger2 = /* @__PURE__ */ (function() {
    function ScrollTrigger3(vars, animation) {
      _coreInitted3 || ScrollTrigger3.register(gsap3) || console.warn("Please gsap.registerPlugin(ScrollTrigger)");
      _context3(this);
      this.init(vars, animation);
    }
    var _proto = ScrollTrigger3.prototype;
    _proto.init = function init5(vars, animation) {
      this.progress = this.start = 0;
      this.vars && this.kill(true, true);
      if (!_enabled) {
        this.update = this.refresh = this.kill = _passThrough3;
        return;
      }
      vars = _setDefaults3(_isString3(vars) || _isNumber3(vars) || vars.nodeType ? {
        trigger: vars
      } : vars, _defaults2);
      var _vars = vars, onUpdate = _vars.onUpdate, toggleClass = _vars.toggleClass, id3 = _vars.id, onToggle = _vars.onToggle, onRefresh = _vars.onRefresh, scrub = _vars.scrub, trigger = _vars.trigger, pin = _vars.pin, pinSpacing = _vars.pinSpacing, invalidateOnRefresh = _vars.invalidateOnRefresh, anticipatePin = _vars.anticipatePin, onScrubComplete = _vars.onScrubComplete, onSnapComplete = _vars.onSnapComplete, once = _vars.once, snap3 = _vars.snap, pinReparent = _vars.pinReparent, pinSpacer = _vars.pinSpacer, containerAnimation = _vars.containerAnimation, fastScrollEnd = _vars.fastScrollEnd, preventOverlaps = _vars.preventOverlaps, direction = vars.horizontal || vars.containerAnimation && vars.horizontal !== false ? _horizontal : _vertical, isToggle = !scrub && scrub !== 0, scroller = _getTarget(vars.scroller || _win4), scrollerCache = gsap3.core.getCache(scroller), isViewport = _isViewport3(scroller), useFixedPosition = ("pinType" in vars ? vars.pinType : _getProxyProp(scroller, "pinType") || isViewport && "fixed") === "fixed", callbacks = [vars.onEnter, vars.onLeave, vars.onEnterBack, vars.onLeaveBack], toggleActions = isToggle && vars.toggleActions.split(" "), markers = "markers" in vars ? vars.markers : _defaults2.markers, borderWidth = isViewport ? 0 : parseFloat(_getComputedStyle(scroller)["border" + direction.p2 + _Width]) || 0, self2 = this, onRefreshInit = vars.onRefreshInit && function() {
        return vars.onRefreshInit(self2);
      }, getScrollerSize = _getSizeFunc(scroller, isViewport, direction), getScrollerOffsets = _getOffsetsFunc(scroller, isViewport), lastSnap = 0, lastRefresh = 0, prevProgress = 0, scrollFunc = _getScrollFunc(scroller, direction), tweenTo, pinCache, snapFunc, scroll1, scroll2, start, end, markerStart, markerEnd, markerStartTrigger, markerEndTrigger, markerVars, executingOnRefresh, change, pinOriginalState, pinActiveState, pinState, spacer, offset, pinGetter, pinSetter, pinStart, pinChange, spacingStart, spacerState, markerStartSetter, pinMoves, markerEndSetter, cs, snap1, snap22, scrubTween, scrubSmooth, snapDurClamp, snapDelayedCall, prevScroll, prevAnimProgress, caMarkerSetter, customRevertReturn;
      self2._startClamp = self2._endClamp = false;
      self2._dir = direction;
      anticipatePin *= 45;
      self2.scroller = scroller;
      self2.scroll = containerAnimation ? containerAnimation.time.bind(containerAnimation) : scrollFunc;
      scroll1 = scrollFunc();
      self2.vars = vars;
      animation = animation || vars.animation;
      if ("refreshPriority" in vars) {
        _sort = 1;
        vars.refreshPriority === -9999 && (_primary = self2);
      }
      scrollerCache.tweenScroll = scrollerCache.tweenScroll || {
        top: _getTweenCreator(scroller, _vertical),
        left: _getTweenCreator(scroller, _horizontal)
      };
      self2.tweenTo = tweenTo = scrollerCache.tweenScroll[direction.p];
      self2.scrubDuration = function(value) {
        scrubSmooth = _isNumber3(value) && value;
        if (!scrubSmooth) {
          scrubTween && scrubTween.progress(1).kill();
          scrubTween = 0;
        } else {
          scrubTween ? scrubTween.duration(value) : scrubTween = gsap3.to(animation, {
            ease: "expo",
            totalProgress: "+=0",
            inherit: false,
            duration: scrubSmooth,
            paused: true,
            onComplete: function onComplete() {
              return onScrubComplete && onScrubComplete(self2);
            }
          });
        }
      };
      if (animation) {
        animation.vars.lazy = false;
        animation._initted && !self2.isReverted || animation.vars.immediateRender !== false && vars.immediateRender !== false && animation.duration() && animation.render(0, true, true);
        self2.animation = animation.pause();
        animation.scrollTrigger = self2;
        self2.scrubDuration(scrub);
        snap1 = 0;
        id3 || (id3 = animation.vars.id);
      }
      if (snap3) {
        if (!_isObject3(snap3) || snap3.push) {
          snap3 = {
            snapTo: snap3
          };
        }
        "scrollBehavior" in _body2.style && gsap3.set(isViewport ? [_body2, _docEl2] : scroller, {
          scrollBehavior: "auto"
        });
        _scrollers.forEach(function(o) {
          return _isFunction3(o) && o.target === (isViewport ? _doc4.scrollingElement || _docEl2 : scroller) && (o.smooth = false);
        });
        snapFunc = _isFunction3(snap3.snapTo) ? snap3.snapTo : snap3.snapTo === "labels" ? _getClosestLabel(animation) : snap3.snapTo === "labelsDirectional" ? _getLabelAtDirection(animation) : snap3.directional !== false ? function(value, st) {
          return _snapDirectional(snap3.snapTo)(value, _getTime2() - lastRefresh < 500 ? 0 : st.direction);
        } : gsap3.utils.snap(snap3.snapTo);
        snapDurClamp = snap3.duration || {
          min: 0.1,
          max: 2
        };
        snapDurClamp = _isObject3(snapDurClamp) ? _clamp4(snapDurClamp.min, snapDurClamp.max) : _clamp4(snapDurClamp, snapDurClamp);
        snapDelayedCall = gsap3.delayedCall(snap3.delay || scrubSmooth / 2 || 0.1, function() {
          var scroll3 = scrollFunc(), refreshedRecently = _getTime2() - lastRefresh < 500, tween = tweenTo.tween;
          if ((refreshedRecently || Math.abs(self2.getVelocity()) < 10) && !tween && !_pointerIsDown && lastSnap !== scroll3) {
            var progress2 = (scroll3 - start) / change, totalProgress = animation && !isToggle ? animation.totalProgress() : progress2, velocity = refreshedRecently ? 0 : (totalProgress - snap22) / (_getTime2() - _time2) * 1e3 || 0, change1 = gsap3.utils.clamp(-progress2, 1 - progress2, _abs(velocity / 2) * velocity / 0.185), naturalEnd = progress2 + (snap3.inertia === false ? 0 : change1), endValue, endScroll, _snap = snap3, onStart = _snap.onStart, _onInterrupt = _snap.onInterrupt, _onComplete = _snap.onComplete;
            endValue = snapFunc(naturalEnd, self2);
            _isNumber3(endValue) || (endValue = naturalEnd);
            endScroll = Math.max(0, Math.round(start + endValue * change));
            if (scroll3 <= end && scroll3 >= start && endScroll !== scroll3) {
              if (tween && !tween._initted && tween.data <= _abs(endScroll - scroll3)) {
                return;
              }
              if (snap3.inertia === false) {
                change1 = endValue - progress2;
              }
              tweenTo(endScroll, {
                duration: snapDurClamp(_abs(Math.max(_abs(naturalEnd - totalProgress), _abs(endValue - totalProgress)) * 0.185 / velocity / 0.05 || 0)),
                ease: snap3.ease || "power3",
                data: _abs(endScroll - scroll3),
                // record the distance so that if another snap tween occurs (conflict) we can prioritize the closest snap.
                onInterrupt: function onInterrupt() {
                  return snapDelayedCall.restart(true) && _onInterrupt && _onInterrupt(self2);
                },
                onComplete: function onComplete() {
                  self2.update();
                  lastSnap = scrollFunc();
                  if (animation && !isToggle) {
                    scrubTween ? scrubTween.resetTo("totalProgress", endValue, animation._tTime / animation._tDur) : animation.progress(endValue);
                  }
                  snap1 = snap22 = animation && !isToggle ? animation.totalProgress() : self2.progress;
                  onSnapComplete && onSnapComplete(self2);
                  _onComplete && _onComplete(self2);
                }
              }, scroll3, change1 * change, endScroll - scroll3 - change1 * change);
              onStart && onStart(self2, tweenTo.tween);
            }
          } else if (self2.isActive && lastSnap !== scroll3) {
            snapDelayedCall.restart(true);
          }
        }).pause();
      }
      id3 && (_ids[id3] = self2);
      trigger = self2.trigger = _getTarget(trigger || pin !== true && pin);
      customRevertReturn = trigger && trigger._gsap && trigger._gsap.stRevert;
      customRevertReturn && (customRevertReturn = customRevertReturn(self2));
      pin = pin === true ? trigger : _getTarget(pin);
      _isString3(toggleClass) && (toggleClass = {
        targets: trigger,
        className: toggleClass
      });
      if (pin) {
        pinSpacing === false || pinSpacing === _margin || (pinSpacing = !pinSpacing && pin.parentNode && pin.parentNode.style && _getComputedStyle(pin.parentNode).display === "flex" ? false : _padding);
        self2.pin = pin;
        pinCache = gsap3.core.getCache(pin);
        if (!pinCache.spacer) {
          if (pinSpacer) {
            pinSpacer = _getTarget(pinSpacer);
            pinSpacer && !pinSpacer.nodeType && (pinSpacer = pinSpacer.current || pinSpacer.nativeElement);
            pinCache.spacerIsNative = !!pinSpacer;
            pinSpacer && (pinCache.spacerState = _getState(pinSpacer));
          }
          pinCache.spacer = spacer = pinSpacer || _doc4.createElement("div");
          spacer.classList.add("pin-spacer");
          id3 && spacer.classList.add("pin-spacer-" + id3);
          pinCache.pinState = pinOriginalState = _getState(pin);
        } else {
          pinOriginalState = pinCache.pinState;
        }
        vars.force3D !== false && gsap3.set(pin, {
          force3D: true
        });
        self2.spacer = spacer = pinCache.spacer;
        cs = _getComputedStyle(pin);
        spacingStart = cs[pinSpacing + direction.os2];
        pinGetter = gsap3.getProperty(pin);
        pinSetter = gsap3.quickSetter(pin, direction.a, _px);
        _swapPinIn(pin, spacer, cs);
        pinState = _getState(pin);
      }
      if (markers) {
        markerVars = _isObject3(markers) ? _setDefaults3(markers, _markerDefaults) : _markerDefaults;
        markerStartTrigger = _createMarker("scroller-start", id3, scroller, direction, markerVars, 0);
        markerEndTrigger = _createMarker("scroller-end", id3, scroller, direction, markerVars, 0, markerStartTrigger);
        offset = markerStartTrigger["offset" + direction.op.d2];
        var content = _getTarget(_getProxyProp(scroller, "content") || scroller);
        markerStart = this.markerStart = _createMarker("start", id3, content, direction, markerVars, offset, 0, containerAnimation);
        markerEnd = this.markerEnd = _createMarker("end", id3, content, direction, markerVars, offset, 0, containerAnimation);
        containerAnimation && (caMarkerSetter = gsap3.quickSetter([markerStart, markerEnd], direction.a, _px));
        if (!useFixedPosition && !(_proxies.length && _getProxyProp(scroller, "fixedMarkers") === true)) {
          _makePositionable(isViewport ? _body2 : scroller);
          gsap3.set([markerStartTrigger, markerEndTrigger], {
            force3D: true
          });
          markerStartSetter = gsap3.quickSetter(markerStartTrigger, direction.a, _px);
          markerEndSetter = gsap3.quickSetter(markerEndTrigger, direction.a, _px);
        }
      }
      if (containerAnimation) {
        var oldOnUpdate = containerAnimation.vars.onUpdate, oldParams = containerAnimation.vars.onUpdateParams;
        containerAnimation.eventCallback("onUpdate", function() {
          self2.update(0, 0, 1);
          oldOnUpdate && oldOnUpdate.apply(containerAnimation, oldParams || []);
        });
      }
      self2.previous = function() {
        return _triggers[_triggers.indexOf(self2) - 1];
      };
      self2.next = function() {
        return _triggers[_triggers.indexOf(self2) + 1];
      };
      self2.revert = function(revert, temp) {
        if (!temp) {
          return self2.kill(true);
        }
        var r = revert !== false || !self2.enabled, prevRefreshing = _refreshing;
        if (r !== self2.isReverted) {
          if (r) {
            prevScroll = Math.max(scrollFunc(), self2.scroll.rec || 0);
            prevProgress = self2.progress;
            prevAnimProgress = animation && animation.progress();
          }
          markerStart && [markerStart, markerEnd, markerStartTrigger, markerEndTrigger].forEach(function(m) {
            return m.style.display = r ? "none" : "block";
          });
          if (r) {
            _refreshing = self2;
            self2.update(r);
          }
          if (pin && (!pinReparent || !self2.isActive)) {
            if (r) {
              _swapPinOut(pin, spacer, pinOriginalState);
            } else {
              _swapPinIn(pin, spacer, _getComputedStyle(pin), spacerState);
            }
          }
          r || self2.update(r);
          _refreshing = prevRefreshing;
          self2.isReverted = r;
        }
      };
      self2.refresh = function(soft, force, position, pinOffset) {
        if ((_refreshing || !self2.enabled) && !force) {
          return;
        }
        if (pin && soft && _lastScrollTime) {
          _addListener3(ScrollTrigger3, "scrollEnd", _softRefresh);
          return;
        }
        !_refreshingAll && onRefreshInit && onRefreshInit(self2);
        _refreshing = self2;
        if (tweenTo.tween && !position) {
          tweenTo.tween.kill();
          tweenTo.tween = 0;
        }
        scrubTween && scrubTween.pause();
        if (invalidateOnRefresh && animation) {
          animation.revert({
            kill: false
          }).invalidate();
          animation.getChildren && animation.getChildren(true, true, false).forEach(function(t) {
            return t.vars.immediateRender && t.render(0, true, true);
          });
        }
        self2.isReverted || self2.revert(true, true);
        self2._subPinOffset = false;
        var size = getScrollerSize(), scrollerBounds = getScrollerOffsets(), max = containerAnimation ? containerAnimation.duration() : _maxScroll(scroller, direction), isFirstRefresh = change <= 0.01 || !change, offset2 = 0, otherPinOffset = pinOffset || 0, parsedEnd = _isObject3(position) ? position.end : vars.end, parsedEndTrigger = vars.endTrigger || trigger, parsedStart = _isObject3(position) ? position.start : vars.start || (vars.start === 0 || !trigger ? 0 : pin ? "0 0" : "0 100%"), pinnedContainer = self2.pinnedContainer = vars.pinnedContainer && _getTarget(vars.pinnedContainer, self2), triggerIndex = trigger && Math.max(0, _triggers.indexOf(self2)) || 0, i = triggerIndex, cs2, bounds, scroll3, isVertical, override, curTrigger, curPin, oppositeScroll, initted, revertedPins, forcedOverflow, markerStartOffset, markerEndOffset;
        if (markers && _isObject3(position)) {
          markerStartOffset = gsap3.getProperty(markerStartTrigger, direction.p);
          markerEndOffset = gsap3.getProperty(markerEndTrigger, direction.p);
        }
        while (i-- > 0) {
          curTrigger = _triggers[i];
          curTrigger.end || curTrigger.refresh(0, 1) || (_refreshing = self2);
          curPin = curTrigger.pin;
          if (curPin && (curPin === trigger || curPin === pin || curPin === pinnedContainer) && !curTrigger.isReverted) {
            revertedPins || (revertedPins = []);
            revertedPins.unshift(curTrigger);
            curTrigger.revert(true, true);
          }
          if (curTrigger !== _triggers[i]) {
            triggerIndex--;
            i--;
          }
        }
        _isFunction3(parsedStart) && (parsedStart = parsedStart(self2));
        parsedStart = _parseClamp(parsedStart, "start", self2);
        start = _parsePosition3(parsedStart, trigger, size, direction, scrollFunc(), markerStart, markerStartTrigger, self2, scrollerBounds, borderWidth, useFixedPosition, max, containerAnimation, self2._startClamp && "_startClamp") || (pin ? -1e-3 : 0);
        _isFunction3(parsedEnd) && (parsedEnd = parsedEnd(self2));
        if (_isString3(parsedEnd) && !parsedEnd.indexOf("+=")) {
          if (~parsedEnd.indexOf(" ")) {
            parsedEnd = (_isString3(parsedStart) ? parsedStart.split(" ")[0] : "") + parsedEnd;
          } else {
            offset2 = _offsetToPx(parsedEnd.substr(2), size);
            parsedEnd = _isString3(parsedStart) ? parsedStart : (containerAnimation ? gsap3.utils.mapRange(0, containerAnimation.duration(), containerAnimation.scrollTrigger.start, containerAnimation.scrollTrigger.end, start) : start) + offset2;
            parsedEndTrigger = trigger;
          }
        }
        parsedEnd = _parseClamp(parsedEnd, "end", self2);
        end = Math.max(start, _parsePosition3(parsedEnd || (parsedEndTrigger ? "100% 0" : max), parsedEndTrigger, size, direction, scrollFunc() + offset2, markerEnd, markerEndTrigger, self2, scrollerBounds, borderWidth, useFixedPosition, max, containerAnimation, self2._endClamp && "_endClamp")) || -1e-3;
        offset2 = 0;
        i = triggerIndex;
        while (i--) {
          curTrigger = _triggers[i];
          curPin = curTrigger.pin;
          if (curPin && curTrigger.start - curTrigger._pinPush <= start && !containerAnimation && curTrigger.end > 0) {
            cs2 = curTrigger.end - (self2._startClamp ? Math.max(0, curTrigger.start) : curTrigger.start);
            if ((curPin === trigger && curTrigger.start - curTrigger._pinPush < start || curPin === pinnedContainer) && isNaN(parsedStart)) {
              offset2 += cs2 * (1 - curTrigger.progress);
            }
            curPin === pin && (otherPinOffset += cs2);
          }
        }
        start += offset2;
        end += offset2;
        self2._startClamp && (self2._startClamp += offset2);
        if (self2._endClamp && !_refreshingAll) {
          self2._endClamp = end || -1e-3;
          end = Math.min(end, _maxScroll(scroller, direction));
        }
        change = end - start || (start -= 0.01) && 1e-3;
        if (isFirstRefresh) {
          prevProgress = gsap3.utils.clamp(0, 1, gsap3.utils.normalize(start, end, prevScroll));
        }
        self2._pinPush = otherPinOffset;
        if (markerStart && offset2) {
          cs2 = {};
          cs2[direction.a] = "+=" + offset2;
          pinnedContainer && (cs2[direction.p] = "-=" + scrollFunc());
          gsap3.set([markerStart, markerEnd], cs2);
        }
        if (pin && !(_clampingMax && self2.end >= _maxScroll(scroller, direction))) {
          cs2 = _getComputedStyle(pin);
          isVertical = direction === _vertical;
          scroll3 = scrollFunc();
          pinStart = parseFloat(pinGetter(direction.a)) + otherPinOffset;
          if (!max && end > 1) {
            forcedOverflow = (isViewport ? _doc4.scrollingElement || _docEl2 : scroller).style;
            forcedOverflow = {
              style: forcedOverflow,
              value: forcedOverflow["overflow" + direction.a.toUpperCase()]
            };
            if (isViewport && _getComputedStyle(_body2)["overflow" + direction.a.toUpperCase()] !== "scroll") {
              forcedOverflow.style["overflow" + direction.a.toUpperCase()] = "scroll";
            }
          }
          _swapPinIn(pin, spacer, cs2);
          pinState = _getState(pin);
          bounds = _getBounds(pin, true);
          oppositeScroll = useFixedPosition && _getScrollFunc(scroller, isVertical ? _horizontal : _vertical)();
          if (pinSpacing) {
            spacerState = [pinSpacing + direction.os2, change + otherPinOffset + _px];
            spacerState.t = spacer;
            i = pinSpacing === _padding ? _getSize(pin, direction) + change + otherPinOffset : 0;
            if (i) {
              spacerState.push(direction.d, i + _px);
              spacer.style.flexBasis !== "auto" && (spacer.style.flexBasis = i + _px);
            }
            _setState(spacerState);
            if (pinnedContainer) {
              _triggers.forEach(function(t) {
                if (t.pin === pinnedContainer && t.vars.pinSpacing !== false) {
                  t._subPinOffset = true;
                }
              });
            }
            useFixedPosition && scrollFunc(prevScroll);
          } else {
            i = _getSize(pin, direction);
            i && spacer.style.flexBasis !== "auto" && (spacer.style.flexBasis = i + _px);
          }
          if (useFixedPosition) {
            override = {
              top: bounds.top + (isVertical ? scroll3 - start : oppositeScroll) + _px,
              left: bounds.left + (isVertical ? oppositeScroll : scroll3 - start) + _px,
              boxSizing: "border-box",
              position: "fixed"
            };
            override[_width] = override["max" + _Width] = Math.ceil(bounds.width) + _px;
            override[_height] = override["max" + _Height] = Math.ceil(bounds.height) + _px;
            override[_margin] = override[_margin + _Top] = override[_margin + _Right] = override[_margin + _Bottom] = override[_margin + _Left] = "0";
            override[_padding] = cs2[_padding];
            override[_padding + _Top] = cs2[_padding + _Top];
            override[_padding + _Right] = cs2[_padding + _Right];
            override[_padding + _Bottom] = cs2[_padding + _Bottom];
            override[_padding + _Left] = cs2[_padding + _Left];
            pinActiveState = _copyState(pinOriginalState, override, pinReparent);
            _refreshingAll && scrollFunc(0);
          }
          if (animation) {
            initted = animation._initted;
            _suppressOverwrites2(1);
            animation.render(animation.duration(), true, true);
            pinChange = pinGetter(direction.a) - pinStart + change + otherPinOffset;
            pinMoves = Math.abs(change - pinChange) > 1;
            useFixedPosition && pinMoves && pinActiveState.splice(pinActiveState.length - 2, 2);
            animation.render(0, true, true);
            initted || animation.invalidate(true);
            animation.parent || animation.totalTime(animation.totalTime());
            _suppressOverwrites2(0);
          } else {
            pinChange = change;
          }
          forcedOverflow && (forcedOverflow.value ? forcedOverflow.style["overflow" + direction.a.toUpperCase()] = forcedOverflow.value : forcedOverflow.style.removeProperty("overflow-" + direction.a));
        } else if (trigger && scrollFunc() && !containerAnimation) {
          bounds = trigger.parentNode;
          while (bounds && bounds !== _body2) {
            if (bounds._pinOffset) {
              start -= bounds._pinOffset;
              end -= bounds._pinOffset;
            }
            bounds = bounds.parentNode;
          }
        }
        revertedPins && revertedPins.forEach(function(t) {
          return t.revert(false, true);
        });
        self2.start = start;
        self2.end = end;
        scroll1 = scroll2 = _refreshingAll ? prevScroll : scrollFunc();
        if (!containerAnimation && !_refreshingAll) {
          scroll1 < prevScroll && scrollFunc(prevScroll);
          self2.scroll.rec = 0;
        }
        self2.revert(false, true);
        lastRefresh = _getTime2();
        if (snapDelayedCall) {
          lastSnap = -1;
          snapDelayedCall.restart(true);
        }
        _refreshing = 0;
        animation && isToggle && (animation._initted || prevAnimProgress) && animation.progress() !== prevAnimProgress && animation.progress(prevAnimProgress || 0, true).render(animation.time(), true, true);
        if (isFirstRefresh || prevProgress !== self2.progress || containerAnimation || invalidateOnRefresh || animation && !animation._initted) {
          animation && !isToggle && (animation._initted || prevProgress || animation.vars.immediateRender !== false) && animation.totalProgress(containerAnimation && start < -1e-3 && !prevProgress ? gsap3.utils.normalize(start, end, 0) : prevProgress, true);
          self2.progress = isFirstRefresh || (scroll1 - start) / change === prevProgress ? 0 : prevProgress;
        }
        pin && pinSpacing && (spacer._pinOffset = Math.round(self2.progress * pinChange));
        scrubTween && scrubTween.invalidate();
        if (!isNaN(markerStartOffset)) {
          markerStartOffset -= gsap3.getProperty(markerStartTrigger, direction.p);
          markerEndOffset -= gsap3.getProperty(markerEndTrigger, direction.p);
          _shiftMarker(markerStartTrigger, direction, markerStartOffset);
          _shiftMarker(markerStart, direction, markerStartOffset - (pinOffset || 0));
          _shiftMarker(markerEndTrigger, direction, markerEndOffset);
          _shiftMarker(markerEnd, direction, markerEndOffset - (pinOffset || 0));
        }
        isFirstRefresh && !_refreshingAll && self2.update();
        if (onRefresh && !_refreshingAll && !executingOnRefresh) {
          executingOnRefresh = true;
          onRefresh(self2);
          executingOnRefresh = false;
        }
      };
      self2.getVelocity = function() {
        return (scrollFunc() - scroll2) / (_getTime2() - _time2) * 1e3 || 0;
      };
      self2.endAnimation = function() {
        _endAnimation(self2.callbackAnimation);
        if (animation) {
          scrubTween ? scrubTween.progress(1) : !animation.paused() ? _endAnimation(animation, animation.reversed()) : isToggle || _endAnimation(animation, self2.direction < 0, 1);
        }
      };
      self2.labelToScroll = function(label) {
        return animation && animation.labels && (start || self2.refresh() || start) + animation.labels[label] / animation.duration() * change || 0;
      };
      self2.getTrailing = function(name) {
        var i = _triggers.indexOf(self2), a = self2.direction > 0 ? _triggers.slice(0, i).reverse() : _triggers.slice(i + 1);
        return (_isString3(name) ? a.filter(function(t) {
          return t.vars.preventOverlaps === name;
        }) : a).filter(function(t) {
          return self2.direction > 0 ? t.end <= start : t.start >= end;
        });
      };
      self2.update = function(reset, recordVelocity, forceFake) {
        if (containerAnimation && !forceFake && !reset) {
          return;
        }
        var scroll3 = _refreshingAll === true ? prevScroll : self2.scroll(), p = reset ? 0 : (scroll3 - start) / change, clipped = p < 0 ? 0 : p > 1 ? 1 : p || 0, prevProgress2 = self2.progress, isActive, wasActive, toggleState, action, stateChanged, toggled, isAtMax, isTakingAction;
        if (recordVelocity) {
          scroll2 = scroll1;
          scroll1 = containerAnimation ? scrollFunc() : scroll3;
          if (snap3) {
            snap22 = snap1;
            snap1 = animation && !isToggle ? animation.totalProgress() : clipped;
          }
        }
        if (anticipatePin && pin && !_refreshing && !_startup2 && _lastScrollTime) {
          if (!clipped && start < scroll3 + (scroll3 - scroll2) / (_getTime2() - _time2) * anticipatePin) {
            clipped = 1e-4;
          } else if (clipped === 1 && end > scroll3 + (scroll3 - scroll2) / (_getTime2() - _time2) * anticipatePin) {
            clipped = 0.9999;
          }
        }
        if (clipped !== prevProgress2 && self2.enabled) {
          isActive = self2.isActive = !!clipped && clipped < 1;
          wasActive = !!prevProgress2 && prevProgress2 < 1;
          toggled = isActive !== wasActive;
          stateChanged = toggled || !!clipped !== !!prevProgress2;
          self2.direction = clipped > prevProgress2 ? 1 : -1;
          self2.progress = clipped;
          if (stateChanged && !_refreshing) {
            toggleState = clipped && !prevProgress2 ? 0 : clipped === 1 ? 1 : prevProgress2 === 1 ? 2 : 3;
            if (isToggle) {
              action = !toggled && toggleActions[toggleState + 1] !== "none" && toggleActions[toggleState + 1] || toggleActions[toggleState];
              isTakingAction = animation && (action === "complete" || action === "reset" || action in animation);
            }
          }
          preventOverlaps && (toggled || isTakingAction) && (isTakingAction || scrub || !animation) && (_isFunction3(preventOverlaps) ? preventOverlaps(self2) : self2.getTrailing(preventOverlaps).forEach(function(t) {
            return t.endAnimation();
          }));
          if (!isToggle) {
            if (scrubTween && !_refreshing && !_startup2) {
              scrubTween._dp._time - scrubTween._start !== scrubTween._time && scrubTween.render(scrubTween._dp._time - scrubTween._start);
              if (scrubTween.resetTo) {
                scrubTween.resetTo("totalProgress", clipped, animation._tTime / animation._tDur);
              } else {
                scrubTween.vars.totalProgress = clipped;
                scrubTween.invalidate().restart();
              }
            } else if (animation) {
              animation.totalProgress(clipped, !!(_refreshing && (lastRefresh || reset)));
            }
          }
          if (pin) {
            reset && pinSpacing && (spacer.style[pinSpacing + direction.os2] = spacingStart);
            if (!useFixedPosition) {
              pinSetter(_round3(pinStart + pinChange * clipped));
            } else if (stateChanged) {
              isAtMax = !reset && clipped > prevProgress2 && end + 1 > scroll3 && scroll3 + 1 >= _maxScroll(scroller, direction);
              if (pinReparent) {
                if (!reset && (isActive || isAtMax)) {
                  var bounds = _getBounds(pin, true), _offset = scroll3 - start;
                  _reparent(pin, _body2, bounds.top + (direction === _vertical ? _offset : 0) + _px, bounds.left + (direction === _vertical ? 0 : _offset) + _px);
                } else {
                  _reparent(pin, spacer);
                }
              }
              _setState(isActive || isAtMax ? pinActiveState : pinState);
              pinMoves && clipped < 1 && isActive || pinSetter(pinStart + (clipped === 1 && !isAtMax ? pinChange : 0));
            }
          }
          snap3 && !tweenTo.tween && !_refreshing && !_startup2 && snapDelayedCall.restart(true);
          toggleClass && (toggled || once && clipped && (clipped < 1 || !_limitCallbacks)) && _toArray(toggleClass.targets).forEach(function(el) {
            return el.classList[isActive || once ? "add" : "remove"](toggleClass.className);
          });
          onUpdate && !isToggle && !reset && onUpdate(self2);
          if (stateChanged && !_refreshing) {
            if (isToggle) {
              if (isTakingAction) {
                if (action === "complete") {
                  animation.pause().totalProgress(1);
                } else if (action === "reset") {
                  animation.restart(true).pause();
                } else if (action === "restart") {
                  animation.restart(true);
                } else {
                  animation[action]();
                }
              }
              onUpdate && onUpdate(self2);
            }
            if (toggled || !_limitCallbacks) {
              onToggle && toggled && _callback3(self2, onToggle);
              callbacks[toggleState] && _callback3(self2, callbacks[toggleState]);
              once && (clipped === 1 ? self2.kill(false, 1) : callbacks[toggleState] = 0);
              if (!toggled) {
                toggleState = clipped === 1 ? 1 : 3;
                callbacks[toggleState] && _callback3(self2, callbacks[toggleState]);
              }
            }
            if (fastScrollEnd && !isActive && Math.abs(self2.getVelocity()) > (_isNumber3(fastScrollEnd) ? fastScrollEnd : 2500)) {
              _endAnimation(self2.callbackAnimation);
              scrubTween ? scrubTween.progress(1) : _endAnimation(animation, action === "reverse" ? 1 : !clipped, 1);
            }
          } else if (isToggle && onUpdate && !_refreshing) {
            onUpdate(self2);
          }
        }
        if (markerEndSetter) {
          var n = containerAnimation ? scroll3 / containerAnimation.duration() * (containerAnimation._caScrollDist || 0) : scroll3;
          markerStartSetter(n + (markerStartTrigger._isFlipped ? 1 : 0));
          markerEndSetter(n);
        }
        caMarkerSetter && caMarkerSetter(-scroll3 / containerAnimation.duration() * (containerAnimation._caScrollDist || 0));
      };
      self2.enable = function(reset, refresh) {
        if (!self2.enabled) {
          self2.enabled = true;
          _addListener3(scroller, "resize", _onResize);
          isViewport || _addListener3(scroller, "scroll", _onScroll3);
          onRefreshInit && _addListener3(ScrollTrigger3, "refreshInit", onRefreshInit);
          if (reset !== false) {
            self2.progress = prevProgress = 0;
            scroll1 = scroll2 = lastSnap = scrollFunc();
          }
          refresh !== false && self2.refresh();
        }
      };
      self2.getTween = function(snap4) {
        return snap4 && tweenTo ? tweenTo.tween : scrubTween;
      };
      self2.setPositions = function(newStart, newEnd, keepClamp, pinOffset) {
        if (containerAnimation) {
          var st = containerAnimation.scrollTrigger, duration = containerAnimation.duration(), _change = st.end - st.start;
          newStart = st.start + _change * newStart / duration;
          newEnd = st.start + _change * newEnd / duration;
        }
        self2.refresh(false, false, {
          start: _keepClamp(newStart, keepClamp && !!self2._startClamp),
          end: _keepClamp(newEnd, keepClamp && !!self2._endClamp)
        }, pinOffset);
        self2.update();
      };
      self2.adjustPinSpacing = function(amount) {
        if (spacerState && amount) {
          var i = spacerState.indexOf(direction.d) + 1;
          spacerState[i] = parseFloat(spacerState[i]) + amount + _px;
          spacerState[1] = parseFloat(spacerState[1]) + amount + _px;
          _setState(spacerState);
        }
      };
      self2.disable = function(reset, allowAnimation) {
        if (self2.enabled) {
          reset !== false && self2.revert(true, true);
          self2.enabled = self2.isActive = false;
          allowAnimation || scrubTween && scrubTween.pause();
          prevScroll = 0;
          pinCache && (pinCache.uncache = 1);
          onRefreshInit && _removeListener3(ScrollTrigger3, "refreshInit", onRefreshInit);
          if (snapDelayedCall) {
            snapDelayedCall.pause();
            tweenTo.tween && tweenTo.tween.kill() && (tweenTo.tween = 0);
          }
          if (!isViewport) {
            var i = _triggers.length;
            while (i--) {
              if (_triggers[i].scroller === scroller && _triggers[i] !== self2) {
                return;
              }
            }
            _removeListener3(scroller, "resize", _onResize);
            isViewport || _removeListener3(scroller, "scroll", _onScroll3);
          }
        }
      };
      self2.kill = function(revert, allowAnimation) {
        self2.disable(revert, allowAnimation);
        scrubTween && !allowAnimation && scrubTween.kill();
        id3 && delete _ids[id3];
        var i = _triggers.indexOf(self2);
        i >= 0 && _triggers.splice(i, 1);
        i === _i && _direction > 0 && _i--;
        i = 0;
        _triggers.forEach(function(t) {
          return t.scroller === self2.scroller && (i = 1);
        });
        i || _refreshingAll || (self2.scroll.rec = 0);
        if (animation) {
          animation.scrollTrigger = null;
          revert && animation.revert({
            kill: false
          });
          allowAnimation || animation.kill();
        }
        markerStart && [markerStart, markerEnd, markerStartTrigger, markerEndTrigger].forEach(function(m) {
          return m.parentNode && m.parentNode.removeChild(m);
        });
        _primary === self2 && (_primary = 0);
        if (pin) {
          pinCache && (pinCache.uncache = 1);
          i = 0;
          _triggers.forEach(function(t) {
            return t.pin === pin && i++;
          });
          i || (pinCache.spacer = 0);
        }
        vars.onKill && vars.onKill(self2);
      };
      _triggers.push(self2);
      self2.enable(false, false);
      customRevertReturn && customRevertReturn(self2);
      if (animation && animation.add && !change) {
        var updateFunc = self2.update;
        self2.update = function() {
          self2.update = updateFunc;
          _scrollers.cache++;
          start || end || self2.refresh();
        };
        gsap3.delayedCall(0.01, self2.update);
        change = 0.01;
        start = end = 0;
      } else {
        self2.refresh();
      }
      pin && _queueRefreshAll();
    };
    ScrollTrigger3.register = function register2(core) {
      if (!_coreInitted3) {
        gsap3 = core || _getGSAP3();
        _windowExists5() && window.document && ScrollTrigger3.enable();
        _coreInitted3 = _enabled;
      }
      return _coreInitted3;
    };
    ScrollTrigger3.defaults = function defaults3(config3) {
      if (config3) {
        for (var p in config3) {
          _defaults2[p] = config3[p];
        }
      }
      return _defaults2;
    };
    ScrollTrigger3.disable = function disable(reset, kill) {
      _enabled = 0;
      _triggers.forEach(function(trigger) {
        return trigger[kill ? "kill" : "disable"](reset);
      });
      _removeListener3(_win4, "wheel", _onScroll3);
      _removeListener3(_doc4, "scroll", _onScroll3);
      clearInterval(_syncInterval);
      _removeListener3(_doc4, "touchcancel", _passThrough3);
      _removeListener3(_body2, "touchstart", _passThrough3);
      _multiListener(_removeListener3, _doc4, "pointerdown,touchstart,mousedown", _pointerDownHandler);
      _multiListener(_removeListener3, _doc4, "pointerup,touchend,mouseup", _pointerUpHandler);
      _resizeDelay.kill();
      _iterateAutoRefresh(_removeListener3);
      for (var i = 0; i < _scrollers.length; i += 3) {
        _wheelListener(_removeListener3, _scrollers[i], _scrollers[i + 1]);
        _wheelListener(_removeListener3, _scrollers[i], _scrollers[i + 2]);
      }
    };
    ScrollTrigger3.enable = function enable() {
      _win4 = window;
      _doc4 = document;
      _docEl2 = _doc4.documentElement;
      _body2 = _doc4.body;
      if (gsap3) {
        _toArray = gsap3.utils.toArray;
        _clamp4 = gsap3.utils.clamp;
        _context3 = gsap3.core.context || _passThrough3;
        _suppressOverwrites2 = gsap3.core.suppressOverwrites || _passThrough3;
        _scrollRestoration = _win4.history.scrollRestoration || "auto";
        _lastScroll = _win4.pageYOffset || 0;
        gsap3.core.globals("ScrollTrigger", ScrollTrigger3);
        if (_body2) {
          _enabled = 1;
          _div100vh = document.createElement("div");
          _div100vh.style.height = "100vh";
          _div100vh.style.position = "absolute";
          _refresh100vh();
          _rafBugFix();
          Observer.register(gsap3);
          ScrollTrigger3.isTouch = Observer.isTouch;
          _fixIOSBug = Observer.isTouch && /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent);
          _ignoreMobileResize = Observer.isTouch === 1;
          _addListener3(_win4, "wheel", _onScroll3);
          _root2 = [_win4, _doc4, _docEl2, _body2];
          if (gsap3.matchMedia) {
            ScrollTrigger3.matchMedia = function(vars) {
              var mm = gsap3.matchMedia(), p;
              for (p in vars) {
                mm.add(p, vars[p]);
              }
              return mm;
            };
            gsap3.addEventListener("matchMediaInit", function() {
              return _revertAll();
            });
            gsap3.addEventListener("matchMediaRevert", function() {
              return _revertRecorded();
            });
            gsap3.addEventListener("matchMedia", function() {
              _refreshAll(0, 1);
              _dispatch3("matchMedia");
            });
            gsap3.matchMedia().add("(orientation: portrait)", function() {
              _setBaseDimensions();
              return _setBaseDimensions;
            });
          } else {
            console.warn("Requires GSAP 3.11.0 or later");
          }
          _setBaseDimensions();
          _addListener3(_doc4, "scroll", _onScroll3);
          var bodyHasStyle = _body2.hasAttribute("style"), bodyStyle = _body2.style, border = bodyStyle.borderTopStyle, AnimationProto = gsap3.core.Animation.prototype, bounds, i;
          AnimationProto.revert || Object.defineProperty(AnimationProto, "revert", {
            value: function value() {
              return this.time(-0.01, true);
            }
          });
          bodyStyle.borderTopStyle = "solid";
          bounds = _getBounds(_body2);
          _vertical.m = Math.round(bounds.top + _vertical.sc()) || 0;
          _horizontal.m = Math.round(bounds.left + _horizontal.sc()) || 0;
          border ? bodyStyle.borderTopStyle = border : bodyStyle.removeProperty("border-top-style");
          if (!bodyHasStyle) {
            _body2.setAttribute("style", "");
            _body2.removeAttribute("style");
          }
          _syncInterval = setInterval(_sync, 250);
          gsap3.delayedCall(0.5, function() {
            return _startup2 = 0;
          });
          _addListener3(_doc4, "touchcancel", _passThrough3);
          _addListener3(_body2, "touchstart", _passThrough3);
          _multiListener(_addListener3, _doc4, "pointerdown,touchstart,mousedown", _pointerDownHandler);
          _multiListener(_addListener3, _doc4, "pointerup,touchend,mouseup", _pointerUpHandler);
          _transformProp2 = gsap3.utils.checkPrefix("transform");
          _stateProps.push(_transformProp2);
          _coreInitted3 = _getTime2();
          _resizeDelay = gsap3.delayedCall(0.2, _refreshAll).pause();
          _autoRefresh = [_doc4, "visibilitychange", function() {
            var w = _win4.innerWidth, h = _win4.innerHeight;
            if (_doc4.hidden) {
              _prevWidth = w;
              _prevHeight = h;
            } else if (_prevWidth !== w || _prevHeight !== h) {
              _onResize();
            }
          }, _doc4, "DOMContentLoaded", _refreshAll, _win4, "load", _refreshAll, _win4, "resize", _onResize];
          _iterateAutoRefresh(_addListener3);
          _triggers.forEach(function(trigger) {
            return trigger.enable(0, 1);
          });
          for (i = 0; i < _scrollers.length; i += 3) {
            _wheelListener(_removeListener3, _scrollers[i], _scrollers[i + 1]);
            _wheelListener(_removeListener3, _scrollers[i], _scrollers[i + 2]);
          }
        }
      }
    };
    ScrollTrigger3.config = function config3(vars) {
      "limitCallbacks" in vars && (_limitCallbacks = !!vars.limitCallbacks);
      var ms = vars.syncInterval;
      ms && clearInterval(_syncInterval) || (_syncInterval = ms) && setInterval(_sync, ms);
      "ignoreMobileResize" in vars && (_ignoreMobileResize = ScrollTrigger3.isTouch === 1 && vars.ignoreMobileResize);
      if ("autoRefreshEvents" in vars) {
        _iterateAutoRefresh(_removeListener3) || _iterateAutoRefresh(_addListener3, vars.autoRefreshEvents || "none");
        _ignoreResize = (vars.autoRefreshEvents + "").indexOf("resize") === -1;
      }
    };
    ScrollTrigger3.scrollerProxy = function scrollerProxy(target, vars) {
      var t = _getTarget(target), i = _scrollers.indexOf(t), isViewport = _isViewport3(t);
      if (~i) {
        _scrollers.splice(i, isViewport ? 6 : 2);
      }
      if (vars) {
        isViewport ? _proxies.unshift(_win4, vars, _body2, vars, _docEl2, vars) : _proxies.unshift(t, vars);
      }
    };
    ScrollTrigger3.clearMatchMedia = function clearMatchMedia(query) {
      _triggers.forEach(function(t) {
        return t._ctx && t._ctx.query === query && t._ctx.kill(true, true);
      });
    };
    ScrollTrigger3.isInViewport = function isInViewport(element, ratio, horizontal) {
      var bounds = (_isString3(element) ? _getTarget(element) : element).getBoundingClientRect(), offset = bounds[horizontal ? _width : _height] * ratio || 0;
      return horizontal ? bounds.right - offset > 0 && bounds.left + offset < _win4.innerWidth : bounds.bottom - offset > 0 && bounds.top + offset < _win4.innerHeight;
    };
    ScrollTrigger3.positionInViewport = function positionInViewport(element, referencePoint, horizontal) {
      _isString3(element) && (element = _getTarget(element));
      var bounds = element.getBoundingClientRect(), size = bounds[horizontal ? _width : _height], offset = referencePoint == null ? size / 2 : referencePoint in _keywords ? _keywords[referencePoint] * size : ~referencePoint.indexOf("%") ? parseFloat(referencePoint) * size / 100 : parseFloat(referencePoint) || 0;
      return horizontal ? (bounds.left + offset) / _win4.innerWidth : (bounds.top + offset) / _win4.innerHeight;
    };
    ScrollTrigger3.killAll = function killAll(allowListeners) {
      _triggers.slice(0).forEach(function(t) {
        return t.vars.id !== "ScrollSmoother" && t.kill();
      });
      if (allowListeners !== true) {
        var listeners = _listeners2.killAll || [];
        _listeners2 = {};
        listeners.forEach(function(f) {
          return f();
        });
      }
    };
    return ScrollTrigger3;
  })();
  ScrollTrigger2.version = "3.13.0";
  ScrollTrigger2.saveStyles = function(targets) {
    return targets ? _toArray(targets).forEach(function(target) {
      if (target && target.style) {
        var i = _savedStyles.indexOf(target);
        i >= 0 && _savedStyles.splice(i, 5);
        _savedStyles.push(target, target.style.cssText, target.getBBox && target.getAttribute("transform"), gsap3.core.getCache(target), _context3());
      }
    }) : _savedStyles;
  };
  ScrollTrigger2.revert = function(soft, media) {
    return _revertAll(!soft, media);
  };
  ScrollTrigger2.create = function(vars, animation) {
    return new ScrollTrigger2(vars, animation);
  };
  ScrollTrigger2.refresh = function(safe) {
    return safe ? _onResize(true) : (_coreInitted3 || ScrollTrigger2.register()) && _refreshAll(true);
  };
  ScrollTrigger2.update = function(force) {
    return ++_scrollers.cache && _updateAll(force === true ? 2 : 0);
  };
  ScrollTrigger2.clearScrollMemory = _clearScrollMemory;
  ScrollTrigger2.maxScroll = function(element, horizontal) {
    return _maxScroll(element, horizontal ? _horizontal : _vertical);
  };
  ScrollTrigger2.getScrollFunc = function(element, horizontal) {
    return _getScrollFunc(_getTarget(element), horizontal ? _horizontal : _vertical);
  };
  ScrollTrigger2.getById = function(id3) {
    return _ids[id3];
  };
  ScrollTrigger2.getAll = function() {
    return _triggers.filter(function(t) {
      return t.vars.id !== "ScrollSmoother";
    });
  };
  ScrollTrigger2.isScrolling = function() {
    return !!_lastScrollTime;
  };
  ScrollTrigger2.snapDirectional = _snapDirectional;
  ScrollTrigger2.addEventListener = function(type, callback) {
    var a = _listeners2[type] || (_listeners2[type] = []);
    ~a.indexOf(callback) || a.push(callback);
  };
  ScrollTrigger2.removeEventListener = function(type, callback) {
    var a = _listeners2[type], i = a && a.indexOf(callback);
    i >= 0 && a.splice(i, 1);
  };
  ScrollTrigger2.batch = function(targets, vars) {
    var result = [], varsCopy = {}, interval = vars.interval || 0.016, batchMax = vars.batchMax || 1e9, proxyCallback = function proxyCallback2(type, callback) {
      var elements = [], triggers = [], delay2 = gsap3.delayedCall(interval, function() {
        callback(elements, triggers);
        elements = [];
        triggers = [];
      }).pause();
      return function(self2) {
        elements.length || delay2.restart(true);
        elements.push(self2.trigger);
        triggers.push(self2);
        batchMax <= elements.length && delay2.progress(1);
      };
    }, p;
    for (p in vars) {
      varsCopy[p] = p.substr(0, 2) === "on" && _isFunction3(vars[p]) && p !== "onRefreshInit" ? proxyCallback(p, vars[p]) : vars[p];
    }
    if (_isFunction3(batchMax)) {
      batchMax = batchMax();
      _addListener3(ScrollTrigger2, "refresh", function() {
        return batchMax = vars.batchMax();
      });
    }
    _toArray(targets).forEach(function(target) {
      var config3 = {};
      for (p in varsCopy) {
        config3[p] = varsCopy[p];
      }
      config3.trigger = target;
      result.push(ScrollTrigger2.create(config3));
    });
    return result;
  };
  var _clampScrollAndGetDurationMultiplier = function _clampScrollAndGetDurationMultiplier2(scrollFunc, current, end, max) {
    current > max ? scrollFunc(max) : current < 0 && scrollFunc(0);
    return end > max ? (max - current) / (end - current) : end < 0 ? current / (current - end) : 1;
  };
  var _allowNativePanning = function _allowNativePanning2(target, direction) {
    if (direction === true) {
      target.style.removeProperty("touch-action");
    } else {
      target.style.touchAction = direction === true ? "auto" : direction ? "pan-" + direction + (Observer.isTouch ? " pinch-zoom" : "") : "none";
    }
    target === _docEl2 && _allowNativePanning2(_body2, direction);
  };
  var _overflow = {
    auto: 1,
    scroll: 1
  };
  var _nestedScroll = function _nestedScroll2(_ref5) {
    var event = _ref5.event, target = _ref5.target, axis = _ref5.axis;
    var node = (event.changedTouches ? event.changedTouches[0] : event).target, cache = node._gsap || gsap3.core.getCache(node), time2 = _getTime2(), cs;
    if (!cache._isScrollT || time2 - cache._isScrollT > 2e3) {
      while (node && node !== _body2 && (node.scrollHeight <= node.clientHeight && node.scrollWidth <= node.clientWidth || !(_overflow[(cs = _getComputedStyle(node)).overflowY] || _overflow[cs.overflowX]))) {
        node = node.parentNode;
      }
      cache._isScroll = node && node !== target && !_isViewport3(node) && (_overflow[(cs = _getComputedStyle(node)).overflowY] || _overflow[cs.overflowX]);
      cache._isScrollT = time2;
    }
    if (cache._isScroll || axis === "x") {
      event.stopPropagation();
      event._gsapAllow = true;
    }
  };
  var _inputObserver = function _inputObserver2(target, type, inputs, nested) {
    return Observer.create({
      target,
      capture: true,
      debounce: false,
      lockAxis: true,
      type,
      onWheel: nested = nested && _nestedScroll,
      onPress: nested,
      onDrag: nested,
      onScroll: nested,
      onEnable: function onEnable() {
        return inputs && _addListener3(_doc4, Observer.eventTypes[0], _captureInputs, false, true);
      },
      onDisable: function onDisable() {
        return _removeListener3(_doc4, Observer.eventTypes[0], _captureInputs, true);
      }
    });
  };
  var _inputExp = /(input|label|select|textarea)/i;
  var _inputIsFocused;
  var _captureInputs = function _captureInputs2(e) {
    var isInput = _inputExp.test(e.target.tagName);
    if (isInput || _inputIsFocused) {
      e._gsapAllow = true;
      _inputIsFocused = isInput;
    }
  };
  var _getScrollNormalizer = function _getScrollNormalizer2(vars) {
    _isObject3(vars) || (vars = {});
    vars.preventDefault = vars.isNormalizer = vars.allowClicks = true;
    vars.type || (vars.type = "wheel,touch");
    vars.debounce = !!vars.debounce;
    vars.id = vars.id || "normalizer";
    var _vars2 = vars, normalizeScrollX = _vars2.normalizeScrollX, momentum = _vars2.momentum, allowNestedScroll = _vars2.allowNestedScroll, onRelease = _vars2.onRelease, self2, maxY, target = _getTarget(vars.target) || _docEl2, smoother = gsap3.core.globals().ScrollSmoother, smootherInstance = smoother && smoother.get(), content = _fixIOSBug && (vars.content && _getTarget(vars.content) || smootherInstance && vars.content !== false && !smootherInstance.smooth() && smootherInstance.content()), scrollFuncY = _getScrollFunc(target, _vertical), scrollFuncX = _getScrollFunc(target, _horizontal), scale2 = 1, initialScale = (Observer.isTouch && _win4.visualViewport ? _win4.visualViewport.scale * _win4.visualViewport.width : _win4.outerWidth) / _win4.innerWidth, wheelRefresh = 0, resolveMomentumDuration = _isFunction3(momentum) ? function() {
      return momentum(self2);
    } : function() {
      return momentum || 2.8;
    }, lastRefreshID, skipTouchMove, inputObserver = _inputObserver(target, vars.type, true, allowNestedScroll), resumeTouchMove = function resumeTouchMove2() {
      return skipTouchMove = false;
    }, scrollClampX = _passThrough3, scrollClampY = _passThrough3, updateClamps = function updateClamps2() {
      maxY = _maxScroll(target, _vertical);
      scrollClampY = _clamp4(_fixIOSBug ? 1 : 0, maxY);
      normalizeScrollX && (scrollClampX = _clamp4(0, _maxScroll(target, _horizontal)));
      lastRefreshID = _refreshID;
    }, removeContentOffset = function removeContentOffset2() {
      content._gsap.y = _round3(parseFloat(content._gsap.y) + scrollFuncY.offset) + "px";
      content.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + parseFloat(content._gsap.y) + ", 0, 1)";
      scrollFuncY.offset = scrollFuncY.cacheID = 0;
    }, ignoreDrag = function ignoreDrag2() {
      if (skipTouchMove) {
        requestAnimationFrame(resumeTouchMove);
        var offset = _round3(self2.deltaY / 2), scroll2 = scrollClampY(scrollFuncY.v - offset);
        if (content && scroll2 !== scrollFuncY.v + scrollFuncY.offset) {
          scrollFuncY.offset = scroll2 - scrollFuncY.v;
          var y = _round3((parseFloat(content && content._gsap.y) || 0) - scrollFuncY.offset);
          content.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + y + ", 0, 1)";
          content._gsap.y = y + "px";
          scrollFuncY.cacheID = _scrollers.cache;
          _updateAll();
        }
        return true;
      }
      scrollFuncY.offset && removeContentOffset();
      skipTouchMove = true;
    }, tween, startScrollX, startScrollY, onStopDelayedCall, onResize = function onResize2() {
      updateClamps();
      if (tween.isActive() && tween.vars.scrollY > maxY) {
        scrollFuncY() > maxY ? tween.progress(1) && scrollFuncY(maxY) : tween.resetTo("scrollY", maxY);
      }
    };
    content && gsap3.set(content, {
      y: "+=0"
    });
    vars.ignoreCheck = function(e) {
      return _fixIOSBug && e.type === "touchmove" && ignoreDrag(e) || scale2 > 1.05 && e.type !== "touchstart" || self2.isGesturing || e.touches && e.touches.length > 1;
    };
    vars.onPress = function() {
      skipTouchMove = false;
      var prevScale = scale2;
      scale2 = _round3((_win4.visualViewport && _win4.visualViewport.scale || 1) / initialScale);
      tween.pause();
      prevScale !== scale2 && _allowNativePanning(target, scale2 > 1.01 ? true : normalizeScrollX ? false : "x");
      startScrollX = scrollFuncX();
      startScrollY = scrollFuncY();
      updateClamps();
      lastRefreshID = _refreshID;
    };
    vars.onRelease = vars.onGestureStart = function(self3, wasDragging) {
      scrollFuncY.offset && removeContentOffset();
      if (!wasDragging) {
        onStopDelayedCall.restart(true);
      } else {
        _scrollers.cache++;
        var dur = resolveMomentumDuration(), currentScroll, endScroll;
        if (normalizeScrollX) {
          currentScroll = scrollFuncX();
          endScroll = currentScroll + dur * 0.05 * -self3.velocityX / 0.227;
          dur *= _clampScrollAndGetDurationMultiplier(scrollFuncX, currentScroll, endScroll, _maxScroll(target, _horizontal));
          tween.vars.scrollX = scrollClampX(endScroll);
        }
        currentScroll = scrollFuncY();
        endScroll = currentScroll + dur * 0.05 * -self3.velocityY / 0.227;
        dur *= _clampScrollAndGetDurationMultiplier(scrollFuncY, currentScroll, endScroll, _maxScroll(target, _vertical));
        tween.vars.scrollY = scrollClampY(endScroll);
        tween.invalidate().duration(dur).play(0.01);
        if (_fixIOSBug && tween.vars.scrollY >= maxY || currentScroll >= maxY - 1) {
          gsap3.to({}, {
            onUpdate: onResize,
            duration: dur
          });
        }
      }
      onRelease && onRelease(self3);
    };
    vars.onWheel = function() {
      tween._ts && tween.pause();
      if (_getTime2() - wheelRefresh > 1e3) {
        lastRefreshID = 0;
        wheelRefresh = _getTime2();
      }
    };
    vars.onChange = function(self3, dx, dy, xArray, yArray) {
      _refreshID !== lastRefreshID && updateClamps();
      dx && normalizeScrollX && scrollFuncX(scrollClampX(xArray[2] === dx ? startScrollX + (self3.startX - self3.x) : scrollFuncX() + dx - xArray[1]));
      if (dy) {
        scrollFuncY.offset && removeContentOffset();
        var isTouch = yArray[2] === dy, y = isTouch ? startScrollY + self3.startY - self3.y : scrollFuncY() + dy - yArray[1], yClamped = scrollClampY(y);
        isTouch && y !== yClamped && (startScrollY += yClamped - y);
        scrollFuncY(yClamped);
      }
      (dy || dx) && _updateAll();
    };
    vars.onEnable = function() {
      _allowNativePanning(target, normalizeScrollX ? false : "x");
      ScrollTrigger2.addEventListener("refresh", onResize);
      _addListener3(_win4, "resize", onResize);
      if (scrollFuncY.smooth) {
        scrollFuncY.target.style.scrollBehavior = "auto";
        scrollFuncY.smooth = scrollFuncX.smooth = false;
      }
      inputObserver.enable();
    };
    vars.onDisable = function() {
      _allowNativePanning(target, true);
      _removeListener3(_win4, "resize", onResize);
      ScrollTrigger2.removeEventListener("refresh", onResize);
      inputObserver.kill();
    };
    vars.lockAxis = vars.lockAxis !== false;
    self2 = new Observer(vars);
    self2.iOS = _fixIOSBug;
    _fixIOSBug && !scrollFuncY() && scrollFuncY(1);
    _fixIOSBug && gsap3.ticker.add(_passThrough3);
    onStopDelayedCall = self2._dc;
    tween = gsap3.to(self2, {
      ease: "power4",
      paused: true,
      inherit: false,
      scrollX: normalizeScrollX ? "+=0.1" : "+=0",
      scrollY: "+=0.1",
      modifiers: {
        scrollY: _interruptionTracker(scrollFuncY, scrollFuncY(), function() {
          return tween.pause();
        })
      },
      onUpdate: _updateAll,
      onComplete: onStopDelayedCall.vars.onComplete
    });
    return self2;
  };
  ScrollTrigger2.sort = function(func) {
    if (_isFunction3(func)) {
      return _triggers.sort(func);
    }
    var scroll2 = _win4.pageYOffset || 0;
    ScrollTrigger2.getAll().forEach(function(t) {
      return t._sortY = t.trigger ? scroll2 + t.trigger.getBoundingClientRect().top : t.start + _win4.innerHeight;
    });
    return _triggers.sort(func || function(a, b) {
      return (a.vars.refreshPriority || 0) * -1e6 + (a.vars.containerAnimation ? 1e6 : a._sortY) - ((b.vars.containerAnimation ? 1e6 : b._sortY) + (b.vars.refreshPriority || 0) * -1e6);
    });
  };
  ScrollTrigger2.observe = function(vars) {
    return new Observer(vars);
  };
  ScrollTrigger2.normalizeScroll = function(vars) {
    if (typeof vars === "undefined") {
      return _normalizer2;
    }
    if (vars === true && _normalizer2) {
      return _normalizer2.enable();
    }
    if (vars === false) {
      _normalizer2 && _normalizer2.kill();
      _normalizer2 = vars;
      return;
    }
    var normalizer = vars instanceof Observer ? vars : _getScrollNormalizer(vars);
    _normalizer2 && _normalizer2.target === normalizer.target && _normalizer2.kill();
    _isViewport3(normalizer.target) && (_normalizer2 = normalizer);
    return normalizer;
  };
  ScrollTrigger2.core = {
    // smaller file size way to leverage in ScrollSmoother and Observer
    _getVelocityProp,
    _inputObserver,
    _scrollers,
    _proxies,
    bridge: {
      // when normalizeScroll sets the scroll position (ss = setScroll)
      ss: function ss() {
        _lastScrollTime || _dispatch3("scrollStart");
        _lastScrollTime = _getTime2();
      },
      // a way to get the _refreshing value in Observer
      ref: function ref() {
        return _refreshing;
      }
    }
  };
  _getGSAP3() && gsap3.registerPlugin(ScrollTrigger2);

  // node_modules/gsap/SplitText.js
  var gsap4;
  var _fonts;
  var _coreInitted4;
  var _initIfNecessary = () => _coreInitted4 || SplitText.register(window.gsap);
  var _charSegmenter = typeof Intl !== "undefined" ? new Intl.Segmenter() : 0;
  var _toArray2 = (r) => typeof r === "string" ? _toArray2(document.querySelectorAll(r)) : "length" in r ? Array.from(r) : [r];
  var _elements = (targets) => _toArray2(targets).filter((e) => e instanceof HTMLElement);
  var _emptyArray3 = [];
  var _context4 = function() {
  };
  var _spacesRegEx = /\s+/g;
  var _emojiSafeRegEx = new RegExp("\\p{RI}\\p{RI}|\\p{Emoji}(\\p{EMod}|\\u{FE0F}\\u{20E3}?|[\\u{E0020}-\\u{E007E}]+\\u{E007F})?(\\u{200D}\\p{Emoji}(\\p{EMod}|\\u{FE0F}\\u{20E3}?|[\\u{E0020}-\\u{E007E}]+\\u{E007F})?)*|.", "gu");
  var _emptyBounds = { left: 0, top: 0, width: 0, height: 0 };
  var _stretchToFitSpecialChars = (collection, specialCharsRegEx) => {
    if (specialCharsRegEx) {
      let charsFound = new Set(collection.join("").match(specialCharsRegEx) || _emptyArray3), i = collection.length, slots, word, char, combined;
      if (charsFound.size) {
        while (--i > -1) {
          word = collection[i];
          for (char of charsFound) {
            if (char.startsWith(word) && char.length > word.length) {
              slots = 0;
              combined = word;
              while (char.startsWith(combined += collection[i + ++slots]) && combined.length < char.length) {
              }
              if (slots && combined.length === char.length) {
                collection[i] = char;
                collection.splice(i + 1, slots);
                break;
              }
            }
          }
        }
      }
    }
    return collection;
  };
  var _disallowInline = (element) => window.getComputedStyle(element).display === "inline" && (element.style.display = "inline-block");
  var _insertNodeBefore = (newChild, parent, existingChild) => parent.insertBefore(typeof newChild === "string" ? document.createTextNode(newChild) : newChild, existingChild);
  var _getWrapper = (type, config3, collection) => {
    let className = config3[type + "sClass"] || "", { tag = "div", aria = "auto", propIndex = false } = config3, display = type === "line" ? "block" : "inline-block", incrementClass = className.indexOf("++") > -1, wrapper = (text) => {
      let el = document.createElement(tag), i = collection.length + 1;
      className && (el.className = className + (incrementClass ? " " + className + i : ""));
      propIndex && el.style.setProperty("--" + type, i + "");
      aria !== "none" && el.setAttribute("aria-hidden", "true");
      if (tag !== "span") {
        el.style.position = "relative";
        el.style.display = display;
      }
      el.textContent = text;
      collection.push(el);
      return el;
    };
    incrementClass && (className = className.replace("++", ""));
    wrapper.collection = collection;
    return wrapper;
  };
  var _getLineWrapper = (element, nodes, config3, collection) => {
    let lineWrapper = _getWrapper("line", config3, collection), textAlign = window.getComputedStyle(element).textAlign || "left";
    return (startIndex, endIndex) => {
      let newLine = lineWrapper("");
      newLine.style.textAlign = textAlign;
      element.insertBefore(newLine, nodes[startIndex]);
      for (; startIndex < endIndex; startIndex++) {
        newLine.appendChild(nodes[startIndex]);
      }
      newLine.normalize();
    };
  };
  var _splitWordsAndCharsRecursively = (element, config3, wordWrapper, charWrapper, prepForCharsOnly, deepSlice, ignore, charSplitRegEx, specialCharsRegEx, isNested) => {
    var _a;
    let nodes = Array.from(element.childNodes), i = 0, { wordDelimiter, reduceWhiteSpace = true, prepareText } = config3, elementBounds = element.getBoundingClientRect(), lastBounds = elementBounds, isPreformatted = !reduceWhiteSpace && window.getComputedStyle(element).whiteSpace.substring(0, 3) === "pre", ignoredPreviousSibling = 0, wordsCollection = wordWrapper.collection, wordDelimIsNotSpace, wordDelimString, wordDelimSplitter, curNode, words, curWordEl, startsWithSpace, endsWithSpace, j, bounds, curWordChars, clonedNode, curSubNode, tempSubNode, curTextContent, wordText, lastWordText, k;
    if (typeof wordDelimiter === "object") {
      wordDelimSplitter = wordDelimiter.delimiter || wordDelimiter;
      wordDelimString = wordDelimiter.replaceWith || "";
    } else {
      wordDelimString = wordDelimiter === "" ? "" : wordDelimiter || " ";
    }
    wordDelimIsNotSpace = wordDelimString !== " ";
    for (; i < nodes.length; i++) {
      curNode = nodes[i];
      if (curNode.nodeType === 3) {
        curTextContent = curNode.textContent || "";
        if (reduceWhiteSpace) {
          curTextContent = curTextContent.replace(_spacesRegEx, " ");
        } else if (isPreformatted) {
          curTextContent = curTextContent.replace(/\n/g, wordDelimString + "\n");
        }
        prepareText && (curTextContent = prepareText(curTextContent, element));
        curNode.textContent = curTextContent;
        words = wordDelimString || wordDelimSplitter ? curTextContent.split(wordDelimSplitter || wordDelimString) : curTextContent.match(charSplitRegEx) || _emptyArray3;
        lastWordText = words[words.length - 1];
        endsWithSpace = wordDelimIsNotSpace ? lastWordText.slice(-1) === " " : !lastWordText;
        lastWordText || words.pop();
        lastBounds = elementBounds;
        startsWithSpace = wordDelimIsNotSpace ? words[0].charAt(0) === " " : !words[0];
        startsWithSpace && _insertNodeBefore(" ", element, curNode);
        words[0] || words.shift();
        _stretchToFitSpecialChars(words, specialCharsRegEx);
        deepSlice && isNested || (curNode.textContent = "");
        for (j = 1; j <= words.length; j++) {
          wordText = words[j - 1];
          if (!reduceWhiteSpace && isPreformatted && wordText.charAt(0) === "\n") {
            (_a = curNode.previousSibling) == null ? void 0 : _a.remove();
            _insertNodeBefore(document.createElement("br"), element, curNode);
            wordText = wordText.slice(1);
          }
          if (!reduceWhiteSpace && wordText === "") {
            _insertNodeBefore(wordDelimString, element, curNode);
          } else if (wordText === " ") {
            element.insertBefore(document.createTextNode(" "), curNode);
          } else {
            wordDelimIsNotSpace && wordText.charAt(0) === " " && _insertNodeBefore(" ", element, curNode);
            if (ignoredPreviousSibling && j === 1 && !startsWithSpace && wordsCollection.indexOf(ignoredPreviousSibling.parentNode) > -1) {
              curWordEl = wordsCollection[wordsCollection.length - 1];
              curWordEl.appendChild(document.createTextNode(charWrapper ? "" : wordText));
            } else {
              curWordEl = wordWrapper(charWrapper ? "" : wordText);
              _insertNodeBefore(curWordEl, element, curNode);
              ignoredPreviousSibling && j === 1 && !startsWithSpace && curWordEl.insertBefore(ignoredPreviousSibling, curWordEl.firstChild);
            }
            if (charWrapper) {
              curWordChars = _charSegmenter ? _stretchToFitSpecialChars([..._charSegmenter.segment(wordText)].map((s) => s.segment), specialCharsRegEx) : wordText.match(charSplitRegEx) || _emptyArray3;
              for (k = 0; k < curWordChars.length; k++) {
                curWordEl.appendChild(curWordChars[k] === " " ? document.createTextNode(" ") : charWrapper(curWordChars[k]));
              }
            }
            if (deepSlice && isNested) {
              curTextContent = curNode.textContent = curTextContent.substring(wordText.length + 1, curTextContent.length);
              bounds = curWordEl.getBoundingClientRect();
              if (bounds.top > lastBounds.top && bounds.left <= lastBounds.left) {
                clonedNode = element.cloneNode();
                curSubNode = element.childNodes[0];
                while (curSubNode && curSubNode !== curWordEl) {
                  tempSubNode = curSubNode;
                  curSubNode = curSubNode.nextSibling;
                  clonedNode.appendChild(tempSubNode);
                }
                element.parentNode.insertBefore(clonedNode, element);
                prepForCharsOnly && _disallowInline(clonedNode);
              }
              lastBounds = bounds;
            }
            if (j < words.length || endsWithSpace) {
              _insertNodeBefore(j >= words.length ? " " : wordDelimIsNotSpace && wordText.slice(-1) === " " ? " " + wordDelimString : wordDelimString, element, curNode);
            }
          }
        }
        element.removeChild(curNode);
        ignoredPreviousSibling = 0;
      } else if (curNode.nodeType === 1) {
        if (ignore && ignore.indexOf(curNode) > -1) {
          wordsCollection.indexOf(curNode.previousSibling) > -1 && wordsCollection[wordsCollection.length - 1].appendChild(curNode);
          ignoredPreviousSibling = curNode;
        } else {
          _splitWordsAndCharsRecursively(curNode, config3, wordWrapper, charWrapper, prepForCharsOnly, deepSlice, ignore, charSplitRegEx, specialCharsRegEx, true);
          ignoredPreviousSibling = 0;
        }
        prepForCharsOnly && _disallowInline(curNode);
      }
    }
  };
  var _SplitText = class _SplitText2 {
    constructor(elements, config3) {
      this.isSplit = false;
      _initIfNecessary();
      this.elements = _elements(elements);
      this.chars = [];
      this.words = [];
      this.lines = [];
      this.masks = [];
      this.vars = config3;
      this._split = () => this.isSplit && this.split(this.vars);
      let orig = [], timerId, checkWidths = () => {
        let i = orig.length, o;
        while (i--) {
          o = orig[i];
          let w = o.element.offsetWidth;
          if (w !== o.width) {
            o.width = w;
            this._split();
            return;
          }
        }
      };
      this._data = { orig, obs: typeof ResizeObserver !== "undefined" && new ResizeObserver(() => {
        clearTimeout(timerId);
        timerId = setTimeout(checkWidths, 200);
      }) };
      _context4(this);
      this.split(config3);
    }
    split(config3) {
      this.isSplit && this.revert();
      this.vars = config3 = config3 || this.vars || {};
      let { type = "chars,words,lines", aria = "auto", deepSlice = true, smartWrap, onSplit, autoSplit = false, specialChars, mask } = this.vars, splitLines = type.indexOf("lines") > -1, splitCharacters = type.indexOf("chars") > -1, splitWords = type.indexOf("words") > -1, onlySplitCharacters = splitCharacters && !splitWords && !splitLines, specialCharsRegEx = specialChars && ("push" in specialChars ? new RegExp("(?:" + specialChars.join("|") + ")", "gu") : specialChars), finalCharSplitRegEx = specialCharsRegEx ? new RegExp(specialCharsRegEx.source + "|" + _emojiSafeRegEx.source, "gu") : _emojiSafeRegEx, ignore = !!config3.ignore && _elements(config3.ignore), { orig, animTime, obs } = this._data, onSplitResult;
      if (splitCharacters || splitWords || splitLines) {
        this.elements.forEach((element, index) => {
          orig[index] = {
            element,
            html: element.innerHTML,
            ariaL: element.getAttribute("aria-label"),
            ariaH: element.getAttribute("aria-hidden")
          };
          aria === "auto" ? element.setAttribute("aria-label", (element.textContent || "").trim()) : aria === "hidden" && element.setAttribute("aria-hidden", "true");
          let chars = [], words = [], lines = [], charWrapper = splitCharacters ? _getWrapper("char", config3, chars) : null, wordWrapper = _getWrapper("word", config3, words), i, curWord, smartWrapSpan, nextSibling;
          _splitWordsAndCharsRecursively(element, config3, wordWrapper, charWrapper, onlySplitCharacters, deepSlice && (splitLines || onlySplitCharacters), ignore, finalCharSplitRegEx, specialCharsRegEx, false);
          if (splitLines) {
            let nodes = _toArray2(element.childNodes), wrapLine = _getLineWrapper(element, nodes, config3, lines), curNode, toRemove = [], lineStartIndex = 0, allBounds = nodes.map((n) => n.nodeType === 1 ? n.getBoundingClientRect() : _emptyBounds), lastBounds = _emptyBounds;
            for (i = 0; i < nodes.length; i++) {
              curNode = nodes[i];
              if (curNode.nodeType === 1) {
                if (curNode.nodeName === "BR") {
                  toRemove.push(curNode);
                  wrapLine(lineStartIndex, i + 1);
                  lineStartIndex = i + 1;
                  lastBounds = allBounds[lineStartIndex];
                } else {
                  if (i && allBounds[i].top > lastBounds.top && allBounds[i].left <= lastBounds.left) {
                    wrapLine(lineStartIndex, i);
                    lineStartIndex = i;
                  }
                  lastBounds = allBounds[i];
                }
              }
            }
            lineStartIndex < i && wrapLine(lineStartIndex, i);
            toRemove.forEach((el) => {
              var _a;
              return (_a = el.parentNode) == null ? void 0 : _a.removeChild(el);
            });
          }
          if (!splitWords) {
            for (i = 0; i < words.length; i++) {
              curWord = words[i];
              if (splitCharacters || !curWord.nextSibling || curWord.nextSibling.nodeType !== 3) {
                if (smartWrap && !splitLines) {
                  smartWrapSpan = document.createElement("span");
                  smartWrapSpan.style.whiteSpace = "nowrap";
                  while (curWord.firstChild) {
                    smartWrapSpan.appendChild(curWord.firstChild);
                  }
                  curWord.replaceWith(smartWrapSpan);
                } else {
                  curWord.replaceWith(...curWord.childNodes);
                }
              } else {
                nextSibling = curWord.nextSibling;
                if (nextSibling && nextSibling.nodeType === 3) {
                  nextSibling.textContent = (curWord.textContent || "") + (nextSibling.textContent || "");
                  curWord.remove();
                }
              }
            }
            words.length = 0;
            element.normalize();
          }
          this.lines.push(...lines);
          this.words.push(...words);
          this.chars.push(...chars);
        });
        mask && this[mask] && this.masks.push(...this[mask].map((el) => {
          let maskEl = el.cloneNode();
          el.replaceWith(maskEl);
          maskEl.appendChild(el);
          el.className && (maskEl.className = el.className.replace(/(\b\w+\b)/g, "$1-mask"));
          maskEl.style.overflow = "clip";
          return maskEl;
        }));
      }
      this.isSplit = true;
      _fonts && (autoSplit ? _fonts.addEventListener("loadingdone", this._split) : _fonts.status === "loading" && console.warn("SplitText called before fonts loaded"));
      if ((onSplitResult = onSplit && onSplit(this)) && onSplitResult.totalTime) {
        this._data.anim = animTime ? onSplitResult.totalTime(animTime) : onSplitResult;
      }
      splitLines && autoSplit && this.elements.forEach((element, index) => {
        orig[index].width = element.offsetWidth;
        obs && obs.observe(element);
      });
      return this;
    }
    revert() {
      var _a, _b;
      let { orig, anim, obs } = this._data;
      obs && obs.disconnect();
      orig.forEach(({ element, html, ariaL, ariaH }) => {
        element.innerHTML = html;
        ariaL ? element.setAttribute("aria-label", ariaL) : element.removeAttribute("aria-label");
        ariaH ? element.setAttribute("aria-hidden", ariaH) : element.removeAttribute("aria-hidden");
      });
      this.chars.length = this.words.length = this.lines.length = orig.length = this.masks.length = 0;
      this.isSplit = false;
      _fonts == null ? void 0 : _fonts.removeEventListener("loadingdone", this._split);
      if (anim) {
        this._data.animTime = anim.totalTime();
        anim.revert();
      }
      (_b = (_a = this.vars).onRevert) == null ? void 0 : _b.call(_a, this);
      return this;
    }
    static create(elements, config3) {
      return new _SplitText2(elements, config3);
    }
    static register(core) {
      gsap4 = gsap4 || core || window.gsap;
      if (gsap4) {
        _toArray2 = gsap4.utils.toArray;
        _context4 = gsap4.core.context || _context4;
      }
      if (!_coreInitted4 && window.innerWidth > 0) {
        _fonts = document.fonts;
        _coreInitted4 = true;
      }
    }
  };
  _SplitText.version = "3.13.0";
  var SplitText = _SplitText;

  // node_modules/@gsap/react/src/index.js
  var import_react = __toESM(require_react());
  var useIsomorphicLayoutEffect2 = typeof document !== "undefined" ? import_react.useLayoutEffect : import_react.useEffect;
  var isConfig = (value) => value && !Array.isArray(value) && typeof value === "object";
  var emptyArray = [];
  var defaultConfig = {};
  var _gsap2 = gsapWithCSS;
  var useGSAP = (callback, dependencies = emptyArray) => {
    let config3 = defaultConfig;
    if (isConfig(callback)) {
      config3 = callback;
      callback = null;
      dependencies = "dependencies" in config3 ? config3.dependencies : emptyArray;
    } else if (isConfig(dependencies)) {
      config3 = dependencies;
      dependencies = "dependencies" in config3 ? config3.dependencies : emptyArray;
    }
    callback && typeof callback !== "function" && console.warn("First parameter must be a function or config object");
    const { scope, revertOnUpdate } = config3, mounted = (0, import_react.useRef)(false), context3 = (0, import_react.useRef)(_gsap2.context(() => {
    }, scope)), contextSafe = (0, import_react.useRef)((func) => context3.current.add(null, func)), deferCleanup = dependencies && dependencies.length && !revertOnUpdate;
    deferCleanup && useIsomorphicLayoutEffect2(() => {
      mounted.current = true;
      return () => context3.current.revert();
    }, emptyArray);
    useIsomorphicLayoutEffect2(() => {
      callback && context3.current.add(callback, scope);
      if (!deferCleanup || !mounted.current) {
        return () => context3.current.revert();
      }
    }, dependencies);
    return { context: context3.current, contextSafe: contextSafe.current };
  };
  useGSAP.register = (core) => {
    _gsap2 = core;
  };
  useGSAP.headless = true;

  // frontend/src/components/SplitText/SplitText.jsx
  var import_jsx_runtime = __toESM(require_jsx_runtime());
  gsapWithCSS.registerPlugin(ScrollTrigger2, SplitText, useGSAP);
  var DEFAULT_FROM = { opacity: 0, y: 40 };
  var DEFAULT_TO = { opacity: 1, y: 0 };
  var SplitText2 = ({
    text,
    className = "",
    delay: delay2 = 100,
    duration = 0.6,
    ease: ease2 = "power3.out",
    splitType = "chars",
    from = DEFAULT_FROM,
    to = DEFAULT_TO,
    threshold = 0.1,
    rootMargin = "-100px",
    textAlign = "center",
    tag = "p",
    onLetterAnimationComplete
  }) => {
    const ref2 = (0, import_react2.useRef)(null);
    const [fontsLoaded, setFontsLoaded] = (0, import_react2.useState)(false);
    const normalizedFrom = (0, import_react2.useMemo)(
      () => ({ ...DEFAULT_FROM, ...from }),
      [from]
    );
    const normalizedTo = (0, import_react2.useMemo)(
      () => ({ ...DEFAULT_TO, ...to }),
      [to]
    );
    (0, import_react2.useEffect)(() => {
      if (typeof document === "undefined" || !document.fonts) {
        setFontsLoaded(true);
        return void 0;
      }
      let isMounted = true;
      if (document.fonts.status === "loaded") {
        setFontsLoaded(true);
        return () => {
          isMounted = false;
        };
      }
      document.fonts.ready.then(() => {
        if (isMounted) {
          setFontsLoaded(true);
        }
      }).catch(() => {
        if (isMounted) {
          setFontsLoaded(true);
        }
      });
      return () => {
        isMounted = false;
      };
    }, []);
    useGSAP(
      () => {
        const el = ref2.current;
        if (!el || !text || !fontsLoaded) return;
        if (el._rbsplitInstance) {
          try {
            el._rbsplitInstance.revert();
          } catch (_) {
          }
          el._rbsplitInstance = null;
        }
        const startPct = (1 - threshold) * 100;
        const [topMarginToken] = `${rootMargin}`.trim().split(/\s+/);
        const marginMatch = /^(-?\d+(?:\.\d+)?)(px|em|rem|%)?$/.exec(
          topMarginToken ?? "0"
        );
        const marginValue = marginMatch ? parseFloat(marginMatch[1]) : 0;
        const marginUnit = marginMatch ? marginMatch[2] || "px" : "px";
        const sign = marginValue === 0 ? "" : marginValue < 0 ? `-=${Math.abs(marginValue)}${marginUnit}` : `+=${marginValue}${marginUnit}`;
        const start = `top ${startPct}%${sign}`;
        const resolveTargets = (self2) => {
          if (splitType.includes("chars") && self2.chars.length) {
            return self2.chars;
          }
          if (splitType.includes("words") && self2.words.length) {
            return self2.words;
          }
          if (splitType.includes("lines") && self2.lines.length) {
            return self2.lines;
          }
          return self2.chars || self2.words || self2.lines;
        };
        const splitInstance = new SplitText(el, {
          type: splitType,
          smartWrap: true,
          autoSplit: splitType === "lines",
          linesClass: "split-line",
          wordsClass: "split-word",
          charsClass: "split-char",
          reduceWhiteSpace: false,
          onSplit: (self2) => {
            const targets = resolveTargets(self2);
            if (!targets || !targets.length) {
              return void 0;
            }
            const tween = gsapWithCSS.fromTo(targets, normalizedFrom, {
              ...normalizedTo,
              duration,
              ease: ease2,
              stagger: delay2 / 1e3,
              scrollTrigger: {
                trigger: el,
                start,
                once: true,
                fastScrollEnd: true,
                anticipatePin: 0.4
              },
              onComplete: () => {
                onLetterAnimationComplete?.();
              },
              willChange: "transform, opacity",
              force3D: true
            });
            return tween;
          }
        });
        el._rbsplitInstance = splitInstance;
        return () => {
          ScrollTrigger2.getAll().forEach((st) => {
            if (st.trigger === el) st.kill();
          });
          try {
            splitInstance.revert();
          } catch (_) {
          }
          el._rbsplitInstance = null;
        };
      },
      {
        dependencies: [
          text,
          delay2,
          duration,
          ease2,
          splitType,
          normalizedFrom,
          normalizedTo,
          threshold,
          rootMargin,
          fontsLoaded,
          onLetterAnimationComplete
        ],
        scope: ref2
      }
    );
    const justifyContent = (0, import_react2.useMemo)(() => {
      if (textAlign === "center") return "center";
      if (textAlign === "right" || textAlign === "end") return "flex-end";
      return "flex-start";
    }, [textAlign]);
    const style = (0, import_react2.useMemo)(
      () => ({
        textAlign,
        overflow: "hidden",
        display: "inline-flex",
        flexWrap: "wrap",
        justifyContent,
        alignItems: "baseline",
        gap: "0.25ch",
        whiteSpace: "normal",
        wordWrap: "break-word",
        willChange: "transform, opacity"
      }),
      [justifyContent, textAlign]
    );
    const classes = `split-parent ${className}`.trim();
    const Tag = tag;
    return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Tag, { ref: ref2, style, className: classes, children: text });
  };
  var SplitText_default = SplitText2;

  // frontend/src/components/TargetCursor/TargetCursor.jsx
  var import_react4 = __toESM(require_react());
  var import_jsx_runtime2 = __toESM(require_jsx_runtime());
  var TargetCursor = ({ targetSelector = ".cursor-target", spinDuration = 2, hideDefaultCursor = true }) => {
    const cursorRef = (0, import_react4.useRef)(null);
    const cornersRef = (0, import_react4.useRef)(null);
    const spinTl = (0, import_react4.useRef)(null);
    const dotRef = (0, import_react4.useRef)(null);
    const constants = (0, import_react4.useMemo)(
      () => ({
        borderWidth: 3,
        cornerSize: 12,
        parallaxStrength: 5e-5
      }),
      []
    );
    const moveCursor = (0, import_react4.useCallback)((x, y) => {
      if (!cursorRef.current) return;
      gsapWithCSS.to(cursorRef.current, {
        x,
        y,
        duration: 0.1,
        ease: "power3.out"
      });
    }, []);
    (0, import_react4.useEffect)(() => {
      if (!cursorRef.current) return;
      const originalCursor = document.body.style.cursor;
      if (hideDefaultCursor) {
        document.body.style.cursor = "none";
      }
      const cursor = cursorRef.current;
      cornersRef.current = cursor.querySelectorAll(".target-cursor-corner");
      let activeTarget = null;
      let currentTargetMove = null;
      let currentLeaveHandler = null;
      let isAnimatingToTarget = false;
      let resumeTimeout = null;
      const cleanupTarget = (target) => {
        if (currentTargetMove) {
          target.removeEventListener("mousemove", currentTargetMove);
        }
        if (currentLeaveHandler) {
          target.removeEventListener("mouseleave", currentLeaveHandler);
        }
        currentTargetMove = null;
        currentLeaveHandler = null;
      };
      gsapWithCSS.set(cursor, {
        xPercent: -50,
        yPercent: -50,
        x: window.innerWidth / 2,
        y: window.innerHeight / 2
      });
      const createSpinTimeline = () => {
        if (spinTl.current) {
          spinTl.current.kill();
        }
        spinTl.current = gsapWithCSS.timeline({ repeat: -1 }).to(cursor, { rotation: "+=360", duration: spinDuration, ease: "none" });
      };
      createSpinTimeline();
      const moveHandler = (e) => moveCursor(e.clientX, e.clientY);
      window.addEventListener("mousemove", moveHandler);
      const scrollHandler = () => {
        if (!activeTarget || !cursorRef.current) return;
        const mouseX = gsapWithCSS.getProperty(cursorRef.current, "x");
        const mouseY = gsapWithCSS.getProperty(cursorRef.current, "y");
        const elementUnderMouse = document.elementFromPoint(mouseX, mouseY);
        const isStillOverTarget = elementUnderMouse && (elementUnderMouse === activeTarget || elementUnderMouse.closest(targetSelector) === activeTarget);
        if (!isStillOverTarget) {
          if (currentLeaveHandler) {
            currentLeaveHandler();
          }
        }
      };
      window.addEventListener("scroll", scrollHandler, { passive: true });
      window.addEventListener("mousemove", moveHandler);
      const mouseDownHandler = () => {
        if (!dotRef.current) return;
        gsapWithCSS.to(dotRef.current, { scale: 0.7, duration: 0.3 });
        gsapWithCSS.to(cursorRef.current, { scale: 0.9, duration: 0.2 });
      };
      const mouseUpHandler = () => {
        if (!dotRef.current) return;
        gsapWithCSS.to(dotRef.current, { scale: 1, duration: 0.3 });
        gsapWithCSS.to(cursorRef.current, { scale: 1, duration: 0.2 });
      };
      window.addEventListener("mousedown", mouseDownHandler);
      window.addEventListener("mouseup", mouseUpHandler);
      const enterHandler = (e) => {
        const directTarget = e.target;
        const allTargets = [];
        let current = directTarget;
        while (current && current !== document.body) {
          if (current.matches(targetSelector)) {
            allTargets.push(current);
          }
          current = current.parentElement;
        }
        const target = allTargets[0] || null;
        if (!target || !cursorRef.current || !cornersRef.current) return;
        if (activeTarget === target) return;
        if (activeTarget) {
          cleanupTarget(activeTarget);
        }
        if (resumeTimeout) {
          clearTimeout(resumeTimeout);
          resumeTimeout = null;
        }
        activeTarget = target;
        const corners = Array.from(cornersRef.current);
        corners.forEach((corner) => {
          gsapWithCSS.killTweensOf(corner);
        });
        gsapWithCSS.killTweensOf(cursorRef.current, "rotation");
        spinTl.current?.pause();
        gsapWithCSS.set(cursorRef.current, { rotation: 0 });
        const updateCorners = (mouseX, mouseY) => {
          const rect = target.getBoundingClientRect();
          const cursorRect = cursorRef.current.getBoundingClientRect();
          const cursorCenterX = cursorRect.left + cursorRect.width / 2;
          const cursorCenterY = cursorRect.top + cursorRect.height / 2;
          const [tlc, trc, brc, blc] = Array.from(cornersRef.current);
          const { borderWidth, cornerSize, parallaxStrength } = constants;
          let tlOffset = {
            x: rect.left - cursorCenterX - borderWidth,
            y: rect.top - cursorCenterY - borderWidth
          };
          let trOffset = {
            x: rect.right - cursorCenterX + borderWidth - cornerSize,
            y: rect.top - cursorCenterY - borderWidth
          };
          let brOffset = {
            x: rect.right - cursorCenterX + borderWidth - cornerSize,
            y: rect.bottom - cursorCenterY + borderWidth - cornerSize
          };
          let blOffset = {
            x: rect.left - cursorCenterX - borderWidth,
            y: rect.bottom - cursorCenterY + borderWidth - cornerSize
          };
          if (mouseX !== void 0 && mouseY !== void 0) {
            const targetCenterX = rect.left + rect.width / 2;
            const targetCenterY = rect.top + rect.height / 2;
            const mouseOffsetX = (mouseX - targetCenterX) * parallaxStrength;
            const mouseOffsetY = (mouseY - targetCenterY) * parallaxStrength;
            tlOffset.x += mouseOffsetX;
            tlOffset.y += mouseOffsetY;
            trOffset.x += mouseOffsetX;
            trOffset.y += mouseOffsetY;
            brOffset.x += mouseOffsetX;
            brOffset.y += mouseOffsetY;
            blOffset.x += mouseOffsetX;
            blOffset.y += mouseOffsetY;
          }
          const tl = gsapWithCSS.timeline();
          const corners2 = [tlc, trc, brc, blc];
          const offsets = [tlOffset, trOffset, brOffset, blOffset];
          corners2.forEach((corner, index) => {
            tl.to(
              corner,
              {
                x: offsets[index].x,
                y: offsets[index].y,
                duration: 0.2,
                ease: "power2.out"
              },
              0
            );
          });
        };
        isAnimatingToTarget = true;
        updateCorners();
        setTimeout(() => {
          isAnimatingToTarget = false;
        }, 1);
        let moveThrottle = null;
        const targetMove = (ev) => {
          if (moveThrottle || isAnimatingToTarget) return;
          moveThrottle = requestAnimationFrame(() => {
            const mouseEvent = ev;
            updateCorners(mouseEvent.clientX, mouseEvent.clientY);
            moveThrottle = null;
          });
        };
        const leaveHandler = () => {
          activeTarget = null;
          isAnimatingToTarget = false;
          if (cornersRef.current) {
            const corners2 = Array.from(cornersRef.current);
            gsapWithCSS.killTweensOf(corners2);
            const { cornerSize } = constants;
            const positions = [
              { x: -cornerSize * 1.5, y: -cornerSize * 1.5 },
              { x: cornerSize * 0.5, y: -cornerSize * 1.5 },
              { x: cornerSize * 0.5, y: cornerSize * 0.5 },
              { x: -cornerSize * 1.5, y: cornerSize * 0.5 }
            ];
            const tl = gsapWithCSS.timeline();
            corners2.forEach((corner, index) => {
              tl.to(
                corner,
                {
                  x: positions[index].x,
                  y: positions[index].y,
                  duration: 0.3,
                  ease: "power3.out"
                },
                0
              );
            });
          }
          resumeTimeout = setTimeout(() => {
            if (!activeTarget && cursorRef.current && spinTl.current) {
              const currentRotation = gsapWithCSS.getProperty(cursorRef.current, "rotation");
              const normalizedRotation = currentRotation % 360;
              spinTl.current.kill();
              spinTl.current = gsapWithCSS.timeline({ repeat: -1 }).to(cursorRef.current, { rotation: "+=360", duration: spinDuration, ease: "none" });
              gsapWithCSS.to(cursorRef.current, {
                rotation: normalizedRotation + 360,
                duration: spinDuration * (1 - normalizedRotation / 360),
                ease: "none",
                onComplete: () => {
                  spinTl.current?.restart();
                }
              });
            }
            resumeTimeout = null;
          }, 50);
          cleanupTarget(target);
        };
        currentTargetMove = targetMove;
        currentLeaveHandler = leaveHandler;
        target.addEventListener("mousemove", targetMove);
        target.addEventListener("mouseleave", leaveHandler);
      };
      window.addEventListener("mouseover", enterHandler, { passive: true });
      return () => {
        window.removeEventListener("mousemove", moveHandler);
        window.removeEventListener("mouseover", enterHandler);
        window.removeEventListener("scroll", scrollHandler);
        if (activeTarget) {
          cleanupTarget(activeTarget);
        }
        console.log("Cleaning up TargetCursor");
        spinTl.current?.kill();
        document.body.style.cursor = originalCursor;
      };
    }, [targetSelector, spinDuration, moveCursor, constants, hideDefaultCursor]);
    (0, import_react4.useEffect)(() => {
      if (!cursorRef.current || !spinTl.current) return;
      if (spinTl.current.isActive()) {
        spinTl.current.kill();
        spinTl.current = gsapWithCSS.timeline({ repeat: -1 }).to(cursorRef.current, { rotation: "+=360", duration: spinDuration, ease: "none" });
      }
    }, [spinDuration]);
    return /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { ref: cursorRef, className: "target-cursor-wrapper", children: [
      /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("div", { ref: dotRef, className: "target-cursor-dot" }),
      /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("div", { className: "target-cursor-corner corner-tl" }),
      /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("div", { className: "target-cursor-corner corner-tr" }),
      /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("div", { className: "target-cursor-corner corner-br" }),
      /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("div", { className: "target-cursor-corner corner-bl" })
    ] });
  };
  var TargetCursor_default = TargetCursor;

  // frontend/src/components/TiltedCard/TiltedCard.jsx
  var import_react29 = __toESM(require_react());

  // node_modules/framer-motion/dist/es/context/LayoutGroupContext.mjs
  var import_react5 = __toESM(require_react(), 1);
  var LayoutGroupContext = (0, import_react5.createContext)({});

  // node_modules/framer-motion/dist/es/utils/use-constant.mjs
  var import_react6 = __toESM(require_react(), 1);
  function useConstant(init5) {
    const ref2 = (0, import_react6.useRef)(null);
    if (ref2.current === null) {
      ref2.current = init5();
    }
    return ref2.current;
  }

  // node_modules/framer-motion/dist/es/utils/use-isomorphic-effect.mjs
  var import_react7 = __toESM(require_react(), 1);

  // node_modules/framer-motion/dist/es/utils/is-browser.mjs
  var isBrowser2 = typeof window !== "undefined";

  // node_modules/framer-motion/dist/es/utils/use-isomorphic-effect.mjs
  var useIsomorphicLayoutEffect3 = isBrowser2 ? import_react7.useLayoutEffect : import_react7.useEffect;

  // node_modules/framer-motion/dist/es/context/PresenceContext.mjs
  var import_react8 = __toESM(require_react(), 1);
  var PresenceContext = /* @__PURE__ */ (0, import_react8.createContext)(null);

  // node_modules/motion-utils/dist/es/array.mjs
  function addUniqueItem(arr, item) {
    if (arr.indexOf(item) === -1)
      arr.push(item);
  }
  function removeItem(arr, item) {
    const index = arr.indexOf(item);
    if (index > -1)
      arr.splice(index, 1);
  }

  // node_modules/motion-utils/dist/es/clamp.mjs
  var clamp3 = (min, max, v) => {
    if (v > max)
      return max;
    if (v < min)
      return min;
    return v;
  };

  // node_modules/motion-utils/dist/es/format-error-message.mjs
  function formatErrorMessage(message, errorCode) {
    return errorCode ? `${message}. For more information and steps for solving, visit https://motion.dev/troubleshooting/${errorCode}` : message;
  }

  // node_modules/motion-utils/dist/es/errors.mjs
  var warning2 = () => {
  };
  var invariant2 = () => {
  };
  if (true) {
    warning2 = (check, message, errorCode) => {
      if (!check && typeof console !== "undefined") {
        console.warn(formatErrorMessage(message, errorCode));
      }
    };
    invariant2 = (check, message, errorCode) => {
      if (!check) {
        throw new Error(formatErrorMessage(message, errorCode));
      }
    };
  }

  // node_modules/motion-utils/dist/es/global-config.mjs
  var MotionGlobalConfig = {};

  // node_modules/motion-utils/dist/es/is-numerical-string.mjs
  var isNumericalString = (v) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(v);

  // node_modules/motion-utils/dist/es/is-object.mjs
  function isObject(value) {
    return typeof value === "object" && value !== null;
  }

  // node_modules/motion-utils/dist/es/is-zero-value-string.mjs
  var isZeroValueString = (v) => /^0[^.\s]+$/u.test(v);

  // node_modules/motion-utils/dist/es/memo.mjs
  // @__NO_SIDE_EFFECTS__
  function memo2(callback) {
    let result;
    return () => {
      if (result === void 0)
        result = callback();
      return result;
    };
  }

  // node_modules/motion-utils/dist/es/noop.mjs
  var noop3 = /* @__NO_SIDE_EFFECTS__ */ (any) => any;

  // node_modules/motion-utils/dist/es/pipe.mjs
  var combineFunctions = (a, b) => (v) => b(a(v));
  var pipe3 = (...transformers) => transformers.reduce(combineFunctions);

  // node_modules/motion-utils/dist/es/progress.mjs
  var progress = /* @__NO_SIDE_EFFECTS__ */ (from, to, value) => {
    const toFromDifference = to - from;
    return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;
  };

  // node_modules/motion-utils/dist/es/subscription-manager.mjs
  var SubscriptionManager = class {
    constructor() {
      this.subscriptions = [];
    }
    add(handler) {
      addUniqueItem(this.subscriptions, handler);
      return () => removeItem(this.subscriptions, handler);
    }
    notify(a, b, c) {
      const numSubscriptions = this.subscriptions.length;
      if (!numSubscriptions)
        return;
      if (numSubscriptions === 1) {
        this.subscriptions[0](a, b, c);
      } else {
        for (let i = 0; i < numSubscriptions; i++) {
          const handler = this.subscriptions[i];
          handler && handler(a, b, c);
        }
      }
    }
    getSize() {
      return this.subscriptions.length;
    }
    clear() {
      this.subscriptions.length = 0;
    }
  };

  // node_modules/motion-utils/dist/es/time-conversion.mjs
  var secondsToMilliseconds = /* @__NO_SIDE_EFFECTS__ */ (seconds) => seconds * 1e3;
  var millisecondsToSeconds = /* @__NO_SIDE_EFFECTS__ */ (milliseconds) => milliseconds / 1e3;

  // node_modules/motion-utils/dist/es/velocity-per-second.mjs
  function velocityPerSecond(velocity, frameDuration) {
    return frameDuration ? velocity * (1e3 / frameDuration) : 0;
  }

  // node_modules/motion-utils/dist/es/warn-once.mjs
  var warned = /* @__PURE__ */ new Set();
  function warnOnce2(condition, message, errorCode) {
    if (condition || warned.has(message))
      return;
    console.warn(formatErrorMessage(message, errorCode));
    warned.add(message);
  }

  // node_modules/motion-utils/dist/es/easing/cubic-bezier.mjs
  var calcBezier = (t, a1, a2) => (((1 - 3 * a2 + 3 * a1) * t + (3 * a2 - 6 * a1)) * t + 3 * a1) * t;
  var subdivisionPrecision = 1e-7;
  var subdivisionMaxIterations = 12;
  function binarySubdivide(x, lowerBound, upperBound, mX1, mX2) {
    let currentX;
    let currentT;
    let i = 0;
    do {
      currentT = lowerBound + (upperBound - lowerBound) / 2;
      currentX = calcBezier(currentT, mX1, mX2) - x;
      if (currentX > 0) {
        upperBound = currentT;
      } else {
        lowerBound = currentT;
      }
    } while (Math.abs(currentX) > subdivisionPrecision && ++i < subdivisionMaxIterations);
    return currentT;
  }
  function cubicBezier(mX1, mY1, mX2, mY2) {
    if (mX1 === mY1 && mX2 === mY2)
      return noop3;
    const getTForX = (aX) => binarySubdivide(aX, 0, 1, mX1, mX2);
    return (t) => t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);
  }

  // node_modules/motion-utils/dist/es/easing/modifiers/mirror.mjs
  var mirrorEasing = (easing) => (p) => p <= 0.5 ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2;

  // node_modules/motion-utils/dist/es/easing/modifiers/reverse.mjs
  var reverseEasing = (easing) => (p) => 1 - easing(1 - p);

  // node_modules/motion-utils/dist/es/easing/back.mjs
  var backOut = /* @__PURE__ */ cubicBezier(0.33, 1.53, 0.69, 0.99);
  var backIn = /* @__PURE__ */ reverseEasing(backOut);
  var backInOut = /* @__PURE__ */ mirrorEasing(backIn);

  // node_modules/motion-utils/dist/es/easing/anticipate.mjs
  var anticipate = (p) => (p *= 2) < 1 ? 0.5 * backIn(p) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));

  // node_modules/motion-utils/dist/es/easing/circ.mjs
  var circIn = (p) => 1 - Math.sin(Math.acos(p));
  var circOut = reverseEasing(circIn);
  var circInOut = mirrorEasing(circIn);

  // node_modules/motion-utils/dist/es/easing/ease.mjs
  var easeIn = /* @__PURE__ */ cubicBezier(0.42, 0, 1, 1);
  var easeOut = /* @__PURE__ */ cubicBezier(0, 0, 0.58, 1);
  var easeInOut = /* @__PURE__ */ cubicBezier(0.42, 0, 0.58, 1);

  // node_modules/motion-utils/dist/es/easing/utils/is-easing-array.mjs
  var isEasingArray = (ease2) => {
    return Array.isArray(ease2) && typeof ease2[0] !== "number";
  };

  // node_modules/motion-utils/dist/es/easing/utils/is-bezier-definition.mjs
  var isBezierDefinition = (easing) => Array.isArray(easing) && typeof easing[0] === "number";

  // node_modules/motion-utils/dist/es/easing/utils/map.mjs
  var easingLookup = {
    linear: noop3,
    easeIn,
    easeInOut,
    easeOut,
    circIn,
    circInOut,
    circOut,
    backIn,
    backInOut,
    backOut,
    anticipate
  };
  var isValidEasing = (easing) => {
    return typeof easing === "string";
  };
  var easingDefinitionToFunction = (definition) => {
    if (isBezierDefinition(definition)) {
      invariant2(definition.length === 4, `Cubic bezier arrays must contain four numerical values.`, "cubic-bezier-length");
      const [x1, y1, x2, y2] = definition;
      return cubicBezier(x1, y1, x2, y2);
    } else if (isValidEasing(definition)) {
      invariant2(easingLookup[definition] !== void 0, `Invalid easing type '${definition}'`, "invalid-easing-type");
      return easingLookup[definition];
    }
    return definition;
  };

  // node_modules/motion-dom/dist/es/frameloop/order.mjs
  var stepsOrder = [
    "setup",
    // Compute
    "read",
    // Read
    "resolveKeyframes",
    // Write/Read/Write/Read
    "preUpdate",
    // Compute
    "update",
    // Compute
    "preRender",
    // Compute
    "render",
    // Write
    "postRender"
    // Compute
  ];

  // node_modules/motion-dom/dist/es/stats/buffer.mjs
  var statsBuffer = {
    value: null,
    addProjectionMetrics: null
  };

  // node_modules/motion-dom/dist/es/frameloop/render-step.mjs
  function createRenderStep(runNextFrame, stepName) {
    let thisFrame = /* @__PURE__ */ new Set();
    let nextFrame = /* @__PURE__ */ new Set();
    let isProcessing = false;
    let flushNextFrame = false;
    const toKeepAlive = /* @__PURE__ */ new WeakSet();
    let latestFrameData = {
      delta: 0,
      timestamp: 0,
      isProcessing: false
    };
    let numCalls = 0;
    function triggerCallback(callback) {
      if (toKeepAlive.has(callback)) {
        step.schedule(callback);
        runNextFrame();
      }
      numCalls++;
      callback(latestFrameData);
    }
    const step = {
      /**
       * Schedule a process to run on the next frame.
       */
      schedule: (callback, keepAlive = false, immediate = false) => {
        const addToCurrentFrame = immediate && isProcessing;
        const queue = addToCurrentFrame ? thisFrame : nextFrame;
        if (keepAlive)
          toKeepAlive.add(callback);
        if (!queue.has(callback))
          queue.add(callback);
        return callback;
      },
      /**
       * Cancel the provided callback from running on the next frame.
       */
      cancel: (callback) => {
        nextFrame.delete(callback);
        toKeepAlive.delete(callback);
      },
      /**
       * Execute all schedule callbacks.
       */
      process: (frameData2) => {
        latestFrameData = frameData2;
        if (isProcessing) {
          flushNextFrame = true;
          return;
        }
        isProcessing = true;
        [thisFrame, nextFrame] = [nextFrame, thisFrame];
        thisFrame.forEach(triggerCallback);
        if (stepName && statsBuffer.value) {
          statsBuffer.value.frameloop[stepName].push(numCalls);
        }
        numCalls = 0;
        thisFrame.clear();
        isProcessing = false;
        if (flushNextFrame) {
          flushNextFrame = false;
          step.process(frameData2);
        }
      }
    };
    return step;
  }

  // node_modules/motion-dom/dist/es/frameloop/batcher.mjs
  var maxElapsed = 40;
  function createRenderBatcher(scheduleNextBatch, allowKeepAlive) {
    let runNextFrame = false;
    let useDefaultElapsed = true;
    const state = {
      delta: 0,
      timestamp: 0,
      isProcessing: false
    };
    const flagRunNextFrame = () => runNextFrame = true;
    const steps = stepsOrder.reduce((acc, key) => {
      acc[key] = createRenderStep(flagRunNextFrame, allowKeepAlive ? key : void 0);
      return acc;
    }, {});
    const { setup, read, resolveKeyframes, preUpdate, update, preRender, render: render4, postRender } = steps;
    const processBatch = () => {
      const timestamp = MotionGlobalConfig.useManualTiming ? state.timestamp : performance.now();
      runNextFrame = false;
      if (!MotionGlobalConfig.useManualTiming) {
        state.delta = useDefaultElapsed ? 1e3 / 60 : Math.max(Math.min(timestamp - state.timestamp, maxElapsed), 1);
      }
      state.timestamp = timestamp;
      state.isProcessing = true;
      setup.process(state);
      read.process(state);
      resolveKeyframes.process(state);
      preUpdate.process(state);
      update.process(state);
      preRender.process(state);
      render4.process(state);
      postRender.process(state);
      state.isProcessing = false;
      if (runNextFrame && allowKeepAlive) {
        useDefaultElapsed = false;
        scheduleNextBatch(processBatch);
      }
    };
    const wake = () => {
      runNextFrame = true;
      useDefaultElapsed = true;
      if (!state.isProcessing) {
        scheduleNextBatch(processBatch);
      }
    };
    const schedule = stepsOrder.reduce((acc, key) => {
      const step = steps[key];
      acc[key] = (process2, keepAlive = false, immediate = false) => {
        if (!runNextFrame)
          wake();
        return step.schedule(process2, keepAlive, immediate);
      };
      return acc;
    }, {});
    const cancel = (process2) => {
      for (let i = 0; i < stepsOrder.length; i++) {
        steps[stepsOrder[i]].cancel(process2);
      }
    };
    return { schedule, cancel, state, steps };
  }

  // node_modules/motion-dom/dist/es/frameloop/frame.mjs
  var { schedule: frame, cancel: cancelFrame, state: frameData, steps: frameSteps } = /* @__PURE__ */ createRenderBatcher(typeof requestAnimationFrame !== "undefined" ? requestAnimationFrame : noop3, true);

  // node_modules/motion-dom/dist/es/frameloop/sync-time.mjs
  var now2;
  function clearTime() {
    now2 = void 0;
  }
  var time = {
    now: () => {
      if (now2 === void 0) {
        time.set(frameData.isProcessing || MotionGlobalConfig.useManualTiming ? frameData.timestamp : performance.now());
      }
      return now2;
    },
    set: (newTime) => {
      now2 = newTime;
      queueMicrotask(clearTime);
    }
  };

  // node_modules/motion-dom/dist/es/stats/animation-count.mjs
  var activeAnimations = {
    layout: 0,
    mainThread: 0,
    waapi: 0
  };

  // node_modules/motion-dom/dist/es/animation/utils/is-css-variable.mjs
  var checkStringStartsWith = (token) => (key) => typeof key === "string" && key.startsWith(token);
  var isCSSVariableName = /* @__PURE__ */ checkStringStartsWith("--");
  var startsAsVariableToken = /* @__PURE__ */ checkStringStartsWith("var(--");
  var isCSSVariableToken = (value) => {
    const startsWithToken = startsAsVariableToken(value);
    if (!startsWithToken)
      return false;
    return singleCssVariableRegex.test(value.split("/*")[0].trim());
  };
  var singleCssVariableRegex = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu;

  // node_modules/motion-dom/dist/es/value/types/numbers/index.mjs
  var number = {
    test: (v) => typeof v === "number",
    parse: parseFloat,
    transform: (v) => v
  };
  var alpha = {
    ...number,
    transform: (v) => clamp3(0, 1, v)
  };
  var scale = {
    ...number,
    default: 1
  };

  // node_modules/motion-dom/dist/es/value/types/utils/sanitize.mjs
  var sanitize = (v) => Math.round(v * 1e5) / 1e5;

  // node_modules/motion-dom/dist/es/value/types/utils/float-regex.mjs
  var floatRegex = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;

  // node_modules/motion-dom/dist/es/value/types/utils/is-nullish.mjs
  function isNullish(v) {
    return v == null;
  }

  // node_modules/motion-dom/dist/es/value/types/utils/single-color-regex.mjs
  var singleColorRegex = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu;

  // node_modules/motion-dom/dist/es/value/types/color/utils.mjs
  var isColorString = (type, testProp) => (v) => {
    return Boolean(typeof v === "string" && singleColorRegex.test(v) && v.startsWith(type) || testProp && !isNullish(v) && Object.prototype.hasOwnProperty.call(v, testProp));
  };
  var splitColor3 = (aName, bName, cName) => (v) => {
    if (typeof v !== "string")
      return v;
    const [a, b, c, alpha2] = v.match(floatRegex);
    return {
      [aName]: parseFloat(a),
      [bName]: parseFloat(b),
      [cName]: parseFloat(c),
      alpha: alpha2 !== void 0 ? parseFloat(alpha2) : 1
    };
  };

  // node_modules/motion-dom/dist/es/value/types/color/rgba.mjs
  var clampRgbUnit = (v) => clamp3(0, 255, v);
  var rgbUnit = {
    ...number,
    transform: (v) => Math.round(clampRgbUnit(v))
  };
  var rgba = {
    test: /* @__PURE__ */ isColorString("rgb", "red"),
    parse: /* @__PURE__ */ splitColor3("red", "green", "blue"),
    transform: ({ red, green, blue, alpha: alpha$1 = 1 }) => "rgba(" + rgbUnit.transform(red) + ", " + rgbUnit.transform(green) + ", " + rgbUnit.transform(blue) + ", " + sanitize(alpha.transform(alpha$1)) + ")"
  };

  // node_modules/motion-dom/dist/es/value/types/color/hex.mjs
  function parseHex(v) {
    let r = "";
    let g = "";
    let b = "";
    let a = "";
    if (v.length > 5) {
      r = v.substring(1, 3);
      g = v.substring(3, 5);
      b = v.substring(5, 7);
      a = v.substring(7, 9);
    } else {
      r = v.substring(1, 2);
      g = v.substring(2, 3);
      b = v.substring(3, 4);
      a = v.substring(4, 5);
      r += r;
      g += g;
      b += b;
      a += a;
    }
    return {
      red: parseInt(r, 16),
      green: parseInt(g, 16),
      blue: parseInt(b, 16),
      alpha: a ? parseInt(a, 16) / 255 : 1
    };
  }
  var hex = {
    test: /* @__PURE__ */ isColorString("#"),
    parse: parseHex,
    transform: rgba.transform
  };

  // node_modules/motion-dom/dist/es/value/types/numbers/units.mjs
  var createUnitType = /* @__NO_SIDE_EFFECTS__ */ (unit) => ({
    test: (v) => typeof v === "string" && v.endsWith(unit) && v.split(" ").length === 1,
    parse: parseFloat,
    transform: (v) => `${v}${unit}`
  });
  var degrees = /* @__PURE__ */ createUnitType("deg");
  var percent = /* @__PURE__ */ createUnitType("%");
  var px = /* @__PURE__ */ createUnitType("px");
  var vh = /* @__PURE__ */ createUnitType("vh");
  var vw = /* @__PURE__ */ createUnitType("vw");
  var progressPercentage = /* @__PURE__ */ (() => ({
    ...percent,
    parse: (v) => percent.parse(v) / 100,
    transform: (v) => percent.transform(v * 100)
  }))();

  // node_modules/motion-dom/dist/es/value/types/color/hsla.mjs
  var hsla = {
    test: /* @__PURE__ */ isColorString("hsl", "hue"),
    parse: /* @__PURE__ */ splitColor3("hue", "saturation", "lightness"),
    transform: ({ hue, saturation, lightness, alpha: alpha$1 = 1 }) => {
      return "hsla(" + Math.round(hue) + ", " + percent.transform(sanitize(saturation)) + ", " + percent.transform(sanitize(lightness)) + ", " + sanitize(alpha.transform(alpha$1)) + ")";
    }
  };

  // node_modules/motion-dom/dist/es/value/types/color/index.mjs
  var color = {
    test: (v) => rgba.test(v) || hex.test(v) || hsla.test(v),
    parse: (v) => {
      if (rgba.test(v)) {
        return rgba.parse(v);
      } else if (hsla.test(v)) {
        return hsla.parse(v);
      } else {
        return hex.parse(v);
      }
    },
    transform: (v) => {
      return typeof v === "string" ? v : v.hasOwnProperty("red") ? rgba.transform(v) : hsla.transform(v);
    },
    getAnimatableNone: (v) => {
      const parsed = color.parse(v);
      parsed.alpha = 0;
      return color.transform(parsed);
    }
  };

  // node_modules/motion-dom/dist/es/value/types/utils/color-regex.mjs
  var colorRegex = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;

  // node_modules/motion-dom/dist/es/value/types/complex/index.mjs
  function test(v) {
    return isNaN(v) && typeof v === "string" && (v.match(floatRegex)?.length || 0) + (v.match(colorRegex)?.length || 0) > 0;
  }
  var NUMBER_TOKEN = "number";
  var COLOR_TOKEN = "color";
  var VAR_TOKEN = "var";
  var VAR_FUNCTION_TOKEN = "var(";
  var SPLIT_TOKEN = "${}";
  var complexRegex = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
  function analyseComplexValue(value) {
    const originalValue = value.toString();
    const values = [];
    const indexes = {
      color: [],
      number: [],
      var: []
    };
    const types = [];
    let i = 0;
    const tokenised = originalValue.replace(complexRegex, (parsedValue) => {
      if (color.test(parsedValue)) {
        indexes.color.push(i);
        types.push(COLOR_TOKEN);
        values.push(color.parse(parsedValue));
      } else if (parsedValue.startsWith(VAR_FUNCTION_TOKEN)) {
        indexes.var.push(i);
        types.push(VAR_TOKEN);
        values.push(parsedValue);
      } else {
        indexes.number.push(i);
        types.push(NUMBER_TOKEN);
        values.push(parseFloat(parsedValue));
      }
      ++i;
      return SPLIT_TOKEN;
    });
    const split = tokenised.split(SPLIT_TOKEN);
    return { values, split, indexes, types };
  }
  function parseComplexValue(v) {
    return analyseComplexValue(v).values;
  }
  function createTransformer(source) {
    const { split, types } = analyseComplexValue(source);
    const numSections = split.length;
    return (v) => {
      let output = "";
      for (let i = 0; i < numSections; i++) {
        output += split[i];
        if (v[i] !== void 0) {
          const type = types[i];
          if (type === NUMBER_TOKEN) {
            output += sanitize(v[i]);
          } else if (type === COLOR_TOKEN) {
            output += color.transform(v[i]);
          } else {
            output += v[i];
          }
        }
      }
      return output;
    };
  }
  var convertNumbersToZero = (v) => typeof v === "number" ? 0 : color.test(v) ? color.getAnimatableNone(v) : v;
  function getAnimatableNone(v) {
    const parsed = parseComplexValue(v);
    const transformer = createTransformer(v);
    return transformer(parsed.map(convertNumbersToZero));
  }
  var complex = {
    test,
    parse: parseComplexValue,
    createTransformer,
    getAnimatableNone
  };

  // node_modules/motion-dom/dist/es/value/types/color/hsla-to-rgba.mjs
  function hueToRgb(p, q, t) {
    if (t < 0)
      t += 1;
    if (t > 1)
      t -= 1;
    if (t < 1 / 6)
      return p + (q - p) * 6 * t;
    if (t < 1 / 2)
      return q;
    if (t < 2 / 3)
      return p + (q - p) * (2 / 3 - t) * 6;
    return p;
  }
  function hslaToRgba({ hue, saturation, lightness, alpha: alpha2 }) {
    hue /= 360;
    saturation /= 100;
    lightness /= 100;
    let red = 0;
    let green = 0;
    let blue = 0;
    if (!saturation) {
      red = green = blue = lightness;
    } else {
      const q = lightness < 0.5 ? lightness * (1 + saturation) : lightness + saturation - lightness * saturation;
      const p = 2 * lightness - q;
      red = hueToRgb(p, q, hue + 1 / 3);
      green = hueToRgb(p, q, hue);
      blue = hueToRgb(p, q, hue - 1 / 3);
    }
    return {
      red: Math.round(red * 255),
      green: Math.round(green * 255),
      blue: Math.round(blue * 255),
      alpha: alpha2
    };
  }

  // node_modules/motion-dom/dist/es/utils/mix/immediate.mjs
  function mixImmediate(a, b) {
    return (p) => p > 0 ? b : a;
  }

  // node_modules/motion-dom/dist/es/utils/mix/number.mjs
  var mixNumber = (from, to, progress2) => {
    return from + (to - from) * progress2;
  };

  // node_modules/motion-dom/dist/es/utils/mix/color.mjs
  var mixLinearColor = (from, to, v) => {
    const fromExpo = from * from;
    const expo = v * (to * to - fromExpo) + fromExpo;
    return expo < 0 ? 0 : Math.sqrt(expo);
  };
  var colorTypes = [hex, rgba, hsla];
  var getColorType = (v) => colorTypes.find((type) => type.test(v));
  function asRGBA(color2) {
    const type = getColorType(color2);
    warning2(Boolean(type), `'${color2}' is not an animatable color. Use the equivalent color code instead.`, "color-not-animatable");
    if (!Boolean(type))
      return false;
    let model = type.parse(color2);
    if (type === hsla) {
      model = hslaToRgba(model);
    }
    return model;
  }
  var mixColor = (from, to) => {
    const fromRGBA = asRGBA(from);
    const toRGBA = asRGBA(to);
    if (!fromRGBA || !toRGBA) {
      return mixImmediate(from, to);
    }
    const blended = { ...fromRGBA };
    return (v) => {
      blended.red = mixLinearColor(fromRGBA.red, toRGBA.red, v);
      blended.green = mixLinearColor(fromRGBA.green, toRGBA.green, v);
      blended.blue = mixLinearColor(fromRGBA.blue, toRGBA.blue, v);
      blended.alpha = mixNumber(fromRGBA.alpha, toRGBA.alpha, v);
      return rgba.transform(blended);
    };
  };

  // node_modules/motion-dom/dist/es/utils/mix/visibility.mjs
  var invisibleValues = /* @__PURE__ */ new Set(["none", "hidden"]);
  function mixVisibility(origin, target) {
    if (invisibleValues.has(origin)) {
      return (p) => p <= 0 ? origin : target;
    } else {
      return (p) => p >= 1 ? target : origin;
    }
  }

  // node_modules/motion-dom/dist/es/utils/mix/complex.mjs
  function mixNumber2(a, b) {
    return (p) => mixNumber(a, b, p);
  }
  function getMixer(a) {
    if (typeof a === "number") {
      return mixNumber2;
    } else if (typeof a === "string") {
      return isCSSVariableToken(a) ? mixImmediate : color.test(a) ? mixColor : mixComplex;
    } else if (Array.isArray(a)) {
      return mixArray;
    } else if (typeof a === "object") {
      return color.test(a) ? mixColor : mixObject;
    }
    return mixImmediate;
  }
  function mixArray(a, b) {
    const output = [...a];
    const numValues = output.length;
    const blendValue = a.map((v, i) => getMixer(v)(v, b[i]));
    return (p) => {
      for (let i = 0; i < numValues; i++) {
        output[i] = blendValue[i](p);
      }
      return output;
    };
  }
  function mixObject(a, b) {
    const output = { ...a, ...b };
    const blendValue = {};
    for (const key in output) {
      if (a[key] !== void 0 && b[key] !== void 0) {
        blendValue[key] = getMixer(a[key])(a[key], b[key]);
      }
    }
    return (v) => {
      for (const key in blendValue) {
        output[key] = blendValue[key](v);
      }
      return output;
    };
  }
  function matchOrder(origin, target) {
    const orderedOrigin = [];
    const pointers = { color: 0, var: 0, number: 0 };
    for (let i = 0; i < target.values.length; i++) {
      const type = target.types[i];
      const originIndex = origin.indexes[type][pointers[type]];
      const originValue = origin.values[originIndex] ?? 0;
      orderedOrigin[i] = originValue;
      pointers[type]++;
    }
    return orderedOrigin;
  }
  var mixComplex = (origin, target) => {
    const template = complex.createTransformer(target);
    const originStats = analyseComplexValue(origin);
    const targetStats = analyseComplexValue(target);
    const canInterpolate = originStats.indexes.var.length === targetStats.indexes.var.length && originStats.indexes.color.length === targetStats.indexes.color.length && originStats.indexes.number.length >= targetStats.indexes.number.length;
    if (canInterpolate) {
      if (invisibleValues.has(origin) && !targetStats.values.length || invisibleValues.has(target) && !originStats.values.length) {
        return mixVisibility(origin, target);
      }
      return pipe3(mixArray(matchOrder(originStats, targetStats), targetStats.values), template);
    } else {
      warning2(true, `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`, "complex-values-different");
      return mixImmediate(origin, target);
    }
  };

  // node_modules/motion-dom/dist/es/utils/mix/index.mjs
  function mix(from, to, p) {
    if (typeof from === "number" && typeof to === "number" && typeof p === "number") {
      return mixNumber(from, to, p);
    }
    const mixer = getMixer(from);
    return mixer(from, to);
  }

  // node_modules/motion-dom/dist/es/animation/drivers/frame.mjs
  var frameloopDriver = (update) => {
    const passTimestamp = ({ timestamp }) => update(timestamp);
    return {
      start: (keepAlive = true) => frame.update(passTimestamp, keepAlive),
      stop: () => cancelFrame(passTimestamp),
      /**
       * If we're processing this frame we can use the
       * framelocked timestamp to keep things in sync.
       */
      now: () => frameData.isProcessing ? frameData.timestamp : time.now()
    };
  };

  // node_modules/motion-dom/dist/es/animation/waapi/utils/linear.mjs
  var generateLinearEasing = (easing, duration, resolution = 10) => {
    let points = "";
    const numPoints = Math.max(Math.round(duration / resolution), 2);
    for (let i = 0; i < numPoints; i++) {
      points += Math.round(easing(i / (numPoints - 1)) * 1e4) / 1e4 + ", ";
    }
    return `linear(${points.substring(0, points.length - 2)})`;
  };

  // node_modules/motion-dom/dist/es/animation/generators/utils/calc-duration.mjs
  var maxGeneratorDuration = 2e4;
  function calcGeneratorDuration(generator) {
    let duration = 0;
    const timeStep = 50;
    let state = generator.next(duration);
    while (!state.done && duration < maxGeneratorDuration) {
      duration += timeStep;
      state = generator.next(duration);
    }
    return duration >= maxGeneratorDuration ? Infinity : duration;
  }

  // node_modules/motion-dom/dist/es/animation/generators/utils/create-generator-easing.mjs
  function createGeneratorEasing(options, scale2 = 100, createGenerator) {
    const generator = createGenerator({ ...options, keyframes: [0, scale2] });
    const duration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);
    return {
      type: "keyframes",
      ease: (progress2) => {
        return generator.next(duration * progress2).value / scale2;
      },
      duration: millisecondsToSeconds(duration)
    };
  }

  // node_modules/motion-dom/dist/es/animation/generators/utils/velocity.mjs
  var velocitySampleDuration = 5;
  function calcGeneratorVelocity(resolveValue, t, current) {
    const prevT = Math.max(t - velocitySampleDuration, 0);
    return velocityPerSecond(current - resolveValue(prevT), t - prevT);
  }

  // node_modules/motion-dom/dist/es/animation/generators/spring/defaults.mjs
  var springDefaults = {
    // Default spring physics
    stiffness: 100,
    damping: 10,
    mass: 1,
    velocity: 0,
    // Default duration/bounce-based options
    duration: 800,
    // in ms
    bounce: 0.3,
    visualDuration: 0.3,
    // in seconds
    // Rest thresholds
    restSpeed: {
      granular: 0.01,
      default: 2
    },
    restDelta: {
      granular: 5e-3,
      default: 0.5
    },
    // Limits
    minDuration: 0.01,
    // in seconds
    maxDuration: 10,
    // in seconds
    minDamping: 0.05,
    maxDamping: 1
  };

  // node_modules/motion-dom/dist/es/animation/generators/spring/find.mjs
  var safeMin = 1e-3;
  function findSpring({ duration = springDefaults.duration, bounce = springDefaults.bounce, velocity = springDefaults.velocity, mass = springDefaults.mass }) {
    let envelope;
    let derivative;
    warning2(duration <= secondsToMilliseconds(springDefaults.maxDuration), "Spring duration must be 10 seconds or less", "spring-duration-limit");
    let dampingRatio = 1 - bounce;
    dampingRatio = clamp3(springDefaults.minDamping, springDefaults.maxDamping, dampingRatio);
    duration = clamp3(springDefaults.minDuration, springDefaults.maxDuration, millisecondsToSeconds(duration));
    if (dampingRatio < 1) {
      envelope = (undampedFreq2) => {
        const exponentialDecay = undampedFreq2 * dampingRatio;
        const delta = exponentialDecay * duration;
        const a = exponentialDecay - velocity;
        const b = calcAngularFreq(undampedFreq2, dampingRatio);
        const c = Math.exp(-delta);
        return safeMin - a / b * c;
      };
      derivative = (undampedFreq2) => {
        const exponentialDecay = undampedFreq2 * dampingRatio;
        const delta = exponentialDecay * duration;
        const d = delta * velocity + velocity;
        const e = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq2, 2) * duration;
        const f = Math.exp(-delta);
        const g = calcAngularFreq(Math.pow(undampedFreq2, 2), dampingRatio);
        const factor = -envelope(undampedFreq2) + safeMin > 0 ? -1 : 1;
        return factor * ((d - e) * f) / g;
      };
    } else {
      envelope = (undampedFreq2) => {
        const a = Math.exp(-undampedFreq2 * duration);
        const b = (undampedFreq2 - velocity) * duration + 1;
        return -safeMin + a * b;
      };
      derivative = (undampedFreq2) => {
        const a = Math.exp(-undampedFreq2 * duration);
        const b = (velocity - undampedFreq2) * (duration * duration);
        return a * b;
      };
    }
    const initialGuess = 5 / duration;
    const undampedFreq = approximateRoot(envelope, derivative, initialGuess);
    duration = secondsToMilliseconds(duration);
    if (isNaN(undampedFreq)) {
      return {
        stiffness: springDefaults.stiffness,
        damping: springDefaults.damping,
        duration
      };
    } else {
      const stiffness = Math.pow(undampedFreq, 2) * mass;
      return {
        stiffness,
        damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),
        duration
      };
    }
  }
  var rootIterations = 12;
  function approximateRoot(envelope, derivative, initialGuess) {
    let result = initialGuess;
    for (let i = 1; i < rootIterations; i++) {
      result = result - envelope(result) / derivative(result);
    }
    return result;
  }
  function calcAngularFreq(undampedFreq, dampingRatio) {
    return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);
  }

  // node_modules/motion-dom/dist/es/animation/generators/spring/index.mjs
  var durationKeys = ["duration", "bounce"];
  var physicsKeys = ["stiffness", "damping", "mass"];
  function isSpringType(options, keys2) {
    return keys2.some((key) => options[key] !== void 0);
  }
  function getSpringOptions(options) {
    let springOptions = {
      velocity: springDefaults.velocity,
      stiffness: springDefaults.stiffness,
      damping: springDefaults.damping,
      mass: springDefaults.mass,
      isResolvedFromDuration: false,
      ...options
    };
    if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys)) {
      if (options.visualDuration) {
        const visualDuration = options.visualDuration;
        const root2 = 2 * Math.PI / (visualDuration * 1.2);
        const stiffness = root2 * root2;
        const damping = 2 * clamp3(0.05, 1, 1 - (options.bounce || 0)) * Math.sqrt(stiffness);
        springOptions = {
          ...springOptions,
          mass: springDefaults.mass,
          stiffness,
          damping
        };
      } else {
        const derived = findSpring(options);
        springOptions = {
          ...springOptions,
          ...derived,
          mass: springDefaults.mass
        };
        springOptions.isResolvedFromDuration = true;
      }
    }
    return springOptions;
  }
  function spring(optionsOrVisualDuration = springDefaults.visualDuration, bounce = springDefaults.bounce) {
    const options = typeof optionsOrVisualDuration !== "object" ? {
      visualDuration: optionsOrVisualDuration,
      keyframes: [0, 1],
      bounce
    } : optionsOrVisualDuration;
    let { restSpeed, restDelta } = options;
    const origin = options.keyframes[0];
    const target = options.keyframes[options.keyframes.length - 1];
    const state = { done: false, value: origin };
    const { stiffness, damping, mass, duration, velocity, isResolvedFromDuration } = getSpringOptions({
      ...options,
      velocity: -millisecondsToSeconds(options.velocity || 0)
    });
    const initialVelocity = velocity || 0;
    const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));
    const initialDelta = target - origin;
    const undampedAngularFreq = millisecondsToSeconds(Math.sqrt(stiffness / mass));
    const isGranularScale = Math.abs(initialDelta) < 5;
    restSpeed || (restSpeed = isGranularScale ? springDefaults.restSpeed.granular : springDefaults.restSpeed.default);
    restDelta || (restDelta = isGranularScale ? springDefaults.restDelta.granular : springDefaults.restDelta.default);
    let resolveSpring;
    if (dampingRatio < 1) {
      const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);
      resolveSpring = (t) => {
        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);
        return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t) + initialDelta * Math.cos(angularFreq * t));
      };
    } else if (dampingRatio === 1) {
      resolveSpring = (t) => target - Math.exp(-undampedAngularFreq * t) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t);
    } else {
      const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);
      resolveSpring = (t) => {
        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);
        const freqForT = Math.min(dampedAngularFreq * t, 300);
        return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;
      };
    }
    const generator = {
      calculatedDuration: isResolvedFromDuration ? duration || null : null,
      next: (t) => {
        const current = resolveSpring(t);
        if (!isResolvedFromDuration) {
          let currentVelocity = t === 0 ? initialVelocity : 0;
          if (dampingRatio < 1) {
            currentVelocity = t === 0 ? secondsToMilliseconds(initialVelocity) : calcGeneratorVelocity(resolveSpring, t, current);
          }
          const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;
          const isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;
          state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;
        } else {
          state.done = t >= duration;
        }
        state.value = state.done ? target : current;
        return state;
      },
      toString: () => {
        const calculatedDuration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);
        const easing = generateLinearEasing((progress2) => generator.next(calculatedDuration * progress2).value, calculatedDuration, 30);
        return calculatedDuration + "ms " + easing;
      },
      toTransition: () => {
      }
    };
    return generator;
  }
  spring.applyToOptions = (options) => {
    const generatorOptions = createGeneratorEasing(options, 100, spring);
    options.ease = generatorOptions.ease;
    options.duration = secondsToMilliseconds(generatorOptions.duration);
    options.type = "keyframes";
    return options;
  };

  // node_modules/motion-dom/dist/es/animation/generators/inertia.mjs
  function inertia({ keyframes: keyframes2, velocity = 0, power = 0.8, timeConstant = 325, bounceDamping = 10, bounceStiffness = 500, modifyTarget, min, max, restDelta = 0.5, restSpeed }) {
    const origin = keyframes2[0];
    const state = {
      done: false,
      value: origin
    };
    const isOutOfBounds = (v) => min !== void 0 && v < min || max !== void 0 && v > max;
    const nearestBoundary = (v) => {
      if (min === void 0)
        return max;
      if (max === void 0)
        return min;
      return Math.abs(min - v) < Math.abs(max - v) ? min : max;
    };
    let amplitude = power * velocity;
    const ideal = origin + amplitude;
    const target = modifyTarget === void 0 ? ideal : modifyTarget(ideal);
    if (target !== ideal)
      amplitude = target - origin;
    const calcDelta = (t) => -amplitude * Math.exp(-t / timeConstant);
    const calcLatest = (t) => target + calcDelta(t);
    const applyFriction = (t) => {
      const delta = calcDelta(t);
      const latest = calcLatest(t);
      state.done = Math.abs(delta) <= restDelta;
      state.value = state.done ? target : latest;
    };
    let timeReachedBoundary;
    let spring$1;
    const checkCatchBoundary = (t) => {
      if (!isOutOfBounds(state.value))
        return;
      timeReachedBoundary = t;
      spring$1 = spring({
        keyframes: [state.value, nearestBoundary(state.value)],
        velocity: calcGeneratorVelocity(calcLatest, t, state.value),
        // TODO: This should be passing * 1000
        damping: bounceDamping,
        stiffness: bounceStiffness,
        restDelta,
        restSpeed
      });
    };
    checkCatchBoundary(0);
    return {
      calculatedDuration: null,
      next: (t) => {
        let hasUpdatedFrame = false;
        if (!spring$1 && timeReachedBoundary === void 0) {
          hasUpdatedFrame = true;
          applyFriction(t);
          checkCatchBoundary(t);
        }
        if (timeReachedBoundary !== void 0 && t >= timeReachedBoundary) {
          return spring$1.next(t - timeReachedBoundary);
        } else {
          !hasUpdatedFrame && applyFriction(t);
          return state;
        }
      }
    };
  }

  // node_modules/motion-dom/dist/es/utils/interpolate.mjs
  function createMixers(output, ease2, customMixer) {
    const mixers = [];
    const mixerFactory = customMixer || MotionGlobalConfig.mix || mix;
    const numMixers = output.length - 1;
    for (let i = 0; i < numMixers; i++) {
      let mixer = mixerFactory(output[i], output[i + 1]);
      if (ease2) {
        const easingFunction = Array.isArray(ease2) ? ease2[i] || noop3 : ease2;
        mixer = pipe3(easingFunction, mixer);
      }
      mixers.push(mixer);
    }
    return mixers;
  }
  function interpolate3(input, output, { clamp: isClamp = true, ease: ease2, mixer } = {}) {
    const inputLength = input.length;
    invariant2(inputLength === output.length, "Both input and output ranges must be the same length", "range-length");
    if (inputLength === 1)
      return () => output[0];
    if (inputLength === 2 && output[0] === output[1])
      return () => output[1];
    const isZeroDeltaRange = input[0] === input[1];
    if (input[0] > input[inputLength - 1]) {
      input = [...input].reverse();
      output = [...output].reverse();
    }
    const mixers = createMixers(output, ease2, mixer);
    const numMixers = mixers.length;
    const interpolator = (v) => {
      if (isZeroDeltaRange && v < input[0])
        return output[0];
      let i = 0;
      if (numMixers > 1) {
        for (; i < input.length - 2; i++) {
          if (v < input[i + 1])
            break;
        }
      }
      const progressInRange = progress(input[i], input[i + 1], v);
      return mixers[i](progressInRange);
    };
    return isClamp ? (v) => interpolator(clamp3(input[0], input[inputLength - 1], v)) : interpolator;
  }

  // node_modules/motion-dom/dist/es/animation/keyframes/offsets/fill.mjs
  function fillOffset(offset, remaining) {
    const min = offset[offset.length - 1];
    for (let i = 1; i <= remaining; i++) {
      const offsetProgress = progress(0, remaining, i);
      offset.push(mixNumber(min, 1, offsetProgress));
    }
  }

  // node_modules/motion-dom/dist/es/animation/keyframes/offsets/default.mjs
  function defaultOffset(arr) {
    const offset = [0];
    fillOffset(offset, arr.length - 1);
    return offset;
  }

  // node_modules/motion-dom/dist/es/animation/keyframes/offsets/time.mjs
  function convertOffsetToTimes(offset, duration) {
    return offset.map((o) => o * duration);
  }

  // node_modules/motion-dom/dist/es/animation/generators/keyframes.mjs
  function defaultEasing(values, easing) {
    return values.map(() => easing || easeInOut).splice(0, values.length - 1);
  }
  function keyframes({ duration = 300, keyframes: keyframeValues, times, ease: ease2 = "easeInOut" }) {
    const easingFunctions = isEasingArray(ease2) ? ease2.map(easingDefinitionToFunction) : easingDefinitionToFunction(ease2);
    const state = {
      done: false,
      value: keyframeValues[0]
    };
    const absoluteTimes = convertOffsetToTimes(
      // Only use the provided offsets if they're the correct length
      // TODO Maybe we should warn here if there's a length mismatch
      times && times.length === keyframeValues.length ? times : defaultOffset(keyframeValues),
      duration
    );
    const mapTimeToKeyframe = interpolate3(absoluteTimes, keyframeValues, {
      ease: Array.isArray(easingFunctions) ? easingFunctions : defaultEasing(keyframeValues, easingFunctions)
    });
    return {
      calculatedDuration: duration,
      next: (t) => {
        state.value = mapTimeToKeyframe(t);
        state.done = t >= duration;
        return state;
      }
    };
  }

  // node_modules/motion-dom/dist/es/animation/keyframes/get-final.mjs
  var isNotNull = (value) => value !== null;
  function getFinalKeyframe(keyframes2, { repeat, repeatType = "loop" }, finalKeyframe, speed = 1) {
    const resolvedKeyframes = keyframes2.filter(isNotNull);
    const useFirstKeyframe = speed < 0 || repeat && repeatType !== "loop" && repeat % 2 === 1;
    const index = useFirstKeyframe ? 0 : resolvedKeyframes.length - 1;
    return !index || finalKeyframe === void 0 ? resolvedKeyframes[index] : finalKeyframe;
  }

  // node_modules/motion-dom/dist/es/animation/utils/replace-transition-type.mjs
  var transitionTypeMap = {
    decay: inertia,
    inertia,
    tween: keyframes,
    keyframes,
    spring
  };
  function replaceTransitionType(transition) {
    if (typeof transition.type === "string") {
      transition.type = transitionTypeMap[transition.type];
    }
  }

  // node_modules/motion-dom/dist/es/animation/utils/WithPromise.mjs
  var WithPromise = class {
    constructor() {
      this.updateFinished();
    }
    get finished() {
      return this._finished;
    }
    updateFinished() {
      this._finished = new Promise((resolve) => {
        this.resolve = resolve;
      });
    }
    notifyFinished() {
      this.resolve();
    }
    /**
     * Allows the animation to be awaited.
     *
     * @deprecated Use `finished` instead.
     */
    then(onResolve, onReject) {
      return this.finished.then(onResolve, onReject);
    }
  };

  // node_modules/motion-dom/dist/es/animation/JSAnimation.mjs
  var percentToProgress = (percent2) => percent2 / 100;
  var JSAnimation = class extends WithPromise {
    constructor(options) {
      super();
      this.state = "idle";
      this.startTime = null;
      this.isStopped = false;
      this.currentTime = 0;
      this.holdTime = null;
      this.playbackSpeed = 1;
      this.stop = () => {
        const { motionValue: motionValue2 } = this.options;
        if (motionValue2 && motionValue2.updatedAt !== time.now()) {
          this.tick(time.now());
        }
        this.isStopped = true;
        if (this.state === "idle")
          return;
        this.teardown();
        this.options.onStop?.();
      };
      activeAnimations.mainThread++;
      this.options = options;
      this.initAnimation();
      this.play();
      if (options.autoplay === false)
        this.pause();
    }
    initAnimation() {
      const { options } = this;
      replaceTransitionType(options);
      const { type = keyframes, repeat = 0, repeatDelay = 0, repeatType, velocity = 0 } = options;
      let { keyframes: keyframes$1 } = options;
      const generatorFactory = type || keyframes;
      if (generatorFactory !== keyframes) {
        invariant2(keyframes$1.length <= 2, `Only two keyframes currently supported with spring and inertia animations. Trying to animate ${keyframes$1}`, "spring-two-frames");
      }
      if (generatorFactory !== keyframes && typeof keyframes$1[0] !== "number") {
        this.mixKeyframes = pipe3(percentToProgress, mix(keyframes$1[0], keyframes$1[1]));
        keyframes$1 = [0, 100];
      }
      const generator = generatorFactory({ ...options, keyframes: keyframes$1 });
      if (repeatType === "mirror") {
        this.mirroredGenerator = generatorFactory({
          ...options,
          keyframes: [...keyframes$1].reverse(),
          velocity: -velocity
        });
      }
      if (generator.calculatedDuration === null) {
        generator.calculatedDuration = calcGeneratorDuration(generator);
      }
      const { calculatedDuration } = generator;
      this.calculatedDuration = calculatedDuration;
      this.resolvedDuration = calculatedDuration + repeatDelay;
      this.totalDuration = this.resolvedDuration * (repeat + 1) - repeatDelay;
      this.generator = generator;
    }
    updateTime(timestamp) {
      const animationTime = Math.round(timestamp - this.startTime) * this.playbackSpeed;
      if (this.holdTime !== null) {
        this.currentTime = this.holdTime;
      } else {
        this.currentTime = animationTime;
      }
    }
    tick(timestamp, sample = false) {
      const { generator, totalDuration, mixKeyframes, mirroredGenerator, resolvedDuration, calculatedDuration } = this;
      if (this.startTime === null)
        return generator.next(0);
      const { delay: delay2 = 0, keyframes: keyframes2, repeat, repeatType, repeatDelay, type, onUpdate, finalKeyframe } = this.options;
      if (this.speed > 0) {
        this.startTime = Math.min(this.startTime, timestamp);
      } else if (this.speed < 0) {
        this.startTime = Math.min(timestamp - totalDuration / this.speed, this.startTime);
      }
      if (sample) {
        this.currentTime = timestamp;
      } else {
        this.updateTime(timestamp);
      }
      const timeWithoutDelay = this.currentTime - delay2 * (this.playbackSpeed >= 0 ? 1 : -1);
      const isInDelayPhase = this.playbackSpeed >= 0 ? timeWithoutDelay < 0 : timeWithoutDelay > totalDuration;
      this.currentTime = Math.max(timeWithoutDelay, 0);
      if (this.state === "finished" && this.holdTime === null) {
        this.currentTime = totalDuration;
      }
      let elapsed = this.currentTime;
      let frameGenerator = generator;
      if (repeat) {
        const progress2 = Math.min(this.currentTime, totalDuration) / resolvedDuration;
        let currentIteration = Math.floor(progress2);
        let iterationProgress = progress2 % 1;
        if (!iterationProgress && progress2 >= 1) {
          iterationProgress = 1;
        }
        iterationProgress === 1 && currentIteration--;
        currentIteration = Math.min(currentIteration, repeat + 1);
        const isOddIteration = Boolean(currentIteration % 2);
        if (isOddIteration) {
          if (repeatType === "reverse") {
            iterationProgress = 1 - iterationProgress;
            if (repeatDelay) {
              iterationProgress -= repeatDelay / resolvedDuration;
            }
          } else if (repeatType === "mirror") {
            frameGenerator = mirroredGenerator;
          }
        }
        elapsed = clamp3(0, 1, iterationProgress) * resolvedDuration;
      }
      const state = isInDelayPhase ? { done: false, value: keyframes2[0] } : frameGenerator.next(elapsed);
      if (mixKeyframes) {
        state.value = mixKeyframes(state.value);
      }
      let { done } = state;
      if (!isInDelayPhase && calculatedDuration !== null) {
        done = this.playbackSpeed >= 0 ? this.currentTime >= totalDuration : this.currentTime <= 0;
      }
      const isAnimationFinished = this.holdTime === null && (this.state === "finished" || this.state === "running" && done);
      if (isAnimationFinished && type !== inertia) {
        state.value = getFinalKeyframe(keyframes2, this.options, finalKeyframe, this.speed);
      }
      if (onUpdate) {
        onUpdate(state.value);
      }
      if (isAnimationFinished) {
        this.finish();
      }
      return state;
    }
    /**
     * Allows the returned animation to be awaited or promise-chained. Currently
     * resolves when the animation finishes at all but in a future update could/should
     * reject if its cancels.
     */
    then(resolve, reject) {
      return this.finished.then(resolve, reject);
    }
    get duration() {
      return millisecondsToSeconds(this.calculatedDuration);
    }
    get iterationDuration() {
      const { delay: delay2 = 0 } = this.options || {};
      return this.duration + millisecondsToSeconds(delay2);
    }
    get time() {
      return millisecondsToSeconds(this.currentTime);
    }
    set time(newTime) {
      newTime = secondsToMilliseconds(newTime);
      this.currentTime = newTime;
      if (this.startTime === null || this.holdTime !== null || this.playbackSpeed === 0) {
        this.holdTime = newTime;
      } else if (this.driver) {
        this.startTime = this.driver.now() - newTime / this.playbackSpeed;
      }
      this.driver?.start(false);
    }
    get speed() {
      return this.playbackSpeed;
    }
    set speed(newSpeed) {
      this.updateTime(time.now());
      const hasChanged = this.playbackSpeed !== newSpeed;
      this.playbackSpeed = newSpeed;
      if (hasChanged) {
        this.time = millisecondsToSeconds(this.currentTime);
      }
    }
    play() {
      if (this.isStopped)
        return;
      const { driver = frameloopDriver, startTime } = this.options;
      if (!this.driver) {
        this.driver = driver((timestamp) => this.tick(timestamp));
      }
      this.options.onPlay?.();
      const now3 = this.driver.now();
      if (this.state === "finished") {
        this.updateFinished();
        this.startTime = now3;
      } else if (this.holdTime !== null) {
        this.startTime = now3 - this.holdTime;
      } else if (!this.startTime) {
        this.startTime = startTime ?? now3;
      }
      if (this.state === "finished" && this.speed < 0) {
        this.startTime += this.calculatedDuration;
      }
      this.holdTime = null;
      this.state = "running";
      this.driver.start();
    }
    pause() {
      this.state = "paused";
      this.updateTime(time.now());
      this.holdTime = this.currentTime;
    }
    complete() {
      if (this.state !== "running") {
        this.play();
      }
      this.state = "finished";
      this.holdTime = null;
    }
    finish() {
      this.notifyFinished();
      this.teardown();
      this.state = "finished";
      this.options.onComplete?.();
    }
    cancel() {
      this.holdTime = null;
      this.startTime = 0;
      this.tick(0);
      this.teardown();
      this.options.onCancel?.();
    }
    teardown() {
      this.state = "idle";
      this.stopDriver();
      this.startTime = this.holdTime = null;
      activeAnimations.mainThread--;
    }
    stopDriver() {
      if (!this.driver)
        return;
      this.driver.stop();
      this.driver = void 0;
    }
    sample(sampleTime) {
      this.startTime = 0;
      return this.tick(sampleTime, true);
    }
    attachTimeline(timeline2) {
      if (this.options.allowFlatten) {
        this.options.type = "keyframes";
        this.options.ease = "linear";
        this.initAnimation();
      }
      this.driver?.stop();
      return timeline2.observe(this);
    }
  };

  // node_modules/motion-dom/dist/es/animation/keyframes/utils/fill-wildcards.mjs
  function fillWildcards(keyframes2) {
    for (let i = 1; i < keyframes2.length; i++) {
      keyframes2[i] ?? (keyframes2[i] = keyframes2[i - 1]);
    }
  }

  // node_modules/motion-dom/dist/es/render/dom/parse-transform.mjs
  var radToDeg = (rad) => rad * 180 / Math.PI;
  var rotate = (v) => {
    const angle = radToDeg(Math.atan2(v[1], v[0]));
    return rebaseAngle(angle);
  };
  var matrix2dParsers = {
    x: 4,
    y: 5,
    translateX: 4,
    translateY: 5,
    scaleX: 0,
    scaleY: 3,
    scale: (v) => (Math.abs(v[0]) + Math.abs(v[3])) / 2,
    rotate,
    rotateZ: rotate,
    skewX: (v) => radToDeg(Math.atan(v[1])),
    skewY: (v) => radToDeg(Math.atan(v[2])),
    skew: (v) => (Math.abs(v[1]) + Math.abs(v[2])) / 2
  };
  var rebaseAngle = (angle) => {
    angle = angle % 360;
    if (angle < 0)
      angle += 360;
    return angle;
  };
  var rotateZ = rotate;
  var scaleX = (v) => Math.sqrt(v[0] * v[0] + v[1] * v[1]);
  var scaleY = (v) => Math.sqrt(v[4] * v[4] + v[5] * v[5]);
  var matrix3dParsers = {
    x: 12,
    y: 13,
    z: 14,
    translateX: 12,
    translateY: 13,
    translateZ: 14,
    scaleX,
    scaleY,
    scale: (v) => (scaleX(v) + scaleY(v)) / 2,
    rotateX: (v) => rebaseAngle(radToDeg(Math.atan2(v[6], v[5]))),
    rotateY: (v) => rebaseAngle(radToDeg(Math.atan2(-v[2], v[0]))),
    rotateZ,
    rotate: rotateZ,
    skewX: (v) => radToDeg(Math.atan(v[4])),
    skewY: (v) => radToDeg(Math.atan(v[1])),
    skew: (v) => (Math.abs(v[1]) + Math.abs(v[4])) / 2
  };
  function defaultTransformValue(name) {
    return name.includes("scale") ? 1 : 0;
  }
  function parseValueFromTransform(transform2, name) {
    if (!transform2 || transform2 === "none") {
      return defaultTransformValue(name);
    }
    const matrix3dMatch = transform2.match(/^matrix3d\(([-\d.e\s,]+)\)$/u);
    let parsers;
    let match;
    if (matrix3dMatch) {
      parsers = matrix3dParsers;
      match = matrix3dMatch;
    } else {
      const matrix2dMatch = transform2.match(/^matrix\(([-\d.e\s,]+)\)$/u);
      parsers = matrix2dParsers;
      match = matrix2dMatch;
    }
    if (!match) {
      return defaultTransformValue(name);
    }
    const valueParser = parsers[name];
    const values = match[1].split(",").map(convertTransformToNumber);
    return typeof valueParser === "function" ? valueParser(values) : values[valueParser];
  }
  var readTransformValue = (instance, name) => {
    const { transform: transform2 = "none" } = getComputedStyle(instance);
    return parseValueFromTransform(transform2, name);
  };
  function convertTransformToNumber(value) {
    return parseFloat(value.trim());
  }

  // node_modules/motion-dom/dist/es/render/utils/keys-transform.mjs
  var transformPropOrder = [
    "transformPerspective",
    "x",
    "y",
    "z",
    "translateX",
    "translateY",
    "translateZ",
    "scale",
    "scaleX",
    "scaleY",
    "rotate",
    "rotateX",
    "rotateY",
    "rotateZ",
    "skew",
    "skewX",
    "skewY"
  ];
  var transformProps = /* @__PURE__ */ (() => new Set(transformPropOrder))();

  // node_modules/motion-dom/dist/es/animation/keyframes/utils/unit-conversion.mjs
  var isNumOrPxType = (v) => v === number || v === px;
  var transformKeys = /* @__PURE__ */ new Set(["x", "y", "z"]);
  var nonTranslationalTransformKeys = transformPropOrder.filter((key) => !transformKeys.has(key));
  function removeNonTranslationalTransform(visualElement) {
    const removedTransforms = [];
    nonTranslationalTransformKeys.forEach((key) => {
      const value = visualElement.getValue(key);
      if (value !== void 0) {
        removedTransforms.push([key, value.get()]);
        value.set(key.startsWith("scale") ? 1 : 0);
      }
    });
    return removedTransforms;
  }
  var positionalValues = {
    // Dimensions
    width: ({ x }, { paddingLeft = "0", paddingRight = "0" }) => x.max - x.min - parseFloat(paddingLeft) - parseFloat(paddingRight),
    height: ({ y }, { paddingTop = "0", paddingBottom = "0" }) => y.max - y.min - parseFloat(paddingTop) - parseFloat(paddingBottom),
    top: (_bbox, { top }) => parseFloat(top),
    left: (_bbox, { left }) => parseFloat(left),
    bottom: ({ y }, { top }) => parseFloat(top) + (y.max - y.min),
    right: ({ x }, { left }) => parseFloat(left) + (x.max - x.min),
    // Transform
    x: (_bbox, { transform: transform2 }) => parseValueFromTransform(transform2, "x"),
    y: (_bbox, { transform: transform2 }) => parseValueFromTransform(transform2, "y")
  };
  positionalValues.translateX = positionalValues.x;
  positionalValues.translateY = positionalValues.y;

  // node_modules/motion-dom/dist/es/animation/keyframes/KeyframesResolver.mjs
  var toResolve = /* @__PURE__ */ new Set();
  var isScheduled = false;
  var anyNeedsMeasurement = false;
  var isForced = false;
  function measureAllKeyframes() {
    if (anyNeedsMeasurement) {
      const resolversToMeasure = Array.from(toResolve).filter((resolver) => resolver.needsMeasurement);
      const elementsToMeasure = new Set(resolversToMeasure.map((resolver) => resolver.element));
      const transformsToRestore = /* @__PURE__ */ new Map();
      elementsToMeasure.forEach((element) => {
        const removedTransforms = removeNonTranslationalTransform(element);
        if (!removedTransforms.length)
          return;
        transformsToRestore.set(element, removedTransforms);
        element.render();
      });
      resolversToMeasure.forEach((resolver) => resolver.measureInitialState());
      elementsToMeasure.forEach((element) => {
        element.render();
        const restore = transformsToRestore.get(element);
        if (restore) {
          restore.forEach(([key, value]) => {
            element.getValue(key)?.set(value);
          });
        }
      });
      resolversToMeasure.forEach((resolver) => resolver.measureEndState());
      resolversToMeasure.forEach((resolver) => {
        if (resolver.suspendedScrollY !== void 0) {
          window.scrollTo(0, resolver.suspendedScrollY);
        }
      });
    }
    anyNeedsMeasurement = false;
    isScheduled = false;
    toResolve.forEach((resolver) => resolver.complete(isForced));
    toResolve.clear();
  }
  function readAllKeyframes() {
    toResolve.forEach((resolver) => {
      resolver.readKeyframes();
      if (resolver.needsMeasurement) {
        anyNeedsMeasurement = true;
      }
    });
  }
  function flushKeyframeResolvers() {
    isForced = true;
    readAllKeyframes();
    measureAllKeyframes();
    isForced = false;
  }
  var KeyframeResolver = class {
    constructor(unresolvedKeyframes, onComplete, name, motionValue2, element, isAsync = false) {
      this.state = "pending";
      this.isAsync = false;
      this.needsMeasurement = false;
      this.unresolvedKeyframes = [...unresolvedKeyframes];
      this.onComplete = onComplete;
      this.name = name;
      this.motionValue = motionValue2;
      this.element = element;
      this.isAsync = isAsync;
    }
    scheduleResolve() {
      this.state = "scheduled";
      if (this.isAsync) {
        toResolve.add(this);
        if (!isScheduled) {
          isScheduled = true;
          frame.read(readAllKeyframes);
          frame.resolveKeyframes(measureAllKeyframes);
        }
      } else {
        this.readKeyframes();
        this.complete();
      }
    }
    readKeyframes() {
      const { unresolvedKeyframes, name, element, motionValue: motionValue2 } = this;
      if (unresolvedKeyframes[0] === null) {
        const currentValue = motionValue2?.get();
        const finalKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];
        if (currentValue !== void 0) {
          unresolvedKeyframes[0] = currentValue;
        } else if (element && name) {
          const valueAsRead = element.readValue(name, finalKeyframe);
          if (valueAsRead !== void 0 && valueAsRead !== null) {
            unresolvedKeyframes[0] = valueAsRead;
          }
        }
        if (unresolvedKeyframes[0] === void 0) {
          unresolvedKeyframes[0] = finalKeyframe;
        }
        if (motionValue2 && currentValue === void 0) {
          motionValue2.set(unresolvedKeyframes[0]);
        }
      }
      fillWildcards(unresolvedKeyframes);
    }
    setFinalKeyframe() {
    }
    measureInitialState() {
    }
    renderEndStyles() {
    }
    measureEndState() {
    }
    complete(isForcedComplete = false) {
      this.state = "complete";
      this.onComplete(this.unresolvedKeyframes, this.finalKeyframe, isForcedComplete);
      toResolve.delete(this);
    }
    cancel() {
      if (this.state === "scheduled") {
        toResolve.delete(this);
        this.state = "pending";
      }
    }
    resume() {
      if (this.state === "pending")
        this.scheduleResolve();
    }
  };

  // node_modules/motion-dom/dist/es/render/dom/is-css-var.mjs
  var isCSSVar = (name) => name.startsWith("--");

  // node_modules/motion-dom/dist/es/render/dom/style-set.mjs
  function setStyle(element, name, value) {
    isCSSVar(name) ? element.style.setProperty(name, value) : element.style[name] = value;
  }

  // node_modules/motion-dom/dist/es/utils/supports/scroll-timeline.mjs
  var supportsScrollTimeline = /* @__PURE__ */ memo2(() => window.ScrollTimeline !== void 0);

  // node_modules/motion-dom/dist/es/utils/supports/flags.mjs
  var supportsFlags = {};

  // node_modules/motion-dom/dist/es/utils/supports/memo.mjs
  function memoSupports(callback, supportsFlag) {
    const memoized = memo2(callback);
    return () => supportsFlags[supportsFlag] ?? memoized();
  }

  // node_modules/motion-dom/dist/es/utils/supports/linear-easing.mjs
  var supportsLinearEasing = /* @__PURE__ */ memoSupports(() => {
    try {
      document.createElement("div").animate({ opacity: 0 }, { easing: "linear(0, 1)" });
    } catch (e) {
      return false;
    }
    return true;
  }, "linearEasing");

  // node_modules/motion-dom/dist/es/animation/waapi/easing/cubic-bezier.mjs
  var cubicBezierAsString = ([a, b, c, d]) => `cubic-bezier(${a}, ${b}, ${c}, ${d})`;

  // node_modules/motion-dom/dist/es/animation/waapi/easing/supported.mjs
  var supportedWaapiEasing = {
    linear: "linear",
    ease: "ease",
    easeIn: "ease-in",
    easeOut: "ease-out",
    easeInOut: "ease-in-out",
    circIn: /* @__PURE__ */ cubicBezierAsString([0, 0.65, 0.55, 1]),
    circOut: /* @__PURE__ */ cubicBezierAsString([0.55, 0, 1, 0.45]),
    backIn: /* @__PURE__ */ cubicBezierAsString([0.31, 0.01, 0.66, -0.59]),
    backOut: /* @__PURE__ */ cubicBezierAsString([0.33, 1.53, 0.69, 0.99])
  };

  // node_modules/motion-dom/dist/es/animation/waapi/easing/map-easing.mjs
  function mapEasingToNativeEasing(easing, duration) {
    if (!easing) {
      return void 0;
    } else if (typeof easing === "function") {
      return supportsLinearEasing() ? generateLinearEasing(easing, duration) : "ease-out";
    } else if (isBezierDefinition(easing)) {
      return cubicBezierAsString(easing);
    } else if (Array.isArray(easing)) {
      return easing.map((segmentEasing) => mapEasingToNativeEasing(segmentEasing, duration) || supportedWaapiEasing.easeOut);
    } else {
      return supportedWaapiEasing[easing];
    }
  }

  // node_modules/motion-dom/dist/es/animation/waapi/start-waapi-animation.mjs
  function startWaapiAnimation(element, valueName, keyframes2, { delay: delay2 = 0, duration = 300, repeat = 0, repeatType = "loop", ease: ease2 = "easeOut", times } = {}, pseudoElement = void 0) {
    const keyframeOptions = {
      [valueName]: keyframes2
    };
    if (times)
      keyframeOptions.offset = times;
    const easing = mapEasingToNativeEasing(ease2, duration);
    if (Array.isArray(easing))
      keyframeOptions.easing = easing;
    if (statsBuffer.value) {
      activeAnimations.waapi++;
    }
    const options = {
      delay: delay2,
      duration,
      easing: !Array.isArray(easing) ? easing : "linear",
      fill: "both",
      iterations: repeat + 1,
      direction: repeatType === "reverse" ? "alternate" : "normal"
    };
    if (pseudoElement)
      options.pseudoElement = pseudoElement;
    const animation = element.animate(keyframeOptions, options);
    if (statsBuffer.value) {
      animation.finished.finally(() => {
        activeAnimations.waapi--;
      });
    }
    return animation;
  }

  // node_modules/motion-dom/dist/es/animation/generators/utils/is-generator.mjs
  function isGenerator(type) {
    return typeof type === "function" && "applyToOptions" in type;
  }

  // node_modules/motion-dom/dist/es/animation/waapi/utils/apply-generator.mjs
  function applyGeneratorOptions({ type, ...options }) {
    if (isGenerator(type) && supportsLinearEasing()) {
      return type.applyToOptions(options);
    } else {
      options.duration ?? (options.duration = 300);
      options.ease ?? (options.ease = "easeOut");
    }
    return options;
  }

  // node_modules/motion-dom/dist/es/animation/NativeAnimation.mjs
  var NativeAnimation = class extends WithPromise {
    constructor(options) {
      super();
      this.finishedTime = null;
      this.isStopped = false;
      if (!options)
        return;
      const { element, name, keyframes: keyframes2, pseudoElement, allowFlatten = false, finalKeyframe, onComplete } = options;
      this.isPseudoElement = Boolean(pseudoElement);
      this.allowFlatten = allowFlatten;
      this.options = options;
      invariant2(typeof options.type !== "string", `Mini animate() doesn't support "type" as a string.`, "mini-spring");
      const transition = applyGeneratorOptions(options);
      this.animation = startWaapiAnimation(element, name, keyframes2, transition, pseudoElement);
      if (transition.autoplay === false) {
        this.animation.pause();
      }
      this.animation.onfinish = () => {
        this.finishedTime = this.time;
        if (!pseudoElement) {
          const keyframe = getFinalKeyframe(keyframes2, this.options, finalKeyframe, this.speed);
          if (this.updateMotionValue) {
            this.updateMotionValue(keyframe);
          } else {
            setStyle(element, name, keyframe);
          }
          this.animation.cancel();
        }
        onComplete?.();
        this.notifyFinished();
      };
    }
    play() {
      if (this.isStopped)
        return;
      this.animation.play();
      if (this.state === "finished") {
        this.updateFinished();
      }
    }
    pause() {
      this.animation.pause();
    }
    complete() {
      this.animation.finish?.();
    }
    cancel() {
      try {
        this.animation.cancel();
      } catch (e) {
      }
    }
    stop() {
      if (this.isStopped)
        return;
      this.isStopped = true;
      const { state } = this;
      if (state === "idle" || state === "finished") {
        return;
      }
      if (this.updateMotionValue) {
        this.updateMotionValue();
      } else {
        this.commitStyles();
      }
      if (!this.isPseudoElement)
        this.cancel();
    }
    /**
     * WAAPI doesn't natively have any interruption capabilities.
     *
     * In this method, we commit styles back to the DOM before cancelling
     * the animation.
     *
     * This is designed to be overridden by NativeAnimationExtended, which
     * will create a renderless JS animation and sample it twice to calculate
     * its current value, "previous" value, and therefore allow
     * Motion to also correctly calculate velocity for any subsequent animation
     * while deferring the commit until the next animation frame.
     */
    commitStyles() {
      if (!this.isPseudoElement) {
        this.animation.commitStyles?.();
      }
    }
    get duration() {
      const duration = this.animation.effect?.getComputedTiming?.().duration || 0;
      return millisecondsToSeconds(Number(duration));
    }
    get iterationDuration() {
      const { delay: delay2 = 0 } = this.options || {};
      return this.duration + millisecondsToSeconds(delay2);
    }
    get time() {
      return millisecondsToSeconds(Number(this.animation.currentTime) || 0);
    }
    set time(newTime) {
      this.finishedTime = null;
      this.animation.currentTime = secondsToMilliseconds(newTime);
    }
    /**
     * The playback speed of the animation.
     * 1 = normal speed, 2 = double speed, 0.5 = half speed.
     */
    get speed() {
      return this.animation.playbackRate;
    }
    set speed(newSpeed) {
      if (newSpeed < 0)
        this.finishedTime = null;
      this.animation.playbackRate = newSpeed;
    }
    get state() {
      return this.finishedTime !== null ? "finished" : this.animation.playState;
    }
    get startTime() {
      return Number(this.animation.startTime);
    }
    set startTime(newStartTime) {
      this.animation.startTime = newStartTime;
    }
    /**
     * Attaches a timeline to the animation, for instance the `ScrollTimeline`.
     */
    attachTimeline({ timeline: timeline2, observe }) {
      if (this.allowFlatten) {
        this.animation.effect?.updateTiming({ easing: "linear" });
      }
      this.animation.onfinish = null;
      if (timeline2 && supportsScrollTimeline()) {
        this.animation.timeline = timeline2;
        return noop3;
      } else {
        return observe(this);
      }
    }
  };

  // node_modules/motion-dom/dist/es/animation/waapi/utils/unsupported-easing.mjs
  var unsupportedEasingFunctions = {
    anticipate,
    backInOut,
    circInOut
  };
  function isUnsupportedEase(key) {
    return key in unsupportedEasingFunctions;
  }
  function replaceStringEasing(transition) {
    if (typeof transition.ease === "string" && isUnsupportedEase(transition.ease)) {
      transition.ease = unsupportedEasingFunctions[transition.ease];
    }
  }

  // node_modules/motion-dom/dist/es/animation/NativeAnimationExtended.mjs
  var sampleDelta = 10;
  var NativeAnimationExtended = class extends NativeAnimation {
    constructor(options) {
      replaceStringEasing(options);
      replaceTransitionType(options);
      super(options);
      if (options.startTime) {
        this.startTime = options.startTime;
      }
      this.options = options;
    }
    /**
     * WAAPI doesn't natively have any interruption capabilities.
     *
     * Rather than read commited styles back out of the DOM, we can
     * create a renderless JS animation and sample it twice to calculate
     * its current value, "previous" value, and therefore allow
     * Motion to calculate velocity for any subsequent animation.
     */
    updateMotionValue(value) {
      const { motionValue: motionValue2, onUpdate, onComplete, element, ...options } = this.options;
      if (!motionValue2)
        return;
      if (value !== void 0) {
        motionValue2.set(value);
        return;
      }
      const sampleAnimation = new JSAnimation({
        ...options,
        autoplay: false
      });
      const sampleTime = secondsToMilliseconds(this.finishedTime ?? this.time);
      motionValue2.setWithVelocity(sampleAnimation.sample(sampleTime - sampleDelta).value, sampleAnimation.sample(sampleTime).value, sampleDelta);
      sampleAnimation.stop();
    }
  };

  // node_modules/motion-dom/dist/es/animation/utils/is-animatable.mjs
  var isAnimatable = (value, name) => {
    if (name === "zIndex")
      return false;
    if (typeof value === "number" || Array.isArray(value))
      return true;
    if (typeof value === "string" && // It's animatable if we have a string
    (complex.test(value) || value === "0") && // And it contains numbers and/or colors
    !value.startsWith("url(")) {
      return true;
    }
    return false;
  };

  // node_modules/motion-dom/dist/es/animation/utils/can-animate.mjs
  function hasKeyframesChanged(keyframes2) {
    const current = keyframes2[0];
    if (keyframes2.length === 1)
      return true;
    for (let i = 0; i < keyframes2.length; i++) {
      if (keyframes2[i] !== current)
        return true;
    }
  }
  function canAnimate(keyframes2, name, type, velocity) {
    const originKeyframe = keyframes2[0];
    if (originKeyframe === null)
      return false;
    if (name === "display" || name === "visibility")
      return true;
    const targetKeyframe = keyframes2[keyframes2.length - 1];
    const isOriginAnimatable = isAnimatable(originKeyframe, name);
    const isTargetAnimatable = isAnimatable(targetKeyframe, name);
    warning2(isOriginAnimatable === isTargetAnimatable, `You are trying to animate ${name} from "${originKeyframe}" to "${targetKeyframe}". "${isOriginAnimatable ? targetKeyframe : originKeyframe}" is not an animatable value.`, "value-not-animatable");
    if (!isOriginAnimatable || !isTargetAnimatable) {
      return false;
    }
    return hasKeyframesChanged(keyframes2) || (type === "spring" || isGenerator(type)) && velocity;
  }

  // node_modules/motion-dom/dist/es/animation/utils/make-animation-instant.mjs
  function makeAnimationInstant(options) {
    options.duration = 0;
    options.type = "keyframes";
  }

  // node_modules/motion-dom/dist/es/animation/waapi/supports/waapi.mjs
  var acceleratedValues = /* @__PURE__ */ new Set([
    "opacity",
    "clipPath",
    "filter",
    "transform"
    // TODO: Could be re-enabled now we have support for linear() easing
    // "background-color"
  ]);
  var supportsWaapi = /* @__PURE__ */ memo2(() => Object.hasOwnProperty.call(Element.prototype, "animate"));
  function supportsBrowserAnimation(options) {
    const { motionValue: motionValue2, name, repeatDelay, repeatType, damping, type } = options;
    const subject = motionValue2?.owner?.current;
    if (!(subject instanceof HTMLElement)) {
      return false;
    }
    const { onUpdate, transformTemplate } = motionValue2.owner.getProps();
    return supportsWaapi() && name && acceleratedValues.has(name) && (name !== "transform" || !transformTemplate) && /**
     * If we're outputting values to onUpdate then we can't use WAAPI as there's
     * no way to read the value from WAAPI every frame.
     */
    !onUpdate && !repeatDelay && repeatType !== "mirror" && damping !== 0 && type !== "inertia";
  }

  // node_modules/motion-dom/dist/es/animation/AsyncMotionValueAnimation.mjs
  var MAX_RESOLVE_DELAY = 40;
  var AsyncMotionValueAnimation = class extends WithPromise {
    constructor({ autoplay = true, delay: delay2 = 0, type = "keyframes", repeat = 0, repeatDelay = 0, repeatType = "loop", keyframes: keyframes2, name, motionValue: motionValue2, element, ...options }) {
      super();
      this.stop = () => {
        if (this._animation) {
          this._animation.stop();
          this.stopTimeline?.();
        }
        this.keyframeResolver?.cancel();
      };
      this.createdAt = time.now();
      const optionsWithDefaults = {
        autoplay,
        delay: delay2,
        type,
        repeat,
        repeatDelay,
        repeatType,
        name,
        motionValue: motionValue2,
        element,
        ...options
      };
      const KeyframeResolver$1 = element?.KeyframeResolver || KeyframeResolver;
      this.keyframeResolver = new KeyframeResolver$1(keyframes2, (resolvedKeyframes, finalKeyframe, forced) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe, optionsWithDefaults, !forced), name, motionValue2, element);
      this.keyframeResolver?.scheduleResolve();
    }
    onKeyframesResolved(keyframes2, finalKeyframe, options, sync) {
      this.keyframeResolver = void 0;
      const { name, type, velocity, delay: delay2, isHandoff, onUpdate } = options;
      this.resolvedAt = time.now();
      if (!canAnimate(keyframes2, name, type, velocity)) {
        if (MotionGlobalConfig.instantAnimations || !delay2) {
          onUpdate?.(getFinalKeyframe(keyframes2, options, finalKeyframe));
        }
        keyframes2[0] = keyframes2[keyframes2.length - 1];
        makeAnimationInstant(options);
        options.repeat = 0;
      }
      const startTime = sync ? !this.resolvedAt ? this.createdAt : this.resolvedAt - this.createdAt > MAX_RESOLVE_DELAY ? this.resolvedAt : this.createdAt : void 0;
      const resolvedOptions = {
        startTime,
        finalKeyframe,
        ...options,
        keyframes: keyframes2
      };
      const animation = !isHandoff && supportsBrowserAnimation(resolvedOptions) ? new NativeAnimationExtended({
        ...resolvedOptions,
        element: resolvedOptions.motionValue.owner.current
      }) : new JSAnimation(resolvedOptions);
      animation.finished.then(() => this.notifyFinished()).catch(noop3);
      if (this.pendingTimeline) {
        this.stopTimeline = animation.attachTimeline(this.pendingTimeline);
        this.pendingTimeline = void 0;
      }
      this._animation = animation;
    }
    get finished() {
      if (!this._animation) {
        return this._finished;
      } else {
        return this.animation.finished;
      }
    }
    then(onResolve, _onReject) {
      return this.finished.finally(onResolve).then(() => {
      });
    }
    get animation() {
      if (!this._animation) {
        this.keyframeResolver?.resume();
        flushKeyframeResolvers();
      }
      return this._animation;
    }
    get duration() {
      return this.animation.duration;
    }
    get iterationDuration() {
      return this.animation.iterationDuration;
    }
    get time() {
      return this.animation.time;
    }
    set time(newTime) {
      this.animation.time = newTime;
    }
    get speed() {
      return this.animation.speed;
    }
    get state() {
      return this.animation.state;
    }
    set speed(newSpeed) {
      this.animation.speed = newSpeed;
    }
    get startTime() {
      return this.animation.startTime;
    }
    attachTimeline(timeline2) {
      if (this._animation) {
        this.stopTimeline = this.animation.attachTimeline(timeline2);
      } else {
        this.pendingTimeline = timeline2;
      }
      return () => this.stop();
    }
    play() {
      this.animation.play();
    }
    pause() {
      this.animation.pause();
    }
    complete() {
      this.animation.complete();
    }
    cancel() {
      if (this._animation) {
        this.animation.cancel();
      }
      this.keyframeResolver?.cancel();
    }
  };

  // node_modules/motion-dom/dist/es/animation/utils/css-variables-conversion.mjs
  var splitCSSVariableRegex = (
    // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive, as it can match a lot of words
    /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u
  );
  function parseCSSVariable(current) {
    const match = splitCSSVariableRegex.exec(current);
    if (!match)
      return [,];
    const [, token1, token2, fallback] = match;
    return [`--${token1 ?? token2}`, fallback];
  }
  var maxDepth = 4;
  function getVariableValue(current, element, depth = 1) {
    invariant2(depth <= maxDepth, `Max CSS variable fallback depth detected in property "${current}". This may indicate a circular fallback dependency.`, "max-css-var-depth");
    const [token, fallback] = parseCSSVariable(current);
    if (!token)
      return;
    const resolved = window.getComputedStyle(element).getPropertyValue(token);
    if (resolved) {
      const trimmed = resolved.trim();
      return isNumericalString(trimmed) ? parseFloat(trimmed) : trimmed;
    }
    return isCSSVariableToken(fallback) ? getVariableValue(fallback, element, depth + 1) : fallback;
  }

  // node_modules/motion-dom/dist/es/animation/utils/get-value-transition.mjs
  function getValueTransition(transition, key) {
    return transition?.[key] ?? transition?.["default"] ?? transition;
  }

  // node_modules/motion-dom/dist/es/render/utils/keys-position.mjs
  var positionalKeys = /* @__PURE__ */ new Set([
    "width",
    "height",
    "top",
    "left",
    "right",
    "bottom",
    ...transformPropOrder
  ]);

  // node_modules/motion-dom/dist/es/value/types/auto.mjs
  var auto = {
    test: (v) => v === "auto",
    parse: (v) => v
  };

  // node_modules/motion-dom/dist/es/value/types/test.mjs
  var testValueType = (v) => (type) => type.test(v);

  // node_modules/motion-dom/dist/es/value/types/dimensions.mjs
  var dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto];
  var findDimensionValueType = (v) => dimensionValueTypes.find(testValueType(v));

  // node_modules/motion-dom/dist/es/animation/keyframes/utils/is-none.mjs
  function isNone(value) {
    if (typeof value === "number") {
      return value === 0;
    } else if (value !== null) {
      return value === "none" || value === "0" || isZeroValueString(value);
    } else {
      return true;
    }
  }

  // node_modules/motion-dom/dist/es/value/types/complex/filter.mjs
  var maxDefaults = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
  function applyDefaultFilter(v) {
    const [name, value] = v.slice(0, -1).split("(");
    if (name === "drop-shadow")
      return v;
    const [number2] = value.match(floatRegex) || [];
    if (!number2)
      return v;
    const unit = value.replace(number2, "");
    let defaultValue = maxDefaults.has(name) ? 1 : 0;
    if (number2 !== value)
      defaultValue *= 100;
    return name + "(" + defaultValue + unit + ")";
  }
  var functionRegex = /\b([a-z-]*)\(.*?\)/gu;
  var filter = {
    ...complex,
    getAnimatableNone: (v) => {
      const functions = v.match(functionRegex);
      return functions ? functions.map(applyDefaultFilter).join(" ") : v;
    }
  };

  // node_modules/motion-dom/dist/es/value/types/int.mjs
  var int = {
    ...number,
    transform: Math.round
  };

  // node_modules/motion-dom/dist/es/value/types/maps/transform.mjs
  var transformValueTypes = {
    rotate: degrees,
    rotateX: degrees,
    rotateY: degrees,
    rotateZ: degrees,
    scale,
    scaleX: scale,
    scaleY: scale,
    scaleZ: scale,
    skew: degrees,
    skewX: degrees,
    skewY: degrees,
    distance: px,
    translateX: px,
    translateY: px,
    translateZ: px,
    x: px,
    y: px,
    z: px,
    perspective: px,
    transformPerspective: px,
    opacity: alpha,
    originX: progressPercentage,
    originY: progressPercentage,
    originZ: px
  };

  // node_modules/motion-dom/dist/es/value/types/maps/number.mjs
  var numberValueTypes = {
    // Border props
    borderWidth: px,
    borderTopWidth: px,
    borderRightWidth: px,
    borderBottomWidth: px,
    borderLeftWidth: px,
    borderRadius: px,
    radius: px,
    borderTopLeftRadius: px,
    borderTopRightRadius: px,
    borderBottomRightRadius: px,
    borderBottomLeftRadius: px,
    // Positioning props
    width: px,
    maxWidth: px,
    height: px,
    maxHeight: px,
    top: px,
    right: px,
    bottom: px,
    left: px,
    // Spacing props
    padding: px,
    paddingTop: px,
    paddingRight: px,
    paddingBottom: px,
    paddingLeft: px,
    margin: px,
    marginTop: px,
    marginRight: px,
    marginBottom: px,
    marginLeft: px,
    // Misc
    backgroundPositionX: px,
    backgroundPositionY: px,
    ...transformValueTypes,
    zIndex: int,
    // SVG
    fillOpacity: alpha,
    strokeOpacity: alpha,
    numOctaves: int
  };

  // node_modules/motion-dom/dist/es/value/types/maps/defaults.mjs
  var defaultValueTypes = {
    ...numberValueTypes,
    // Color props
    color,
    backgroundColor: color,
    outlineColor: color,
    fill: color,
    stroke: color,
    // Border props
    borderColor: color,
    borderTopColor: color,
    borderRightColor: color,
    borderBottomColor: color,
    borderLeftColor: color,
    filter,
    WebkitFilter: filter
  };
  var getDefaultValueType = (key) => defaultValueTypes[key];

  // node_modules/motion-dom/dist/es/value/types/utils/animatable-none.mjs
  function getAnimatableNone2(key, value) {
    let defaultValueType = getDefaultValueType(key);
    if (defaultValueType !== filter)
      defaultValueType = complex;
    return defaultValueType.getAnimatableNone ? defaultValueType.getAnimatableNone(value) : void 0;
  }

  // node_modules/motion-dom/dist/es/animation/keyframes/utils/make-none-animatable.mjs
  var invalidTemplates = /* @__PURE__ */ new Set(["auto", "none", "0"]);
  function makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name) {
    let i = 0;
    let animatableTemplate = void 0;
    while (i < unresolvedKeyframes.length && !animatableTemplate) {
      const keyframe = unresolvedKeyframes[i];
      if (typeof keyframe === "string" && !invalidTemplates.has(keyframe) && analyseComplexValue(keyframe).values.length) {
        animatableTemplate = unresolvedKeyframes[i];
      }
      i++;
    }
    if (animatableTemplate && name) {
      for (const noneIndex of noneKeyframeIndexes) {
        unresolvedKeyframes[noneIndex] = getAnimatableNone2(name, animatableTemplate);
      }
    }
  }

  // node_modules/motion-dom/dist/es/animation/keyframes/DOMKeyframesResolver.mjs
  var DOMKeyframesResolver = class extends KeyframeResolver {
    constructor(unresolvedKeyframes, onComplete, name, motionValue2, element) {
      super(unresolvedKeyframes, onComplete, name, motionValue2, element, true);
    }
    readKeyframes() {
      const { unresolvedKeyframes, element, name } = this;
      if (!element || !element.current)
        return;
      super.readKeyframes();
      for (let i = 0; i < unresolvedKeyframes.length; i++) {
        let keyframe = unresolvedKeyframes[i];
        if (typeof keyframe === "string") {
          keyframe = keyframe.trim();
          if (isCSSVariableToken(keyframe)) {
            const resolved = getVariableValue(keyframe, element.current);
            if (resolved !== void 0) {
              unresolvedKeyframes[i] = resolved;
            }
            if (i === unresolvedKeyframes.length - 1) {
              this.finalKeyframe = keyframe;
            }
          }
        }
      }
      this.resolveNoneKeyframes();
      if (!positionalKeys.has(name) || unresolvedKeyframes.length !== 2) {
        return;
      }
      const [origin, target] = unresolvedKeyframes;
      const originType = findDimensionValueType(origin);
      const targetType = findDimensionValueType(target);
      if (originType === targetType)
        return;
      if (isNumOrPxType(originType) && isNumOrPxType(targetType)) {
        for (let i = 0; i < unresolvedKeyframes.length; i++) {
          const value = unresolvedKeyframes[i];
          if (typeof value === "string") {
            unresolvedKeyframes[i] = parseFloat(value);
          }
        }
      } else if (positionalValues[name]) {
        this.needsMeasurement = true;
      }
    }
    resolveNoneKeyframes() {
      const { unresolvedKeyframes, name } = this;
      const noneKeyframeIndexes = [];
      for (let i = 0; i < unresolvedKeyframes.length; i++) {
        if (unresolvedKeyframes[i] === null || isNone(unresolvedKeyframes[i])) {
          noneKeyframeIndexes.push(i);
        }
      }
      if (noneKeyframeIndexes.length) {
        makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name);
      }
    }
    measureInitialState() {
      const { element, unresolvedKeyframes, name } = this;
      if (!element || !element.current)
        return;
      if (name === "height") {
        this.suspendedScrollY = window.pageYOffset;
      }
      this.measuredOrigin = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));
      unresolvedKeyframes[0] = this.measuredOrigin;
      const measureKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];
      if (measureKeyframe !== void 0) {
        element.getValue(name, measureKeyframe).jump(measureKeyframe, false);
      }
    }
    measureEndState() {
      const { element, name, unresolvedKeyframes } = this;
      if (!element || !element.current)
        return;
      const value = element.getValue(name);
      value && value.jump(this.measuredOrigin, false);
      const finalKeyframeIndex = unresolvedKeyframes.length - 1;
      const finalKeyframe = unresolvedKeyframes[finalKeyframeIndex];
      unresolvedKeyframes[finalKeyframeIndex] = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));
      if (finalKeyframe !== null && this.finalKeyframe === void 0) {
        this.finalKeyframe = finalKeyframe;
      }
      if (this.removedTransforms?.length) {
        this.removedTransforms.forEach(([unsetTransformName, unsetTransformValue]) => {
          element.getValue(unsetTransformName).set(unsetTransformValue);
        });
      }
      this.resolveNoneKeyframes();
    }
  };

  // node_modules/motion-dom/dist/es/utils/resolve-elements.mjs
  function resolveElements(elementOrSelector, scope, selectorCache) {
    if (elementOrSelector instanceof EventTarget) {
      return [elementOrSelector];
    } else if (typeof elementOrSelector === "string") {
      let root2 = document;
      if (scope) {
        root2 = scope.current;
      }
      const elements = selectorCache?.[elementOrSelector] ?? root2.querySelectorAll(elementOrSelector);
      return elements ? Array.from(elements) : [];
    }
    return Array.from(elementOrSelector);
  }

  // node_modules/motion-dom/dist/es/value/types/utils/get-as-type.mjs
  var getValueAsType = (value, type) => {
    return type && typeof value === "number" ? type.transform(value) : value;
  };

  // node_modules/motion-dom/dist/es/utils/is-html-element.mjs
  function isHTMLElement(element) {
    return isObject(element) && "offsetHeight" in element;
  }

  // node_modules/motion-dom/dist/es/value/index.mjs
  var MAX_VELOCITY_DELTA = 30;
  var isFloat = (value) => {
    return !isNaN(parseFloat(value));
  };
  var collectMotionValues = {
    current: void 0
  };
  var MotionValue = class {
    /**
     * @param init - The initiating value
     * @param config - Optional configuration options
     *
     * -  `transformer`: A function to transform incoming values with.
     */
    constructor(init5, options = {}) {
      this.canTrackVelocity = null;
      this.events = {};
      this.updateAndNotify = (v) => {
        const currentTime = time.now();
        if (this.updatedAt !== currentTime) {
          this.setPrevFrameValue();
        }
        this.prev = this.current;
        this.setCurrent(v);
        if (this.current !== this.prev) {
          this.events.change?.notify(this.current);
          if (this.dependents) {
            for (const dependent of this.dependents) {
              dependent.dirty();
            }
          }
        }
      };
      this.hasAnimated = false;
      this.setCurrent(init5);
      this.owner = options.owner;
    }
    setCurrent(current) {
      this.current = current;
      this.updatedAt = time.now();
      if (this.canTrackVelocity === null && current !== void 0) {
        this.canTrackVelocity = isFloat(this.current);
      }
    }
    setPrevFrameValue(prevFrameValue = this.current) {
      this.prevFrameValue = prevFrameValue;
      this.prevUpdatedAt = this.updatedAt;
    }
    /**
     * Adds a function that will be notified when the `MotionValue` is updated.
     *
     * It returns a function that, when called, will cancel the subscription.
     *
     * When calling `onChange` inside a React component, it should be wrapped with the
     * `useEffect` hook. As it returns an unsubscribe function, this should be returned
     * from the `useEffect` function to ensure you don't add duplicate subscribers..
     *
     * ```jsx
     * export const MyComponent = () => {
     *   const x = useMotionValue(0)
     *   const y = useMotionValue(0)
     *   const opacity = useMotionValue(1)
     *
     *   useEffect(() => {
     *     function updateOpacity() {
     *       const maxXY = Math.max(x.get(), y.get())
     *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
     *       opacity.set(newOpacity)
     *     }
     *
     *     const unsubscribeX = x.on("change", updateOpacity)
     *     const unsubscribeY = y.on("change", updateOpacity)
     *
     *     return () => {
     *       unsubscribeX()
     *       unsubscribeY()
     *     }
     *   }, [])
     *
     *   return <motion.div style={{ x }} />
     * }
     * ```
     *
     * @param subscriber - A function that receives the latest value.
     * @returns A function that, when called, will cancel this subscription.
     *
     * @deprecated
     */
    onChange(subscription) {
      if (true) {
        warnOnce2(false, `value.onChange(callback) is deprecated. Switch to value.on("change", callback).`);
      }
      return this.on("change", subscription);
    }
    on(eventName, callback) {
      if (!this.events[eventName]) {
        this.events[eventName] = new SubscriptionManager();
      }
      const unsubscribe = this.events[eventName].add(callback);
      if (eventName === "change") {
        return () => {
          unsubscribe();
          frame.read(() => {
            if (!this.events.change.getSize()) {
              this.stop();
            }
          });
        };
      }
      return unsubscribe;
    }
    clearListeners() {
      for (const eventManagers in this.events) {
        this.events[eventManagers].clear();
      }
    }
    /**
     * Attaches a passive effect to the `MotionValue`.
     */
    attach(passiveEffect, stopPassiveEffect) {
      this.passiveEffect = passiveEffect;
      this.stopPassiveEffect = stopPassiveEffect;
    }
    /**
     * Sets the state of the `MotionValue`.
     *
     * @remarks
     *
     * ```jsx
     * const x = useMotionValue(0)
     * x.set(10)
     * ```
     *
     * @param latest - Latest value to set.
     * @param render - Whether to notify render subscribers. Defaults to `true`
     *
     * @public
     */
    set(v) {
      if (!this.passiveEffect) {
        this.updateAndNotify(v);
      } else {
        this.passiveEffect(v, this.updateAndNotify);
      }
    }
    setWithVelocity(prev, current, delta) {
      this.set(current);
      this.prev = void 0;
      this.prevFrameValue = prev;
      this.prevUpdatedAt = this.updatedAt - delta;
    }
    /**
     * Set the state of the `MotionValue`, stopping any active animations,
     * effects, and resets velocity to `0`.
     */
    jump(v, endAnimation = true) {
      this.updateAndNotify(v);
      this.prev = v;
      this.prevUpdatedAt = this.prevFrameValue = void 0;
      endAnimation && this.stop();
      if (this.stopPassiveEffect)
        this.stopPassiveEffect();
    }
    dirty() {
      this.events.change?.notify(this.current);
    }
    addDependent(dependent) {
      if (!this.dependents) {
        this.dependents = /* @__PURE__ */ new Set();
      }
      this.dependents.add(dependent);
    }
    removeDependent(dependent) {
      if (this.dependents) {
        this.dependents.delete(dependent);
      }
    }
    /**
     * Returns the latest state of `MotionValue`
     *
     * @returns - The latest state of `MotionValue`
     *
     * @public
     */
    get() {
      if (collectMotionValues.current) {
        collectMotionValues.current.push(this);
      }
      return this.current;
    }
    /**
     * @public
     */
    getPrevious() {
      return this.prev;
    }
    /**
     * Returns the latest velocity of `MotionValue`
     *
     * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
     *
     * @public
     */
    getVelocity() {
      const currentTime = time.now();
      if (!this.canTrackVelocity || this.prevFrameValue === void 0 || currentTime - this.updatedAt > MAX_VELOCITY_DELTA) {
        return 0;
      }
      const delta = Math.min(this.updatedAt - this.prevUpdatedAt, MAX_VELOCITY_DELTA);
      return velocityPerSecond(parseFloat(this.current) - parseFloat(this.prevFrameValue), delta);
    }
    /**
     * Registers a new animation to control this `MotionValue`. Only one
     * animation can drive a `MotionValue` at one time.
     *
     * ```jsx
     * value.start()
     * ```
     *
     * @param animation - A function that starts the provided animation
     */
    start(startAnimation) {
      this.stop();
      return new Promise((resolve) => {
        this.hasAnimated = true;
        this.animation = startAnimation(resolve);
        if (this.events.animationStart) {
          this.events.animationStart.notify();
        }
      }).then(() => {
        if (this.events.animationComplete) {
          this.events.animationComplete.notify();
        }
        this.clearAnimation();
      });
    }
    /**
     * Stop the currently active animation.
     *
     * @public
     */
    stop() {
      if (this.animation) {
        this.animation.stop();
        if (this.events.animationCancel) {
          this.events.animationCancel.notify();
        }
      }
      this.clearAnimation();
    }
    /**
     * Returns `true` if this value is currently animating.
     *
     * @public
     */
    isAnimating() {
      return !!this.animation;
    }
    clearAnimation() {
      delete this.animation;
    }
    /**
     * Destroy and clean up subscribers to this `MotionValue`.
     *
     * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
     * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
     * created a `MotionValue` via the `motionValue` function.
     *
     * @public
     */
    destroy() {
      this.dependents?.clear();
      this.events.destroy?.notify();
      this.clearListeners();
      this.stop();
      if (this.stopPassiveEffect) {
        this.stopPassiveEffect();
      }
    }
  };
  function motionValue(init5, options) {
    return new MotionValue(init5, options);
  }

  // node_modules/motion-dom/dist/es/frameloop/microtask.mjs
  var { schedule: microtask, cancel: cancelMicrotask } = /* @__PURE__ */ createRenderBatcher(queueMicrotask, false);

  // node_modules/motion-dom/dist/es/gestures/drag/state/is-active.mjs
  var isDragging = {
    x: false,
    y: false
  };
  function isDragActive() {
    return isDragging.x || isDragging.y;
  }

  // node_modules/motion-dom/dist/es/gestures/drag/state/set-active.mjs
  function setDragLock(axis) {
    if (axis === "x" || axis === "y") {
      if (isDragging[axis]) {
        return null;
      } else {
        isDragging[axis] = true;
        return () => {
          isDragging[axis] = false;
        };
      }
    } else {
      if (isDragging.x || isDragging.y) {
        return null;
      } else {
        isDragging.x = isDragging.y = true;
        return () => {
          isDragging.x = isDragging.y = false;
        };
      }
    }
  }

  // node_modules/motion-dom/dist/es/gestures/utils/setup.mjs
  function setupGesture(elementOrSelector, options) {
    const elements = resolveElements(elementOrSelector);
    const gestureAbortController = new AbortController();
    const eventOptions = {
      passive: true,
      ...options,
      signal: gestureAbortController.signal
    };
    const cancel = () => gestureAbortController.abort();
    return [elements, eventOptions, cancel];
  }

  // node_modules/motion-dom/dist/es/gestures/hover.mjs
  function isValidHover(event) {
    return !(event.pointerType === "touch" || isDragActive());
  }
  function hover(elementOrSelector, onHoverStart, options = {}) {
    const [elements, eventOptions, cancel] = setupGesture(elementOrSelector, options);
    const onPointerEnter = (enterEvent) => {
      if (!isValidHover(enterEvent))
        return;
      const { target } = enterEvent;
      const onHoverEnd = onHoverStart(target, enterEvent);
      if (typeof onHoverEnd !== "function" || !target)
        return;
      const onPointerLeave = (leaveEvent) => {
        if (!isValidHover(leaveEvent))
          return;
        onHoverEnd(leaveEvent);
        target.removeEventListener("pointerleave", onPointerLeave);
      };
      target.addEventListener("pointerleave", onPointerLeave, eventOptions);
    };
    elements.forEach((element) => {
      element.addEventListener("pointerenter", onPointerEnter, eventOptions);
    });
    return cancel;
  }

  // node_modules/motion-dom/dist/es/gestures/utils/is-node-or-child.mjs
  var isNodeOrChild = (parent, child) => {
    if (!child) {
      return false;
    } else if (parent === child) {
      return true;
    } else {
      return isNodeOrChild(parent, child.parentElement);
    }
  };

  // node_modules/motion-dom/dist/es/gestures/utils/is-primary-pointer.mjs
  var isPrimaryPointer = (event) => {
    if (event.pointerType === "mouse") {
      return typeof event.button !== "number" || event.button <= 0;
    } else {
      return event.isPrimary !== false;
    }
  };

  // node_modules/motion-dom/dist/es/gestures/press/utils/is-keyboard-accessible.mjs
  var focusableElements = /* @__PURE__ */ new Set([
    "BUTTON",
    "INPUT",
    "SELECT",
    "TEXTAREA",
    "A"
  ]);
  function isElementKeyboardAccessible(element) {
    return focusableElements.has(element.tagName) || element.tabIndex !== -1;
  }

  // node_modules/motion-dom/dist/es/gestures/press/utils/state.mjs
  var isPressing = /* @__PURE__ */ new WeakSet();

  // node_modules/motion-dom/dist/es/gestures/press/utils/keyboard.mjs
  function filterEvents(callback) {
    return (event) => {
      if (event.key !== "Enter")
        return;
      callback(event);
    };
  }
  function firePointerEvent(target, type) {
    target.dispatchEvent(new PointerEvent("pointer" + type, { isPrimary: true, bubbles: true }));
  }
  var enableKeyboardPress = (focusEvent, eventOptions) => {
    const element = focusEvent.currentTarget;
    if (!element)
      return;
    const handleKeydown = filterEvents(() => {
      if (isPressing.has(element))
        return;
      firePointerEvent(element, "down");
      const handleKeyup = filterEvents(() => {
        firePointerEvent(element, "up");
      });
      const handleBlur = () => firePointerEvent(element, "cancel");
      element.addEventListener("keyup", handleKeyup, eventOptions);
      element.addEventListener("blur", handleBlur, eventOptions);
    });
    element.addEventListener("keydown", handleKeydown, eventOptions);
    element.addEventListener("blur", () => element.removeEventListener("keydown", handleKeydown), eventOptions);
  };

  // node_modules/motion-dom/dist/es/gestures/press/index.mjs
  function isValidPressEvent(event) {
    return isPrimaryPointer(event) && !isDragActive();
  }
  function press(targetOrSelector, onPressStart, options = {}) {
    const [targets, eventOptions, cancelEvents] = setupGesture(targetOrSelector, options);
    const startPress = (startEvent) => {
      const target = startEvent.currentTarget;
      if (!isValidPressEvent(startEvent))
        return;
      isPressing.add(target);
      const onPressEnd = onPressStart(target, startEvent);
      const onPointerEnd = (endEvent, success) => {
        window.removeEventListener("pointerup", onPointerUp);
        window.removeEventListener("pointercancel", onPointerCancel);
        if (isPressing.has(target)) {
          isPressing.delete(target);
        }
        if (!isValidPressEvent(endEvent)) {
          return;
        }
        if (typeof onPressEnd === "function") {
          onPressEnd(endEvent, { success });
        }
      };
      const onPointerUp = (upEvent) => {
        onPointerEnd(upEvent, target === window || target === document || options.useGlobalTarget || isNodeOrChild(target, upEvent.target));
      };
      const onPointerCancel = (cancelEvent) => {
        onPointerEnd(cancelEvent, false);
      };
      window.addEventListener("pointerup", onPointerUp, eventOptions);
      window.addEventListener("pointercancel", onPointerCancel, eventOptions);
    };
    targets.forEach((target) => {
      const pointerDownTarget = options.useGlobalTarget ? window : target;
      pointerDownTarget.addEventListener("pointerdown", startPress, eventOptions);
      if (isHTMLElement(target)) {
        target.addEventListener("focus", (event) => enableKeyboardPress(event, eventOptions));
        if (!isElementKeyboardAccessible(target) && !target.hasAttribute("tabindex")) {
          target.tabIndex = 0;
        }
      }
    });
    return cancelEvents;
  }

  // node_modules/motion-dom/dist/es/utils/is-svg-element.mjs
  function isSVGElement(element) {
    return isObject(element) && "ownerSVGElement" in element;
  }

  // node_modules/motion-dom/dist/es/resize/handle-element.mjs
  var resizeHandlers = /* @__PURE__ */ new WeakMap();
  var observer;
  var getSize = (borderBoxAxis, svgAxis, htmlAxis) => (target, borderBoxSize) => {
    if (borderBoxSize && borderBoxSize[0]) {
      return borderBoxSize[0][borderBoxAxis + "Size"];
    } else if (isSVGElement(target) && "getBBox" in target) {
      return target.getBBox()[svgAxis];
    } else {
      return target[htmlAxis];
    }
  };
  var getWidth = /* @__PURE__ */ getSize("inline", "width", "offsetWidth");
  var getHeight = /* @__PURE__ */ getSize("block", "height", "offsetHeight");
  function notifyTarget({ target, borderBoxSize }) {
    resizeHandlers.get(target)?.forEach((handler) => {
      handler(target, {
        get width() {
          return getWidth(target, borderBoxSize);
        },
        get height() {
          return getHeight(target, borderBoxSize);
        }
      });
    });
  }
  function notifyAll(entries) {
    entries.forEach(notifyTarget);
  }
  function createResizeObserver() {
    if (typeof ResizeObserver === "undefined")
      return;
    observer = new ResizeObserver(notifyAll);
  }
  function resizeElement(target, handler) {
    if (!observer)
      createResizeObserver();
    const elements = resolveElements(target);
    elements.forEach((element) => {
      let elementHandlers = resizeHandlers.get(element);
      if (!elementHandlers) {
        elementHandlers = /* @__PURE__ */ new Set();
        resizeHandlers.set(element, elementHandlers);
      }
      elementHandlers.add(handler);
      observer?.observe(element);
    });
    return () => {
      elements.forEach((element) => {
        const elementHandlers = resizeHandlers.get(element);
        elementHandlers?.delete(handler);
        if (!elementHandlers?.size) {
          observer?.unobserve(element);
        }
      });
    };
  }

  // node_modules/motion-dom/dist/es/resize/handle-window.mjs
  var windowCallbacks = /* @__PURE__ */ new Set();
  var windowResizeHandler;
  function createWindowResizeHandler() {
    windowResizeHandler = () => {
      const info = {
        get width() {
          return window.innerWidth;
        },
        get height() {
          return window.innerHeight;
        }
      };
      windowCallbacks.forEach((callback) => callback(info));
    };
    window.addEventListener("resize", windowResizeHandler);
  }
  function resizeWindow(callback) {
    windowCallbacks.add(callback);
    if (!windowResizeHandler)
      createWindowResizeHandler();
    return () => {
      windowCallbacks.delete(callback);
      if (!windowCallbacks.size && typeof windowResizeHandler === "function") {
        window.removeEventListener("resize", windowResizeHandler);
        windowResizeHandler = void 0;
      }
    };
  }

  // node_modules/motion-dom/dist/es/resize/index.mjs
  function resize(a, b) {
    return typeof a === "function" ? resizeWindow(a) : resizeElement(a, b);
  }

  // node_modules/motion-dom/dist/es/scroll/observe.mjs
  function observeTimeline(update, timeline2) {
    let prevProgress;
    const onFrame = () => {
      const { currentTime } = timeline2;
      const percentage = currentTime === null ? 0 : currentTime.value;
      const progress2 = percentage / 100;
      if (prevProgress !== progress2) {
        update(progress2);
      }
      prevProgress = progress2;
    };
    frame.preUpdate(onFrame, true);
    return () => cancelFrame(onFrame);
  }

  // node_modules/motion-dom/dist/es/utils/is-svg-svg-element.mjs
  function isSVGSVGElement(element) {
    return isSVGElement(element) && element.tagName === "svg";
  }

  // node_modules/motion-dom/dist/es/utils/transform.mjs
  function transform(...args) {
    const useImmediate = !Array.isArray(args[0]);
    const argOffset = useImmediate ? 0 : -1;
    const inputValue = args[0 + argOffset];
    const inputRange = args[1 + argOffset];
    const outputRange = args[2 + argOffset];
    const options = args[3 + argOffset];
    const interpolator = interpolate3(inputRange, outputRange, options);
    return useImmediate ? interpolator(inputValue) : interpolator;
  }

  // node_modules/motion-dom/dist/es/value/utils/is-motion-value.mjs
  var isMotionValue = (value) => Boolean(value && value.getVelocity);

  // node_modules/motion-dom/dist/es/value/spring-value.mjs
  function attachSpring(value, source, options) {
    const initialValue = value.get();
    let activeAnimation = null;
    let latestValue = initialValue;
    let latestSetter;
    const unit = typeof initialValue === "string" ? initialValue.replace(/[\d.-]/g, "") : void 0;
    const stopAnimation = () => {
      if (activeAnimation) {
        activeAnimation.stop();
        activeAnimation = null;
      }
    };
    const startAnimation = () => {
      stopAnimation();
      activeAnimation = new JSAnimation({
        keyframes: [asNumber(value.get()), asNumber(latestValue)],
        velocity: value.getVelocity(),
        type: "spring",
        restDelta: 1e-3,
        restSpeed: 0.01,
        ...options,
        onUpdate: latestSetter
      });
    };
    value.attach((v, set) => {
      latestValue = v;
      latestSetter = (latest) => set(parseValue(latest, unit));
      frame.postRender(startAnimation);
    }, stopAnimation);
    if (isMotionValue(source)) {
      const removeSourceOnChange = source.on("change", (v) => value.set(parseValue(v, unit)));
      const removeValueOnDestroy = value.on("destroy", removeSourceOnChange);
      return () => {
        removeSourceOnChange();
        removeValueOnDestroy();
      };
    }
    return stopAnimation;
  }
  function parseValue(v, unit) {
    return unit ? v + unit : v;
  }
  function asNumber(v) {
    return typeof v === "number" ? v : parseFloat(v);
  }

  // node_modules/motion-dom/dist/es/value/types/utils/find.mjs
  var valueTypes = [...dimensionValueTypes, color, complex];
  var findValueType = (v) => valueTypes.find(testValueType(v));

  // node_modules/framer-motion/dist/es/context/MotionConfigContext.mjs
  var import_react9 = __toESM(require_react(), 1);
  var MotionConfigContext = (0, import_react9.createContext)({
    transformPagePoint: (p) => p,
    isStatic: false,
    reducedMotion: "never"
  });

  // node_modules/framer-motion/dist/es/components/AnimatePresence/use-presence.mjs
  var import_react10 = __toESM(require_react(), 1);
  function usePresence(subscribe = true) {
    const context3 = (0, import_react10.useContext)(PresenceContext);
    if (context3 === null)
      return [true, null];
    const { isPresent, onExitComplete, register: register2 } = context3;
    const id3 = (0, import_react10.useId)();
    (0, import_react10.useEffect)(() => {
      if (subscribe) {
        return register2(id3);
      }
    }, [subscribe]);
    const safeToRemove = (0, import_react10.useCallback)(() => subscribe && onExitComplete && onExitComplete(id3), [id3, onExitComplete, subscribe]);
    return !isPresent && onExitComplete ? [false, safeToRemove] : [true];
  }

  // node_modules/framer-motion/dist/es/context/LazyContext.mjs
  var import_react11 = __toESM(require_react(), 1);
  var LazyContext = (0, import_react11.createContext)({ strict: false });

  // node_modules/framer-motion/dist/es/motion/features/definitions.mjs
  var featureProps = {
    animation: [
      "animate",
      "variants",
      "whileHover",
      "whileTap",
      "exit",
      "whileInView",
      "whileFocus",
      "whileDrag"
    ],
    exit: ["exit"],
    drag: ["drag", "dragControls"],
    focus: ["whileFocus"],
    hover: ["whileHover", "onHoverStart", "onHoverEnd"],
    tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
    pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
    inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
    layout: ["layout", "layoutId"]
  };
  var featureDefinitions = {};
  for (const key in featureProps) {
    featureDefinitions[key] = {
      isEnabled: (props) => featureProps[key].some((name) => !!props[name])
    };
  }

  // node_modules/framer-motion/dist/es/motion/features/load-features.mjs
  function loadFeatures(features) {
    for (const key in features) {
      featureDefinitions[key] = {
        ...featureDefinitions[key],
        ...features[key]
      };
    }
  }

  // node_modules/framer-motion/dist/es/motion/utils/valid-prop.mjs
  var validMotionProps = /* @__PURE__ */ new Set([
    "animate",
    "exit",
    "variants",
    "initial",
    "style",
    "values",
    "variants",
    "transition",
    "transformTemplate",
    "custom",
    "inherit",
    "onBeforeLayoutMeasure",
    "onAnimationStart",
    "onAnimationComplete",
    "onUpdate",
    "onDragStart",
    "onDrag",
    "onDragEnd",
    "onMeasureDragConstraints",
    "onDirectionLock",
    "onDragTransitionEnd",
    "_dragX",
    "_dragY",
    "onHoverStart",
    "onHoverEnd",
    "onViewportEnter",
    "onViewportLeave",
    "globalTapTarget",
    "ignoreStrict",
    "viewport"
  ]);
  function isValidMotionProp(key) {
    return key.startsWith("while") || key.startsWith("drag") && key !== "draggable" || key.startsWith("layout") || key.startsWith("onTap") || key.startsWith("onPan") || key.startsWith("onLayout") || validMotionProps.has(key);
  }

  // node_modules/framer-motion/dist/es/render/dom/utils/filter-props.mjs
  var shouldForward = (key) => !isValidMotionProp(key);
  function loadExternalIsValidProp(isValidProp) {
    if (typeof isValidProp !== "function")
      return;
    shouldForward = (key) => key.startsWith("on") ? !isValidMotionProp(key) : isValidProp(key);
  }
  try {
    loadExternalIsValidProp(__require("@emotion/is-prop-valid").default);
  } catch {
  }
  function filterProps(props, isDom, forwardMotionProps) {
    const filteredProps = {};
    for (const key in props) {
      if (key === "values" && typeof props.values === "object")
        continue;
      if (shouldForward(key) || forwardMotionProps === true && isValidMotionProp(key) || !isDom && !isValidMotionProp(key) || // If trying to use native HTML drag events, forward drag listeners
      props["draggable"] && key.startsWith("onDrag")) {
        filteredProps[key] = props[key];
      }
    }
    return filteredProps;
  }

  // node_modules/framer-motion/dist/es/motion/index.mjs
  var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
  var import_react21 = __toESM(require_react(), 1);

  // node_modules/framer-motion/dist/es/context/MotionContext/index.mjs
  var import_react12 = __toESM(require_react(), 1);
  var MotionContext = /* @__PURE__ */ (0, import_react12.createContext)({});

  // node_modules/framer-motion/dist/es/context/MotionContext/create.mjs
  var import_react13 = __toESM(require_react(), 1);

  // node_modules/framer-motion/dist/es/animation/utils/is-animation-controls.mjs
  function isAnimationControls(v) {
    return v !== null && typeof v === "object" && typeof v.start === "function";
  }

  // node_modules/framer-motion/dist/es/render/utils/is-variant-label.mjs
  function isVariantLabel(v) {
    return typeof v === "string" || Array.isArray(v);
  }

  // node_modules/framer-motion/dist/es/render/utils/variant-props.mjs
  var variantPriorityOrder = [
    "animate",
    "whileInView",
    "whileFocus",
    "whileHover",
    "whileTap",
    "whileDrag",
    "exit"
  ];
  var variantProps = ["initial", ...variantPriorityOrder];

  // node_modules/framer-motion/dist/es/render/utils/is-controlling-variants.mjs
  function isControllingVariants(props) {
    return isAnimationControls(props.animate) || variantProps.some((name) => isVariantLabel(props[name]));
  }
  function isVariantNode(props) {
    return Boolean(isControllingVariants(props) || props.variants);
  }

  // node_modules/framer-motion/dist/es/context/MotionContext/utils.mjs
  function getCurrentTreeVariants(props, context3) {
    if (isControllingVariants(props)) {
      const { initial, animate } = props;
      return {
        initial: initial === false || isVariantLabel(initial) ? initial : void 0,
        animate: isVariantLabel(animate) ? animate : void 0
      };
    }
    return props.inherit !== false ? context3 : {};
  }

  // node_modules/framer-motion/dist/es/context/MotionContext/create.mjs
  function useCreateMotionContext(props) {
    const { initial, animate } = getCurrentTreeVariants(props, (0, import_react13.useContext)(MotionContext));
    return (0, import_react13.useMemo)(() => ({ initial, animate }), [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate)]);
  }
  function variantLabelsAsDependency(prop) {
    return Array.isArray(prop) ? prop.join(" ") : prop;
  }

  // node_modules/framer-motion/dist/es/render/dom/use-render.mjs
  var import_react16 = __toESM(require_react(), 1);

  // node_modules/framer-motion/dist/es/render/html/use-props.mjs
  var import_react14 = __toESM(require_react(), 1);

  // node_modules/framer-motion/dist/es/projection/styles/scale-correction.mjs
  var scaleCorrectors = {};
  function addScaleCorrector(correctors) {
    for (const key in correctors) {
      scaleCorrectors[key] = correctors[key];
      if (isCSSVariableName(key)) {
        scaleCorrectors[key].isCSSVariable = true;
      }
    }
  }

  // node_modules/framer-motion/dist/es/motion/utils/is-forced-motion-value.mjs
  function isForcedMotionValue(key, { layout: layout2, layoutId }) {
    return transformProps.has(key) || key.startsWith("origin") || (layout2 || layoutId !== void 0) && (!!scaleCorrectors[key] || key === "opacity");
  }

  // node_modules/framer-motion/dist/es/render/html/utils/build-transform.mjs
  var translateAlias = {
    x: "translateX",
    y: "translateY",
    z: "translateZ",
    transformPerspective: "perspective"
  };
  var numTransforms = transformPropOrder.length;
  function buildTransform(latestValues, transform2, transformTemplate) {
    let transformString = "";
    let transformIsDefault = true;
    for (let i = 0; i < numTransforms; i++) {
      const key = transformPropOrder[i];
      const value = latestValues[key];
      if (value === void 0)
        continue;
      let valueIsDefault = true;
      if (typeof value === "number") {
        valueIsDefault = value === (key.startsWith("scale") ? 1 : 0);
      } else {
        valueIsDefault = parseFloat(value) === 0;
      }
      if (!valueIsDefault || transformTemplate) {
        const valueAsType = getValueAsType(value, numberValueTypes[key]);
        if (!valueIsDefault) {
          transformIsDefault = false;
          const transformName = translateAlias[key] || key;
          transformString += `${transformName}(${valueAsType}) `;
        }
        if (transformTemplate) {
          transform2[key] = valueAsType;
        }
      }
    }
    transformString = transformString.trim();
    if (transformTemplate) {
      transformString = transformTemplate(transform2, transformIsDefault ? "" : transformString);
    } else if (transformIsDefault) {
      transformString = "none";
    }
    return transformString;
  }

  // node_modules/framer-motion/dist/es/render/html/utils/build-styles.mjs
  function buildHTMLStyles(state, latestValues, transformTemplate) {
    const { style, vars, transformOrigin } = state;
    let hasTransform2 = false;
    let hasTransformOrigin = false;
    for (const key in latestValues) {
      const value = latestValues[key];
      if (transformProps.has(key)) {
        hasTransform2 = true;
        continue;
      } else if (isCSSVariableName(key)) {
        vars[key] = value;
        continue;
      } else {
        const valueAsType = getValueAsType(value, numberValueTypes[key]);
        if (key.startsWith("origin")) {
          hasTransformOrigin = true;
          transformOrigin[key] = valueAsType;
        } else {
          style[key] = valueAsType;
        }
      }
    }
    if (!latestValues.transform) {
      if (hasTransform2 || transformTemplate) {
        style.transform = buildTransform(latestValues, state.transform, transformTemplate);
      } else if (style.transform) {
        style.transform = "none";
      }
    }
    if (hasTransformOrigin) {
      const { originX = "50%", originY = "50%", originZ = 0 } = transformOrigin;
      style.transformOrigin = `${originX} ${originY} ${originZ}`;
    }
  }

  // node_modules/framer-motion/dist/es/render/html/utils/create-render-state.mjs
  var createHtmlRenderState = () => ({
    style: {},
    transform: {},
    transformOrigin: {},
    vars: {}
  });

  // node_modules/framer-motion/dist/es/render/html/use-props.mjs
  function copyRawValuesOnly(target, source, props) {
    for (const key in source) {
      if (!isMotionValue(source[key]) && !isForcedMotionValue(key, props)) {
        target[key] = source[key];
      }
    }
  }
  function useInitialMotionValues({ transformTemplate }, visualState) {
    return (0, import_react14.useMemo)(() => {
      const state = createHtmlRenderState();
      buildHTMLStyles(state, visualState, transformTemplate);
      return Object.assign({}, state.vars, state.style);
    }, [visualState]);
  }
  function useStyle(props, visualState) {
    const styleProp = props.style || {};
    const style = {};
    copyRawValuesOnly(style, styleProp, props);
    Object.assign(style, useInitialMotionValues(props, visualState));
    return style;
  }
  function useHTMLProps(props, visualState) {
    const htmlProps = {};
    const style = useStyle(props, visualState);
    if (props.drag && props.dragListener !== false) {
      htmlProps.draggable = false;
      style.userSelect = style.WebkitUserSelect = style.WebkitTouchCallout = "none";
      style.touchAction = props.drag === true ? "none" : `pan-${props.drag === "x" ? "y" : "x"}`;
    }
    if (props.tabIndex === void 0 && (props.onTap || props.onTapStart || props.whileTap)) {
      htmlProps.tabIndex = 0;
    }
    htmlProps.style = style;
    return htmlProps;
  }

  // node_modules/framer-motion/dist/es/render/svg/use-props.mjs
  var import_react15 = __toESM(require_react(), 1);

  // node_modules/framer-motion/dist/es/render/svg/utils/path.mjs
  var dashKeys = {
    offset: "stroke-dashoffset",
    array: "stroke-dasharray"
  };
  var camelKeys = {
    offset: "strokeDashoffset",
    array: "strokeDasharray"
  };
  function buildSVGPath(attrs, length, spacing = 1, offset = 0, useDashCase = true) {
    attrs.pathLength = 1;
    const keys2 = useDashCase ? dashKeys : camelKeys;
    attrs[keys2.offset] = px.transform(-offset);
    const pathLength = px.transform(length);
    const pathSpacing = px.transform(spacing);
    attrs[keys2.array] = `${pathLength} ${pathSpacing}`;
  }

  // node_modules/framer-motion/dist/es/render/svg/utils/build-attrs.mjs
  function buildSVGAttrs(state, {
    attrX,
    attrY,
    attrScale,
    pathLength,
    pathSpacing = 1,
    pathOffset = 0,
    // This is object creation, which we try to avoid per-frame.
    ...latest
  }, isSVGTag2, transformTemplate, styleProp) {
    buildHTMLStyles(state, latest, transformTemplate);
    if (isSVGTag2) {
      if (state.style.viewBox) {
        state.attrs.viewBox = state.style.viewBox;
      }
      return;
    }
    state.attrs = state.style;
    state.style = {};
    const { attrs, style } = state;
    if (attrs.transform) {
      style.transform = attrs.transform;
      delete attrs.transform;
    }
    if (style.transform || attrs.transformOrigin) {
      style.transformOrigin = attrs.transformOrigin ?? "50% 50%";
      delete attrs.transformOrigin;
    }
    if (style.transform) {
      style.transformBox = styleProp?.transformBox ?? "fill-box";
      delete attrs.transformBox;
    }
    if (attrX !== void 0)
      attrs.x = attrX;
    if (attrY !== void 0)
      attrs.y = attrY;
    if (attrScale !== void 0)
      attrs.scale = attrScale;
    if (pathLength !== void 0) {
      buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false);
    }
  }

  // node_modules/framer-motion/dist/es/render/svg/utils/create-render-state.mjs
  var createSvgRenderState = () => ({
    ...createHtmlRenderState(),
    attrs: {}
  });

  // node_modules/framer-motion/dist/es/render/svg/utils/is-svg-tag.mjs
  var isSVGTag = (tag) => typeof tag === "string" && tag.toLowerCase() === "svg";

  // node_modules/framer-motion/dist/es/render/svg/use-props.mjs
  function useSVGProps(props, visualState, _isStatic, Component3) {
    const visualProps = (0, import_react15.useMemo)(() => {
      const state = createSvgRenderState();
      buildSVGAttrs(state, visualState, isSVGTag(Component3), props.transformTemplate, props.style);
      return {
        ...state.attrs,
        style: { ...state.style }
      };
    }, [visualState]);
    if (props.style) {
      const rawStyles = {};
      copyRawValuesOnly(rawStyles, props.style, props);
      visualProps.style = { ...rawStyles, ...visualProps.style };
    }
    return visualProps;
  }

  // node_modules/framer-motion/dist/es/render/svg/lowercase-elements.mjs
  var lowercaseSVGElements = [
    "animate",
    "circle",
    "defs",
    "desc",
    "ellipse",
    "g",
    "image",
    "line",
    "filter",
    "marker",
    "mask",
    "metadata",
    "path",
    "pattern",
    "polygon",
    "polyline",
    "rect",
    "stop",
    "switch",
    "symbol",
    "svg",
    "text",
    "tspan",
    "use",
    "view"
  ];

  // node_modules/framer-motion/dist/es/render/dom/utils/is-svg-component.mjs
  function isSVGComponent(Component3) {
    if (
      /**
       * If it's not a string, it's a custom React component. Currently we only support
       * HTML custom React components.
       */
      typeof Component3 !== "string" || /**
       * If it contains a dash, the element is a custom HTML webcomponent.
       */
      Component3.includes("-")
    ) {
      return false;
    } else if (
      /**
       * If it's in our list of lowercase SVG tags, it's an SVG component
       */
      lowercaseSVGElements.indexOf(Component3) > -1 || /**
       * If it contains a capital letter, it's an SVG component
       */
      /[A-Z]/u.test(Component3)
    ) {
      return true;
    }
    return false;
  }

  // node_modules/framer-motion/dist/es/render/dom/use-render.mjs
  function useRender(Component3, props, ref2, { latestValues }, isStatic, forwardMotionProps = false) {
    const useVisualProps = isSVGComponent(Component3) ? useSVGProps : useHTMLProps;
    const visualProps = useVisualProps(props, latestValues, isStatic, Component3);
    const filteredProps = filterProps(props, typeof Component3 === "string", forwardMotionProps);
    const elementProps = Component3 !== import_react16.Fragment ? { ...filteredProps, ...visualProps, ref: ref2 } : {};
    const { children } = props;
    const renderedChildren = (0, import_react16.useMemo)(() => isMotionValue(children) ? children.get() : children, [children]);
    return (0, import_react16.createElement)(Component3, {
      ...elementProps,
      children: renderedChildren
    });
  }

  // node_modules/framer-motion/dist/es/motion/utils/use-visual-state.mjs
  var import_react17 = __toESM(require_react(), 1);

  // node_modules/framer-motion/dist/es/render/utils/resolve-variants.mjs
  function getValueState(visualElement) {
    const state = [{}, {}];
    visualElement?.values.forEach((value, key) => {
      state[0][key] = value.get();
      state[1][key] = value.getVelocity();
    });
    return state;
  }
  function resolveVariantFromProps(props, definition, custom, visualElement) {
    if (typeof definition === "function") {
      const [current, velocity] = getValueState(visualElement);
      definition = definition(custom !== void 0 ? custom : props.custom, current, velocity);
    }
    if (typeof definition === "string") {
      definition = props.variants && props.variants[definition];
    }
    if (typeof definition === "function") {
      const [current, velocity] = getValueState(visualElement);
      definition = definition(custom !== void 0 ? custom : props.custom, current, velocity);
    }
    return definition;
  }

  // node_modules/framer-motion/dist/es/value/utils/resolve-motion-value.mjs
  function resolveMotionValue(value) {
    return isMotionValue(value) ? value.get() : value;
  }

  // node_modules/framer-motion/dist/es/motion/utils/use-visual-state.mjs
  function makeState({ scrapeMotionValuesFromProps: scrapeMotionValuesFromProps3, createRenderState }, props, context3, presenceContext) {
    const state = {
      latestValues: makeLatestValues(props, context3, presenceContext, scrapeMotionValuesFromProps3),
      renderState: createRenderState()
    };
    return state;
  }
  function makeLatestValues(props, context3, presenceContext, scrapeMotionValues) {
    const values = {};
    const motionValues = scrapeMotionValues(props, {});
    for (const key in motionValues) {
      values[key] = resolveMotionValue(motionValues[key]);
    }
    let { initial, animate } = props;
    const isControllingVariants$1 = isControllingVariants(props);
    const isVariantNode$1 = isVariantNode(props);
    if (context3 && isVariantNode$1 && !isControllingVariants$1 && props.inherit !== false) {
      if (initial === void 0)
        initial = context3.initial;
      if (animate === void 0)
        animate = context3.animate;
    }
    let isInitialAnimationBlocked = presenceContext ? presenceContext.initial === false : false;
    isInitialAnimationBlocked = isInitialAnimationBlocked || initial === false;
    const variantToSet = isInitialAnimationBlocked ? animate : initial;
    if (variantToSet && typeof variantToSet !== "boolean" && !isAnimationControls(variantToSet)) {
      const list = Array.isArray(variantToSet) ? variantToSet : [variantToSet];
      for (let i = 0; i < list.length; i++) {
        const resolved = resolveVariantFromProps(props, list[i]);
        if (resolved) {
          const { transitionEnd, transition, ...target } = resolved;
          for (const key in target) {
            let valueTarget = target[key];
            if (Array.isArray(valueTarget)) {
              const index = isInitialAnimationBlocked ? valueTarget.length - 1 : 0;
              valueTarget = valueTarget[index];
            }
            if (valueTarget !== null) {
              values[key] = valueTarget;
            }
          }
          for (const key in transitionEnd) {
            values[key] = transitionEnd[key];
          }
        }
      }
    }
    return values;
  }
  var makeUseVisualState = (config3) => (props, isStatic) => {
    const context3 = (0, import_react17.useContext)(MotionContext);
    const presenceContext = (0, import_react17.useContext)(PresenceContext);
    const make = () => makeState(config3, props, context3, presenceContext);
    return isStatic ? make() : useConstant(make);
  };

  // node_modules/framer-motion/dist/es/render/html/utils/scrape-motion-values.mjs
  function scrapeMotionValuesFromProps(props, prevProps, visualElement) {
    const { style } = props;
    const newValues = {};
    for (const key in style) {
      if (isMotionValue(style[key]) || prevProps.style && isMotionValue(prevProps.style[key]) || isForcedMotionValue(key, props) || visualElement?.getValue(key)?.liveStyle !== void 0) {
        newValues[key] = style[key];
      }
    }
    return newValues;
  }

  // node_modules/framer-motion/dist/es/render/html/use-html-visual-state.mjs
  var useHTMLVisualState = /* @__PURE__ */ makeUseVisualState({
    scrapeMotionValuesFromProps,
    createRenderState: createHtmlRenderState
  });

  // node_modules/framer-motion/dist/es/render/svg/utils/scrape-motion-values.mjs
  function scrapeMotionValuesFromProps2(props, prevProps, visualElement) {
    const newValues = scrapeMotionValuesFromProps(props, prevProps, visualElement);
    for (const key in props) {
      if (isMotionValue(props[key]) || isMotionValue(prevProps[key])) {
        const targetKey = transformPropOrder.indexOf(key) !== -1 ? "attr" + key.charAt(0).toUpperCase() + key.substring(1) : key;
        newValues[targetKey] = props[key];
      }
    }
    return newValues;
  }

  // node_modules/framer-motion/dist/es/render/svg/use-svg-visual-state.mjs
  var useSVGVisualState = /* @__PURE__ */ makeUseVisualState({
    scrapeMotionValuesFromProps: scrapeMotionValuesFromProps2,
    createRenderState: createSvgRenderState
  });

  // node_modules/framer-motion/dist/es/motion/utils/symbol.mjs
  var motionComponentSymbol = Symbol.for("motionComponentSymbol");

  // node_modules/framer-motion/dist/es/motion/utils/use-motion-ref.mjs
  var import_react18 = __toESM(require_react(), 1);

  // node_modules/framer-motion/dist/es/utils/is-ref-object.mjs
  function isRefObject(ref2) {
    return ref2 && typeof ref2 === "object" && Object.prototype.hasOwnProperty.call(ref2, "current");
  }

  // node_modules/framer-motion/dist/es/motion/utils/use-motion-ref.mjs
  function useMotionRef(visualState, visualElement, externalRef) {
    return (0, import_react18.useCallback)(
      (instance) => {
        if (instance) {
          visualState.onMount && visualState.onMount(instance);
        }
        if (visualElement) {
          if (instance) {
            visualElement.mount(instance);
          } else {
            visualElement.unmount();
          }
        }
        if (externalRef) {
          if (typeof externalRef === "function") {
            externalRef(instance);
          } else if (isRefObject(externalRef)) {
            externalRef.current = instance;
          }
        }
      },
      /**
       * Include externalRef in dependencies to ensure the callback updates
       * when the ref changes, allowing proper ref forwarding.
       */
      [visualElement]
    );
  }

  // node_modules/framer-motion/dist/es/motion/utils/use-visual-element.mjs
  var import_react20 = __toESM(require_react(), 1);

  // node_modules/framer-motion/dist/es/render/dom/utils/camel-to-dash.mjs
  var camelToDash = (str) => str.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase();

  // node_modules/framer-motion/dist/es/animation/optimized-appear/data-id.mjs
  var optimizedAppearDataId = "framerAppearId";
  var optimizedAppearDataAttribute = "data-" + camelToDash(optimizedAppearDataId);

  // node_modules/framer-motion/dist/es/context/SwitchLayoutGroupContext.mjs
  var import_react19 = __toESM(require_react(), 1);
  var SwitchLayoutGroupContext = (0, import_react19.createContext)({});

  // node_modules/framer-motion/dist/es/motion/utils/use-visual-element.mjs
  function useVisualElement(Component3, visualState, props, createVisualElement, ProjectionNodeConstructor) {
    const { visualElement: parent } = (0, import_react20.useContext)(MotionContext);
    const lazyContext = (0, import_react20.useContext)(LazyContext);
    const presenceContext = (0, import_react20.useContext)(PresenceContext);
    const reducedMotionConfig = (0, import_react20.useContext)(MotionConfigContext).reducedMotion;
    const visualElementRef = (0, import_react20.useRef)(null);
    createVisualElement = createVisualElement || lazyContext.renderer;
    if (!visualElementRef.current && createVisualElement) {
      visualElementRef.current = createVisualElement(Component3, {
        visualState,
        parent,
        props,
        presenceContext,
        blockInitialAnimation: presenceContext ? presenceContext.initial === false : false,
        reducedMotionConfig
      });
    }
    const visualElement = visualElementRef.current;
    const initialLayoutGroupConfig = (0, import_react20.useContext)(SwitchLayoutGroupContext);
    if (visualElement && !visualElement.projection && ProjectionNodeConstructor && (visualElement.type === "html" || visualElement.type === "svg")) {
      createProjectionNode(visualElementRef.current, props, ProjectionNodeConstructor, initialLayoutGroupConfig);
    }
    const isMounted = (0, import_react20.useRef)(false);
    (0, import_react20.useInsertionEffect)(() => {
      if (visualElement && isMounted.current) {
        visualElement.update(props, presenceContext);
      }
    });
    const optimisedAppearId = props[optimizedAppearDataAttribute];
    const wantsHandoff = (0, import_react20.useRef)(Boolean(optimisedAppearId) && !window.MotionHandoffIsComplete?.(optimisedAppearId) && window.MotionHasOptimisedAnimation?.(optimisedAppearId));
    useIsomorphicLayoutEffect3(() => {
      if (!visualElement)
        return;
      isMounted.current = true;
      window.MotionIsMounted = true;
      visualElement.updateFeatures();
      visualElement.scheduleRenderMicrotask();
      if (wantsHandoff.current && visualElement.animationState) {
        visualElement.animationState.animateChanges();
      }
    });
    (0, import_react20.useEffect)(() => {
      if (!visualElement)
        return;
      if (!wantsHandoff.current && visualElement.animationState) {
        visualElement.animationState.animateChanges();
      }
      if (wantsHandoff.current) {
        queueMicrotask(() => {
          window.MotionHandoffMarkAsComplete?.(optimisedAppearId);
        });
        wantsHandoff.current = false;
      }
      visualElement.enteringChildren = void 0;
    });
    return visualElement;
  }
  function createProjectionNode(visualElement, props, ProjectionNodeConstructor, initialPromotionConfig) {
    const { layoutId, layout: layout2, drag: drag2, dragConstraints, layoutScroll, layoutRoot, layoutCrossfade } = props;
    visualElement.projection = new ProjectionNodeConstructor(visualElement.latestValues, props["data-framer-portal-id"] ? void 0 : getClosestProjectingNode(visualElement.parent));
    visualElement.projection.setOptions({
      layoutId,
      layout: layout2,
      alwaysMeasureLayout: Boolean(drag2) || dragConstraints && isRefObject(dragConstraints),
      visualElement,
      /**
       * TODO: Update options in an effect. This could be tricky as it'll be too late
       * to update by the time layout animations run.
       * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
       * ensuring it gets called if there's no potential layout animations.
       *
       */
      animationType: typeof layout2 === "string" ? layout2 : "both",
      initialPromotionConfig,
      crossfade: layoutCrossfade,
      layoutScroll,
      layoutRoot
    });
  }
  function getClosestProjectingNode(visualElement) {
    if (!visualElement)
      return void 0;
    return visualElement.options.allowProjection !== false ? visualElement.projection : getClosestProjectingNode(visualElement.parent);
  }

  // node_modules/framer-motion/dist/es/motion/index.mjs
  function createMotionComponent(Component3, { forwardMotionProps = false } = {}, preloadedFeatures, createVisualElement) {
    preloadedFeatures && loadFeatures(preloadedFeatures);
    const useVisualState = isSVGComponent(Component3) ? useSVGVisualState : useHTMLVisualState;
    function MotionDOMComponent(props, externalRef) {
      let MeasureLayout2;
      const configAndProps = {
        ...(0, import_react21.useContext)(MotionConfigContext),
        ...props,
        layoutId: useLayoutId(props)
      };
      const { isStatic } = configAndProps;
      const context3 = useCreateMotionContext(props);
      const visualState = useVisualState(props, isStatic);
      if (!isStatic && isBrowser2) {
        useStrictMode(configAndProps, preloadedFeatures);
        const layoutProjection = getProjectionFunctionality(configAndProps);
        MeasureLayout2 = layoutProjection.MeasureLayout;
        context3.visualElement = useVisualElement(Component3, visualState, configAndProps, createVisualElement, layoutProjection.ProjectionNode);
      }
      return (0, import_jsx_runtime3.jsxs)(MotionContext.Provider, { value: context3, children: [MeasureLayout2 && context3.visualElement ? (0, import_jsx_runtime3.jsx)(MeasureLayout2, { visualElement: context3.visualElement, ...configAndProps }) : null, useRender(Component3, props, useMotionRef(visualState, context3.visualElement, externalRef), visualState, isStatic, forwardMotionProps)] });
    }
    MotionDOMComponent.displayName = `motion.${typeof Component3 === "string" ? Component3 : `create(${Component3.displayName ?? Component3.name ?? ""})`}`;
    const ForwardRefMotionComponent = (0, import_react21.forwardRef)(MotionDOMComponent);
    ForwardRefMotionComponent[motionComponentSymbol] = Component3;
    return ForwardRefMotionComponent;
  }
  function useLayoutId({ layoutId }) {
    const layoutGroupId = (0, import_react21.useContext)(LayoutGroupContext).id;
    return layoutGroupId && layoutId !== void 0 ? layoutGroupId + "-" + layoutId : layoutId;
  }
  function useStrictMode(configAndProps, preloadedFeatures) {
    const isStrict = (0, import_react21.useContext)(LazyContext).strict;
    if (preloadedFeatures && isStrict) {
      const strictMessage = "You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.";
      configAndProps.ignoreStrict ? warning2(false, strictMessage, "lazy-strict-mode") : invariant2(false, strictMessage, "lazy-strict-mode");
    }
  }
  function getProjectionFunctionality(props) {
    const { drag: drag2, layout: layout2 } = featureDefinitions;
    if (!drag2 && !layout2)
      return {};
    const combined = { ...drag2, ...layout2 };
    return {
      MeasureLayout: drag2?.isEnabled(props) || layout2?.isEnabled(props) ? combined.MeasureLayout : void 0,
      ProjectionNode: combined.ProjectionNode
    };
  }

  // node_modules/framer-motion/dist/es/render/components/create-proxy.mjs
  function createMotionProxy(preloadedFeatures, createVisualElement) {
    if (typeof Proxy === "undefined") {
      return createMotionComponent;
    }
    const componentCache = /* @__PURE__ */ new Map();
    const factory = (Component3, options) => {
      return createMotionComponent(Component3, options, preloadedFeatures, createVisualElement);
    };
    const deprecatedFactoryFunction = (Component3, options) => {
      if (true) {
        warnOnce2(false, "motion() is deprecated. Use motion.create() instead.");
      }
      return factory(Component3, options);
    };
    return new Proxy(deprecatedFactoryFunction, {
      /**
       * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.
       * The prop name is passed through as `key` and we can use that to generate a `motion`
       * DOM component with that name.
       */
      get: (_target, key) => {
        if (key === "create")
          return factory;
        if (!componentCache.has(key)) {
          componentCache.set(key, createMotionComponent(key, void 0, preloadedFeatures, createVisualElement));
        }
        return componentCache.get(key);
      }
    });
  }

  // node_modules/framer-motion/dist/es/render/dom/create-visual-element.mjs
  var import_react22 = __toESM(require_react(), 1);

  // node_modules/framer-motion/dist/es/projection/geometry/conversion.mjs
  function convertBoundingBoxToBox({ top, left, right, bottom }) {
    return {
      x: { min: left, max: right },
      y: { min: top, max: bottom }
    };
  }
  function convertBoxToBoundingBox({ x, y }) {
    return { top: y.min, right: x.max, bottom: y.max, left: x.min };
  }
  function transformBoxPoints(point2, transformPoint2) {
    if (!transformPoint2)
      return point2;
    const topLeft = transformPoint2({ x: point2.left, y: point2.top });
    const bottomRight = transformPoint2({ x: point2.right, y: point2.bottom });
    return {
      top: topLeft.y,
      left: topLeft.x,
      bottom: bottomRight.y,
      right: bottomRight.x
    };
  }

  // node_modules/framer-motion/dist/es/projection/utils/has-transform.mjs
  function isIdentityScale(scale2) {
    return scale2 === void 0 || scale2 === 1;
  }
  function hasScale({ scale: scale2, scaleX: scaleX2, scaleY: scaleY2 }) {
    return !isIdentityScale(scale2) || !isIdentityScale(scaleX2) || !isIdentityScale(scaleY2);
  }
  function hasTransform(values) {
    return hasScale(values) || has2DTranslate(values) || values.z || values.rotate || values.rotateX || values.rotateY || values.skewX || values.skewY;
  }
  function has2DTranslate(values) {
    return is2DTranslate(values.x) || is2DTranslate(values.y);
  }
  function is2DTranslate(value) {
    return value && value !== "0%";
  }

  // node_modules/framer-motion/dist/es/projection/geometry/delta-apply.mjs
  function scalePoint(point2, scale2, originPoint) {
    const distanceFromOrigin = point2 - originPoint;
    const scaled = scale2 * distanceFromOrigin;
    return originPoint + scaled;
  }
  function applyPointDelta(point2, translate, scale2, originPoint, boxScale) {
    if (boxScale !== void 0) {
      point2 = scalePoint(point2, boxScale, originPoint);
    }
    return scalePoint(point2, scale2, originPoint) + translate;
  }
  function applyAxisDelta(axis, translate = 0, scale2 = 1, originPoint, boxScale) {
    axis.min = applyPointDelta(axis.min, translate, scale2, originPoint, boxScale);
    axis.max = applyPointDelta(axis.max, translate, scale2, originPoint, boxScale);
  }
  function applyBoxDelta(box, { x, y }) {
    applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);
    applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);
  }
  var TREE_SCALE_SNAP_MIN = 0.999999999999;
  var TREE_SCALE_SNAP_MAX = 1.0000000000001;
  function applyTreeDeltas(box, treeScale, treePath, isSharedTransition = false) {
    const treeLength = treePath.length;
    if (!treeLength)
      return;
    treeScale.x = treeScale.y = 1;
    let node;
    let delta;
    for (let i = 0; i < treeLength; i++) {
      node = treePath[i];
      delta = node.projectionDelta;
      const { visualElement } = node.options;
      if (visualElement && visualElement.props.style && visualElement.props.style.display === "contents") {
        continue;
      }
      if (isSharedTransition && node.options.layoutScroll && node.scroll && node !== node.root) {
        transformBox(box, {
          x: -node.scroll.offset.x,
          y: -node.scroll.offset.y
        });
      }
      if (delta) {
        treeScale.x *= delta.x.scale;
        treeScale.y *= delta.y.scale;
        applyBoxDelta(box, delta);
      }
      if (isSharedTransition && hasTransform(node.latestValues)) {
        transformBox(box, node.latestValues);
      }
    }
    if (treeScale.x < TREE_SCALE_SNAP_MAX && treeScale.x > TREE_SCALE_SNAP_MIN) {
      treeScale.x = 1;
    }
    if (treeScale.y < TREE_SCALE_SNAP_MAX && treeScale.y > TREE_SCALE_SNAP_MIN) {
      treeScale.y = 1;
    }
  }
  function translateAxis(axis, distance2) {
    axis.min = axis.min + distance2;
    axis.max = axis.max + distance2;
  }
  function transformAxis(axis, axisTranslate, axisScale, boxScale, axisOrigin = 0.5) {
    const originPoint = mixNumber(axis.min, axis.max, axisOrigin);
    applyAxisDelta(axis, axisTranslate, axisScale, originPoint, boxScale);
  }
  function transformBox(box, transform2) {
    transformAxis(box.x, transform2.x, transform2.scaleX, transform2.scale, transform2.originX);
    transformAxis(box.y, transform2.y, transform2.scaleY, transform2.scale, transform2.originY);
  }

  // node_modules/framer-motion/dist/es/projection/utils/measure.mjs
  function measureViewportBox(instance, transformPoint2) {
    return convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(), transformPoint2));
  }
  function measurePageBox(element, rootProjectionNode2, transformPagePoint) {
    const viewportBox = measureViewportBox(element, transformPagePoint);
    const { scroll: scroll2 } = rootProjectionNode2;
    if (scroll2) {
      translateAxis(viewportBox.x, scroll2.offset.x);
      translateAxis(viewportBox.y, scroll2.offset.y);
    }
    return viewportBox;
  }

  // node_modules/framer-motion/dist/es/projection/geometry/models.mjs
  var createAxisDelta = () => ({
    translate: 0,
    scale: 1,
    origin: 0,
    originPoint: 0
  });
  var createDelta = () => ({
    x: createAxisDelta(),
    y: createAxisDelta()
  });
  var createAxis = () => ({ min: 0, max: 0 });
  var createBox = () => ({
    x: createAxis(),
    y: createAxis()
  });

  // node_modules/framer-motion/dist/es/utils/reduced-motion/state.mjs
  var prefersReducedMotion = { current: null };
  var hasReducedMotionListener = { current: false };

  // node_modules/framer-motion/dist/es/utils/reduced-motion/index.mjs
  function initPrefersReducedMotion() {
    hasReducedMotionListener.current = true;
    if (!isBrowser2)
      return;
    if (window.matchMedia) {
      const motionMediaQuery = window.matchMedia("(prefers-reduced-motion)");
      const setReducedMotionPreferences = () => prefersReducedMotion.current = motionMediaQuery.matches;
      motionMediaQuery.addEventListener("change", setReducedMotionPreferences);
      setReducedMotionPreferences();
    } else {
      prefersReducedMotion.current = false;
    }
  }

  // node_modules/framer-motion/dist/es/render/store.mjs
  var visualElementStore = /* @__PURE__ */ new WeakMap();

  // node_modules/framer-motion/dist/es/render/utils/motion-values.mjs
  function updateMotionValuesFromProps(element, next, prev) {
    for (const key in next) {
      const nextValue = next[key];
      const prevValue = prev[key];
      if (isMotionValue(nextValue)) {
        element.addValue(key, nextValue);
      } else if (isMotionValue(prevValue)) {
        element.addValue(key, motionValue(nextValue, { owner: element }));
      } else if (prevValue !== nextValue) {
        if (element.hasValue(key)) {
          const existingValue = element.getValue(key);
          if (existingValue.liveStyle === true) {
            existingValue.jump(nextValue);
          } else if (!existingValue.hasAnimated) {
            existingValue.set(nextValue);
          }
        } else {
          const latestValue = element.getStaticValue(key);
          element.addValue(key, motionValue(latestValue !== void 0 ? latestValue : nextValue, { owner: element }));
        }
      }
    }
    for (const key in prev) {
      if (next[key] === void 0)
        element.removeValue(key);
    }
    return next;
  }

  // node_modules/framer-motion/dist/es/render/VisualElement.mjs
  var propEventHandlers = [
    "AnimationStart",
    "AnimationComplete",
    "Update",
    "BeforeLayoutMeasure",
    "LayoutMeasure",
    "LayoutAnimationStart",
    "LayoutAnimationComplete"
  ];
  var VisualElement = class {
    /**
     * This method takes React props and returns found MotionValues. For example, HTML
     * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
     *
     * This isn't an abstract method as it needs calling in the constructor, but it is
     * intended to be one.
     */
    scrapeMotionValuesFromProps(_props, _prevProps, _visualElement) {
      return {};
    }
    constructor({ parent, props, presenceContext, reducedMotionConfig, blockInitialAnimation, visualState }, options = {}) {
      this.current = null;
      this.children = /* @__PURE__ */ new Set();
      this.isVariantNode = false;
      this.isControllingVariants = false;
      this.shouldReduceMotion = null;
      this.values = /* @__PURE__ */ new Map();
      this.KeyframeResolver = KeyframeResolver;
      this.features = {};
      this.valueSubscriptions = /* @__PURE__ */ new Map();
      this.prevMotionValues = {};
      this.events = {};
      this.propEventSubscriptions = {};
      this.notifyUpdate = () => this.notify("Update", this.latestValues);
      this.render = () => {
        if (!this.current)
          return;
        this.triggerBuild();
        this.renderInstance(this.current, this.renderState, this.props.style, this.projection);
      };
      this.renderScheduledAt = 0;
      this.scheduleRender = () => {
        const now3 = time.now();
        if (this.renderScheduledAt < now3) {
          this.renderScheduledAt = now3;
          frame.render(this.render, false, true);
        }
      };
      const { latestValues, renderState } = visualState;
      this.latestValues = latestValues;
      this.baseTarget = { ...latestValues };
      this.initialValues = props.initial ? { ...latestValues } : {};
      this.renderState = renderState;
      this.parent = parent;
      this.props = props;
      this.presenceContext = presenceContext;
      this.depth = parent ? parent.depth + 1 : 0;
      this.reducedMotionConfig = reducedMotionConfig;
      this.options = options;
      this.blockInitialAnimation = Boolean(blockInitialAnimation);
      this.isControllingVariants = isControllingVariants(props);
      this.isVariantNode = isVariantNode(props);
      if (this.isVariantNode) {
        this.variantChildren = /* @__PURE__ */ new Set();
      }
      this.manuallyAnimateOnMount = Boolean(parent && parent.current);
      const { willChange, ...initialMotionValues } = this.scrapeMotionValuesFromProps(props, {}, this);
      for (const key in initialMotionValues) {
        const value = initialMotionValues[key];
        if (latestValues[key] !== void 0 && isMotionValue(value)) {
          value.set(latestValues[key]);
        }
      }
    }
    mount(instance) {
      this.current = instance;
      visualElementStore.set(instance, this);
      if (this.projection && !this.projection.instance) {
        this.projection.mount(instance);
      }
      if (this.parent && this.isVariantNode && !this.isControllingVariants) {
        this.removeFromVariantTree = this.parent.addVariantChild(this);
      }
      this.values.forEach((value, key) => this.bindToMotionValue(key, value));
      if (!hasReducedMotionListener.current) {
        initPrefersReducedMotion();
      }
      this.shouldReduceMotion = this.reducedMotionConfig === "never" ? false : this.reducedMotionConfig === "always" ? true : prefersReducedMotion.current;
      if (true) {
        warnOnce2(this.shouldReduceMotion !== true, "You have Reduced Motion enabled on your device. Animations may not appear as expected.", "reduced-motion-disabled");
      }
      this.parent?.addChild(this);
      this.update(this.props, this.presenceContext);
    }
    unmount() {
      this.projection && this.projection.unmount();
      cancelFrame(this.notifyUpdate);
      cancelFrame(this.render);
      this.valueSubscriptions.forEach((remove) => remove());
      this.valueSubscriptions.clear();
      this.removeFromVariantTree && this.removeFromVariantTree();
      this.parent?.removeChild(this);
      for (const key in this.events) {
        this.events[key].clear();
      }
      for (const key in this.features) {
        const feature = this.features[key];
        if (feature) {
          feature.unmount();
          feature.isMounted = false;
        }
      }
      this.current = null;
    }
    addChild(child) {
      this.children.add(child);
      this.enteringChildren ?? (this.enteringChildren = /* @__PURE__ */ new Set());
      this.enteringChildren.add(child);
    }
    removeChild(child) {
      this.children.delete(child);
      this.enteringChildren && this.enteringChildren.delete(child);
    }
    bindToMotionValue(key, value) {
      if (this.valueSubscriptions.has(key)) {
        this.valueSubscriptions.get(key)();
      }
      const valueIsTransform = transformProps.has(key);
      if (valueIsTransform && this.onBindTransform) {
        this.onBindTransform();
      }
      const removeOnChange = value.on("change", (latestValue) => {
        this.latestValues[key] = latestValue;
        this.props.onUpdate && frame.preRender(this.notifyUpdate);
        if (valueIsTransform && this.projection) {
          this.projection.isTransformDirty = true;
        }
        this.scheduleRender();
      });
      let removeSyncCheck;
      if (window.MotionCheckAppearSync) {
        removeSyncCheck = window.MotionCheckAppearSync(this, key, value);
      }
      this.valueSubscriptions.set(key, () => {
        removeOnChange();
        if (removeSyncCheck)
          removeSyncCheck();
        if (value.owner)
          value.stop();
      });
    }
    sortNodePosition(other) {
      if (!this.current || !this.sortInstanceNodePosition || this.type !== other.type) {
        return 0;
      }
      return this.sortInstanceNodePosition(this.current, other.current);
    }
    updateFeatures() {
      let key = "animation";
      for (key in featureDefinitions) {
        const featureDefinition = featureDefinitions[key];
        if (!featureDefinition)
          continue;
        const { isEnabled, Feature: FeatureConstructor } = featureDefinition;
        if (!this.features[key] && FeatureConstructor && isEnabled(this.props)) {
          this.features[key] = new FeatureConstructor(this);
        }
        if (this.features[key]) {
          const feature = this.features[key];
          if (feature.isMounted) {
            feature.update();
          } else {
            feature.mount();
            feature.isMounted = true;
          }
        }
      }
    }
    triggerBuild() {
      this.build(this.renderState, this.latestValues, this.props);
    }
    /**
     * Measure the current viewport box with or without transforms.
     * Only measures axis-aligned boxes, rotate and skew must be manually
     * removed with a re-render to work.
     */
    measureViewportBox() {
      return this.current ? this.measureInstanceViewportBox(this.current, this.props) : createBox();
    }
    getStaticValue(key) {
      return this.latestValues[key];
    }
    setStaticValue(key, value) {
      this.latestValues[key] = value;
    }
    /**
     * Update the provided props. Ensure any newly-added motion values are
     * added to our map, old ones removed, and listeners updated.
     */
    update(props, presenceContext) {
      if (props.transformTemplate || this.props.transformTemplate) {
        this.scheduleRender();
      }
      this.prevProps = this.props;
      this.props = props;
      this.prevPresenceContext = this.presenceContext;
      this.presenceContext = presenceContext;
      for (let i = 0; i < propEventHandlers.length; i++) {
        const key = propEventHandlers[i];
        if (this.propEventSubscriptions[key]) {
          this.propEventSubscriptions[key]();
          delete this.propEventSubscriptions[key];
        }
        const listenerName = "on" + key;
        const listener = props[listenerName];
        if (listener) {
          this.propEventSubscriptions[key] = this.on(key, listener);
        }
      }
      this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(props, this.prevProps, this), this.prevMotionValues);
      if (this.handleChildMotionValue) {
        this.handleChildMotionValue();
      }
    }
    getProps() {
      return this.props;
    }
    /**
     * Returns the variant definition with a given name.
     */
    getVariant(name) {
      return this.props.variants ? this.props.variants[name] : void 0;
    }
    /**
     * Returns the defined default transition on this component.
     */
    getDefaultTransition() {
      return this.props.transition;
    }
    getTransformPagePoint() {
      return this.props.transformPagePoint;
    }
    getClosestVariantNode() {
      return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
    }
    /**
     * Add a child visual element to our set of children.
     */
    addVariantChild(child) {
      const closestVariantNode = this.getClosestVariantNode();
      if (closestVariantNode) {
        closestVariantNode.variantChildren && closestVariantNode.variantChildren.add(child);
        return () => closestVariantNode.variantChildren.delete(child);
      }
    }
    /**
     * Add a motion value and bind it to this visual element.
     */
    addValue(key, value) {
      const existingValue = this.values.get(key);
      if (value !== existingValue) {
        if (existingValue)
          this.removeValue(key);
        this.bindToMotionValue(key, value);
        this.values.set(key, value);
        this.latestValues[key] = value.get();
      }
    }
    /**
     * Remove a motion value and unbind any active subscriptions.
     */
    removeValue(key) {
      this.values.delete(key);
      const unsubscribe = this.valueSubscriptions.get(key);
      if (unsubscribe) {
        unsubscribe();
        this.valueSubscriptions.delete(key);
      }
      delete this.latestValues[key];
      this.removeValueFromRenderState(key, this.renderState);
    }
    /**
     * Check whether we have a motion value for this key
     */
    hasValue(key) {
      return this.values.has(key);
    }
    getValue(key, defaultValue) {
      if (this.props.values && this.props.values[key]) {
        return this.props.values[key];
      }
      let value = this.values.get(key);
      if (value === void 0 && defaultValue !== void 0) {
        value = motionValue(defaultValue === null ? void 0 : defaultValue, { owner: this });
        this.addValue(key, value);
      }
      return value;
    }
    /**
     * If we're trying to animate to a previously unencountered value,
     * we need to check for it in our state and as a last resort read it
     * directly from the instance (which might have performance implications).
     */
    readValue(key, target) {
      let value = this.latestValues[key] !== void 0 || !this.current ? this.latestValues[key] : this.getBaseTargetFromProps(this.props, key) ?? this.readValueFromInstance(this.current, key, this.options);
      if (value !== void 0 && value !== null) {
        if (typeof value === "string" && (isNumericalString(value) || isZeroValueString(value))) {
          value = parseFloat(value);
        } else if (!findValueType(value) && complex.test(target)) {
          value = getAnimatableNone2(key, target);
        }
        this.setBaseTarget(key, isMotionValue(value) ? value.get() : value);
      }
      return isMotionValue(value) ? value.get() : value;
    }
    /**
     * Set the base target to later animate back to. This is currently
     * only hydrated on creation and when we first read a value.
     */
    setBaseTarget(key, value) {
      this.baseTarget[key] = value;
    }
    /**
     * Find the base target for a value thats been removed from all animation
     * props.
     */
    getBaseTarget(key) {
      const { initial } = this.props;
      let valueFromInitial;
      if (typeof initial === "string" || typeof initial === "object") {
        const variant = resolveVariantFromProps(this.props, initial, this.presenceContext?.custom);
        if (variant) {
          valueFromInitial = variant[key];
        }
      }
      if (initial && valueFromInitial !== void 0) {
        return valueFromInitial;
      }
      const target = this.getBaseTargetFromProps(this.props, key);
      if (target !== void 0 && !isMotionValue(target))
        return target;
      return this.initialValues[key] !== void 0 && valueFromInitial === void 0 ? void 0 : this.baseTarget[key];
    }
    on(eventName, callback) {
      if (!this.events[eventName]) {
        this.events[eventName] = new SubscriptionManager();
      }
      return this.events[eventName].add(callback);
    }
    notify(eventName, ...args) {
      if (this.events[eventName]) {
        this.events[eventName].notify(...args);
      }
    }
    scheduleRenderMicrotask() {
      microtask.render(this.render);
    }
  };

  // node_modules/framer-motion/dist/es/render/dom/DOMVisualElement.mjs
  var DOMVisualElement = class extends VisualElement {
    constructor() {
      super(...arguments);
      this.KeyframeResolver = DOMKeyframesResolver;
    }
    sortInstanceNodePosition(a, b) {
      return a.compareDocumentPosition(b) & 2 ? 1 : -1;
    }
    getBaseTargetFromProps(props, key) {
      return props.style ? props.style[key] : void 0;
    }
    removeValueFromRenderState(key, { vars, style }) {
      delete vars[key];
      delete style[key];
    }
    handleChildMotionValue() {
      if (this.childSubscription) {
        this.childSubscription();
        delete this.childSubscription;
      }
      const { children } = this.props;
      if (isMotionValue(children)) {
        this.childSubscription = children.on("change", (latest) => {
          if (this.current) {
            this.current.textContent = `${latest}`;
          }
        });
      }
    }
  };

  // node_modules/framer-motion/dist/es/render/html/utils/render.mjs
  function renderHTML(element, { style, vars }, styleProp, projection) {
    const elementStyle = element.style;
    let key;
    for (key in style) {
      elementStyle[key] = style[key];
    }
    projection?.applyProjectionStyles(elementStyle, styleProp);
    for (key in vars) {
      elementStyle.setProperty(key, vars[key]);
    }
  }

  // node_modules/framer-motion/dist/es/render/html/HTMLVisualElement.mjs
  function getComputedStyle2(element) {
    return window.getComputedStyle(element);
  }
  var HTMLVisualElement = class extends DOMVisualElement {
    constructor() {
      super(...arguments);
      this.type = "html";
      this.renderInstance = renderHTML;
    }
    readValueFromInstance(instance, key) {
      if (transformProps.has(key)) {
        return this.projection?.isProjecting ? defaultTransformValue(key) : readTransformValue(instance, key);
      } else {
        const computedStyle = getComputedStyle2(instance);
        const value = (isCSSVariableName(key) ? computedStyle.getPropertyValue(key) : computedStyle[key]) || 0;
        return typeof value === "string" ? value.trim() : value;
      }
    }
    measureInstanceViewportBox(instance, { transformPagePoint }) {
      return measureViewportBox(instance, transformPagePoint);
    }
    build(renderState, latestValues, props) {
      buildHTMLStyles(renderState, latestValues, props.transformTemplate);
    }
    scrapeMotionValuesFromProps(props, prevProps, visualElement) {
      return scrapeMotionValuesFromProps(props, prevProps, visualElement);
    }
  };

  // node_modules/framer-motion/dist/es/render/svg/utils/camel-case-attrs.mjs
  var camelCaseAttributes = /* @__PURE__ */ new Set([
    "baseFrequency",
    "diffuseConstant",
    "kernelMatrix",
    "kernelUnitLength",
    "keySplines",
    "keyTimes",
    "limitingConeAngle",
    "markerHeight",
    "markerWidth",
    "numOctaves",
    "targetX",
    "targetY",
    "surfaceScale",
    "specularConstant",
    "specularExponent",
    "stdDeviation",
    "tableValues",
    "viewBox",
    "gradientTransform",
    "pathLength",
    "startOffset",
    "textLength",
    "lengthAdjust"
  ]);

  // node_modules/framer-motion/dist/es/render/svg/utils/render.mjs
  function renderSVG(element, renderState, _styleProp, projection) {
    renderHTML(element, renderState, void 0, projection);
    for (const key in renderState.attrs) {
      element.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, renderState.attrs[key]);
    }
  }

  // node_modules/framer-motion/dist/es/render/svg/SVGVisualElement.mjs
  var SVGVisualElement = class extends DOMVisualElement {
    constructor() {
      super(...arguments);
      this.type = "svg";
      this.isSVGTag = false;
      this.measureInstanceViewportBox = createBox;
    }
    getBaseTargetFromProps(props, key) {
      return props[key];
    }
    readValueFromInstance(instance, key) {
      if (transformProps.has(key)) {
        const defaultType = getDefaultValueType(key);
        return defaultType ? defaultType.default || 0 : 0;
      }
      key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;
      return instance.getAttribute(key);
    }
    scrapeMotionValuesFromProps(props, prevProps, visualElement) {
      return scrapeMotionValuesFromProps2(props, prevProps, visualElement);
    }
    build(renderState, latestValues, props) {
      buildSVGAttrs(renderState, latestValues, this.isSVGTag, props.transformTemplate, props.style);
    }
    renderInstance(instance, renderState, styleProp, projection) {
      renderSVG(instance, renderState, styleProp, projection);
    }
    mount(instance) {
      this.isSVGTag = isSVGTag(instance.tagName);
      super.mount(instance);
    }
  };

  // node_modules/framer-motion/dist/es/render/dom/create-visual-element.mjs
  var createDomVisualElement = (Component3, options) => {
    return isSVGComponent(Component3) ? new SVGVisualElement(options) : new HTMLVisualElement(options, {
      allowProjection: Component3 !== import_react22.Fragment
    });
  };

  // node_modules/framer-motion/dist/es/render/utils/resolve-dynamic-variants.mjs
  function resolveVariant(visualElement, definition, custom) {
    const props = visualElement.getProps();
    return resolveVariantFromProps(props, definition, custom !== void 0 ? custom : props.custom, visualElement);
  }

  // node_modules/framer-motion/dist/es/animation/utils/is-keyframes-target.mjs
  var isKeyframesTarget = (v) => {
    return Array.isArray(v);
  };

  // node_modules/framer-motion/dist/es/render/utils/setters.mjs
  function setMotionValue(visualElement, key, value) {
    if (visualElement.hasValue(key)) {
      visualElement.getValue(key).set(value);
    } else {
      visualElement.addValue(key, motionValue(value));
    }
  }
  function resolveFinalValueInKeyframes(v) {
    return isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;
  }
  function setTarget(visualElement, definition) {
    const resolved = resolveVariant(visualElement, definition);
    let { transitionEnd = {}, transition = {}, ...target } = resolved || {};
    target = { ...target, ...transitionEnd };
    for (const key in target) {
      const value = resolveFinalValueInKeyframes(target[key]);
      setMotionValue(visualElement, key, value);
    }
  }

  // node_modules/framer-motion/dist/es/value/use-will-change/is.mjs
  function isWillChangeMotionValue(value) {
    return Boolean(isMotionValue(value) && value.add);
  }

  // node_modules/framer-motion/dist/es/value/use-will-change/add-will-change.mjs
  function addValueToWillChange(visualElement, key) {
    const willChange = visualElement.getValue("willChange");
    if (isWillChangeMotionValue(willChange)) {
      return willChange.add(key);
    } else if (!willChange && MotionGlobalConfig.WillChange) {
      const newWillChange = new MotionGlobalConfig.WillChange("auto");
      visualElement.addValue("willChange", newWillChange);
      newWillChange.add(key);
    }
  }

  // node_modules/framer-motion/dist/es/animation/optimized-appear/get-appear-id.mjs
  function getOptimisedAppearId(visualElement) {
    return visualElement.props[optimizedAppearDataAttribute];
  }

  // node_modules/framer-motion/dist/es/animation/animators/waapi/utils/get-final-keyframe.mjs
  var isNotNull2 = (value) => value !== null;
  function getFinalKeyframe2(keyframes2, { repeat, repeatType = "loop" }, finalKeyframe) {
    const resolvedKeyframes = keyframes2.filter(isNotNull2);
    const index = repeat && repeatType !== "loop" && repeat % 2 === 1 ? 0 : resolvedKeyframes.length - 1;
    return !index || finalKeyframe === void 0 ? resolvedKeyframes[index] : finalKeyframe;
  }

  // node_modules/framer-motion/dist/es/animation/utils/default-transitions.mjs
  var underDampedSpring = {
    type: "spring",
    stiffness: 500,
    damping: 25,
    restSpeed: 10
  };
  var criticallyDampedSpring = (target) => ({
    type: "spring",
    stiffness: 550,
    damping: target === 0 ? 2 * Math.sqrt(550) : 30,
    restSpeed: 10
  });
  var keyframesTransition = {
    type: "keyframes",
    duration: 0.8
  };
  var ease = {
    type: "keyframes",
    ease: [0.25, 0.1, 0.35, 1],
    duration: 0.3
  };
  var getDefaultTransition = (valueKey, { keyframes: keyframes2 }) => {
    if (keyframes2.length > 2) {
      return keyframesTransition;
    } else if (transformProps.has(valueKey)) {
      return valueKey.startsWith("scale") ? criticallyDampedSpring(keyframes2[1]) : underDampedSpring;
    }
    return ease;
  };

  // node_modules/framer-motion/dist/es/animation/utils/is-transition-defined.mjs
  function isTransitionDefined({ when, delay: _delay, delayChildren, staggerChildren, staggerDirection, repeat, repeatType, repeatDelay, from, elapsed, ...transition }) {
    return !!Object.keys(transition).length;
  }

  // node_modules/framer-motion/dist/es/animation/interfaces/motion-value.mjs
  var animateMotionValue = (name, value, target, transition = {}, element, isHandoff) => (onComplete) => {
    const valueTransition = getValueTransition(transition, name) || {};
    const delay2 = valueTransition.delay || transition.delay || 0;
    let { elapsed = 0 } = transition;
    elapsed = elapsed - secondsToMilliseconds(delay2);
    const options = {
      keyframes: Array.isArray(target) ? target : [null, target],
      ease: "easeOut",
      velocity: value.getVelocity(),
      ...valueTransition,
      delay: -elapsed,
      onUpdate: (v) => {
        value.set(v);
        valueTransition.onUpdate && valueTransition.onUpdate(v);
      },
      onComplete: () => {
        onComplete();
        valueTransition.onComplete && valueTransition.onComplete();
      },
      name,
      motionValue: value,
      element: isHandoff ? void 0 : element
    };
    if (!isTransitionDefined(valueTransition)) {
      Object.assign(options, getDefaultTransition(name, options));
    }
    options.duration && (options.duration = secondsToMilliseconds(options.duration));
    options.repeatDelay && (options.repeatDelay = secondsToMilliseconds(options.repeatDelay));
    if (options.from !== void 0) {
      options.keyframes[0] = options.from;
    }
    let shouldSkip = false;
    if (options.type === false || options.duration === 0 && !options.repeatDelay) {
      makeAnimationInstant(options);
      if (options.delay === 0) {
        shouldSkip = true;
      }
    }
    if (MotionGlobalConfig.instantAnimations || MotionGlobalConfig.skipAnimations) {
      shouldSkip = true;
      makeAnimationInstant(options);
      options.delay = 0;
    }
    options.allowFlatten = !valueTransition.type && !valueTransition.ease;
    if (shouldSkip && !isHandoff && value.get() !== void 0) {
      const finalKeyframe = getFinalKeyframe2(options.keyframes, valueTransition);
      if (finalKeyframe !== void 0) {
        frame.update(() => {
          options.onUpdate(finalKeyframe);
          options.onComplete();
        });
        return;
      }
    }
    return valueTransition.isSync ? new JSAnimation(options) : new AsyncMotionValueAnimation(options);
  };

  // node_modules/framer-motion/dist/es/animation/interfaces/visual-element-target.mjs
  function shouldBlockAnimation({ protectedKeys, needsAnimating }, key) {
    const shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;
    needsAnimating[key] = false;
    return shouldBlock;
  }
  function animateTarget(visualElement, targetAndTransition, { delay: delay2 = 0, transitionOverride, type } = {}) {
    let { transition = visualElement.getDefaultTransition(), transitionEnd, ...target } = targetAndTransition;
    if (transitionOverride)
      transition = transitionOverride;
    const animations2 = [];
    const animationTypeState = type && visualElement.animationState && visualElement.animationState.getState()[type];
    for (const key in target) {
      const value = visualElement.getValue(key, visualElement.latestValues[key] ?? null);
      const valueTarget = target[key];
      if (valueTarget === void 0 || animationTypeState && shouldBlockAnimation(animationTypeState, key)) {
        continue;
      }
      const valueTransition = {
        delay: delay2,
        ...getValueTransition(transition || {}, key)
      };
      const currentValue = value.get();
      if (currentValue !== void 0 && !value.isAnimating && !Array.isArray(valueTarget) && valueTarget === currentValue && !valueTransition.velocity) {
        continue;
      }
      let isHandoff = false;
      if (window.MotionHandoffAnimation) {
        const appearId = getOptimisedAppearId(visualElement);
        if (appearId) {
          const startTime = window.MotionHandoffAnimation(appearId, key, frame);
          if (startTime !== null) {
            valueTransition.startTime = startTime;
            isHandoff = true;
          }
        }
      }
      addValueToWillChange(visualElement, key);
      value.start(animateMotionValue(key, value, valueTarget, visualElement.shouldReduceMotion && positionalKeys.has(key) ? { type: false } : valueTransition, visualElement, isHandoff));
      const animation = value.animation;
      if (animation) {
        animations2.push(animation);
      }
    }
    if (transitionEnd) {
      Promise.all(animations2).then(() => {
        frame.update(() => {
          transitionEnd && setTarget(visualElement, transitionEnd);
        });
      });
    }
    return animations2;
  }

  // node_modules/framer-motion/dist/es/animation/utils/calc-child-stagger.mjs
  function calcChildStagger(children, child, delayChildren, staggerChildren = 0, staggerDirection = 1) {
    const index = Array.from(children).sort((a, b) => a.sortNodePosition(b)).indexOf(child);
    const numChildren = children.size;
    const maxStaggerDuration = (numChildren - 1) * staggerChildren;
    const delayIsFunction = typeof delayChildren === "function";
    return delayIsFunction ? delayChildren(index, numChildren) : staggerDirection === 1 ? index * staggerChildren : maxStaggerDuration - index * staggerChildren;
  }

  // node_modules/framer-motion/dist/es/animation/interfaces/visual-element-variant.mjs
  function animateVariant(visualElement, variant, options = {}) {
    const resolved = resolveVariant(visualElement, variant, options.type === "exit" ? visualElement.presenceContext?.custom : void 0);
    let { transition = visualElement.getDefaultTransition() || {} } = resolved || {};
    if (options.transitionOverride) {
      transition = options.transitionOverride;
    }
    const getAnimation = resolved ? () => Promise.all(animateTarget(visualElement, resolved, options)) : () => Promise.resolve();
    const getChildAnimations = visualElement.variantChildren && visualElement.variantChildren.size ? (forwardDelay = 0) => {
      const { delayChildren = 0, staggerChildren, staggerDirection } = transition;
      return animateChildren(visualElement, variant, forwardDelay, delayChildren, staggerChildren, staggerDirection, options);
    } : () => Promise.resolve();
    const { when } = transition;
    if (when) {
      const [first, last] = when === "beforeChildren" ? [getAnimation, getChildAnimations] : [getChildAnimations, getAnimation];
      return first().then(() => last());
    } else {
      return Promise.all([getAnimation(), getChildAnimations(options.delay)]);
    }
  }
  function animateChildren(visualElement, variant, delay2 = 0, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options) {
    const animations2 = [];
    for (const child of visualElement.variantChildren) {
      child.notify("AnimationStart", variant);
      animations2.push(animateVariant(child, variant, {
        ...options,
        delay: delay2 + (typeof delayChildren === "function" ? 0 : delayChildren) + calcChildStagger(visualElement.variantChildren, child, delayChildren, staggerChildren, staggerDirection)
      }).then(() => child.notify("AnimationComplete", variant)));
    }
    return Promise.all(animations2);
  }

  // node_modules/framer-motion/dist/es/animation/interfaces/visual-element.mjs
  function animateVisualElement(visualElement, definition, options = {}) {
    visualElement.notify("AnimationStart", definition);
    let animation;
    if (Array.isArray(definition)) {
      const animations2 = definition.map((variant) => animateVariant(visualElement, variant, options));
      animation = Promise.all(animations2);
    } else if (typeof definition === "string") {
      animation = animateVariant(visualElement, definition, options);
    } else {
      const resolvedDefinition = typeof definition === "function" ? resolveVariant(visualElement, definition, options.custom) : definition;
      animation = Promise.all(animateTarget(visualElement, resolvedDefinition, options));
    }
    return animation.then(() => {
      visualElement.notify("AnimationComplete", definition);
    });
  }

  // node_modules/framer-motion/dist/es/utils/shallow-compare.mjs
  function shallowCompare(next, prev) {
    if (!Array.isArray(prev))
      return false;
    const prevLength = prev.length;
    if (prevLength !== next.length)
      return false;
    for (let i = 0; i < prevLength; i++) {
      if (prev[i] !== next[i])
        return false;
    }
    return true;
  }

  // node_modules/framer-motion/dist/es/render/utils/get-variant-context.mjs
  var numVariantProps = variantProps.length;
  function getVariantContext(visualElement) {
    if (!visualElement)
      return void 0;
    if (!visualElement.isControllingVariants) {
      const context4 = visualElement.parent ? getVariantContext(visualElement.parent) || {} : {};
      if (visualElement.props.initial !== void 0) {
        context4.initial = visualElement.props.initial;
      }
      return context4;
    }
    const context3 = {};
    for (let i = 0; i < numVariantProps; i++) {
      const name = variantProps[i];
      const prop = visualElement.props[name];
      if (isVariantLabel(prop) || prop === false) {
        context3[name] = prop;
      }
    }
    return context3;
  }

  // node_modules/framer-motion/dist/es/render/utils/animation-state.mjs
  var reversePriorityOrder = [...variantPriorityOrder].reverse();
  var numAnimationTypes = variantPriorityOrder.length;
  function animateList(visualElement) {
    return (animations2) => Promise.all(animations2.map(({ animation, options }) => animateVisualElement(visualElement, animation, options)));
  }
  function createAnimationState(visualElement) {
    let animate = animateList(visualElement);
    let state = createState();
    let isInitialRender = true;
    const buildResolvedTypeValues = (type) => (acc, definition) => {
      const resolved = resolveVariant(visualElement, definition, type === "exit" ? visualElement.presenceContext?.custom : void 0);
      if (resolved) {
        const { transition, transitionEnd, ...target } = resolved;
        acc = { ...acc, ...target, ...transitionEnd };
      }
      return acc;
    };
    function setAnimateFunction(makeAnimator) {
      animate = makeAnimator(visualElement);
    }
    function animateChanges(changedActiveType) {
      const { props } = visualElement;
      const context3 = getVariantContext(visualElement.parent) || {};
      const animations2 = [];
      const removedKeys = /* @__PURE__ */ new Set();
      let encounteredKeys = {};
      let removedVariantIndex = Infinity;
      for (let i = 0; i < numAnimationTypes; i++) {
        const type = reversePriorityOrder[i];
        const typeState = state[type];
        const prop = props[type] !== void 0 ? props[type] : context3[type];
        const propIsVariant = isVariantLabel(prop);
        const activeDelta = type === changedActiveType ? typeState.isActive : null;
        if (activeDelta === false)
          removedVariantIndex = i;
        let isInherited = prop === context3[type] && prop !== props[type] && propIsVariant;
        if (isInherited && isInitialRender && visualElement.manuallyAnimateOnMount) {
          isInherited = false;
        }
        typeState.protectedKeys = { ...encounteredKeys };
        if (
          // If it isn't active and hasn't *just* been set as inactive
          !typeState.isActive && activeDelta === null || // If we didn't and don't have any defined prop for this animation type
          !prop && !typeState.prevProp || // Or if the prop doesn't define an animation
          isAnimationControls(prop) || typeof prop === "boolean"
        ) {
          continue;
        }
        const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);
        let shouldAnimateType = variantDidChange || // If we're making this variant active, we want to always make it active
        type === changedActiveType && typeState.isActive && !isInherited && propIsVariant || // If we removed a higher-priority variant (i is in reverse order)
        i > removedVariantIndex && propIsVariant;
        let handledRemovedValues = false;
        const definitionList = Array.isArray(prop) ? prop : [prop];
        let resolvedValues = definitionList.reduce(buildResolvedTypeValues(type), {});
        if (activeDelta === false)
          resolvedValues = {};
        const { prevResolvedValues = {} } = typeState;
        const allKeys = {
          ...prevResolvedValues,
          ...resolvedValues
        };
        const markToAnimate = (key) => {
          shouldAnimateType = true;
          if (removedKeys.has(key)) {
            handledRemovedValues = true;
            removedKeys.delete(key);
          }
          typeState.needsAnimating[key] = true;
          const motionValue2 = visualElement.getValue(key);
          if (motionValue2)
            motionValue2.liveStyle = false;
        };
        for (const key in allKeys) {
          const next = resolvedValues[key];
          const prev = prevResolvedValues[key];
          if (encounteredKeys.hasOwnProperty(key))
            continue;
          let valueHasChanged = false;
          if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {
            valueHasChanged = !shallowCompare(next, prev);
          } else {
            valueHasChanged = next !== prev;
          }
          if (valueHasChanged) {
            if (next !== void 0 && next !== null) {
              markToAnimate(key);
            } else {
              removedKeys.add(key);
            }
          } else if (next !== void 0 && removedKeys.has(key)) {
            markToAnimate(key);
          } else {
            typeState.protectedKeys[key] = true;
          }
        }
        typeState.prevProp = prop;
        typeState.prevResolvedValues = resolvedValues;
        if (typeState.isActive) {
          encounteredKeys = { ...encounteredKeys, ...resolvedValues };
        }
        if (isInitialRender && visualElement.blockInitialAnimation) {
          shouldAnimateType = false;
        }
        const willAnimateViaParent = isInherited && variantDidChange;
        const needsAnimating = !willAnimateViaParent || handledRemovedValues;
        if (shouldAnimateType && needsAnimating) {
          animations2.push(...definitionList.map((animation) => {
            const options = { type };
            if (typeof animation === "string" && isInitialRender && !willAnimateViaParent && visualElement.manuallyAnimateOnMount && visualElement.parent) {
              const { parent } = visualElement;
              const parentVariant = resolveVariant(parent, animation);
              if (parent.enteringChildren && parentVariant) {
                const { delayChildren } = parentVariant.transition || {};
                options.delay = calcChildStagger(parent.enteringChildren, visualElement, delayChildren);
              }
            }
            return {
              animation,
              options
            };
          }));
        }
      }
      if (removedKeys.size) {
        const fallbackAnimation = {};
        if (typeof props.initial !== "boolean") {
          const initialTransition = resolveVariant(visualElement, Array.isArray(props.initial) ? props.initial[0] : props.initial);
          if (initialTransition && initialTransition.transition) {
            fallbackAnimation.transition = initialTransition.transition;
          }
        }
        removedKeys.forEach((key) => {
          const fallbackTarget = visualElement.getBaseTarget(key);
          const motionValue2 = visualElement.getValue(key);
          if (motionValue2)
            motionValue2.liveStyle = true;
          fallbackAnimation[key] = fallbackTarget ?? null;
        });
        animations2.push({ animation: fallbackAnimation });
      }
      let shouldAnimate = Boolean(animations2.length);
      if (isInitialRender && (props.initial === false || props.initial === props.animate) && !visualElement.manuallyAnimateOnMount) {
        shouldAnimate = false;
      }
      isInitialRender = false;
      return shouldAnimate ? animate(animations2) : Promise.resolve();
    }
    function setActive(type, isActive) {
      if (state[type].isActive === isActive)
        return Promise.resolve();
      visualElement.variantChildren?.forEach((child) => child.animationState?.setActive(type, isActive));
      state[type].isActive = isActive;
      const animations2 = animateChanges(type);
      for (const key in state) {
        state[key].protectedKeys = {};
      }
      return animations2;
    }
    return {
      animateChanges,
      setActive,
      setAnimateFunction,
      getState: () => state,
      reset: () => {
        state = createState();
      }
    };
  }
  function checkVariantsDidChange(prev, next) {
    if (typeof next === "string") {
      return next !== prev;
    } else if (Array.isArray(next)) {
      return !shallowCompare(next, prev);
    }
    return false;
  }
  function createTypeState(isActive = false) {
    return {
      isActive,
      protectedKeys: {},
      needsAnimating: {},
      prevResolvedValues: {}
    };
  }
  function createState() {
    return {
      animate: createTypeState(true),
      whileInView: createTypeState(),
      whileHover: createTypeState(),
      whileTap: createTypeState(),
      whileDrag: createTypeState(),
      whileFocus: createTypeState(),
      exit: createTypeState()
    };
  }

  // node_modules/framer-motion/dist/es/motion/features/Feature.mjs
  var Feature = class {
    constructor(node) {
      this.isMounted = false;
      this.node = node;
    }
    update() {
    }
  };

  // node_modules/framer-motion/dist/es/motion/features/animation/index.mjs
  var AnimationFeature = class extends Feature {
    /**
     * We dynamically generate the AnimationState manager as it contains a reference
     * to the underlying animation library. We only want to load that if we load this,
     * so people can optionally code split it out using the `m` component.
     */
    constructor(node) {
      super(node);
      node.animationState || (node.animationState = createAnimationState(node));
    }
    updateAnimationControlsSubscription() {
      const { animate } = this.node.getProps();
      if (isAnimationControls(animate)) {
        this.unmountControls = animate.subscribe(this.node);
      }
    }
    /**
     * Subscribe any provided AnimationControls to the component's VisualElement
     */
    mount() {
      this.updateAnimationControlsSubscription();
    }
    update() {
      const { animate } = this.node.getProps();
      const { animate: prevAnimate } = this.node.prevProps || {};
      if (animate !== prevAnimate) {
        this.updateAnimationControlsSubscription();
      }
    }
    unmount() {
      this.node.animationState.reset();
      this.unmountControls?.();
    }
  };

  // node_modules/framer-motion/dist/es/motion/features/animation/exit.mjs
  var id = 0;
  var ExitAnimationFeature = class extends Feature {
    constructor() {
      super(...arguments);
      this.id = id++;
    }
    update() {
      if (!this.node.presenceContext)
        return;
      const { isPresent, onExitComplete } = this.node.presenceContext;
      const { isPresent: prevIsPresent } = this.node.prevPresenceContext || {};
      if (!this.node.animationState || isPresent === prevIsPresent) {
        return;
      }
      const exitAnimation = this.node.animationState.setActive("exit", !isPresent);
      if (onExitComplete && !isPresent) {
        exitAnimation.then(() => {
          onExitComplete(this.id);
        });
      }
    }
    mount() {
      const { register: register2, onExitComplete } = this.node.presenceContext || {};
      if (onExitComplete) {
        onExitComplete(this.id);
      }
      if (register2) {
        this.unmount = register2(this.id);
      }
    }
    unmount() {
    }
  };

  // node_modules/framer-motion/dist/es/motion/features/animations.mjs
  var animations = {
    animation: {
      Feature: AnimationFeature
    },
    exit: {
      Feature: ExitAnimationFeature
    }
  };

  // node_modules/framer-motion/dist/es/events/add-dom-event.mjs
  function addDomEvent(target, eventName, handler, options = { passive: true }) {
    target.addEventListener(eventName, handler, options);
    return () => target.removeEventListener(eventName, handler);
  }

  // node_modules/framer-motion/dist/es/events/event-info.mjs
  function extractEventInfo(event) {
    return {
      point: {
        x: event.pageX,
        y: event.pageY
      }
    };
  }
  var addPointerInfo = (handler) => {
    return (event) => isPrimaryPointer(event) && handler(event, extractEventInfo(event));
  };

  // node_modules/framer-motion/dist/es/events/add-pointer-event.mjs
  function addPointerEvent(target, eventName, handler, options) {
    return addDomEvent(target, eventName, addPointerInfo(handler), options);
  }

  // node_modules/framer-motion/dist/es/projection/geometry/delta-calc.mjs
  var SCALE_PRECISION = 1e-4;
  var SCALE_MIN = 1 - SCALE_PRECISION;
  var SCALE_MAX = 1 + SCALE_PRECISION;
  var TRANSLATE_PRECISION = 0.01;
  var TRANSLATE_MIN = 0 - TRANSLATE_PRECISION;
  var TRANSLATE_MAX = 0 + TRANSLATE_PRECISION;
  function calcLength(axis) {
    return axis.max - axis.min;
  }
  function isNear(value, target, maxDistance) {
    return Math.abs(value - target) <= maxDistance;
  }
  function calcAxisDelta(delta, source, target, origin = 0.5) {
    delta.origin = origin;
    delta.originPoint = mixNumber(source.min, source.max, delta.origin);
    delta.scale = calcLength(target) / calcLength(source);
    delta.translate = mixNumber(target.min, target.max, delta.origin) - delta.originPoint;
    if (delta.scale >= SCALE_MIN && delta.scale <= SCALE_MAX || isNaN(delta.scale)) {
      delta.scale = 1;
    }
    if (delta.translate >= TRANSLATE_MIN && delta.translate <= TRANSLATE_MAX || isNaN(delta.translate)) {
      delta.translate = 0;
    }
  }
  function calcBoxDelta(delta, source, target, origin) {
    calcAxisDelta(delta.x, source.x, target.x, origin ? origin.originX : void 0);
    calcAxisDelta(delta.y, source.y, target.y, origin ? origin.originY : void 0);
  }
  function calcRelativeAxis(target, relative, parent) {
    target.min = parent.min + relative.min;
    target.max = target.min + calcLength(relative);
  }
  function calcRelativeBox(target, relative, parent) {
    calcRelativeAxis(target.x, relative.x, parent.x);
    calcRelativeAxis(target.y, relative.y, parent.y);
  }
  function calcRelativeAxisPosition(target, layout2, parent) {
    target.min = layout2.min - parent.min;
    target.max = target.min + calcLength(layout2);
  }
  function calcRelativePosition(target, layout2, parent) {
    calcRelativeAxisPosition(target.x, layout2.x, parent.x);
    calcRelativeAxisPosition(target.y, layout2.y, parent.y);
  }

  // node_modules/framer-motion/dist/es/projection/utils/each-axis.mjs
  function eachAxis(callback) {
    return [callback("x"), callback("y")];
  }

  // node_modules/framer-motion/dist/es/utils/get-context-window.mjs
  var getContextWindow = ({ current }) => {
    return current ? current.ownerDocument.defaultView : null;
  };

  // node_modules/framer-motion/dist/es/utils/distance.mjs
  var distance = (a, b) => Math.abs(a - b);
  function distance2D(a, b) {
    const xDelta = distance(a.x, b.x);
    const yDelta = distance(a.y, b.y);
    return Math.sqrt(xDelta ** 2 + yDelta ** 2);
  }

  // node_modules/framer-motion/dist/es/gestures/pan/PanSession.mjs
  var PanSession = class {
    constructor(event, handlers, { transformPagePoint, contextWindow = window, dragSnapToOrigin = false, distanceThreshold = 3 } = {}) {
      this.startEvent = null;
      this.lastMoveEvent = null;
      this.lastMoveEventInfo = null;
      this.handlers = {};
      this.contextWindow = window;
      this.updatePoint = () => {
        if (!(this.lastMoveEvent && this.lastMoveEventInfo))
          return;
        const info2 = getPanInfo(this.lastMoveEventInfo, this.history);
        const isPanStarted = this.startEvent !== null;
        const isDistancePastThreshold = distance2D(info2.offset, { x: 0, y: 0 }) >= this.distanceThreshold;
        if (!isPanStarted && !isDistancePastThreshold)
          return;
        const { point: point3 } = info2;
        const { timestamp: timestamp2 } = frameData;
        this.history.push({ ...point3, timestamp: timestamp2 });
        const { onStart, onMove } = this.handlers;
        if (!isPanStarted) {
          onStart && onStart(this.lastMoveEvent, info2);
          this.startEvent = this.lastMoveEvent;
        }
        onMove && onMove(this.lastMoveEvent, info2);
      };
      this.handlePointerMove = (event2, info2) => {
        this.lastMoveEvent = event2;
        this.lastMoveEventInfo = transformPoint(info2, this.transformPagePoint);
        frame.update(this.updatePoint, true);
      };
      this.handlePointerUp = (event2, info2) => {
        this.end();
        const { onEnd, onSessionEnd, resumeAnimation } = this.handlers;
        if (this.dragSnapToOrigin)
          resumeAnimation && resumeAnimation();
        if (!(this.lastMoveEvent && this.lastMoveEventInfo))
          return;
        const panInfo = getPanInfo(event2.type === "pointercancel" ? this.lastMoveEventInfo : transformPoint(info2, this.transformPagePoint), this.history);
        if (this.startEvent && onEnd) {
          onEnd(event2, panInfo);
        }
        onSessionEnd && onSessionEnd(event2, panInfo);
      };
      if (!isPrimaryPointer(event))
        return;
      this.dragSnapToOrigin = dragSnapToOrigin;
      this.handlers = handlers;
      this.transformPagePoint = transformPagePoint;
      this.distanceThreshold = distanceThreshold;
      this.contextWindow = contextWindow || window;
      const info = extractEventInfo(event);
      const initialInfo = transformPoint(info, this.transformPagePoint);
      const { point: point2 } = initialInfo;
      const { timestamp } = frameData;
      this.history = [{ ...point2, timestamp }];
      const { onSessionStart } = handlers;
      onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history));
      this.removeListeners = pipe3(addPointerEvent(this.contextWindow, "pointermove", this.handlePointerMove), addPointerEvent(this.contextWindow, "pointerup", this.handlePointerUp), addPointerEvent(this.contextWindow, "pointercancel", this.handlePointerUp));
    }
    updateHandlers(handlers) {
      this.handlers = handlers;
    }
    end() {
      this.removeListeners && this.removeListeners();
      cancelFrame(this.updatePoint);
    }
  };
  function transformPoint(info, transformPagePoint) {
    return transformPagePoint ? { point: transformPagePoint(info.point) } : info;
  }
  function subtractPoint(a, b) {
    return { x: a.x - b.x, y: a.y - b.y };
  }
  function getPanInfo({ point: point2 }, history) {
    return {
      point: point2,
      delta: subtractPoint(point2, lastDevicePoint(history)),
      offset: subtractPoint(point2, startDevicePoint(history)),
      velocity: getVelocity(history, 0.1)
    };
  }
  function startDevicePoint(history) {
    return history[0];
  }
  function lastDevicePoint(history) {
    return history[history.length - 1];
  }
  function getVelocity(history, timeDelta) {
    if (history.length < 2) {
      return { x: 0, y: 0 };
    }
    let i = history.length - 1;
    let timestampedPoint = null;
    const lastPoint = lastDevicePoint(history);
    while (i >= 0) {
      timestampedPoint = history[i];
      if (lastPoint.timestamp - timestampedPoint.timestamp > secondsToMilliseconds(timeDelta)) {
        break;
      }
      i--;
    }
    if (!timestampedPoint) {
      return { x: 0, y: 0 };
    }
    const time2 = millisecondsToSeconds(lastPoint.timestamp - timestampedPoint.timestamp);
    if (time2 === 0) {
      return { x: 0, y: 0 };
    }
    const currentVelocity = {
      x: (lastPoint.x - timestampedPoint.x) / time2,
      y: (lastPoint.y - timestampedPoint.y) / time2
    };
    if (currentVelocity.x === Infinity) {
      currentVelocity.x = 0;
    }
    if (currentVelocity.y === Infinity) {
      currentVelocity.y = 0;
    }
    return currentVelocity;
  }

  // node_modules/framer-motion/dist/es/gestures/drag/utils/constraints.mjs
  function applyConstraints(point2, { min, max }, elastic) {
    if (min !== void 0 && point2 < min) {
      point2 = elastic ? mixNumber(min, point2, elastic.min) : Math.max(point2, min);
    } else if (max !== void 0 && point2 > max) {
      point2 = elastic ? mixNumber(max, point2, elastic.max) : Math.min(point2, max);
    }
    return point2;
  }
  function calcRelativeAxisConstraints(axis, min, max) {
    return {
      min: min !== void 0 ? axis.min + min : void 0,
      max: max !== void 0 ? axis.max + max - (axis.max - axis.min) : void 0
    };
  }
  function calcRelativeConstraints(layoutBox, { top, left, bottom, right }) {
    return {
      x: calcRelativeAxisConstraints(layoutBox.x, left, right),
      y: calcRelativeAxisConstraints(layoutBox.y, top, bottom)
    };
  }
  function calcViewportAxisConstraints(layoutAxis, constraintsAxis) {
    let min = constraintsAxis.min - layoutAxis.min;
    let max = constraintsAxis.max - layoutAxis.max;
    if (constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min) {
      [min, max] = [max, min];
    }
    return { min, max };
  }
  function calcViewportConstraints(layoutBox, constraintsBox) {
    return {
      x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),
      y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y)
    };
  }
  function calcOrigin(source, target) {
    let origin = 0.5;
    const sourceLength = calcLength(source);
    const targetLength = calcLength(target);
    if (targetLength > sourceLength) {
      origin = progress(target.min, target.max - sourceLength, source.min);
    } else if (sourceLength > targetLength) {
      origin = progress(source.min, source.max - targetLength, target.min);
    }
    return clamp3(0, 1, origin);
  }
  function rebaseAxisConstraints(layout2, constraints) {
    const relativeConstraints = {};
    if (constraints.min !== void 0) {
      relativeConstraints.min = constraints.min - layout2.min;
    }
    if (constraints.max !== void 0) {
      relativeConstraints.max = constraints.max - layout2.min;
    }
    return relativeConstraints;
  }
  var defaultElastic = 0.35;
  function resolveDragElastic(dragElastic = defaultElastic) {
    if (dragElastic === false) {
      dragElastic = 0;
    } else if (dragElastic === true) {
      dragElastic = defaultElastic;
    }
    return {
      x: resolveAxisElastic(dragElastic, "left", "right"),
      y: resolveAxisElastic(dragElastic, "top", "bottom")
    };
  }
  function resolveAxisElastic(dragElastic, minLabel, maxLabel) {
    return {
      min: resolvePointElastic(dragElastic, minLabel),
      max: resolvePointElastic(dragElastic, maxLabel)
    };
  }
  function resolvePointElastic(dragElastic, label) {
    return typeof dragElastic === "number" ? dragElastic : dragElastic[label] || 0;
  }

  // node_modules/framer-motion/dist/es/gestures/drag/VisualElementDragControls.mjs
  var elementDragControls = /* @__PURE__ */ new WeakMap();
  var VisualElementDragControls = class {
    constructor(visualElement) {
      this.openDragLock = null;
      this.isDragging = false;
      this.currentDirection = null;
      this.originPoint = { x: 0, y: 0 };
      this.constraints = false;
      this.hasMutatedConstraints = false;
      this.elastic = createBox();
      this.latestPointerEvent = null;
      this.latestPanInfo = null;
      this.visualElement = visualElement;
    }
    start(originEvent, { snapToCursor = false, distanceThreshold } = {}) {
      const { presenceContext } = this.visualElement;
      if (presenceContext && presenceContext.isPresent === false)
        return;
      const onSessionStart = (event) => {
        const { dragSnapToOrigin: dragSnapToOrigin2 } = this.getProps();
        dragSnapToOrigin2 ? this.pauseAnimation() : this.stopAnimation();
        if (snapToCursor) {
          this.snapToCursor(extractEventInfo(event).point);
        }
      };
      const onStart = (event, info) => {
        const { drag: drag2, dragPropagation, onDragStart } = this.getProps();
        if (drag2 && !dragPropagation) {
          if (this.openDragLock)
            this.openDragLock();
          this.openDragLock = setDragLock(drag2);
          if (!this.openDragLock)
            return;
        }
        this.latestPointerEvent = event;
        this.latestPanInfo = info;
        this.isDragging = true;
        this.currentDirection = null;
        this.resolveConstraints();
        if (this.visualElement.projection) {
          this.visualElement.projection.isAnimationBlocked = true;
          this.visualElement.projection.target = void 0;
        }
        eachAxis((axis) => {
          let current = this.getAxisMotionValue(axis).get() || 0;
          if (percent.test(current)) {
            const { projection } = this.visualElement;
            if (projection && projection.layout) {
              const measuredAxis = projection.layout.layoutBox[axis];
              if (measuredAxis) {
                const length = calcLength(measuredAxis);
                current = length * (parseFloat(current) / 100);
              }
            }
          }
          this.originPoint[axis] = current;
        });
        if (onDragStart) {
          frame.postRender(() => onDragStart(event, info));
        }
        addValueToWillChange(this.visualElement, "transform");
        const { animationState } = this.visualElement;
        animationState && animationState.setActive("whileDrag", true);
      };
      const onMove = (event, info) => {
        this.latestPointerEvent = event;
        this.latestPanInfo = info;
        const { dragPropagation, dragDirectionLock, onDirectionLock, onDrag } = this.getProps();
        if (!dragPropagation && !this.openDragLock)
          return;
        const { offset } = info;
        if (dragDirectionLock && this.currentDirection === null) {
          this.currentDirection = getCurrentDirection(offset);
          if (this.currentDirection !== null) {
            onDirectionLock && onDirectionLock(this.currentDirection);
          }
          return;
        }
        this.updateAxis("x", info.point, offset);
        this.updateAxis("y", info.point, offset);
        this.visualElement.render();
        onDrag && onDrag(event, info);
      };
      const onSessionEnd = (event, info) => {
        this.latestPointerEvent = event;
        this.latestPanInfo = info;
        this.stop(event, info);
        this.latestPointerEvent = null;
        this.latestPanInfo = null;
      };
      const resumeAnimation = () => eachAxis((axis) => this.getAnimationState(axis) === "paused" && this.getAxisMotionValue(axis).animation?.play());
      const { dragSnapToOrigin } = this.getProps();
      this.panSession = new PanSession(originEvent, {
        onSessionStart,
        onStart,
        onMove,
        onSessionEnd,
        resumeAnimation
      }, {
        transformPagePoint: this.visualElement.getTransformPagePoint(),
        dragSnapToOrigin,
        distanceThreshold,
        contextWindow: getContextWindow(this.visualElement)
      });
    }
    /**
     * @internal
     */
    stop(event, panInfo) {
      const finalEvent = event || this.latestPointerEvent;
      const finalPanInfo = panInfo || this.latestPanInfo;
      const isDragging2 = this.isDragging;
      this.cancel();
      if (!isDragging2 || !finalPanInfo || !finalEvent)
        return;
      const { velocity } = finalPanInfo;
      this.startAnimation(velocity);
      const { onDragEnd } = this.getProps();
      if (onDragEnd) {
        frame.postRender(() => onDragEnd(finalEvent, finalPanInfo));
      }
    }
    /**
     * @internal
     */
    cancel() {
      this.isDragging = false;
      const { projection, animationState } = this.visualElement;
      if (projection) {
        projection.isAnimationBlocked = false;
      }
      this.panSession && this.panSession.end();
      this.panSession = void 0;
      const { dragPropagation } = this.getProps();
      if (!dragPropagation && this.openDragLock) {
        this.openDragLock();
        this.openDragLock = null;
      }
      animationState && animationState.setActive("whileDrag", false);
    }
    updateAxis(axis, _point, offset) {
      const { drag: drag2 } = this.getProps();
      if (!offset || !shouldDrag(axis, drag2, this.currentDirection))
        return;
      const axisValue = this.getAxisMotionValue(axis);
      let next = this.originPoint[axis] + offset[axis];
      if (this.constraints && this.constraints[axis]) {
        next = applyConstraints(next, this.constraints[axis], this.elastic[axis]);
      }
      axisValue.set(next);
    }
    resolveConstraints() {
      const { dragConstraints, dragElastic } = this.getProps();
      const layout2 = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(false) : this.visualElement.projection?.layout;
      const prevConstraints = this.constraints;
      if (dragConstraints && isRefObject(dragConstraints)) {
        if (!this.constraints) {
          this.constraints = this.resolveRefConstraints();
        }
      } else {
        if (dragConstraints && layout2) {
          this.constraints = calcRelativeConstraints(layout2.layoutBox, dragConstraints);
        } else {
          this.constraints = false;
        }
      }
      this.elastic = resolveDragElastic(dragElastic);
      if (prevConstraints !== this.constraints && layout2 && this.constraints && !this.hasMutatedConstraints) {
        eachAxis((axis) => {
          if (this.constraints !== false && this.getAxisMotionValue(axis)) {
            this.constraints[axis] = rebaseAxisConstraints(layout2.layoutBox[axis], this.constraints[axis]);
          }
        });
      }
    }
    resolveRefConstraints() {
      const { dragConstraints: constraints, onMeasureDragConstraints } = this.getProps();
      if (!constraints || !isRefObject(constraints))
        return false;
      const constraintsElement = constraints.current;
      invariant2(constraintsElement !== null, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.", "drag-constraints-ref");
      const { projection } = this.visualElement;
      if (!projection || !projection.layout)
        return false;
      const constraintsBox = measurePageBox(constraintsElement, projection.root, this.visualElement.getTransformPagePoint());
      let measuredConstraints = calcViewportConstraints(projection.layout.layoutBox, constraintsBox);
      if (onMeasureDragConstraints) {
        const userConstraints = onMeasureDragConstraints(convertBoxToBoundingBox(measuredConstraints));
        this.hasMutatedConstraints = !!userConstraints;
        if (userConstraints) {
          measuredConstraints = convertBoundingBoxToBox(userConstraints);
        }
      }
      return measuredConstraints;
    }
    startAnimation(velocity) {
      const { drag: drag2, dragMomentum, dragElastic, dragTransition, dragSnapToOrigin, onDragTransitionEnd } = this.getProps();
      const constraints = this.constraints || {};
      const momentumAnimations = eachAxis((axis) => {
        if (!shouldDrag(axis, drag2, this.currentDirection)) {
          return;
        }
        let transition = constraints && constraints[axis] || {};
        if (dragSnapToOrigin)
          transition = { min: 0, max: 0 };
        const bounceStiffness = dragElastic ? 200 : 1e6;
        const bounceDamping = dragElastic ? 40 : 1e7;
        const inertia2 = {
          type: "inertia",
          velocity: dragMomentum ? velocity[axis] : 0,
          bounceStiffness,
          bounceDamping,
          timeConstant: 750,
          restDelta: 1,
          restSpeed: 10,
          ...dragTransition,
          ...transition
        };
        return this.startAxisValueAnimation(axis, inertia2);
      });
      return Promise.all(momentumAnimations).then(onDragTransitionEnd);
    }
    startAxisValueAnimation(axis, transition) {
      const axisValue = this.getAxisMotionValue(axis);
      addValueToWillChange(this.visualElement, axis);
      return axisValue.start(animateMotionValue(axis, axisValue, 0, transition, this.visualElement, false));
    }
    stopAnimation() {
      eachAxis((axis) => this.getAxisMotionValue(axis).stop());
    }
    pauseAnimation() {
      eachAxis((axis) => this.getAxisMotionValue(axis).animation?.pause());
    }
    getAnimationState(axis) {
      return this.getAxisMotionValue(axis).animation?.state;
    }
    /**
     * Drag works differently depending on which props are provided.
     *
     * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
     * - Otherwise, we apply the delta to the x/y motion values.
     */
    getAxisMotionValue(axis) {
      const dragKey = `_drag${axis.toUpperCase()}`;
      const props = this.visualElement.getProps();
      const externalMotionValue = props[dragKey];
      return externalMotionValue ? externalMotionValue : this.visualElement.getValue(axis, (props.initial ? props.initial[axis] : void 0) || 0);
    }
    snapToCursor(point2) {
      eachAxis((axis) => {
        const { drag: drag2 } = this.getProps();
        if (!shouldDrag(axis, drag2, this.currentDirection))
          return;
        const { projection } = this.visualElement;
        const axisValue = this.getAxisMotionValue(axis);
        if (projection && projection.layout) {
          const { min, max } = projection.layout.layoutBox[axis];
          axisValue.set(point2[axis] - mixNumber(min, max, 0.5));
        }
      });
    }
    /**
     * When the viewport resizes we want to check if the measured constraints
     * have changed and, if so, reposition the element within those new constraints
     * relative to where it was before the resize.
     */
    scalePositionWithinConstraints() {
      if (!this.visualElement.current)
        return;
      const { drag: drag2, dragConstraints } = this.getProps();
      const { projection } = this.visualElement;
      if (!isRefObject(dragConstraints) || !projection || !this.constraints)
        return;
      this.stopAnimation();
      const boxProgress = { x: 0, y: 0 };
      eachAxis((axis) => {
        const axisValue = this.getAxisMotionValue(axis);
        if (axisValue && this.constraints !== false) {
          const latest = axisValue.get();
          boxProgress[axis] = calcOrigin({ min: latest, max: latest }, this.constraints[axis]);
        }
      });
      const { transformTemplate } = this.visualElement.getProps();
      this.visualElement.current.style.transform = transformTemplate ? transformTemplate({}, "") : "none";
      projection.root && projection.root.updateScroll();
      projection.updateLayout();
      this.resolveConstraints();
      eachAxis((axis) => {
        if (!shouldDrag(axis, drag2, null))
          return;
        const axisValue = this.getAxisMotionValue(axis);
        const { min, max } = this.constraints[axis];
        axisValue.set(mixNumber(min, max, boxProgress[axis]));
      });
    }
    addListeners() {
      if (!this.visualElement.current)
        return;
      elementDragControls.set(this.visualElement, this);
      const element = this.visualElement.current;
      const stopPointerListener = addPointerEvent(element, "pointerdown", (event) => {
        const { drag: drag2, dragListener = true } = this.getProps();
        drag2 && dragListener && this.start(event);
      });
      const measureDragConstraints = () => {
        const { dragConstraints } = this.getProps();
        if (isRefObject(dragConstraints) && dragConstraints.current) {
          this.constraints = this.resolveRefConstraints();
        }
      };
      const { projection } = this.visualElement;
      const stopMeasureLayoutListener = projection.addEventListener("measure", measureDragConstraints);
      if (projection && !projection.layout) {
        projection.root && projection.root.updateScroll();
        projection.updateLayout();
      }
      frame.read(measureDragConstraints);
      const stopResizeListener = addDomEvent(window, "resize", () => this.scalePositionWithinConstraints());
      const stopLayoutUpdateListener = projection.addEventListener("didUpdate", (({ delta, hasLayoutChanged }) => {
        if (this.isDragging && hasLayoutChanged) {
          eachAxis((axis) => {
            const motionValue2 = this.getAxisMotionValue(axis);
            if (!motionValue2)
              return;
            this.originPoint[axis] += delta[axis].translate;
            motionValue2.set(motionValue2.get() + delta[axis].translate);
          });
          this.visualElement.render();
        }
      }));
      return () => {
        stopResizeListener();
        stopPointerListener();
        stopMeasureLayoutListener();
        stopLayoutUpdateListener && stopLayoutUpdateListener();
      };
    }
    getProps() {
      const props = this.visualElement.getProps();
      const { drag: drag2 = false, dragDirectionLock = false, dragPropagation = false, dragConstraints = false, dragElastic = defaultElastic, dragMomentum = true } = props;
      return {
        ...props,
        drag: drag2,
        dragDirectionLock,
        dragPropagation,
        dragConstraints,
        dragElastic,
        dragMomentum
      };
    }
  };
  function shouldDrag(direction, drag2, currentDirection) {
    return (drag2 === true || drag2 === direction) && (currentDirection === null || currentDirection === direction);
  }
  function getCurrentDirection(offset, lockThreshold = 10) {
    let direction = null;
    if (Math.abs(offset.y) > lockThreshold) {
      direction = "y";
    } else if (Math.abs(offset.x) > lockThreshold) {
      direction = "x";
    }
    return direction;
  }

  // node_modules/framer-motion/dist/es/gestures/drag/index.mjs
  var DragGesture = class extends Feature {
    constructor(node) {
      super(node);
      this.removeGroupControls = noop3;
      this.removeListeners = noop3;
      this.controls = new VisualElementDragControls(node);
    }
    mount() {
      const { dragControls } = this.node.getProps();
      if (dragControls) {
        this.removeGroupControls = dragControls.subscribe(this.controls);
      }
      this.removeListeners = this.controls.addListeners() || noop3;
    }
    unmount() {
      this.removeGroupControls();
      this.removeListeners();
    }
  };

  // node_modules/framer-motion/dist/es/gestures/pan/index.mjs
  var asyncHandler = (handler) => (event, info) => {
    if (handler) {
      frame.postRender(() => handler(event, info));
    }
  };
  var PanGesture = class extends Feature {
    constructor() {
      super(...arguments);
      this.removePointerDownListener = noop3;
    }
    onPointerDown(pointerDownEvent) {
      this.session = new PanSession(pointerDownEvent, this.createPanHandlers(), {
        transformPagePoint: this.node.getTransformPagePoint(),
        contextWindow: getContextWindow(this.node)
      });
    }
    createPanHandlers() {
      const { onPanSessionStart, onPanStart, onPan, onPanEnd } = this.node.getProps();
      return {
        onSessionStart: asyncHandler(onPanSessionStart),
        onStart: asyncHandler(onPanStart),
        onMove: onPan,
        onEnd: (event, info) => {
          delete this.session;
          if (onPanEnd) {
            frame.postRender(() => onPanEnd(event, info));
          }
        }
      };
    }
    mount() {
      this.removePointerDownListener = addPointerEvent(this.node.current, "pointerdown", (event) => this.onPointerDown(event));
    }
    update() {
      this.session && this.session.updateHandlers(this.createPanHandlers());
    }
    unmount() {
      this.removePointerDownListener();
      this.session && this.session.end();
    }
  };

  // node_modules/framer-motion/dist/es/motion/features/layout/MeasureLayout.mjs
  var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
  var import_react23 = __toESM(require_react(), 1);

  // node_modules/framer-motion/dist/es/projection/node/state.mjs
  var globalProjectionState = {
    /**
     * Global flag as to whether the tree has animated since the last time
     * we resized the window
     */
    hasAnimatedSinceResize: true,
    /**
     * We set this to true once, on the first update. Any nodes added to the tree beyond that
     * update will be given a `data-projection-id` attribute.
     */
    hasEverUpdated: false
  };

  // node_modules/framer-motion/dist/es/projection/styles/scale-border-radius.mjs
  function pixelsToPercent(pixels, axis) {
    if (axis.max === axis.min)
      return 0;
    return pixels / (axis.max - axis.min) * 100;
  }
  var correctBorderRadius = {
    correct: (latest, node) => {
      if (!node.target)
        return latest;
      if (typeof latest === "string") {
        if (px.test(latest)) {
          latest = parseFloat(latest);
        } else {
          return latest;
        }
      }
      const x = pixelsToPercent(latest, node.target.x);
      const y = pixelsToPercent(latest, node.target.y);
      return `${x}% ${y}%`;
    }
  };

  // node_modules/framer-motion/dist/es/projection/styles/scale-box-shadow.mjs
  var correctBoxShadow = {
    correct: (latest, { treeScale, projectionDelta }) => {
      const original = latest;
      const shadow = complex.parse(latest);
      if (shadow.length > 5)
        return original;
      const template = complex.createTransformer(latest);
      const offset = typeof shadow[0] !== "number" ? 1 : 0;
      const xScale = projectionDelta.x.scale * treeScale.x;
      const yScale = projectionDelta.y.scale * treeScale.y;
      shadow[0 + offset] /= xScale;
      shadow[1 + offset] /= yScale;
      const averageScale = mixNumber(xScale, yScale, 0.5);
      if (typeof shadow[2 + offset] === "number")
        shadow[2 + offset] /= averageScale;
      if (typeof shadow[3 + offset] === "number")
        shadow[3 + offset] /= averageScale;
      return template(shadow);
    }
  };

  // node_modules/framer-motion/dist/es/motion/features/layout/MeasureLayout.mjs
  var hasTakenAnySnapshot = false;
  var MeasureLayoutWithContext = class extends import_react23.Component {
    /**
     * This only mounts projection nodes for components that
     * need measuring, we might want to do it for all components
     * in order to incorporate transforms
     */
    componentDidMount() {
      const { visualElement, layoutGroup, switchLayoutGroup, layoutId } = this.props;
      const { projection } = visualElement;
      addScaleCorrector(defaultScaleCorrectors);
      if (projection) {
        if (layoutGroup.group)
          layoutGroup.group.add(projection);
        if (switchLayoutGroup && switchLayoutGroup.register && layoutId) {
          switchLayoutGroup.register(projection);
        }
        if (hasTakenAnySnapshot) {
          projection.root.didUpdate();
        }
        projection.addEventListener("animationComplete", () => {
          this.safeToRemove();
        });
        projection.setOptions({
          ...projection.options,
          onExitComplete: () => this.safeToRemove()
        });
      }
      globalProjectionState.hasEverUpdated = true;
    }
    getSnapshotBeforeUpdate(prevProps) {
      const { layoutDependency, visualElement, drag: drag2, isPresent } = this.props;
      const { projection } = visualElement;
      if (!projection)
        return null;
      projection.isPresent = isPresent;
      hasTakenAnySnapshot = true;
      if (drag2 || prevProps.layoutDependency !== layoutDependency || layoutDependency === void 0 || prevProps.isPresent !== isPresent) {
        projection.willUpdate();
      } else {
        this.safeToRemove();
      }
      if (prevProps.isPresent !== isPresent) {
        if (isPresent) {
          projection.promote();
        } else if (!projection.relegate()) {
          frame.postRender(() => {
            const stack = projection.getStack();
            if (!stack || !stack.members.length) {
              this.safeToRemove();
            }
          });
        }
      }
      return null;
    }
    componentDidUpdate() {
      const { projection } = this.props.visualElement;
      if (projection) {
        projection.root.didUpdate();
        microtask.postRender(() => {
          if (!projection.currentAnimation && projection.isLead()) {
            this.safeToRemove();
          }
        });
      }
    }
    componentWillUnmount() {
      const { visualElement, layoutGroup, switchLayoutGroup: promoteContext } = this.props;
      const { projection } = visualElement;
      hasTakenAnySnapshot = true;
      if (projection) {
        projection.scheduleCheckAfterUnmount();
        if (layoutGroup && layoutGroup.group)
          layoutGroup.group.remove(projection);
        if (promoteContext && promoteContext.deregister)
          promoteContext.deregister(projection);
      }
    }
    safeToRemove() {
      const { safeToRemove } = this.props;
      safeToRemove && safeToRemove();
    }
    render() {
      return null;
    }
  };
  function MeasureLayout(props) {
    const [isPresent, safeToRemove] = usePresence();
    const layoutGroup = (0, import_react23.useContext)(LayoutGroupContext);
    return (0, import_jsx_runtime4.jsx)(MeasureLayoutWithContext, { ...props, layoutGroup, switchLayoutGroup: (0, import_react23.useContext)(SwitchLayoutGroupContext), isPresent, safeToRemove });
  }
  var defaultScaleCorrectors = {
    borderRadius: {
      ...correctBorderRadius,
      applyTo: [
        "borderTopLeftRadius",
        "borderTopRightRadius",
        "borderBottomLeftRadius",
        "borderBottomRightRadius"
      ]
    },
    borderTopLeftRadius: correctBorderRadius,
    borderTopRightRadius: correctBorderRadius,
    borderBottomLeftRadius: correctBorderRadius,
    borderBottomRightRadius: correctBorderRadius,
    boxShadow: correctBoxShadow
  };

  // node_modules/framer-motion/dist/es/animation/animate/single-value.mjs
  function animateSingleValue(value, keyframes2, options) {
    const motionValue$1 = isMotionValue(value) ? value : motionValue(value);
    motionValue$1.start(animateMotionValue("", motionValue$1, keyframes2, options));
    return motionValue$1.animation;
  }

  // node_modules/framer-motion/dist/es/render/utils/compare-by-depth.mjs
  var compareByDepth = (a, b) => a.depth - b.depth;

  // node_modules/framer-motion/dist/es/render/utils/flat-tree.mjs
  var FlatTree = class {
    constructor() {
      this.children = [];
      this.isDirty = false;
    }
    add(child) {
      addUniqueItem(this.children, child);
      this.isDirty = true;
    }
    remove(child) {
      removeItem(this.children, child);
      this.isDirty = true;
    }
    forEach(callback) {
      this.isDirty && this.children.sort(compareByDepth);
      this.isDirty = false;
      this.children.forEach(callback);
    }
  };

  // node_modules/framer-motion/dist/es/utils/delay.mjs
  function delay(callback, timeout) {
    const start = time.now();
    const checkElapsed = ({ timestamp }) => {
      const elapsed = timestamp - start;
      if (elapsed >= timeout) {
        cancelFrame(checkElapsed);
        callback(elapsed - timeout);
      }
    };
    frame.setup(checkElapsed, true);
    return () => cancelFrame(checkElapsed);
  }

  // node_modules/framer-motion/dist/es/projection/animation/mix-values.mjs
  var borders = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"];
  var numBorders = borders.length;
  var asNumber2 = (value) => typeof value === "string" ? parseFloat(value) : value;
  var isPx = (value) => typeof value === "number" || px.test(value);
  function mixValues(target, follow, lead, progress2, shouldCrossfadeOpacity, isOnlyMember) {
    if (shouldCrossfadeOpacity) {
      target.opacity = mixNumber(0, lead.opacity ?? 1, easeCrossfadeIn(progress2));
      target.opacityExit = mixNumber(follow.opacity ?? 1, 0, easeCrossfadeOut(progress2));
    } else if (isOnlyMember) {
      target.opacity = mixNumber(follow.opacity ?? 1, lead.opacity ?? 1, progress2);
    }
    for (let i = 0; i < numBorders; i++) {
      const borderLabel = `border${borders[i]}Radius`;
      let followRadius = getRadius(follow, borderLabel);
      let leadRadius = getRadius(lead, borderLabel);
      if (followRadius === void 0 && leadRadius === void 0)
        continue;
      followRadius || (followRadius = 0);
      leadRadius || (leadRadius = 0);
      const canMix = followRadius === 0 || leadRadius === 0 || isPx(followRadius) === isPx(leadRadius);
      if (canMix) {
        target[borderLabel] = Math.max(mixNumber(asNumber2(followRadius), asNumber2(leadRadius), progress2), 0);
        if (percent.test(leadRadius) || percent.test(followRadius)) {
          target[borderLabel] += "%";
        }
      } else {
        target[borderLabel] = leadRadius;
      }
    }
    if (follow.rotate || lead.rotate) {
      target.rotate = mixNumber(follow.rotate || 0, lead.rotate || 0, progress2);
    }
  }
  function getRadius(values, radiusName) {
    return values[radiusName] !== void 0 ? values[radiusName] : values.borderRadius;
  }
  var easeCrossfadeIn = /* @__PURE__ */ compress(0, 0.5, circOut);
  var easeCrossfadeOut = /* @__PURE__ */ compress(0.5, 0.95, noop3);
  function compress(min, max, easing) {
    return (p) => {
      if (p < min)
        return 0;
      if (p > max)
        return 1;
      return easing(progress(min, max, p));
    };
  }

  // node_modules/framer-motion/dist/es/projection/geometry/copy.mjs
  function copyAxisInto(axis, originAxis) {
    axis.min = originAxis.min;
    axis.max = originAxis.max;
  }
  function copyBoxInto(box, originBox) {
    copyAxisInto(box.x, originBox.x);
    copyAxisInto(box.y, originBox.y);
  }
  function copyAxisDeltaInto(delta, originDelta) {
    delta.translate = originDelta.translate;
    delta.scale = originDelta.scale;
    delta.originPoint = originDelta.originPoint;
    delta.origin = originDelta.origin;
  }

  // node_modules/framer-motion/dist/es/projection/geometry/delta-remove.mjs
  function removePointDelta(point2, translate, scale2, originPoint, boxScale) {
    point2 -= translate;
    point2 = scalePoint(point2, 1 / scale2, originPoint);
    if (boxScale !== void 0) {
      point2 = scalePoint(point2, 1 / boxScale, originPoint);
    }
    return point2;
  }
  function removeAxisDelta(axis, translate = 0, scale2 = 1, origin = 0.5, boxScale, originAxis = axis, sourceAxis = axis) {
    if (percent.test(translate)) {
      translate = parseFloat(translate);
      const relativeProgress = mixNumber(sourceAxis.min, sourceAxis.max, translate / 100);
      translate = relativeProgress - sourceAxis.min;
    }
    if (typeof translate !== "number")
      return;
    let originPoint = mixNumber(originAxis.min, originAxis.max, origin);
    if (axis === originAxis)
      originPoint -= translate;
    axis.min = removePointDelta(axis.min, translate, scale2, originPoint, boxScale);
    axis.max = removePointDelta(axis.max, translate, scale2, originPoint, boxScale);
  }
  function removeAxisTransforms(axis, transforms, [key, scaleKey, originKey], origin, sourceAxis) {
    removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale, origin, sourceAxis);
  }
  var xKeys = ["x", "scaleX", "originX"];
  var yKeys = ["y", "scaleY", "originY"];
  function removeBoxTransforms(box, transforms, originBox, sourceBox) {
    removeAxisTransforms(box.x, transforms, xKeys, originBox ? originBox.x : void 0, sourceBox ? sourceBox.x : void 0);
    removeAxisTransforms(box.y, transforms, yKeys, originBox ? originBox.y : void 0, sourceBox ? sourceBox.y : void 0);
  }

  // node_modules/framer-motion/dist/es/projection/geometry/utils.mjs
  function isAxisDeltaZero(delta) {
    return delta.translate === 0 && delta.scale === 1;
  }
  function isDeltaZero(delta) {
    return isAxisDeltaZero(delta.x) && isAxisDeltaZero(delta.y);
  }
  function axisEquals(a, b) {
    return a.min === b.min && a.max === b.max;
  }
  function boxEquals(a, b) {
    return axisEquals(a.x, b.x) && axisEquals(a.y, b.y);
  }
  function axisEqualsRounded(a, b) {
    return Math.round(a.min) === Math.round(b.min) && Math.round(a.max) === Math.round(b.max);
  }
  function boxEqualsRounded(a, b) {
    return axisEqualsRounded(a.x, b.x) && axisEqualsRounded(a.y, b.y);
  }
  function aspectRatio(box) {
    return calcLength(box.x) / calcLength(box.y);
  }
  function axisDeltaEquals(a, b) {
    return a.translate === b.translate && a.scale === b.scale && a.originPoint === b.originPoint;
  }

  // node_modules/framer-motion/dist/es/projection/shared/stack.mjs
  var NodeStack = class {
    constructor() {
      this.members = [];
    }
    add(node) {
      addUniqueItem(this.members, node);
      node.scheduleRender();
    }
    remove(node) {
      removeItem(this.members, node);
      if (node === this.prevLead) {
        this.prevLead = void 0;
      }
      if (node === this.lead) {
        const prevLead = this.members[this.members.length - 1];
        if (prevLead) {
          this.promote(prevLead);
        }
      }
    }
    relegate(node) {
      const indexOfNode = this.members.findIndex((member) => node === member);
      if (indexOfNode === 0)
        return false;
      let prevLead;
      for (let i = indexOfNode; i >= 0; i--) {
        const member = this.members[i];
        if (member.isPresent !== false) {
          prevLead = member;
          break;
        }
      }
      if (prevLead) {
        this.promote(prevLead);
        return true;
      } else {
        return false;
      }
    }
    promote(node, preserveFollowOpacity) {
      const prevLead = this.lead;
      if (node === prevLead)
        return;
      this.prevLead = prevLead;
      this.lead = node;
      node.show();
      if (prevLead) {
        prevLead.instance && prevLead.scheduleRender();
        node.scheduleRender();
        node.resumeFrom = prevLead;
        if (preserveFollowOpacity) {
          node.resumeFrom.preserveOpacity = true;
        }
        if (prevLead.snapshot) {
          node.snapshot = prevLead.snapshot;
          node.snapshot.latestValues = prevLead.animationValues || prevLead.latestValues;
        }
        if (node.root && node.root.isUpdating) {
          node.isLayoutDirty = true;
        }
        const { crossfade } = node.options;
        if (crossfade === false) {
          prevLead.hide();
        }
      }
    }
    exitAnimationComplete() {
      this.members.forEach((node) => {
        const { options, resumingFrom } = node;
        options.onExitComplete && options.onExitComplete();
        if (resumingFrom) {
          resumingFrom.options.onExitComplete && resumingFrom.options.onExitComplete();
        }
      });
    }
    scheduleRender() {
      this.members.forEach((node) => {
        node.instance && node.scheduleRender(false);
      });
    }
    /**
     * Clear any leads that have been removed this render to prevent them from being
     * used in future animations and to prevent memory leaks
     */
    removeLeadSnapshot() {
      if (this.lead && this.lead.snapshot) {
        this.lead.snapshot = void 0;
      }
    }
  };

  // node_modules/framer-motion/dist/es/projection/styles/transform.mjs
  function buildProjectionTransform(delta, treeScale, latestTransform) {
    let transform2 = "";
    const xTranslate = delta.x.translate / treeScale.x;
    const yTranslate = delta.y.translate / treeScale.y;
    const zTranslate = latestTransform?.z || 0;
    if (xTranslate || yTranslate || zTranslate) {
      transform2 = `translate3d(${xTranslate}px, ${yTranslate}px, ${zTranslate}px) `;
    }
    if (treeScale.x !== 1 || treeScale.y !== 1) {
      transform2 += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `;
    }
    if (latestTransform) {
      const { transformPerspective, rotate: rotate2, rotateX, rotateY, skewX, skewY } = latestTransform;
      if (transformPerspective)
        transform2 = `perspective(${transformPerspective}px) ${transform2}`;
      if (rotate2)
        transform2 += `rotate(${rotate2}deg) `;
      if (rotateX)
        transform2 += `rotateX(${rotateX}deg) `;
      if (rotateY)
        transform2 += `rotateY(${rotateY}deg) `;
      if (skewX)
        transform2 += `skewX(${skewX}deg) `;
      if (skewY)
        transform2 += `skewY(${skewY}deg) `;
    }
    const elementScaleX = delta.x.scale * treeScale.x;
    const elementScaleY = delta.y.scale * treeScale.y;
    if (elementScaleX !== 1 || elementScaleY !== 1) {
      transform2 += `scale(${elementScaleX}, ${elementScaleY})`;
    }
    return transform2 || "none";
  }

  // node_modules/framer-motion/dist/es/projection/node/create-projection-node.mjs
  var metrics = {
    nodes: 0,
    calculatedTargetDeltas: 0,
    calculatedProjections: 0
  };
  var transformAxes = ["", "X", "Y", "Z"];
  var animationTarget = 1e3;
  var id2 = 0;
  function resetDistortingTransform(key, visualElement, values, sharedAnimationValues) {
    const { latestValues } = visualElement;
    if (latestValues[key]) {
      values[key] = latestValues[key];
      visualElement.setStaticValue(key, 0);
      if (sharedAnimationValues) {
        sharedAnimationValues[key] = 0;
      }
    }
  }
  function cancelTreeOptimisedTransformAnimations(projectionNode) {
    projectionNode.hasCheckedOptimisedAppear = true;
    if (projectionNode.root === projectionNode)
      return;
    const { visualElement } = projectionNode.options;
    if (!visualElement)
      return;
    const appearId = getOptimisedAppearId(visualElement);
    if (window.MotionHasOptimisedAnimation(appearId, "transform")) {
      const { layout: layout2, layoutId } = projectionNode.options;
      window.MotionCancelOptimisedAnimation(appearId, "transform", frame, !(layout2 || layoutId));
    }
    const { parent } = projectionNode;
    if (parent && !parent.hasCheckedOptimisedAppear) {
      cancelTreeOptimisedTransformAnimations(parent);
    }
  }
  function createProjectionNode2({ attachResizeListener, defaultParent, measureScroll, checkIsScrollRoot, resetTransform }) {
    return class ProjectionNode {
      constructor(latestValues = {}, parent = defaultParent?.()) {
        this.id = id2++;
        this.animationId = 0;
        this.animationCommitId = 0;
        this.children = /* @__PURE__ */ new Set();
        this.options = {};
        this.isTreeAnimating = false;
        this.isAnimationBlocked = false;
        this.isLayoutDirty = false;
        this.isProjectionDirty = false;
        this.isSharedProjectionDirty = false;
        this.isTransformDirty = false;
        this.updateManuallyBlocked = false;
        this.updateBlockedByResize = false;
        this.isUpdating = false;
        this.isSVG = false;
        this.needsReset = false;
        this.shouldResetTransform = false;
        this.hasCheckedOptimisedAppear = false;
        this.treeScale = { x: 1, y: 1 };
        this.eventHandlers = /* @__PURE__ */ new Map();
        this.hasTreeAnimated = false;
        this.updateScheduled = false;
        this.scheduleUpdate = () => this.update();
        this.projectionUpdateScheduled = false;
        this.checkUpdateFailed = () => {
          if (this.isUpdating) {
            this.isUpdating = false;
            this.clearAllSnapshots();
          }
        };
        this.updateProjection = () => {
          this.projectionUpdateScheduled = false;
          if (statsBuffer.value) {
            metrics.nodes = metrics.calculatedTargetDeltas = metrics.calculatedProjections = 0;
          }
          this.nodes.forEach(propagateDirtyNodes);
          this.nodes.forEach(resolveTargetDelta);
          this.nodes.forEach(calcProjection);
          this.nodes.forEach(cleanDirtyNodes);
          if (statsBuffer.addProjectionMetrics) {
            statsBuffer.addProjectionMetrics(metrics);
          }
        };
        this.resolvedRelativeTargetAt = 0;
        this.hasProjected = false;
        this.isVisible = true;
        this.animationProgress = 0;
        this.sharedNodes = /* @__PURE__ */ new Map();
        this.latestValues = latestValues;
        this.root = parent ? parent.root || parent : this;
        this.path = parent ? [...parent.path, parent] : [];
        this.parent = parent;
        this.depth = parent ? parent.depth + 1 : 0;
        for (let i = 0; i < this.path.length; i++) {
          this.path[i].shouldResetTransform = true;
        }
        if (this.root === this)
          this.nodes = new FlatTree();
      }
      addEventListener(name, handler) {
        if (!this.eventHandlers.has(name)) {
          this.eventHandlers.set(name, new SubscriptionManager());
        }
        return this.eventHandlers.get(name).add(handler);
      }
      notifyListeners(name, ...args) {
        const subscriptionManager = this.eventHandlers.get(name);
        subscriptionManager && subscriptionManager.notify(...args);
      }
      hasListeners(name) {
        return this.eventHandlers.has(name);
      }
      /**
       * Lifecycles
       */
      mount(instance) {
        if (this.instance)
          return;
        this.isSVG = isSVGElement(instance) && !isSVGSVGElement(instance);
        this.instance = instance;
        const { layoutId, layout: layout2, visualElement } = this.options;
        if (visualElement && !visualElement.current) {
          visualElement.mount(instance);
        }
        this.root.nodes.add(this);
        this.parent && this.parent.children.add(this);
        if (this.root.hasTreeAnimated && (layout2 || layoutId)) {
          this.isLayoutDirty = true;
        }
        if (attachResizeListener) {
          let cancelDelay;
          let innerWidth = 0;
          const resizeUnblockUpdate = () => this.root.updateBlockedByResize = false;
          frame.read(() => {
            innerWidth = window.innerWidth;
          });
          attachResizeListener(instance, () => {
            const newInnerWidth = window.innerWidth;
            if (newInnerWidth === innerWidth)
              return;
            innerWidth = newInnerWidth;
            this.root.updateBlockedByResize = true;
            cancelDelay && cancelDelay();
            cancelDelay = delay(resizeUnblockUpdate, 250);
            if (globalProjectionState.hasAnimatedSinceResize) {
              globalProjectionState.hasAnimatedSinceResize = false;
              this.nodes.forEach(finishAnimation);
            }
          });
        }
        if (layoutId) {
          this.root.registerSharedNode(layoutId, this);
        }
        if (this.options.animate !== false && visualElement && (layoutId || layout2)) {
          this.addEventListener("didUpdate", ({ delta, hasLayoutChanged, hasRelativeLayoutChanged, layout: newLayout }) => {
            if (this.isTreeAnimationBlocked()) {
              this.target = void 0;
              this.relativeTarget = void 0;
              return;
            }
            const layoutTransition = this.options.transition || visualElement.getDefaultTransition() || defaultLayoutTransition;
            const { onLayoutAnimationStart, onLayoutAnimationComplete } = visualElement.getProps();
            const hasTargetChanged = !this.targetLayout || !boxEqualsRounded(this.targetLayout, newLayout);
            const hasOnlyRelativeTargetChanged = !hasLayoutChanged && hasRelativeLayoutChanged;
            if (this.options.layoutRoot || this.resumeFrom || hasOnlyRelativeTargetChanged || hasLayoutChanged && (hasTargetChanged || !this.currentAnimation)) {
              if (this.resumeFrom) {
                this.resumingFrom = this.resumeFrom;
                this.resumingFrom.resumingFrom = void 0;
              }
              const animationOptions = {
                ...getValueTransition(layoutTransition, "layout"),
                onPlay: onLayoutAnimationStart,
                onComplete: onLayoutAnimationComplete
              };
              if (visualElement.shouldReduceMotion || this.options.layoutRoot) {
                animationOptions.delay = 0;
                animationOptions.type = false;
              }
              this.startAnimation(animationOptions);
              this.setAnimationOrigin(delta, hasOnlyRelativeTargetChanged);
            } else {
              if (!hasLayoutChanged) {
                finishAnimation(this);
              }
              if (this.isLead() && this.options.onExitComplete) {
                this.options.onExitComplete();
              }
            }
            this.targetLayout = newLayout;
          });
        }
      }
      unmount() {
        this.options.layoutId && this.willUpdate();
        this.root.nodes.remove(this);
        const stack = this.getStack();
        stack && stack.remove(this);
        this.parent && this.parent.children.delete(this);
        this.instance = void 0;
        this.eventHandlers.clear();
        cancelFrame(this.updateProjection);
      }
      // only on the root
      blockUpdate() {
        this.updateManuallyBlocked = true;
      }
      unblockUpdate() {
        this.updateManuallyBlocked = false;
      }
      isUpdateBlocked() {
        return this.updateManuallyBlocked || this.updateBlockedByResize;
      }
      isTreeAnimationBlocked() {
        return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || false;
      }
      // Note: currently only running on root node
      startUpdate() {
        if (this.isUpdateBlocked())
          return;
        this.isUpdating = true;
        this.nodes && this.nodes.forEach(resetSkewAndRotation);
        this.animationId++;
      }
      getTransformTemplate() {
        const { visualElement } = this.options;
        return visualElement && visualElement.getProps().transformTemplate;
      }
      willUpdate(shouldNotifyListeners = true) {
        this.root.hasTreeAnimated = true;
        if (this.root.isUpdateBlocked()) {
          this.options.onExitComplete && this.options.onExitComplete();
          return;
        }
        if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear) {
          cancelTreeOptimisedTransformAnimations(this);
        }
        !this.root.isUpdating && this.root.startUpdate();
        if (this.isLayoutDirty)
          return;
        this.isLayoutDirty = true;
        for (let i = 0; i < this.path.length; i++) {
          const node = this.path[i];
          node.shouldResetTransform = true;
          node.updateScroll("snapshot");
          if (node.options.layoutRoot) {
            node.willUpdate(false);
          }
        }
        const { layoutId, layout: layout2 } = this.options;
        if (layoutId === void 0 && !layout2)
          return;
        const transformTemplate = this.getTransformTemplate();
        this.prevTransformTemplateValue = transformTemplate ? transformTemplate(this.latestValues, "") : void 0;
        this.updateSnapshot();
        shouldNotifyListeners && this.notifyListeners("willUpdate");
      }
      update() {
        this.updateScheduled = false;
        const updateWasBlocked = this.isUpdateBlocked();
        if (updateWasBlocked) {
          this.unblockUpdate();
          this.clearAllSnapshots();
          this.nodes.forEach(clearMeasurements);
          return;
        }
        if (this.animationId <= this.animationCommitId) {
          this.nodes.forEach(clearIsLayoutDirty);
          return;
        }
        this.animationCommitId = this.animationId;
        if (!this.isUpdating) {
          this.nodes.forEach(clearIsLayoutDirty);
        } else {
          this.isUpdating = false;
          this.nodes.forEach(resetTransformStyle);
          this.nodes.forEach(updateLayout);
          this.nodes.forEach(notifyLayoutUpdate);
        }
        this.clearAllSnapshots();
        const now3 = time.now();
        frameData.delta = clamp3(0, 1e3 / 60, now3 - frameData.timestamp);
        frameData.timestamp = now3;
        frameData.isProcessing = true;
        frameSteps.update.process(frameData);
        frameSteps.preRender.process(frameData);
        frameSteps.render.process(frameData);
        frameData.isProcessing = false;
      }
      didUpdate() {
        if (!this.updateScheduled) {
          this.updateScheduled = true;
          microtask.read(this.scheduleUpdate);
        }
      }
      clearAllSnapshots() {
        this.nodes.forEach(clearSnapshot);
        this.sharedNodes.forEach(removeLeadSnapshots);
      }
      scheduleUpdateProjection() {
        if (!this.projectionUpdateScheduled) {
          this.projectionUpdateScheduled = true;
          frame.preRender(this.updateProjection, false, true);
        }
      }
      scheduleCheckAfterUnmount() {
        frame.postRender(() => {
          if (this.isLayoutDirty) {
            this.root.didUpdate();
          } else {
            this.root.checkUpdateFailed();
          }
        });
      }
      /**
       * Update measurements
       */
      updateSnapshot() {
        if (this.snapshot || !this.instance)
          return;
        this.snapshot = this.measure();
        if (this.snapshot && !calcLength(this.snapshot.measuredBox.x) && !calcLength(this.snapshot.measuredBox.y)) {
          this.snapshot = void 0;
        }
      }
      updateLayout() {
        if (!this.instance)
          return;
        this.updateScroll();
        if (!(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty) {
          return;
        }
        if (this.resumeFrom && !this.resumeFrom.instance) {
          for (let i = 0; i < this.path.length; i++) {
            const node = this.path[i];
            node.updateScroll();
          }
        }
        const prevLayout = this.layout;
        this.layout = this.measure(false);
        this.layoutCorrected = createBox();
        this.isLayoutDirty = false;
        this.projectionDelta = void 0;
        this.notifyListeners("measure", this.layout.layoutBox);
        const { visualElement } = this.options;
        visualElement && visualElement.notify("LayoutMeasure", this.layout.layoutBox, prevLayout ? prevLayout.layoutBox : void 0);
      }
      updateScroll(phase = "measure") {
        let needsMeasurement = Boolean(this.options.layoutScroll && this.instance);
        if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === phase) {
          needsMeasurement = false;
        }
        if (needsMeasurement && this.instance) {
          const isRoot = checkIsScrollRoot(this.instance);
          this.scroll = {
            animationId: this.root.animationId,
            phase,
            isRoot,
            offset: measureScroll(this.instance),
            wasRoot: this.scroll ? this.scroll.isRoot : isRoot
          };
        }
      }
      resetTransform() {
        if (!resetTransform)
          return;
        const isResetRequested = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout;
        const hasProjection = this.projectionDelta && !isDeltaZero(this.projectionDelta);
        const transformTemplate = this.getTransformTemplate();
        const transformTemplateValue = transformTemplate ? transformTemplate(this.latestValues, "") : void 0;
        const transformTemplateHasChanged = transformTemplateValue !== this.prevTransformTemplateValue;
        if (isResetRequested && this.instance && (hasProjection || hasTransform(this.latestValues) || transformTemplateHasChanged)) {
          resetTransform(this.instance, transformTemplateValue);
          this.shouldResetTransform = false;
          this.scheduleRender();
        }
      }
      measure(removeTransform = true) {
        const pageBox = this.measurePageBox();
        let layoutBox = this.removeElementScroll(pageBox);
        if (removeTransform) {
          layoutBox = this.removeTransform(layoutBox);
        }
        roundBox(layoutBox);
        return {
          animationId: this.root.animationId,
          measuredBox: pageBox,
          layoutBox,
          latestValues: {},
          source: this.id
        };
      }
      measurePageBox() {
        const { visualElement } = this.options;
        if (!visualElement)
          return createBox();
        const box = visualElement.measureViewportBox();
        const wasInScrollRoot = this.scroll?.wasRoot || this.path.some(checkNodeWasScrollRoot);
        if (!wasInScrollRoot) {
          const { scroll: scroll2 } = this.root;
          if (scroll2) {
            translateAxis(box.x, scroll2.offset.x);
            translateAxis(box.y, scroll2.offset.y);
          }
        }
        return box;
      }
      removeElementScroll(box) {
        const boxWithoutScroll = createBox();
        copyBoxInto(boxWithoutScroll, box);
        if (this.scroll?.wasRoot) {
          return boxWithoutScroll;
        }
        for (let i = 0; i < this.path.length; i++) {
          const node = this.path[i];
          const { scroll: scroll2, options } = node;
          if (node !== this.root && scroll2 && options.layoutScroll) {
            if (scroll2.wasRoot) {
              copyBoxInto(boxWithoutScroll, box);
            }
            translateAxis(boxWithoutScroll.x, scroll2.offset.x);
            translateAxis(boxWithoutScroll.y, scroll2.offset.y);
          }
        }
        return boxWithoutScroll;
      }
      applyTransform(box, transformOnly = false) {
        const withTransforms = createBox();
        copyBoxInto(withTransforms, box);
        for (let i = 0; i < this.path.length; i++) {
          const node = this.path[i];
          if (!transformOnly && node.options.layoutScroll && node.scroll && node !== node.root) {
            transformBox(withTransforms, {
              x: -node.scroll.offset.x,
              y: -node.scroll.offset.y
            });
          }
          if (!hasTransform(node.latestValues))
            continue;
          transformBox(withTransforms, node.latestValues);
        }
        if (hasTransform(this.latestValues)) {
          transformBox(withTransforms, this.latestValues);
        }
        return withTransforms;
      }
      removeTransform(box) {
        const boxWithoutTransform = createBox();
        copyBoxInto(boxWithoutTransform, box);
        for (let i = 0; i < this.path.length; i++) {
          const node = this.path[i];
          if (!node.instance)
            continue;
          if (!hasTransform(node.latestValues))
            continue;
          hasScale(node.latestValues) && node.updateSnapshot();
          const sourceBox = createBox();
          const nodeBox = node.measurePageBox();
          copyBoxInto(sourceBox, nodeBox);
          removeBoxTransforms(boxWithoutTransform, node.latestValues, node.snapshot ? node.snapshot.layoutBox : void 0, sourceBox);
        }
        if (hasTransform(this.latestValues)) {
          removeBoxTransforms(boxWithoutTransform, this.latestValues);
        }
        return boxWithoutTransform;
      }
      setTargetDelta(delta) {
        this.targetDelta = delta;
        this.root.scheduleUpdateProjection();
        this.isProjectionDirty = true;
      }
      setOptions(options) {
        this.options = {
          ...this.options,
          ...options,
          crossfade: options.crossfade !== void 0 ? options.crossfade : true
        };
      }
      clearMeasurements() {
        this.scroll = void 0;
        this.layout = void 0;
        this.snapshot = void 0;
        this.prevTransformTemplateValue = void 0;
        this.targetDelta = void 0;
        this.target = void 0;
        this.isLayoutDirty = false;
      }
      forceRelativeParentToResolveTarget() {
        if (!this.relativeParent)
          return;
        if (this.relativeParent.resolvedRelativeTargetAt !== frameData.timestamp) {
          this.relativeParent.resolveTargetDelta(true);
        }
      }
      resolveTargetDelta(forceRecalculation = false) {
        const lead = this.getLead();
        this.isProjectionDirty || (this.isProjectionDirty = lead.isProjectionDirty);
        this.isTransformDirty || (this.isTransformDirty = lead.isTransformDirty);
        this.isSharedProjectionDirty || (this.isSharedProjectionDirty = lead.isSharedProjectionDirty);
        const isShared = Boolean(this.resumingFrom) || this !== lead;
        const canSkip = !(forceRecalculation || isShared && this.isSharedProjectionDirty || this.isProjectionDirty || this.parent?.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize);
        if (canSkip)
          return;
        const { layout: layout2, layoutId } = this.options;
        if (!this.layout || !(layout2 || layoutId))
          return;
        this.resolvedRelativeTargetAt = frameData.timestamp;
        if (!this.targetDelta && !this.relativeTarget) {
          const relativeParent = this.getClosestProjectingParent();
          if (relativeParent && relativeParent.layout && this.animationProgress !== 1) {
            this.relativeParent = relativeParent;
            this.forceRelativeParentToResolveTarget();
            this.relativeTarget = createBox();
            this.relativeTargetOrigin = createBox();
            calcRelativePosition(this.relativeTargetOrigin, this.layout.layoutBox, relativeParent.layout.layoutBox);
            copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
          } else {
            this.relativeParent = this.relativeTarget = void 0;
          }
        }
        if (!this.relativeTarget && !this.targetDelta)
          return;
        if (!this.target) {
          this.target = createBox();
          this.targetWithTransforms = createBox();
        }
        if (this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target) {
          this.forceRelativeParentToResolveTarget();
          calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target);
        } else if (this.targetDelta) {
          if (Boolean(this.resumingFrom)) {
            this.target = this.applyTransform(this.layout.layoutBox);
          } else {
            copyBoxInto(this.target, this.layout.layoutBox);
          }
          applyBoxDelta(this.target, this.targetDelta);
        } else {
          copyBoxInto(this.target, this.layout.layoutBox);
        }
        if (this.attemptToResolveRelativeTarget) {
          this.attemptToResolveRelativeTarget = false;
          const relativeParent = this.getClosestProjectingParent();
          if (relativeParent && Boolean(relativeParent.resumingFrom) === Boolean(this.resumingFrom) && !relativeParent.options.layoutScroll && relativeParent.target && this.animationProgress !== 1) {
            this.relativeParent = relativeParent;
            this.forceRelativeParentToResolveTarget();
            this.relativeTarget = createBox();
            this.relativeTargetOrigin = createBox();
            calcRelativePosition(this.relativeTargetOrigin, this.target, relativeParent.target);
            copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
          } else {
            this.relativeParent = this.relativeTarget = void 0;
          }
        }
        if (statsBuffer.value) {
          metrics.calculatedTargetDeltas++;
        }
      }
      getClosestProjectingParent() {
        if (!this.parent || hasScale(this.parent.latestValues) || has2DTranslate(this.parent.latestValues)) {
          return void 0;
        }
        if (this.parent.isProjecting()) {
          return this.parent;
        } else {
          return this.parent.getClosestProjectingParent();
        }
      }
      isProjecting() {
        return Boolean((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);
      }
      calcProjection() {
        const lead = this.getLead();
        const isShared = Boolean(this.resumingFrom) || this !== lead;
        let canSkip = true;
        if (this.isProjectionDirty || this.parent?.isProjectionDirty) {
          canSkip = false;
        }
        if (isShared && (this.isSharedProjectionDirty || this.isTransformDirty)) {
          canSkip = false;
        }
        if (this.resolvedRelativeTargetAt === frameData.timestamp) {
          canSkip = false;
        }
        if (canSkip)
          return;
        const { layout: layout2, layoutId } = this.options;
        this.isTreeAnimating = Boolean(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation);
        if (!this.isTreeAnimating) {
          this.targetDelta = this.relativeTarget = void 0;
        }
        if (!this.layout || !(layout2 || layoutId))
          return;
        copyBoxInto(this.layoutCorrected, this.layout.layoutBox);
        const prevTreeScaleX = this.treeScale.x;
        const prevTreeScaleY = this.treeScale.y;
        applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, isShared);
        if (lead.layout && !lead.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1)) {
          lead.target = lead.layout.layoutBox;
          lead.targetWithTransforms = createBox();
        }
        const { target } = lead;
        if (!target) {
          if (this.prevProjectionDelta) {
            this.createProjectionDeltas();
            this.scheduleRender();
          }
          return;
        }
        if (!this.projectionDelta || !this.prevProjectionDelta) {
          this.createProjectionDeltas();
        } else {
          copyAxisDeltaInto(this.prevProjectionDelta.x, this.projectionDelta.x);
          copyAxisDeltaInto(this.prevProjectionDelta.y, this.projectionDelta.y);
        }
        calcBoxDelta(this.projectionDelta, this.layoutCorrected, target, this.latestValues);
        if (this.treeScale.x !== prevTreeScaleX || this.treeScale.y !== prevTreeScaleY || !axisDeltaEquals(this.projectionDelta.x, this.prevProjectionDelta.x) || !axisDeltaEquals(this.projectionDelta.y, this.prevProjectionDelta.y)) {
          this.hasProjected = true;
          this.scheduleRender();
          this.notifyListeners("projectionUpdate", target);
        }
        if (statsBuffer.value) {
          metrics.calculatedProjections++;
        }
      }
      hide() {
        this.isVisible = false;
      }
      show() {
        this.isVisible = true;
      }
      scheduleRender(notifyAll2 = true) {
        this.options.visualElement?.scheduleRender();
        if (notifyAll2) {
          const stack = this.getStack();
          stack && stack.scheduleRender();
        }
        if (this.resumingFrom && !this.resumingFrom.instance) {
          this.resumingFrom = void 0;
        }
      }
      createProjectionDeltas() {
        this.prevProjectionDelta = createDelta();
        this.projectionDelta = createDelta();
        this.projectionDeltaWithTransform = createDelta();
      }
      setAnimationOrigin(delta, hasOnlyRelativeTargetChanged = false) {
        const snapshot = this.snapshot;
        const snapshotLatestValues = snapshot ? snapshot.latestValues : {};
        const mixedValues = { ...this.latestValues };
        const targetDelta = createDelta();
        if (!this.relativeParent || !this.relativeParent.options.layoutRoot) {
          this.relativeTarget = this.relativeTargetOrigin = void 0;
        }
        this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;
        const relativeLayout = createBox();
        const snapshotSource = snapshot ? snapshot.source : void 0;
        const layoutSource = this.layout ? this.layout.source : void 0;
        const isSharedLayoutAnimation = snapshotSource !== layoutSource;
        const stack = this.getStack();
        const isOnlyMember = !stack || stack.members.length <= 1;
        const shouldCrossfadeOpacity = Boolean(isSharedLayoutAnimation && !isOnlyMember && this.options.crossfade === true && !this.path.some(hasOpacityCrossfade));
        this.animationProgress = 0;
        let prevRelativeTarget;
        this.mixTargetDelta = (latest) => {
          const progress2 = latest / 1e3;
          mixAxisDelta(targetDelta.x, delta.x, progress2);
          mixAxisDelta(targetDelta.y, delta.y, progress2);
          this.setTargetDelta(targetDelta);
          if (this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout) {
            calcRelativePosition(relativeLayout, this.layout.layoutBox, this.relativeParent.layout.layoutBox);
            mixBox(this.relativeTarget, this.relativeTargetOrigin, relativeLayout, progress2);
            if (prevRelativeTarget && boxEquals(this.relativeTarget, prevRelativeTarget)) {
              this.isProjectionDirty = false;
            }
            if (!prevRelativeTarget)
              prevRelativeTarget = createBox();
            copyBoxInto(prevRelativeTarget, this.relativeTarget);
          }
          if (isSharedLayoutAnimation) {
            this.animationValues = mixedValues;
            mixValues(mixedValues, snapshotLatestValues, this.latestValues, progress2, shouldCrossfadeOpacity, isOnlyMember);
          }
          this.root.scheduleUpdateProjection();
          this.scheduleRender();
          this.animationProgress = progress2;
        };
        this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
      }
      startAnimation(options) {
        this.notifyListeners("animationStart");
        this.currentAnimation?.stop();
        this.resumingFrom?.currentAnimation?.stop();
        if (this.pendingAnimation) {
          cancelFrame(this.pendingAnimation);
          this.pendingAnimation = void 0;
        }
        this.pendingAnimation = frame.update(() => {
          globalProjectionState.hasAnimatedSinceResize = true;
          activeAnimations.layout++;
          this.motionValue || (this.motionValue = motionValue(0));
          this.currentAnimation = animateSingleValue(this.motionValue, [0, 1e3], {
            ...options,
            velocity: 0,
            isSync: true,
            onUpdate: (latest) => {
              this.mixTargetDelta(latest);
              options.onUpdate && options.onUpdate(latest);
            },
            onStop: () => {
              activeAnimations.layout--;
            },
            onComplete: () => {
              activeAnimations.layout--;
              options.onComplete && options.onComplete();
              this.completeAnimation();
            }
          });
          if (this.resumingFrom) {
            this.resumingFrom.currentAnimation = this.currentAnimation;
          }
          this.pendingAnimation = void 0;
        });
      }
      completeAnimation() {
        if (this.resumingFrom) {
          this.resumingFrom.currentAnimation = void 0;
          this.resumingFrom.preserveOpacity = void 0;
        }
        const stack = this.getStack();
        stack && stack.exitAnimationComplete();
        this.resumingFrom = this.currentAnimation = this.animationValues = void 0;
        this.notifyListeners("animationComplete");
      }
      finishAnimation() {
        if (this.currentAnimation) {
          this.mixTargetDelta && this.mixTargetDelta(animationTarget);
          this.currentAnimation.stop();
        }
        this.completeAnimation();
      }
      applyTransformsToTarget() {
        const lead = this.getLead();
        let { targetWithTransforms, target, layout: layout2, latestValues } = lead;
        if (!targetWithTransforms || !target || !layout2)
          return;
        if (this !== lead && this.layout && layout2 && shouldAnimatePositionOnly(this.options.animationType, this.layout.layoutBox, layout2.layoutBox)) {
          target = this.target || createBox();
          const xLength = calcLength(this.layout.layoutBox.x);
          target.x.min = lead.target.x.min;
          target.x.max = target.x.min + xLength;
          const yLength = calcLength(this.layout.layoutBox.y);
          target.y.min = lead.target.y.min;
          target.y.max = target.y.min + yLength;
        }
        copyBoxInto(targetWithTransforms, target);
        transformBox(targetWithTransforms, latestValues);
        calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, targetWithTransforms, latestValues);
      }
      registerSharedNode(layoutId, node) {
        if (!this.sharedNodes.has(layoutId)) {
          this.sharedNodes.set(layoutId, new NodeStack());
        }
        const stack = this.sharedNodes.get(layoutId);
        stack.add(node);
        const config3 = node.options.initialPromotionConfig;
        node.promote({
          transition: config3 ? config3.transition : void 0,
          preserveFollowOpacity: config3 && config3.shouldPreserveFollowOpacity ? config3.shouldPreserveFollowOpacity(node) : void 0
        });
      }
      isLead() {
        const stack = this.getStack();
        return stack ? stack.lead === this : true;
      }
      getLead() {
        const { layoutId } = this.options;
        return layoutId ? this.getStack()?.lead || this : this;
      }
      getPrevLead() {
        const { layoutId } = this.options;
        return layoutId ? this.getStack()?.prevLead : void 0;
      }
      getStack() {
        const { layoutId } = this.options;
        if (layoutId)
          return this.root.sharedNodes.get(layoutId);
      }
      promote({ needsReset, transition, preserveFollowOpacity } = {}) {
        const stack = this.getStack();
        if (stack)
          stack.promote(this, preserveFollowOpacity);
        if (needsReset) {
          this.projectionDelta = void 0;
          this.needsReset = true;
        }
        if (transition)
          this.setOptions({ transition });
      }
      relegate() {
        const stack = this.getStack();
        if (stack) {
          return stack.relegate(this);
        } else {
          return false;
        }
      }
      resetSkewAndRotation() {
        const { visualElement } = this.options;
        if (!visualElement)
          return;
        let hasDistortingTransform = false;
        const { latestValues } = visualElement;
        if (latestValues.z || latestValues.rotate || latestValues.rotateX || latestValues.rotateY || latestValues.rotateZ || latestValues.skewX || latestValues.skewY) {
          hasDistortingTransform = true;
        }
        if (!hasDistortingTransform)
          return;
        const resetValues = {};
        if (latestValues.z) {
          resetDistortingTransform("z", visualElement, resetValues, this.animationValues);
        }
        for (let i = 0; i < transformAxes.length; i++) {
          resetDistortingTransform(`rotate${transformAxes[i]}`, visualElement, resetValues, this.animationValues);
          resetDistortingTransform(`skew${transformAxes[i]}`, visualElement, resetValues, this.animationValues);
        }
        visualElement.render();
        for (const key in resetValues) {
          visualElement.setStaticValue(key, resetValues[key]);
          if (this.animationValues) {
            this.animationValues[key] = resetValues[key];
          }
        }
        visualElement.scheduleRender();
      }
      applyProjectionStyles(targetStyle, styleProp) {
        if (!this.instance || this.isSVG)
          return;
        if (!this.isVisible) {
          targetStyle.visibility = "hidden";
          return;
        }
        const transformTemplate = this.getTransformTemplate();
        if (this.needsReset) {
          this.needsReset = false;
          targetStyle.visibility = "";
          targetStyle.opacity = "";
          targetStyle.pointerEvents = resolveMotionValue(styleProp?.pointerEvents) || "";
          targetStyle.transform = transformTemplate ? transformTemplate(this.latestValues, "") : "none";
          return;
        }
        const lead = this.getLead();
        if (!this.projectionDelta || !this.layout || !lead.target) {
          if (this.options.layoutId) {
            targetStyle.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1;
            targetStyle.pointerEvents = resolveMotionValue(styleProp?.pointerEvents) || "";
          }
          if (this.hasProjected && !hasTransform(this.latestValues)) {
            targetStyle.transform = transformTemplate ? transformTemplate({}, "") : "none";
            this.hasProjected = false;
          }
          return;
        }
        targetStyle.visibility = "";
        const valuesToRender = lead.animationValues || lead.latestValues;
        this.applyTransformsToTarget();
        let transform2 = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, valuesToRender);
        if (transformTemplate) {
          transform2 = transformTemplate(valuesToRender, transform2);
        }
        targetStyle.transform = transform2;
        const { x, y } = this.projectionDelta;
        targetStyle.transformOrigin = `${x.origin * 100}% ${y.origin * 100}% 0`;
        if (lead.animationValues) {
          targetStyle.opacity = lead === this ? valuesToRender.opacity ?? this.latestValues.opacity ?? 1 : this.preserveOpacity ? this.latestValues.opacity : valuesToRender.opacityExit;
        } else {
          targetStyle.opacity = lead === this ? valuesToRender.opacity !== void 0 ? valuesToRender.opacity : "" : valuesToRender.opacityExit !== void 0 ? valuesToRender.opacityExit : 0;
        }
        for (const key in scaleCorrectors) {
          if (valuesToRender[key] === void 0)
            continue;
          const { correct, applyTo, isCSSVariable } = scaleCorrectors[key];
          const corrected = transform2 === "none" ? valuesToRender[key] : correct(valuesToRender[key], lead);
          if (applyTo) {
            const num = applyTo.length;
            for (let i = 0; i < num; i++) {
              targetStyle[applyTo[i]] = corrected;
            }
          } else {
            if (isCSSVariable) {
              this.options.visualElement.renderState.vars[key] = corrected;
            } else {
              targetStyle[key] = corrected;
            }
          }
        }
        if (this.options.layoutId) {
          targetStyle.pointerEvents = lead === this ? resolveMotionValue(styleProp?.pointerEvents) || "" : "none";
        }
      }
      clearSnapshot() {
        this.resumeFrom = this.snapshot = void 0;
      }
      // Only run on root
      resetTree() {
        this.root.nodes.forEach((node) => node.currentAnimation?.stop());
        this.root.nodes.forEach(clearMeasurements);
        this.root.sharedNodes.clear();
      }
    };
  }
  function updateLayout(node) {
    node.updateLayout();
  }
  function notifyLayoutUpdate(node) {
    const snapshot = node.resumeFrom?.snapshot || node.snapshot;
    if (node.isLead() && node.layout && snapshot && node.hasListeners("didUpdate")) {
      const { layoutBox: layout2, measuredBox: measuredLayout } = node.layout;
      const { animationType } = node.options;
      const isShared = snapshot.source !== node.layout.source;
      if (animationType === "size") {
        eachAxis((axis) => {
          const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];
          const length = calcLength(axisSnapshot);
          axisSnapshot.min = layout2[axis].min;
          axisSnapshot.max = axisSnapshot.min + length;
        });
      } else if (shouldAnimatePositionOnly(animationType, snapshot.layoutBox, layout2)) {
        eachAxis((axis) => {
          const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];
          const length = calcLength(layout2[axis]);
          axisSnapshot.max = axisSnapshot.min + length;
          if (node.relativeTarget && !node.currentAnimation) {
            node.isProjectionDirty = true;
            node.relativeTarget[axis].max = node.relativeTarget[axis].min + length;
          }
        });
      }
      const layoutDelta = createDelta();
      calcBoxDelta(layoutDelta, layout2, snapshot.layoutBox);
      const visualDelta = createDelta();
      if (isShared) {
        calcBoxDelta(visualDelta, node.applyTransform(measuredLayout, true), snapshot.measuredBox);
      } else {
        calcBoxDelta(visualDelta, layout2, snapshot.layoutBox);
      }
      const hasLayoutChanged = !isDeltaZero(layoutDelta);
      let hasRelativeLayoutChanged = false;
      if (!node.resumeFrom) {
        const relativeParent = node.getClosestProjectingParent();
        if (relativeParent && !relativeParent.resumeFrom) {
          const { snapshot: parentSnapshot, layout: parentLayout } = relativeParent;
          if (parentSnapshot && parentLayout) {
            const relativeSnapshot = createBox();
            calcRelativePosition(relativeSnapshot, snapshot.layoutBox, parentSnapshot.layoutBox);
            const relativeLayout = createBox();
            calcRelativePosition(relativeLayout, layout2, parentLayout.layoutBox);
            if (!boxEqualsRounded(relativeSnapshot, relativeLayout)) {
              hasRelativeLayoutChanged = true;
            }
            if (relativeParent.options.layoutRoot) {
              node.relativeTarget = relativeLayout;
              node.relativeTargetOrigin = relativeSnapshot;
              node.relativeParent = relativeParent;
            }
          }
        }
      }
      node.notifyListeners("didUpdate", {
        layout: layout2,
        snapshot,
        delta: visualDelta,
        layoutDelta,
        hasLayoutChanged,
        hasRelativeLayoutChanged
      });
    } else if (node.isLead()) {
      const { onExitComplete } = node.options;
      onExitComplete && onExitComplete();
    }
    node.options.transition = void 0;
  }
  function propagateDirtyNodes(node) {
    if (statsBuffer.value) {
      metrics.nodes++;
    }
    if (!node.parent)
      return;
    if (!node.isProjecting()) {
      node.isProjectionDirty = node.parent.isProjectionDirty;
    }
    node.isSharedProjectionDirty || (node.isSharedProjectionDirty = Boolean(node.isProjectionDirty || node.parent.isProjectionDirty || node.parent.isSharedProjectionDirty));
    node.isTransformDirty || (node.isTransformDirty = node.parent.isTransformDirty);
  }
  function cleanDirtyNodes(node) {
    node.isProjectionDirty = node.isSharedProjectionDirty = node.isTransformDirty = false;
  }
  function clearSnapshot(node) {
    node.clearSnapshot();
  }
  function clearMeasurements(node) {
    node.clearMeasurements();
  }
  function clearIsLayoutDirty(node) {
    node.isLayoutDirty = false;
  }
  function resetTransformStyle(node) {
    const { visualElement } = node.options;
    if (visualElement && visualElement.getProps().onBeforeLayoutMeasure) {
      visualElement.notify("BeforeLayoutMeasure");
    }
    node.resetTransform();
  }
  function finishAnimation(node) {
    node.finishAnimation();
    node.targetDelta = node.relativeTarget = node.target = void 0;
    node.isProjectionDirty = true;
  }
  function resolveTargetDelta(node) {
    node.resolveTargetDelta();
  }
  function calcProjection(node) {
    node.calcProjection();
  }
  function resetSkewAndRotation(node) {
    node.resetSkewAndRotation();
  }
  function removeLeadSnapshots(stack) {
    stack.removeLeadSnapshot();
  }
  function mixAxisDelta(output, delta, p) {
    output.translate = mixNumber(delta.translate, 0, p);
    output.scale = mixNumber(delta.scale, 1, p);
    output.origin = delta.origin;
    output.originPoint = delta.originPoint;
  }
  function mixAxis(output, from, to, p) {
    output.min = mixNumber(from.min, to.min, p);
    output.max = mixNumber(from.max, to.max, p);
  }
  function mixBox(output, from, to, p) {
    mixAxis(output.x, from.x, to.x, p);
    mixAxis(output.y, from.y, to.y, p);
  }
  function hasOpacityCrossfade(node) {
    return node.animationValues && node.animationValues.opacityExit !== void 0;
  }
  var defaultLayoutTransition = {
    duration: 0.45,
    ease: [0.4, 0, 0.1, 1]
  };
  var userAgentContains = (string) => typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(string);
  var roundPoint = userAgentContains("applewebkit/") && !userAgentContains("chrome/") ? Math.round : noop3;
  function roundAxis(axis) {
    axis.min = roundPoint(axis.min);
    axis.max = roundPoint(axis.max);
  }
  function roundBox(box) {
    roundAxis(box.x);
    roundAxis(box.y);
  }
  function shouldAnimatePositionOnly(animationType, snapshot, layout2) {
    return animationType === "position" || animationType === "preserve-aspect" && !isNear(aspectRatio(snapshot), aspectRatio(layout2), 0.2);
  }
  function checkNodeWasScrollRoot(node) {
    return node !== node.root && node.scroll?.wasRoot;
  }

  // node_modules/framer-motion/dist/es/projection/node/DocumentProjectionNode.mjs
  var DocumentProjectionNode = createProjectionNode2({
    attachResizeListener: (ref2, notify) => addDomEvent(ref2, "resize", notify),
    measureScroll: () => ({
      x: document.documentElement.scrollLeft || document.body.scrollLeft,
      y: document.documentElement.scrollTop || document.body.scrollTop
    }),
    checkIsScrollRoot: () => true
  });

  // node_modules/framer-motion/dist/es/projection/node/HTMLProjectionNode.mjs
  var rootProjectionNode = {
    current: void 0
  };
  var HTMLProjectionNode = createProjectionNode2({
    measureScroll: (instance) => ({
      x: instance.scrollLeft,
      y: instance.scrollTop
    }),
    defaultParent: () => {
      if (!rootProjectionNode.current) {
        const documentNode = new DocumentProjectionNode({});
        documentNode.mount(window);
        documentNode.setOptions({ layoutScroll: true });
        rootProjectionNode.current = documentNode;
      }
      return rootProjectionNode.current;
    },
    resetTransform: (instance, value) => {
      instance.style.transform = value !== void 0 ? value : "none";
    },
    checkIsScrollRoot: (instance) => Boolean(window.getComputedStyle(instance).position === "fixed")
  });

  // node_modules/framer-motion/dist/es/motion/features/drag.mjs
  var drag = {
    pan: {
      Feature: PanGesture
    },
    drag: {
      Feature: DragGesture,
      ProjectionNode: HTMLProjectionNode,
      MeasureLayout
    }
  };

  // node_modules/framer-motion/dist/es/gestures/hover.mjs
  function handleHoverEvent(node, event, lifecycle) {
    const { props } = node;
    if (node.animationState && props.whileHover) {
      node.animationState.setActive("whileHover", lifecycle === "Start");
    }
    const eventName = "onHover" + lifecycle;
    const callback = props[eventName];
    if (callback) {
      frame.postRender(() => callback(event, extractEventInfo(event)));
    }
  }
  var HoverGesture = class extends Feature {
    mount() {
      const { current } = this.node;
      if (!current)
        return;
      this.unmount = hover(current, (_element, startEvent) => {
        handleHoverEvent(this.node, startEvent, "Start");
        return (endEvent) => handleHoverEvent(this.node, endEvent, "End");
      });
    }
    unmount() {
    }
  };

  // node_modules/framer-motion/dist/es/gestures/focus.mjs
  var FocusGesture = class extends Feature {
    constructor() {
      super(...arguments);
      this.isActive = false;
    }
    onFocus() {
      let isFocusVisible = false;
      try {
        isFocusVisible = this.node.current.matches(":focus-visible");
      } catch (e) {
        isFocusVisible = true;
      }
      if (!isFocusVisible || !this.node.animationState)
        return;
      this.node.animationState.setActive("whileFocus", true);
      this.isActive = true;
    }
    onBlur() {
      if (!this.isActive || !this.node.animationState)
        return;
      this.node.animationState.setActive("whileFocus", false);
      this.isActive = false;
    }
    mount() {
      this.unmount = pipe3(addDomEvent(this.node.current, "focus", () => this.onFocus()), addDomEvent(this.node.current, "blur", () => this.onBlur()));
    }
    unmount() {
    }
  };

  // node_modules/framer-motion/dist/es/gestures/press.mjs
  function handlePressEvent(node, event, lifecycle) {
    const { props } = node;
    if (node.current instanceof HTMLButtonElement && node.current.disabled) {
      return;
    }
    if (node.animationState && props.whileTap) {
      node.animationState.setActive("whileTap", lifecycle === "Start");
    }
    const eventName = "onTap" + (lifecycle === "End" ? "" : lifecycle);
    const callback = props[eventName];
    if (callback) {
      frame.postRender(() => callback(event, extractEventInfo(event)));
    }
  }
  var PressGesture = class extends Feature {
    mount() {
      const { current } = this.node;
      if (!current)
        return;
      this.unmount = press(current, (_element, startEvent) => {
        handlePressEvent(this.node, startEvent, "Start");
        return (endEvent, { success }) => handlePressEvent(this.node, endEvent, success ? "End" : "Cancel");
      }, { useGlobalTarget: this.node.props.globalTapTarget });
    }
    unmount() {
    }
  };

  // node_modules/framer-motion/dist/es/motion/features/viewport/observers.mjs
  var observerCallbacks = /* @__PURE__ */ new WeakMap();
  var observers = /* @__PURE__ */ new WeakMap();
  var fireObserverCallback = (entry) => {
    const callback = observerCallbacks.get(entry.target);
    callback && callback(entry);
  };
  var fireAllObserverCallbacks = (entries) => {
    entries.forEach(fireObserverCallback);
  };
  function initIntersectionObserver({ root: root2, ...options }) {
    const lookupRoot = root2 || document;
    if (!observers.has(lookupRoot)) {
      observers.set(lookupRoot, {});
    }
    const rootObservers = observers.get(lookupRoot);
    const key = JSON.stringify(options);
    if (!rootObservers[key]) {
      rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, { root: root2, ...options });
    }
    return rootObservers[key];
  }
  function observeIntersection(element, options, callback) {
    const rootInteresectionObserver = initIntersectionObserver(options);
    observerCallbacks.set(element, callback);
    rootInteresectionObserver.observe(element);
    return () => {
      observerCallbacks.delete(element);
      rootInteresectionObserver.unobserve(element);
    };
  }

  // node_modules/framer-motion/dist/es/motion/features/viewport/index.mjs
  var thresholdNames = {
    some: 0,
    all: 1
  };
  var InViewFeature = class extends Feature {
    constructor() {
      super(...arguments);
      this.hasEnteredView = false;
      this.isInView = false;
    }
    startObserver() {
      this.unmount();
      const { viewport = {} } = this.node.getProps();
      const { root: root2, margin: rootMargin, amount = "some", once } = viewport;
      const options = {
        root: root2 ? root2.current : void 0,
        rootMargin,
        threshold: typeof amount === "number" ? amount : thresholdNames[amount]
      };
      const onIntersectionUpdate = (entry) => {
        const { isIntersecting } = entry;
        if (this.isInView === isIntersecting)
          return;
        this.isInView = isIntersecting;
        if (once && !isIntersecting && this.hasEnteredView) {
          return;
        } else if (isIntersecting) {
          this.hasEnteredView = true;
        }
        if (this.node.animationState) {
          this.node.animationState.setActive("whileInView", isIntersecting);
        }
        const { onViewportEnter, onViewportLeave } = this.node.getProps();
        const callback = isIntersecting ? onViewportEnter : onViewportLeave;
        callback && callback(entry);
      };
      return observeIntersection(this.node.current, options, onIntersectionUpdate);
    }
    mount() {
      this.startObserver();
    }
    update() {
      if (typeof IntersectionObserver === "undefined")
        return;
      const { props, prevProps } = this.node;
      const hasOptionsChanged = ["amount", "margin", "root"].some(hasViewportOptionChanged(props, prevProps));
      if (hasOptionsChanged) {
        this.startObserver();
      }
    }
    unmount() {
    }
  };
  function hasViewportOptionChanged({ viewport = {} }, { viewport: prevViewport = {} } = {}) {
    return (name) => viewport[name] !== prevViewport[name];
  }

  // node_modules/framer-motion/dist/es/motion/features/gestures.mjs
  var gestureAnimations = {
    inView: {
      Feature: InViewFeature
    },
    tap: {
      Feature: PressGesture
    },
    focus: {
      Feature: FocusGesture
    },
    hover: {
      Feature: HoverGesture
    }
  };

  // node_modules/framer-motion/dist/es/motion/features/layout.mjs
  var layout = {
    layout: {
      ProjectionNode: HTMLProjectionNode,
      MeasureLayout
    }
  };

  // node_modules/framer-motion/dist/es/render/components/motion/feature-bundle.mjs
  var featureBundle = {
    ...animations,
    ...gestureAnimations,
    ...drag,
    ...layout
  };

  // node_modules/framer-motion/dist/es/render/components/motion/proxy.mjs
  var motion = /* @__PURE__ */ createMotionProxy(featureBundle, createDomVisualElement);

  // node_modules/framer-motion/dist/es/utils/use-motion-value-event.mjs
  var import_react24 = __toESM(require_react(), 1);
  function useMotionValueEvent(value, event, callback) {
    (0, import_react24.useInsertionEffect)(() => value.on(event, callback), [value, event, callback]);
  }

  // node_modules/framer-motion/dist/es/value/use-scroll.mjs
  var import_react25 = __toESM(require_react(), 1);

  // node_modules/framer-motion/dist/es/render/dom/scroll/info.mjs
  var maxElapsed2 = 50;
  var createAxisInfo = () => ({
    current: 0,
    offset: [],
    progress: 0,
    scrollLength: 0,
    targetOffset: 0,
    targetLength: 0,
    containerLength: 0,
    velocity: 0
  });
  var createScrollInfo = () => ({
    time: 0,
    x: createAxisInfo(),
    y: createAxisInfo()
  });
  var keys = {
    x: {
      length: "Width",
      position: "Left"
    },
    y: {
      length: "Height",
      position: "Top"
    }
  };
  function updateAxisInfo(element, axisName, info, time2) {
    const axis = info[axisName];
    const { length, position } = keys[axisName];
    const prev = axis.current;
    const prevTime = info.time;
    axis.current = element[`scroll${position}`];
    axis.scrollLength = element[`scroll${length}`] - element[`client${length}`];
    axis.offset.length = 0;
    axis.offset[0] = 0;
    axis.offset[1] = axis.scrollLength;
    axis.progress = progress(0, axis.scrollLength, axis.current);
    const elapsed = time2 - prevTime;
    axis.velocity = elapsed > maxElapsed2 ? 0 : velocityPerSecond(axis.current - prev, elapsed);
  }
  function updateScrollInfo(element, info, time2) {
    updateAxisInfo(element, "x", info, time2);
    updateAxisInfo(element, "y", info, time2);
    info.time = time2;
  }

  // node_modules/framer-motion/dist/es/render/dom/scroll/offsets/inset.mjs
  function calcInset(element, container2) {
    const inset = { x: 0, y: 0 };
    let current = element;
    while (current && current !== container2) {
      if (isHTMLElement(current)) {
        inset.x += current.offsetLeft;
        inset.y += current.offsetTop;
        current = current.offsetParent;
      } else if (current.tagName === "svg") {
        const svgBoundingBox = current.getBoundingClientRect();
        current = current.parentElement;
        const parentBoundingBox = current.getBoundingClientRect();
        inset.x += svgBoundingBox.left - parentBoundingBox.left;
        inset.y += svgBoundingBox.top - parentBoundingBox.top;
      } else if (current instanceof SVGGraphicsElement) {
        const { x, y } = current.getBBox();
        inset.x += x;
        inset.y += y;
        let svg = null;
        let parent = current.parentNode;
        while (!svg) {
          if (parent.tagName === "svg") {
            svg = parent;
          }
          parent = current.parentNode;
        }
        current = svg;
      } else {
        break;
      }
    }
    return inset;
  }

  // node_modules/framer-motion/dist/es/render/dom/scroll/offsets/edge.mjs
  var namedEdges = {
    start: 0,
    center: 0.5,
    end: 1
  };
  function resolveEdge(edge, length, inset = 0) {
    let delta = 0;
    if (edge in namedEdges) {
      edge = namedEdges[edge];
    }
    if (typeof edge === "string") {
      const asNumber3 = parseFloat(edge);
      if (edge.endsWith("px")) {
        delta = asNumber3;
      } else if (edge.endsWith("%")) {
        edge = asNumber3 / 100;
      } else if (edge.endsWith("vw")) {
        delta = asNumber3 / 100 * document.documentElement.clientWidth;
      } else if (edge.endsWith("vh")) {
        delta = asNumber3 / 100 * document.documentElement.clientHeight;
      } else {
        edge = asNumber3;
      }
    }
    if (typeof edge === "number") {
      delta = length * edge;
    }
    return inset + delta;
  }

  // node_modules/framer-motion/dist/es/render/dom/scroll/offsets/offset.mjs
  var defaultOffset2 = [0, 0];
  function resolveOffset(offset, containerLength, targetLength, targetInset) {
    let offsetDefinition = Array.isArray(offset) ? offset : defaultOffset2;
    let targetPoint = 0;
    let containerPoint = 0;
    if (typeof offset === "number") {
      offsetDefinition = [offset, offset];
    } else if (typeof offset === "string") {
      offset = offset.trim();
      if (offset.includes(" ")) {
        offsetDefinition = offset.split(" ");
      } else {
        offsetDefinition = [offset, namedEdges[offset] ? offset : `0`];
      }
    }
    targetPoint = resolveEdge(offsetDefinition[0], targetLength, targetInset);
    containerPoint = resolveEdge(offsetDefinition[1], containerLength);
    return targetPoint - containerPoint;
  }

  // node_modules/framer-motion/dist/es/render/dom/scroll/offsets/presets.mjs
  var ScrollOffset = {
    Enter: [
      [0, 1],
      [1, 1]
    ],
    Exit: [
      [0, 0],
      [1, 0]
    ],
    Any: [
      [1, 0],
      [0, 1]
    ],
    All: [
      [0, 0],
      [1, 1]
    ]
  };

  // node_modules/framer-motion/dist/es/render/dom/scroll/offsets/index.mjs
  var point = { x: 0, y: 0 };
  function getTargetSize(target) {
    return "getBBox" in target && target.tagName !== "svg" ? target.getBBox() : { width: target.clientWidth, height: target.clientHeight };
  }
  function resolveOffsets(container2, info, options) {
    const { offset: offsetDefinition = ScrollOffset.All } = options;
    const { target = container2, axis = "y" } = options;
    const lengthLabel = axis === "y" ? "height" : "width";
    const inset = target !== container2 ? calcInset(target, container2) : point;
    const targetSize = target === container2 ? { width: container2.scrollWidth, height: container2.scrollHeight } : getTargetSize(target);
    const containerSize = {
      width: container2.clientWidth,
      height: container2.clientHeight
    };
    info[axis].offset.length = 0;
    let hasChanged = !info[axis].interpolate;
    const numOffsets = offsetDefinition.length;
    for (let i = 0; i < numOffsets; i++) {
      const offset = resolveOffset(offsetDefinition[i], containerSize[lengthLabel], targetSize[lengthLabel], inset[axis]);
      if (!hasChanged && offset !== info[axis].interpolatorOffsets[i]) {
        hasChanged = true;
      }
      info[axis].offset[i] = offset;
    }
    if (hasChanged) {
      info[axis].interpolate = interpolate3(info[axis].offset, defaultOffset(offsetDefinition), { clamp: false });
      info[axis].interpolatorOffsets = [...info[axis].offset];
    }
    info[axis].progress = clamp3(0, 1, info[axis].interpolate(info[axis].current));
  }

  // node_modules/framer-motion/dist/es/render/dom/scroll/on-scroll-handler.mjs
  function measure(container2, target = container2, info) {
    info.x.targetOffset = 0;
    info.y.targetOffset = 0;
    if (target !== container2) {
      let node = target;
      while (node && node !== container2) {
        info.x.targetOffset += node.offsetLeft;
        info.y.targetOffset += node.offsetTop;
        node = node.offsetParent;
      }
    }
    info.x.targetLength = target === container2 ? target.scrollWidth : target.clientWidth;
    info.y.targetLength = target === container2 ? target.scrollHeight : target.clientHeight;
    info.x.containerLength = container2.clientWidth;
    info.y.containerLength = container2.clientHeight;
    if (true) {
      if (container2 && target && target !== container2) {
        warnOnce2(getComputedStyle(container2).position !== "static", "Please ensure that the container has a non-static position, like 'relative', 'fixed', or 'absolute' to ensure scroll offset is calculated correctly.");
      }
    }
  }
  function createOnScrollHandler(element, onScroll, info, options = {}) {
    return {
      measure: (time2) => {
        measure(element, options.target, info);
        updateScrollInfo(element, info, time2);
        if (options.offset || options.target) {
          resolveOffsets(element, info, options);
        }
      },
      notify: () => onScroll(info)
    };
  }

  // node_modules/framer-motion/dist/es/render/dom/scroll/track.mjs
  var scrollListeners = /* @__PURE__ */ new WeakMap();
  var resizeListeners = /* @__PURE__ */ new WeakMap();
  var onScrollHandlers = /* @__PURE__ */ new WeakMap();
  var getEventTarget = (element) => element === document.scrollingElement ? window : element;
  function scrollInfo(onScroll, { container: container2 = document.scrollingElement, ...options } = {}) {
    if (!container2)
      return noop3;
    let containerHandlers = onScrollHandlers.get(container2);
    if (!containerHandlers) {
      containerHandlers = /* @__PURE__ */ new Set();
      onScrollHandlers.set(container2, containerHandlers);
    }
    const info = createScrollInfo();
    const containerHandler = createOnScrollHandler(container2, onScroll, info, options);
    containerHandlers.add(containerHandler);
    if (!scrollListeners.has(container2)) {
      const measureAll = () => {
        for (const handler of containerHandlers) {
          handler.measure(frameData.timestamp);
        }
        frame.preUpdate(notifyAll2);
      };
      const notifyAll2 = () => {
        for (const handler of containerHandlers) {
          handler.notify();
        }
      };
      const listener2 = () => frame.read(measureAll);
      scrollListeners.set(container2, listener2);
      const target = getEventTarget(container2);
      window.addEventListener("resize", listener2, { passive: true });
      if (container2 !== document.documentElement) {
        resizeListeners.set(container2, resize(container2, listener2));
      }
      target.addEventListener("scroll", listener2, { passive: true });
      listener2();
    }
    const listener = scrollListeners.get(container2);
    frame.read(listener, false, true);
    return () => {
      cancelFrame(listener);
      const currentHandlers = onScrollHandlers.get(container2);
      if (!currentHandlers)
        return;
      currentHandlers.delete(containerHandler);
      if (currentHandlers.size)
        return;
      const scrollListener = scrollListeners.get(container2);
      scrollListeners.delete(container2);
      if (scrollListener) {
        getEventTarget(container2).removeEventListener("scroll", scrollListener);
        resizeListeners.get(container2)?.();
        window.removeEventListener("resize", scrollListener);
      }
    };
  }

  // node_modules/framer-motion/dist/es/render/dom/scroll/utils/get-timeline.mjs
  var timelineCache = /* @__PURE__ */ new Map();
  function scrollTimelineFallback(options) {
    const currentTime = { value: 0 };
    const cancel = scrollInfo((info) => {
      currentTime.value = info[options.axis].progress * 100;
    }, options);
    return { currentTime, cancel };
  }
  function getTimeline({ source, container: container2, ...options }) {
    const { axis } = options;
    if (source)
      container2 = source;
    const containerCache = timelineCache.get(container2) ?? /* @__PURE__ */ new Map();
    timelineCache.set(container2, containerCache);
    const targetKey = options.target ?? "self";
    const targetCache = containerCache.get(targetKey) ?? {};
    const axisKey = axis + (options.offset ?? []).join(",");
    if (!targetCache[axisKey]) {
      targetCache[axisKey] = !options.target && supportsScrollTimeline() ? new ScrollTimeline({ source: container2, axis }) : scrollTimelineFallback({ container: container2, ...options });
    }
    return targetCache[axisKey];
  }

  // node_modules/framer-motion/dist/es/render/dom/scroll/attach-animation.mjs
  function attachToAnimation(animation, options) {
    const timeline2 = getTimeline(options);
    return animation.attachTimeline({
      timeline: options.target ? void 0 : timeline2,
      observe: (valueAnimation) => {
        valueAnimation.pause();
        return observeTimeline((progress2) => {
          valueAnimation.time = valueAnimation.iterationDuration * progress2;
        }, timeline2);
      }
    });
  }

  // node_modules/framer-motion/dist/es/render/dom/scroll/attach-function.mjs
  function isOnScrollWithInfo(onScroll) {
    return onScroll.length === 2;
  }
  function attachToFunction(onScroll, options) {
    if (isOnScrollWithInfo(onScroll)) {
      return scrollInfo((info) => {
        onScroll(info[options.axis].progress, info);
      }, options);
    } else {
      return observeTimeline(onScroll, getTimeline(options));
    }
  }

  // node_modules/framer-motion/dist/es/render/dom/scroll/index.mjs
  function scroll(onScroll, { axis = "y", container: container2 = document.scrollingElement, ...options } = {}) {
    if (!container2)
      return noop3;
    const optionsWithDefaults = { axis, container: container2, ...options };
    return typeof onScroll === "function" ? attachToFunction(onScroll, optionsWithDefaults) : attachToAnimation(onScroll, optionsWithDefaults);
  }

  // node_modules/framer-motion/dist/es/value/use-scroll.mjs
  var createScrollMotionValues = () => ({
    scrollX: motionValue(0),
    scrollY: motionValue(0),
    scrollXProgress: motionValue(0),
    scrollYProgress: motionValue(0)
  });
  var isRefPending = (ref2) => {
    if (!ref2)
      return false;
    return !ref2.current;
  };
  function useScroll({ container: container2, target, ...options } = {}) {
    const values = useConstant(createScrollMotionValues);
    const scrollAnimation = (0, import_react25.useRef)(null);
    const needsStart = (0, import_react25.useRef)(false);
    const start = (0, import_react25.useCallback)(() => {
      scrollAnimation.current = scroll((_progress, { x, y }) => {
        values.scrollX.set(x.current);
        values.scrollXProgress.set(x.progress);
        values.scrollY.set(y.current);
        values.scrollYProgress.set(y.progress);
      }, {
        ...options,
        container: container2?.current || void 0,
        target: target?.current || void 0
      });
      return () => {
        scrollAnimation.current?.();
      };
    }, [container2, target, JSON.stringify(options.offset)]);
    useIsomorphicLayoutEffect3(() => {
      needsStart.current = false;
      if (isRefPending(container2) || isRefPending(target)) {
        needsStart.current = true;
        return;
      } else {
        return start();
      }
    }, [start]);
    (0, import_react25.useEffect)(() => {
      if (needsStart.current) {
        invariant2(!isRefPending(container2), "Container ref is defined but not hydrated", "use-scroll-ref");
        invariant2(!isRefPending(target), "Target ref is defined but not hydrated", "use-scroll-ref");
        return start();
      } else {
        return;
      }
    }, [start]);
    return values;
  }

  // node_modules/framer-motion/dist/es/value/use-motion-value.mjs
  var import_react26 = __toESM(require_react(), 1);
  function useMotionValue(initial) {
    const value = useConstant(() => motionValue(initial));
    const { isStatic } = (0, import_react26.useContext)(MotionConfigContext);
    if (isStatic) {
      const [, setLatest] = (0, import_react26.useState)(initial);
      (0, import_react26.useEffect)(() => value.on("change", setLatest), []);
    }
    return value;
  }

  // node_modules/framer-motion/dist/es/value/use-combine-values.mjs
  function useCombineMotionValues(values, combineValues) {
    const value = useMotionValue(combineValues());
    const updateValue = () => value.set(combineValues());
    updateValue();
    useIsomorphicLayoutEffect3(() => {
      const scheduleUpdate = () => frame.preRender(updateValue, false, true);
      const subscriptions = values.map((v) => v.on("change", scheduleUpdate));
      return () => {
        subscriptions.forEach((unsubscribe) => unsubscribe());
        cancelFrame(updateValue);
      };
    });
    return value;
  }

  // node_modules/framer-motion/dist/es/value/use-spring.mjs
  var import_react27 = __toESM(require_react(), 1);

  // node_modules/framer-motion/dist/es/value/use-computed.mjs
  function useComputed(compute) {
    collectMotionValues.current = [];
    compute();
    const value = useCombineMotionValues(collectMotionValues.current, compute);
    collectMotionValues.current = void 0;
    return value;
  }

  // node_modules/framer-motion/dist/es/value/use-transform.mjs
  function useTransform(input, inputRangeOrTransformer, outputRange, options) {
    if (typeof input === "function") {
      return useComputed(input);
    }
    const transformer = typeof inputRangeOrTransformer === "function" ? inputRangeOrTransformer : transform(inputRangeOrTransformer, outputRange, options);
    return Array.isArray(input) ? useListTransform(input, transformer) : useListTransform([input], ([latest]) => transformer(latest));
  }
  function useListTransform(values, transformer) {
    const latest = useConstant(() => []);
    return useCombineMotionValues(values, () => {
      latest.length = 0;
      const numValues = values.length;
      for (let i = 0; i < numValues; i++) {
        latest[i] = values[i].get();
      }
      return transformer(latest);
    });
  }

  // node_modules/framer-motion/dist/es/value/use-spring.mjs
  function useSpring(source, options = {}) {
    const { isStatic } = (0, import_react27.useContext)(MotionConfigContext);
    const getFromSource = () => isMotionValue(source) ? source.get() : source;
    if (isStatic) {
      return useTransform(getFromSource);
    }
    const value = useMotionValue(getFromSource());
    (0, import_react27.useInsertionEffect)(() => {
      return attachSpring(value, source, options);
    }, [value, JSON.stringify(options)]);
    return value;
  }

  // node_modules/framer-motion/dist/es/utils/use-animation-frame.mjs
  var import_react28 = __toESM(require_react(), 1);
  function useAnimationFrame(callback) {
    const initialTimestamp = (0, import_react28.useRef)(0);
    const { isStatic } = (0, import_react28.useContext)(MotionConfigContext);
    (0, import_react28.useEffect)(() => {
      if (isStatic)
        return;
      const provideTimeSinceStart = ({ timestamp, delta }) => {
        if (!initialTimestamp.current)
          initialTimestamp.current = timestamp;
        callback(timestamp - initialTimestamp.current, delta);
      };
      frame.update(provideTimeSinceStart, true);
      return () => cancelFrame(provideTimeSinceStart);
    }, [callback]);
  }

  // node_modules/framer-motion/dist/es/value/use-velocity.mjs
  function useVelocity(value) {
    const velocity = useMotionValue(value.getVelocity());
    const updateVelocity = () => {
      const latest = value.getVelocity();
      velocity.set(latest);
      if (latest)
        frame.update(updateVelocity);
    };
    useMotionValueEvent(value, "change", () => {
      frame.update(updateVelocity, false, true);
    });
    return velocity;
  }

  // frontend/src/components/TiltedCard/TiltedCard.jsx
  var import_jsx_runtime5 = __toESM(require_jsx_runtime());
  var springValues = {
    damping: 30,
    stiffness: 100,
    mass: 2
  };
  function TiltedCard({
    imageSrc,
    altText = "Tilted card image",
    captionText = "",
    containerHeight = "300px",
    containerWidth = "100%",
    imageHeight = "300px",
    imageWidth = "300px",
    scaleOnHover = 1.1,
    rotateAmplitude = 14,
    showMobileWarning = true,
    showTooltip = true,
    overlayContent = null,
    displayOverlayContent = false
  }) {
    const ref2 = (0, import_react29.useRef)(null);
    const x = useMotionValue();
    const y = useMotionValue();
    const rotateX = useSpring(useMotionValue(0), springValues);
    const rotateY = useSpring(useMotionValue(0), springValues);
    const scale2 = useSpring(1, springValues);
    const opacity = useSpring(0);
    const rotateFigcaption = useSpring(0, {
      stiffness: 350,
      damping: 30,
      mass: 1
    });
    const [lastY, setLastY] = (0, import_react29.useState)(0);
    function handleMouse(e) {
      if (!ref2.current) return;
      const rect = ref2.current.getBoundingClientRect();
      const offsetX = e.clientX - rect.left - rect.width / 2;
      const offsetY = e.clientY - rect.top - rect.height / 2;
      const rotationX = offsetY / (rect.height / 2) * -rotateAmplitude;
      const rotationY = offsetX / (rect.width / 2) * rotateAmplitude;
      rotateX.set(rotationX);
      rotateY.set(rotationY);
      x.set(e.clientX - rect.left);
      y.set(e.clientY - rect.top);
      const velocityY = offsetY - lastY;
      rotateFigcaption.set(-velocityY * 0.6);
      setLastY(offsetY);
    }
    function handleMouseEnter() {
      scale2.set(scaleOnHover);
      opacity.set(1);
    }
    function handleMouseLeave() {
      opacity.set(0);
      scale2.set(1);
      rotateX.set(0);
      rotateY.set(0);
      rotateFigcaption.set(0);
    }
    return /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(
      "figure",
      {
        ref: ref2,
        className: "tilted-card-figure",
        style: {
          height: containerHeight,
          width: containerWidth
        },
        onMouseMove: handleMouse,
        onMouseEnter: handleMouseEnter,
        onMouseLeave: handleMouseLeave,
        children: [
          showMobileWarning && /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("div", { className: "tilted-card-mobile-alert", children: "This effect is not optimized for mobile. Check on desktop." }),
          /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(
            motion.div,
            {
              className: "tilted-card-inner",
              style: {
                width: imageWidth,
                height: imageHeight,
                rotateX,
                rotateY,
                scale: scale2
              },
              children: [
                /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
                  motion.img,
                  {
                    src: imageSrc,
                    alt: altText,
                    className: "tilted-card-img",
                    style: {
                      width: imageWidth,
                      height: imageHeight
                    }
                  }
                ),
                displayOverlayContent && overlayContent && /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(motion.div, { className: "tilted-card-overlay", children: overlayContent })
              ]
            }
          ),
          showTooltip && /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
            motion.figcaption,
            {
              className: "tilted-card-caption",
              style: {
                x,
                y,
                opacity,
                rotate: rotateFigcaption
              },
              children: captionText
            }
          )
        ]
      }
    );
  }

  // frontend/src/components/ScrambledText/ScrambledText.jsx
  var import_react31 = __toESM(require_react());

  // node_modules/gsap/utils/strings.js
  var _trimExp = /(?:^\s+|\s+$)/g;
  var emojiExp = /([\uD800-\uDBFF][\uDC00-\uDFFF](?:[\u200D\uFE0F][\uD800-\uDBFF][\uDC00-\uDFFF]){2,}|\uD83D\uDC69(?:\u200D(?:(?:\uD83D\uDC69\u200D)?\uD83D\uDC67|(?:\uD83D\uDC69\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2642\u2640]\uFE0F|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDD27\uDCBC\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC6F\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3C-\uDD3E\uDDD6-\uDDDF])\u200D[\u2640\u2642]\uFE0F|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|(?:\u26F9|\uD83C[\uDFCC\uDFCB]|\uD83D\uDD75)(?:\uFE0F\u200D[\u2640\u2642]|(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642])\uFE0F|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\uD83D\uDC69\u200D[\u2695\u2696\u2708]|\uD83D\uDC68(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708]))\uFE0F|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83D\uDC69\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|\uD83D\uDC68(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]))|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDD1-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\u200D(?:(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC69\uDC6E\uDC70-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD26\uDD30-\uDD39\uDD3D\uDD3E\uDDD1-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])?|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDEEB\uDEEC\uDEF4-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u2660\u2663\u2665\u2666\u2668\u267B\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])\uFE0F)/;
  function getText(e) {
    var type = e.nodeType, result = "";
    if (type === 1 || type === 9 || type === 11) {
      if (typeof e.textContent === "string") {
        return e.textContent;
      } else {
        for (e = e.firstChild; e; e = e.nextSibling) {
          result += getText(e);
        }
      }
    } else if (type === 3 || type === 4) {
      return e.nodeValue;
    }
    return result;
  }
  function emojiSafeSplit(text, delimiter, trim, preserveSpaces, unescapedCharCodes) {
    text += "";
    trim && (text = text.trim ? text.trim() : text.replace(_trimExp, ""));
    if (delimiter && delimiter !== "") {
      return text.replace(/>/g, "&gt;").replace(/</g, "&lt;").split(delimiter);
    }
    var result = [], l = text.length, i = 0, j, character;
    for (; i < l; i++) {
      character = text.charAt(i);
      if (character.charCodeAt(0) >= 55296 && character.charCodeAt(0) <= 56319 || text.charCodeAt(i + 1) >= 65024 && text.charCodeAt(i + 1) <= 65039) {
        j = ((text.substr(i, 12).split(emojiExp) || [])[1] || "").length || 2;
        character = text.substr(i, j);
        result.emoji = 1;
        i += j - 1;
      }
      result.push(unescapedCharCodes ? character : character === ">" ? "&gt;" : character === "<" ? "&lt;" : preserveSpaces && character === " " && (text.charAt(i - 1) === " " || text.charAt(i + 1) === " ") ? "&nbsp;" : character);
    }
    return result;
  }

  // node_modules/gsap/ScrambleTextPlugin.js
  var CharSet = /* @__PURE__ */ (function() {
    function CharSet2(chars) {
      this.chars = emojiSafeSplit(chars);
      this.sets = [];
      this.length = 50;
      for (var i = 0; i < 20; i++) {
        this.sets[i] = _scrambleText(80, this.chars);
      }
    }
    var _proto = CharSet2.prototype;
    _proto.grow = function grow(newLength) {
      for (var i = 0; i < 20; i++) {
        this.sets[i] += _scrambleText(newLength - this.length, this.chars);
      }
      this.length = newLength;
    };
    return CharSet2;
  })();
  var gsap5;
  var _coreInitted5;
  var _getGSAP5 = function _getGSAP6() {
    return gsap5 || typeof window !== "undefined" && (gsap5 = window.gsap) && gsap5.registerPlugin && gsap5;
  };
  var _bonusValidated = 1;
  var _spacesExp = /\s+/g;
  var _scrambleText = function _scrambleText2(length, chars) {
    var l = chars.length, s = "";
    while (--length > -1) {
      s += chars[~~(Math.random() * l)];
    }
    return s;
  };
  var _upper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  var _lower = _upper.toLowerCase();
  var _charsLookup = {
    upperCase: new CharSet(_upper),
    lowerCase: new CharSet(_lower),
    upperAndLowerCase: new CharSet(_upper + _lower)
  };
  var _initCore5 = function _initCore6() {
    _coreInitted5 = gsap5 = _getGSAP5();
  };
  var ScrambleTextPlugin = {
    version: "3.13.0",
    name: "scrambleText",
    register: function register(core, Plugin, propTween) {
      gsap5 = core;
      _initCore5();
    },
    init: function init4(target, value, tween, index, targets) {
      _coreInitted5 || _initCore5();
      this.prop = "innerHTML" in target ? "innerHTML" : "textContent" in target ? "textContent" : 0;
      if (!this.prop) {
        return;
      }
      this.target = target;
      if (typeof value !== "object") {
        value = {
          text: value
        };
      }
      var text = value.text || value.value || "", trim = value.trim !== false, data = this, delim, maxLength, charset, splitByChars;
      data.delimiter = delim = value.delimiter || "";
      data.original = emojiSafeSplit(getText(target).replace(_spacesExp, " ").split("&nbsp;").join(""), delim, trim);
      if (text === "{original}" || text === true || text == null) {
        text = data.original.join(delim);
      }
      data.text = emojiSafeSplit((text || "").replace(_spacesExp, " "), delim, trim);
      data.hasClass = !!(value.newClass || value.oldClass);
      data.newClass = value.newClass;
      data.oldClass = value.oldClass;
      splitByChars = delim === "";
      data.textHasEmoji = splitByChars && !!data.text.emoji;
      data.charsHaveEmoji = !!value.chars && !!emojiSafeSplit(value.chars).emoji;
      data.length = splitByChars ? data.original.length : data.original.join(delim).length;
      data.lengthDif = (splitByChars ? data.text.length : data.text.join(delim).length) - data.length;
      data.fillChar = value.fillChar || value.chars && ~value.chars.indexOf(" ") ? "&nbsp;" : "";
      data.charSet = charset = _charsLookup[value.chars || "upperCase"] || new CharSet(value.chars);
      data.speed = 0.05 / (value.speed || 1);
      data.prevScrambleTime = 0;
      data.setIndex = Math.random() * 20 | 0;
      maxLength = data.length + Math.max(data.lengthDif, 0);
      if (maxLength > charset.length) {
        charset.grow(maxLength);
      }
      data.chars = charset.sets[data.setIndex];
      data.revealDelay = value.revealDelay || 0;
      data.tweenLength = value.tweenLength !== false;
      data.tween = tween;
      data.rightToLeft = !!value.rightToLeft;
      data._props.push("scrambleText", "text");
      return _bonusValidated;
    },
    render: function render3(ratio, data) {
      var target = data.target, prop = data.prop, text = data.text, delimiter = data.delimiter, tween = data.tween, prevScrambleTime = data.prevScrambleTime, revealDelay = data.revealDelay, setIndex = data.setIndex, chars = data.chars, charSet = data.charSet, length = data.length, textHasEmoji = data.textHasEmoji, charsHaveEmoji = data.charsHaveEmoji, lengthDif = data.lengthDif, tweenLength = data.tweenLength, oldClass = data.oldClass, newClass = data.newClass, rightToLeft = data.rightToLeft, fillChar = data.fillChar, speed = data.speed, original = data.original, hasClass = data.hasClass, l = text.length, time2 = tween._time, timeDif = time2 - prevScrambleTime, i, i2, startText, endText, applyNew, applyOld, str, startClass, endClass, position, r;
      if (revealDelay) {
        if (tween._from) {
          time2 = tween._dur - time2;
        }
        ratio = time2 === 0 ? 0 : time2 < revealDelay ? 1e-6 : time2 === tween._dur ? 1 : tween._ease((time2 - revealDelay) / (tween._dur - revealDelay));
      }
      if (ratio < 0) {
        ratio = 0;
      } else if (ratio > 1) {
        ratio = 1;
      }
      if (rightToLeft) {
        ratio = 1 - ratio;
      }
      i = ~~(ratio * l + 0.5);
      if (ratio) {
        if (timeDif > speed || timeDif < -speed) {
          data.setIndex = setIndex = (setIndex + (Math.random() * 19 | 0)) % 20;
          data.chars = charSet.sets[setIndex];
          data.prevScrambleTime += timeDif;
        }
        endText = chars;
      } else {
        endText = original.join(delimiter);
      }
      r = tween._from ? ratio : 1 - ratio;
      position = length + (tweenLength ? tween._from ? r * r * r : 1 - r * r * r : 1) * lengthDif;
      if (rightToLeft) {
        if (ratio === 1 && (tween._from || tween.data === "isFromStart")) {
          startText = "";
          endText = original.join(delimiter);
        } else {
          str = text.slice(i).join(delimiter);
          if (charsHaveEmoji) {
            startText = emojiSafeSplit(endText).slice(0, position - (textHasEmoji ? emojiSafeSplit(str) : str).length + 0.5 | 0).join("");
          } else {
            startText = endText.substr(0, position - (textHasEmoji ? emojiSafeSplit(str) : str).length + 0.5 | 0);
          }
          endText = str;
        }
      } else {
        startText = text.slice(0, i).join(delimiter);
        i2 = (textHasEmoji ? emojiSafeSplit(startText) : startText).length;
        if (charsHaveEmoji) {
          endText = emojiSafeSplit(endText).slice(i2, position + 0.5 | 0).join("");
        } else {
          endText = endText.substr(i2, position - i2 + 0.5 | 0);
        }
      }
      if (hasClass) {
        startClass = rightToLeft ? oldClass : newClass;
        endClass = rightToLeft ? newClass : oldClass;
        applyNew = startClass && i !== 0;
        applyOld = endClass && i !== l;
        str = (applyNew ? "<span class='" + startClass + "'>" : "") + startText + (applyNew ? "</span>" : "") + (applyOld ? "<span class='" + endClass + "'>" : "") + delimiter + endText + (applyOld ? "</span>" : "");
      } else {
        str = startText + delimiter + endText;
      }
      target[prop] = fillChar === "&nbsp;" && ~str.indexOf("  ") ? str.split("  ").join("&nbsp;&nbsp;") : str;
    }
  };
  ScrambleTextPlugin.emojiSafeSplit = emojiSafeSplit;
  ScrambleTextPlugin.getText = getText;
  _getGSAP5() && gsap5.registerPlugin(ScrambleTextPlugin);

  // frontend/src/components/ScrambledText/ScrambledText.jsx
  var import_jsx_runtime6 = __toESM(require_jsx_runtime());
  gsapWithCSS.registerPlugin(SplitText, ScrambleTextPlugin);

  // frontend/src/components/ScrollVelocity/ScrollVelocity.jsx
  var import_react32 = __toESM(require_react());
  var import_jsx_runtime7 = __toESM(require_jsx_runtime());
  function useElementWidth(ref2) {
    const [width, setWidth] = (0, import_react32.useState)(0);
    (0, import_react32.useLayoutEffect)(() => {
      function updateWidth() {
        if (ref2.current) {
          setWidth(ref2.current.offsetWidth);
        }
      }
      updateWidth();
      window.addEventListener("resize", updateWidth);
      return () => window.removeEventListener("resize", updateWidth);
    }, [ref2]);
    return width;
  }
  var ScrollVelocity = ({
    scrollContainerRef,
    texts = [],
    velocity = 100,
    className = "",
    damping = 50,
    stiffness = 400,
    numCopies = 6,
    velocityMapping = { input: [0, 1e3], output: [0, 5] },
    parallaxClassName = "parallax",
    scrollerClassName = "scroller",
    parallaxStyle,
    scrollerStyle
  }) => {
    function VelocityText({
      children,
      baseVelocity = velocity,
      scrollContainerRef: scrollContainerRef2,
      className: className2 = "",
      damping: damping2,
      stiffness: stiffness2,
      numCopies: numCopies2,
      velocityMapping: velocityMapping2,
      parallaxClassName: parallaxClassName2,
      scrollerClassName: scrollerClassName2,
      parallaxStyle: parallaxStyle2,
      scrollerStyle: scrollerStyle2
    }) {
      const baseX = useMotionValue(0);
      const scrollOptions = scrollContainerRef2 ? { container: scrollContainerRef2 } : {};
      const { scrollY } = useScroll(scrollOptions);
      const scrollVelocity = useVelocity(scrollY);
      const smoothVelocity = useSpring(scrollVelocity, {
        damping: damping2 ?? 50,
        stiffness: stiffness2 ?? 400
      });
      const velocityFactor = useTransform(
        smoothVelocity,
        velocityMapping2?.input || [0, 1e3],
        velocityMapping2?.output || [0, 5],
        { clamp: false }
      );
      const copyRef = (0, import_react32.useRef)(null);
      const copyWidth = useElementWidth(copyRef);
      function wrap3(min, max, v) {
        const range = max - min;
        const mod = ((v - min) % range + range) % range;
        return mod + min;
      }
      const x = useTransform(baseX, (v) => {
        if (copyWidth === 0) return "0px";
        return `${wrap3(-copyWidth, 0, v)}px`;
      });
      const directionFactor = (0, import_react32.useRef)(1);
      useAnimationFrame((t, delta) => {
        let moveBy = directionFactor.current * baseVelocity * (delta / 1e3);
        if (velocityFactor.get() < 0) {
          directionFactor.current = -1;
        } else if (velocityFactor.get() > 0) {
          directionFactor.current = 1;
        }
        moveBy += directionFactor.current * moveBy * velocityFactor.get();
        baseX.set(baseX.get() + moveBy);
      });
      const spans = [];
      for (let i = 0; i < numCopies2; i++) {
        spans.push(
          /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("span", { className: className2, ref: i === 0 ? copyRef : null, children }, i)
        );
      }
      return /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("div", { className: parallaxClassName2, style: parallaxStyle2, children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
        motion.div,
        {
          className: scrollerClassName2,
          style: { x, ...scrollerStyle2 },
          children: spans
        }
      ) });
    }
    return /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("section", { children: texts.map((text, index) => /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)(
      VelocityText,
      {
        className,
        baseVelocity: index % 2 !== 0 ? -velocity : velocity,
        scrollContainerRef,
        damping,
        stiffness,
        numCopies,
        velocityMapping,
        parallaxClassName,
        scrollerClassName,
        parallaxStyle,
        scrollerStyle,
        children: [
          text,
          "\xA0"
        ]
      },
      index
    )) });
  };
  var ScrollVelocity_default = ScrollVelocity;

  // frontend/src/components/Squares/Squares.jsx
  var import_react34 = __toESM(require_react());
  var import_jsx_runtime8 = __toESM(require_jsx_runtime());
  var Squares = ({
    direction = "right",
    speed = 1,
    borderColor = "#999",
    squareSize = 40,
    hoverFillColor = "#222",
    className = ""
  }) => {
    const canvasRef = (0, import_react34.useRef)(null);
    const requestRef = (0, import_react34.useRef)(null);
    const numSquaresX = (0, import_react34.useRef)();
    const numSquaresY = (0, import_react34.useRef)();
    const gridOffset = (0, import_react34.useRef)({ x: 0, y: 0 });
    const hoveredSquare = (0, import_react34.useRef)(null);
    (0, import_react34.useEffect)(() => {
      const canvas = canvasRef.current;
      const ctx = canvas.getContext("2d");
      const resizeCanvas = () => {
        canvas.width = canvas.offsetWidth;
        canvas.height = canvas.offsetHeight;
        numSquaresX.current = Math.ceil(canvas.width / squareSize) + 1;
        numSquaresY.current = Math.ceil(canvas.height / squareSize) + 1;
      };
      window.addEventListener("resize", resizeCanvas);
      resizeCanvas();
      const drawGrid = () => {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const startX = Math.floor(gridOffset.current.x / squareSize) * squareSize;
        const startY = Math.floor(gridOffset.current.y / squareSize) * squareSize;
        for (let x = startX; x < canvas.width + squareSize; x += squareSize) {
          for (let y = startY; y < canvas.height + squareSize; y += squareSize) {
            const squareX = x - gridOffset.current.x % squareSize;
            const squareY = y - gridOffset.current.y % squareSize;
            if (hoveredSquare.current && Math.floor((x - startX) / squareSize) === hoveredSquare.current.x && Math.floor((y - startY) / squareSize) === hoveredSquare.current.y) {
              ctx.fillStyle = hoverFillColor;
              ctx.fillRect(squareX, squareY, squareSize, squareSize);
            }
            ctx.strokeStyle = borderColor;
            ctx.strokeRect(squareX, squareY, squareSize, squareSize);
          }
        }
        const gradient = ctx.createRadialGradient(
          canvas.width / 2,
          canvas.height / 2,
          0,
          canvas.width / 2,
          canvas.height / 2,
          Math.sqrt(canvas.width ** 2 + canvas.height ** 2) / 2
        );
        gradient.addColorStop(0, "rgba(0, 0, 0, 0)");
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      };
      const updateAnimation = () => {
        const effectiveSpeed = Math.max(speed, 0.1);
        switch (direction) {
          case "right":
            gridOffset.current.x = (gridOffset.current.x - effectiveSpeed + squareSize) % squareSize;
            break;
          case "left":
            gridOffset.current.x = (gridOffset.current.x + effectiveSpeed + squareSize) % squareSize;
            break;
          case "up":
            gridOffset.current.y = (gridOffset.current.y + effectiveSpeed + squareSize) % squareSize;
            break;
          case "down":
            gridOffset.current.y = (gridOffset.current.y - effectiveSpeed + squareSize) % squareSize;
            break;
          case "diagonal":
            gridOffset.current.x = (gridOffset.current.x - effectiveSpeed + squareSize) % squareSize;
            gridOffset.current.y = (gridOffset.current.y - effectiveSpeed + squareSize) % squareSize;
            break;
          default:
            break;
        }
        drawGrid();
        requestRef.current = requestAnimationFrame(updateAnimation);
      };
      const handleMouseMove = (event) => {
        const rect = canvas.getBoundingClientRect();
        const mouseX = event.clientX - rect.left;
        const mouseY = event.clientY - rect.top;
        const startX = Math.floor(gridOffset.current.x / squareSize) * squareSize;
        const startY = Math.floor(gridOffset.current.y / squareSize) * squareSize;
        const hoveredSquareX = Math.floor(
          (mouseX + gridOffset.current.x - startX) / squareSize
        );
        const hoveredSquareY = Math.floor(
          (mouseY + gridOffset.current.y - startY) / squareSize
        );
        if (!hoveredSquare.current || hoveredSquare.current.x !== hoveredSquareX || hoveredSquare.current.y !== hoveredSquareY) {
          hoveredSquare.current = { x: hoveredSquareX, y: hoveredSquareY };
        }
      };
      const handleMouseLeave = () => {
        hoveredSquare.current = null;
      };
      canvas.addEventListener("mousemove", handleMouseMove);
      canvas.addEventListener("mouseleave", handleMouseLeave);
      requestRef.current = requestAnimationFrame(updateAnimation);
      return () => {
        window.removeEventListener("resize", resizeCanvas);
        cancelAnimationFrame(requestRef.current);
        canvas.removeEventListener("mousemove", handleMouseMove);
        canvas.removeEventListener("mouseleave", handleMouseLeave);
      };
    }, [direction, speed, borderColor, hoverFillColor, squareSize]);
    return /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("canvas", { ref: canvasRef, className: `squares-canvas ${className}` });
  };
  var Squares_default = Squares;

  // frontend/src/App.jsx
  var import_jsx_runtime9 = __toESM(require_jsx_runtime());
  var import_meta = {};
  var isdevmodeenabled = true;
  var DEFAULT_BACKEND_BASE = "http://127.0.0.1:5001";
  var envApiBase = void 0;
  try {
    envApiBase = import_meta?.env?.VITE_API_BASE_URL;
  } catch (err) {
    envApiBase = void 0;
  }
  var API_BASE = envApiBase || (typeof window !== "undefined" && window.location.protocol === "file:" ? DEFAULT_BACKEND_BASE : "");
  function HomePage() {
    const navigate = useNavigate();
    (0, import_react35.useEffect)(() => {
      if (localStorage.getItem("skipHome") === "true") {
        navigate("/main");
      }
    }, [navigate]);
    function handleStartClick() {
      localStorage.setItem("skipHome", "true");
      navigate("/main");
    }
    return /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { className: "app-container", children: [
      /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("div", { className: "background-layer", children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
        Squares_default,
        {
          speed: 0.2,
          squareSize: 40,
          direction: "up",
          borderColor: "#fff",
          hoverFillColor: "#222"
        }
      ) }),
      /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { className: "welcome-shell", children: [
        /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("div", { className: "titlebar", children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("span", {}) }),
        /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
          SplitText_default,
          {
            text: "Welcome to LearnIT",
            className: "welcome-headline",
            delay: 100,
            duration: 0.6,
            ease: "power3.out",
            splitType: "words,chars",
            from: { opacity: 0, y: 36 },
            to: { opacity: 1, y: 0 },
            threshold: 0.1,
            rootMargin: "-100px",
            textAlign: "center",
            tag: "h1"
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("p", { className: "welcome-note", children: "Learn more about the topics that you like Powered by AI." }),
        /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("p", { className: "welcome-tagline", children: "Developed by Eduardo Almeyda" }),
        /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { children: [
          /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(TargetCursor_default, { spinDuration: 2, hideDefaultCursor: true }),
          /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("button", { id: "start-button", className: "cursor-target", onClick: handleStartClick, children: "Start Here" })
        ] })
      ] })
    ] });
  }
  function VideoPage() {
    const navigate = useNavigate();
    const [videoId, setVideoId] = (0, import_react35.useState)("");
    const [title, setTitle] = (0, import_react35.useState)("");
    const [currentTime, setCurrentTime] = (0, import_react35.useState)(0);
    const [streamUrl, setStreamUrl] = (0, import_react35.useState)("");
    const [loading, setLoading] = (0, import_react35.useState)(false);
    const [error, setError] = (0, import_react35.useState)("");
    const videoRef = import_react35.default.useRef(null);
    const hlsRef = import_react35.default.useRef(null);
    const [chatMessages, setChatMessages] = (0, import_react35.useState)([]);
    const [chatInput, setChatInput] = (0, import_react35.useState)("");
    const [chatLoading, setChatLoading] = (0, import_react35.useState)(false);
    const chatMessagesEndRef = import_react35.default.useRef(null);
    const [videoSummary, setVideoSummary] = (0, import_react35.useState)("");
    const [summaryLoading, setSummaryLoading] = (0, import_react35.useState)(false);
    const [quizMode, setQuizMode] = (0, import_react35.useState)(false);
    const [quizQuestions, setQuizQuestions] = (0, import_react35.useState)([]);
    const [currentQuestionIndex, setCurrentQuestionIndex] = (0, import_react35.useState)(0);
    const [selectedAnswer, setSelectedAnswer] = (0, import_react35.useState)(null);
    const [quizAnswers, setQuizAnswers] = (0, import_react35.useState)([]);
    const [showExplanation, setShowExplanation] = (0, import_react35.useState)(false);
    const [quizLoading, setQuizLoading] = (0, import_react35.useState)(false);
    const [quizComplete, setQuizComplete] = (0, import_react35.useState)(false);
    (0, import_react35.useEffect)(() => {
      const currentLesson = JSON.parse(localStorage.getItem("currentLesson"));
      if (currentLesson) {
        setVideoId(currentLesson.videoId);
        console.log("Video ID set to:", currentLesson.videoId);
        setTitle(currentLesson.title);
        const savedProgress = localStorage.getItem(`progress_${currentLesson.videoId}`);
        if (savedProgress) {
          setCurrentTime(parseInt(savedProgress));
        }
        fetchStreamUrl(currentLesson.videoId);
      }
      return () => {
        if (hlsRef.current) {
          hlsRef.current.destroy();
        }
        if (currentLesson && videoRef.current) {
          localStorage.setItem(`progress_${currentLesson.videoId}`, Math.floor(videoRef.current.currentTime).toString());
        }
      };
    }, []);
    const fetchStreamUrl = async (vid) => {
      setLoading(true);
      setError("");
      try {
        const response = await fetch(`${API_BASE}/api/youtube/stream`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ videoId: vid })
        });
        const data = await response.json();
        if (response.ok) {
          setStreamUrl(data.streamUrl);
          setTimeout(() => {
            fetchVideoSummary();
          }, 5e3);
        } else {
          setError(data.error || "Failed to load video");
        }
      } catch (err) {
        setError("Failed to connect to backend");
        console.error(err);
      } finally {
        setLoading(false);
      }
    };
    const fetchVideoSummary = async () => {
      setSummaryLoading(true);
      try {
        const response = await fetch(`${API_BASE}/api/video/summary`, {
          method: "POST",
          headers: { "Content-Type": "application/json" }
        });
        if (response.ok) {
          const data = await response.json();
          setVideoSummary(data.summary);
        } else {
          console.error("Failed to load video summary");
        }
      } catch (err) {
        console.error("Error fetching video summary:", err);
      } finally {
        setSummaryLoading(false);
      }
    };
    (0, import_react35.useEffect)(() => {
      if (!streamUrl || !videoRef.current) return;
      const video = videoRef.current;
      if (Hls.isSupported()) {
        if (hlsRef.current) {
          hlsRef.current.destroy();
        }
        const hls = new Hls({
          enableWorker: true,
          lowLatencyMode: true,
          backBufferLength: 90
        });
        hlsRef.current = hls;
        hls.loadSource(streamUrl);
        hls.attachMedia(video);
        hls.on(Hls.Events.MANIFEST_PARSED, () => {
          console.log("HLS manifest parsed, starting playback");
          if (currentTime > 0) {
            video.currentTime = currentTime;
          }
          video.play().catch((err) => console.log("Autoplay prevented:", err));
        });
        hls.on(Hls.Events.ERROR, (event, data) => {
          console.error("HLS error:", data);
          if (data.fatal) {
            switch (data.type) {
              case Hls.ErrorTypes.NETWORK_ERROR:
                console.log("Network error, trying to recover...");
                hls.startLoad();
                break;
              case Hls.ErrorTypes.MEDIA_ERROR:
                console.log("Media error, trying to recover...");
                hls.recoverMediaError();
                break;
              default:
                console.log("Fatal error, destroying HLS instance");
                hls.destroy();
                setError("Failed to play video stream");
                break;
            }
          }
        });
      } else if (video.canPlayType("application/vnd.apple.mpegurl")) {
        video.src = streamUrl;
        video.addEventListener("loadedmetadata", () => {
          if (currentTime > 0) {
            video.currentTime = currentTime;
          }
        });
      } else {
        setError("HLS not supported in this browser");
      }
      return () => {
        if (hlsRef.current) {
          hlsRef.current.destroy();
        }
      };
    }, [streamUrl, currentTime]);
    (0, import_react35.useEffect)(() => {
      if (!videoId || !videoRef.current) return;
      const interval = setInterval(() => {
        if (videoRef.current && !videoRef.current.paused) {
          const time2 = Math.floor(videoRef.current.currentTime);
          localStorage.setItem(`progress_${videoId}`, time2.toString());
          console.log(`Progress saved: ${time2} seconds`);
        }
      }, 5e3);
      return () => clearInterval(interval);
    }, [videoId, streamUrl]);
    (0, import_react35.useEffect)(() => {
      chatMessagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
    }, [chatMessages]);
    const sendChatMessage = async () => {
      if (!chatInput.trim() || chatLoading) return;
      const currentTimestamp = videoRef.current ? Math.floor(videoRef.current.currentTime) : 0;
      const minutes = Math.floor(currentTimestamp / 60);
      const seconds = currentTimestamp % 60;
      const timeString = `${minutes}:${seconds.toString().padStart(2, "0")}`;
      const userMsg = { role: "user", text: chatInput };
      setChatMessages((prev) => [...prev, userMsg]);
      setChatInput("");
      setChatLoading(true);
      try {
        const response = await fetch(`${API_BASE}/api/AIP`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            message: `[Timestamp ${timeString}] ${chatInput}`
          })
        });
        if (!response.ok) {
          throw new Error("Failed to get response from AI");
        }
        const data = await response.json();
        const aiMsg = { role: "assistant", text: data.reply };
        setChatMessages((prev) => [...prev, aiMsg]);
      } catch (err) {
        console.error("Chat error:", err);
        setChatMessages((prev) => [...prev, {
          role: "error",
          text: "Failed to get response from AI. Please try again."
        }]);
      } finally {
        setChatLoading(false);
      }
    };
    const clearChat = () => {
      setChatMessages([]);
    };
    const startQuiz = async (personalized = false) => {
      setQuizLoading(true);
      setQuizMode(true);
      setQuizComplete(false);
      try {
        const currentTimestamp = videoRef.current ? Math.floor(videoRef.current.currentTime) : 0;
        const minutes = Math.floor(currentTimestamp / 60);
        const seconds = currentTimestamp % 60;
        const timeString = `${minutes}:${seconds.toString().padStart(2, "0")}`;
        const endpoint = personalized ? "/api/quiz/personalized" : "/api/quiz/generate";
        const body = personalized ? JSON.stringify({ previousAnswers: quizAnswers, timestamp: timeString }) : JSON.stringify({ timestamp: timeString });
        const response = await fetch(`${API_BASE}${endpoint}`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body
        });
        if (!response.ok) {
          throw new Error("Failed to generate quiz");
        }
        const data = await response.json();
        setQuizQuestions(data.questions || []);
        setCurrentQuestionIndex(0);
        setSelectedAnswer(null);
        setShowExplanation(false);
      } catch (err) {
        console.error("Quiz error:", err);
        alert("Failed to generate quiz. Please try again.");
        setQuizMode(false);
      } finally {
        setQuizLoading(false);
      }
    };
    const selectQuizAnswer = (optionIndex) => {
      if (showExplanation) return;
      setSelectedAnswer(optionIndex);
    };
    const submitQuizAnswer = () => {
      if (selectedAnswer === null) return;
      const currentQuestion = quizQuestions[currentQuestionIndex];
      const isCorrect = selectedAnswer === currentQuestion.correct;
      setQuizAnswers((prev) => [...prev, {
        question: currentQuestion.question,
        correct: isCorrect,
        topic: currentQuestion.question.split(" ").slice(0, 5).join(" ")
        // First few words as topic
      }]);
      setShowExplanation(true);
    };
    const nextQuestion = () => {
      if (currentQuestionIndex < quizQuestions.length - 1) {
        setCurrentQuestionIndex((prev) => prev + 1);
        setSelectedAnswer(null);
        setShowExplanation(false);
      } else {
        setQuizComplete(true);
      }
    };
    const exitQuiz = () => {
      setQuizMode(false);
      setQuizQuestions([]);
      setCurrentQuestionIndex(0);
      setSelectedAnswer(null);
      setShowExplanation(false);
      setQuizComplete(false);
    };
    return /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { style: { padding: 24 }, children: [
      /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("div", { className: "titlebar", children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("span", {}) }),
      /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
        "button",
        {
          onClick: () => navigate(-1),
          style: {
            background: "#2a2a2a",
            border: "1px solid #c0c0c0",
            padding: "8px 12px",
            color: "#fff",
            fontSize: "20px",
            cursor: "pointer",
            borderRadius: "6px",
            marginBottom: "20px",
            display: "inline-flex",
            alignItems: "center",
            justifyContent: "center",
            minWidth: "40px",
            transition: "all 0.2s ease"
          },
          onMouseOver: (e) => {
            e.currentTarget.style.background = "#3a3a3a";
          },
          onMouseOut: (e) => {
            e.currentTarget.style.background = "#2a2a2a";
          },
          children: "\u2190"
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("h1", { children: "Video Feed Page" }),
      /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("h1", { children: title }),
      /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("p", { children: [
        "Current Progress: ",
        videoRef.current ? Math.floor(videoRef.current.currentTime / 60) : 0,
        ":",
        videoRef.current ? (Math.floor(videoRef.current.currentTime) % 60).toString().padStart(2, "0") : "00"
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("p", { style: { fontSize: "12px", color: "#888" }, children: [
        "Video ID: ",
        videoId
      ] }),
      loading && /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("p", { children: "Loading video..." }),
      error && /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("p", { style: { color: "red" }, children: [
        "Error: ",
        error
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { className: "video-chat-wrapper", children: [
        streamUrl && !loading && /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("div", { className: "video-section", children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
          "video",
          {
            ref: videoRef,
            width: "800",
            height: "500",
            controls: true,
            style: { backgroundColor: "#000", maxWidth: "100%", height: "auto" }
          }
        ) }),
        /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { className: "ChatContainer", children: [
          /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { style: {
            display: "flex",
            justifyContent: "space-between",
            alignItems: "center",
            marginBottom: "10px"
          }, children: [
            /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("h3", { style: { margin: 0, color: "#fff" }, children: quizMode ? "Quiz Mode" : "Ask AI about this video" }),
            /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { style: { display: "flex", gap: "8px" }, children: [
              !quizMode && /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)(import_jsx_runtime9.Fragment, { children: [
                /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("button", { onClick: () => startQuiz(false), className: "quiz-button", children: "Test Understanding" }),
                /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("button", { onClick: () => startQuiz(true), className: "quiz-button-personalized", children: "Personalized Test" })
              ] }),
              quizMode && /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("button", { onClick: exitQuiz, className: "chat-clear-button", children: "Exit Quiz" }),
              !quizMode && chatMessages.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("button", { onClick: clearChat, className: "chat-clear-button", children: "Clear Chat" })
            ] })
          ] }),
          quizMode && quizLoading && /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("div", { className: "quiz-loading", children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("p", { children: "\u{1F914} Generating quiz questions..." }) }),
          quizMode && !quizLoading && quizComplete && /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { className: "quiz-complete", children: [
            /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("h2", { children: "Quiz Completed!" }),
            /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("p", { children: [
              "You answered ",
              quizAnswers.filter((a) => a.correct).length,
              " out of ",
              quizQuestions.length,
              " correctly"
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("p", { children: [
              "Score: ",
              Math.round(quizAnswers.filter((a) => a.correct).length / quizQuestions.length * 100),
              "%"
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { style: { marginTop: "20px", display: "flex", gap: "10px", justifyContent: "center" }, children: [
              /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("button", { onClick: () => startQuiz(false), className: "quiz-button", children: "Try Again" }),
              /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("button", { onClick: () => startQuiz(true), className: "quiz-button-personalized", children: "Personalized Test" }),
              /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("button", { onClick: exitQuiz, className: "chat-send-button", children: "Back to Chat" })
            ] })
          ] }),
          quizMode && !quizLoading && !quizComplete && quizQuestions.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { className: "quiz-question-container", children: [
            /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { className: "quiz-progress", children: [
              "Question ",
              currentQuestionIndex + 1,
              " of ",
              quizQuestions.length
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("div", { className: "quiz-question", children: quizQuestions[currentQuestionIndex].question }),
            /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("div", { className: "quiz-options", children: quizQuestions[currentQuestionIndex].options.map((option, idx) => /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
              "button",
              {
                onClick: () => selectQuizAnswer(idx),
                className: `quiz-option ${selectedAnswer === idx ? "selected" : ""} ${showExplanation && idx === quizQuestions[currentQuestionIndex].correct ? "correct" : ""} ${showExplanation && selectedAnswer === idx && idx !== quizQuestions[currentQuestionIndex].correct ? "incorrect" : ""}`,
                disabled: showExplanation,
                children: option
              },
              idx
            )) }),
            showExplanation && /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { className: "quiz-explanation", children: [
              /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("strong", { children: selectedAnswer === quizQuestions[currentQuestionIndex].correct ? "\u2705 Correct!" : "\u274C Incorrect" }),
              /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("p", { children: quizQuestions[currentQuestionIndex].explanation })
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { className: "quiz-actions", children: [
              !showExplanation && /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
                "button",
                {
                  onClick: submitQuizAnswer,
                  disabled: selectedAnswer === null,
                  className: "chat-send-button",
                  children: "Submit Answer"
                }
              ),
              showExplanation && /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("button", { onClick: nextQuestion, className: "chat-send-button", children: currentQuestionIndex < quizQuestions.length - 1 ? "Next Question" : "Finish Quiz" })
            ] })
          ] }),
          !quizMode && /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)(import_jsx_runtime9.Fragment, { children: [
            /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { className: "chat-messages-area", children: [
              chatMessages.length === 0 && /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("div", { className: "chat-empty-state", children: "Start a conversation about the video..." }),
              chatMessages.map((msg, idx) => /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { className: `chat-message ${msg.role}`, children: [
                /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { className: "chat-message-role", children: [
                  msg.role === "user" ? "\u{1F464} You" : msg.role === "error" ? "\u26A0\uFE0F Error" : "\u{1F916} AI",
                  ":"
                ] }),
                /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("div", { className: "chat-message-text", children: msg.text })
              ] }, idx)),
              chatLoading && /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("div", { style: {
                textAlign: "center",
                padding: "10px",
                fontStyle: "italic",
                color: "#666"
              }, children: "\u{1F914} AI is thinking..." }),
              /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("div", { ref: chatMessagesEndRef })
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { className: "chat-input-area", children: [
              /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
                "input",
                {
                  type: "text",
                  className: "chat-input",
                  value: chatInput,
                  onChange: (e) => setChatInput(e.target.value),
                  onKeyPress: (e) => {
                    if (e.key === "Enter" && !e.shiftKey) {
                      e.preventDefault();
                      sendChatMessage();
                    }
                  },
                  placeholder: "Ask a question about the video...",
                  disabled: chatLoading
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
                "button",
                {
                  onClick: sendChatMessage,
                  disabled: chatLoading || !chatInput.trim(),
                  className: "chat-send-button",
                  children: chatLoading ? "Sending..." : "Send"
                }
              )
            ] })
          ] })
        ] })
      ] }),
      summaryLoading && /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { style: {
        marginTop: "40px",
        padding: "20px 0",
        textAlign: "center",
        color: "#888",
        fontSize: "16px",
        fontStyle: "italic"
      }, children: [
        /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("div", { style: { fontSize: "24px", marginBottom: "10px" }, children: "\u{1F504}" }),
        "Generating video overview and key terms..."
      ] }),
      videoSummary && /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { style: {
        marginTop: "50px",
        paddingTop: "30px",
        borderTop: "2px solid #333"
      }, children: [
        /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("div", { style: {
          fontSize: "28px",
          fontWeight: "700",
          color: "#fff",
          marginBottom: "20px",
          letterSpacing: "0.5px"
        }, children: "\u{1F4DA} Video Overview" }),
        /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("div", { style: {
          color: "#ddd",
          fontSize: "16px",
          lineHeight: "1.8",
          whiteSpace: "pre-wrap",
          fontFamily: "inherit",
          maxWidth: "900px"
        }, children: videoSummary })
      ] })
    ] });
  }
  function CreditsPage() {
    const navigate = useNavigate();
    return /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { style: { padding: 24 }, children: [
      /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("div", { className: "titlebar", children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("span", {}) }),
      /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
        "button",
        {
          onClick: () => navigate("/main"),
          style: {
            marginBottom: "20px",
            padding: "10px 20px",
            background: "#444",
            color: "white",
            border: "none",
            borderRadius: "6px",
            cursor: "pointer",
            fontSize: "14px",
            fontWeight: "600"
          },
          children: "\u2190 Back to Dashboard"
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("h1", { children: "Credits Page" }),
      /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("p", { children: "This project was made for the Congressional App Project." }),
      /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("img", { src: "https://www.congressionalappchallenge.us/wp-content/uploads/2018/08/logo_white.png", className: "cimg" }),
      /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("p", { children: "Samples From:" }),
      /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("img", { src: "https://reactbits.dev/assets/react-bits-logo-BEVRCkxh.svg", className: "rimg" }),
      /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
        ScrollVelocity_default,
        {
          texts: ["Eduardo Almeyda"],
          velocity: 100,
          className: "custom-scroll-text"
        }
      )
    ] });
  }
  function MainPage() {
    const navigate = useNavigate();
    const [inputValue, setInputValue] = (0, import_react35.useState)("");
    function handleBack() {
      localStorage.removeItem("skipHome");
      navigate("/");
    }
    const [results, setResults] = (0, import_react35.useState)([]);
    const [error, setError] = (0, import_react35.useState)(null);
    const [loading, setLoading] = (0, import_react35.useState)(false);
    async function handleEnter(value) {
      const query = value.trim() + " course";
      if (!query) return;
      setLoading(true);
      setError(null);
      try {
        const response = await fetch(`${API_BASE}/api/youtube/search`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({ query })
        });
        if (!response.ok) {
          throw new Error(`Backend responded with ${response.status}`);
        }
        const json2 = await response.json();
        setResults(json2.results ?? []);
      } catch (err) {
        console.error("Failed to fetch results", err);
        setError(err.message);
        setResults([]);
      } finally {
        setLoading(false);
      }
    }
    function selectlesson(title, high, videoId) {
      let lessons = JSON.parse(localStorage.getItem("lessons")) || [];
      let exists = lessons.some((lesson) => lesson.title === title);
      if (!exists) {
        let lessons2 = JSON.parse(localStorage.getItem("lessons")) || [];
        lessons2.push({ title, high, videoId });
        console.log("Selected lesson:", title, high, videoId, "MEMDAT: ", JSON.stringify(lessons2));
        localStorage.setItem("lessons", JSON.stringify(lessons2));
      } else {
        console.log("Lesson Already exists, not adding duplicate");
      }
      navigate("/main", { state: { refresh: Date.now() } });
    }
    return /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { style: { padding: 24 }, children: [
      /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("div", { className: "titlebar", children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("span", {}) }),
      /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("h1", { children: "Current Lessons" }),
      /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("p", { className: "LessonTitle", children: " " }),
      /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("div", { className: "Selected-lessons-container", children: JSON.parse(localStorage.getItem("lessons"))?.map((lesson, index) => /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("div", { className: "Selected-lesson-item", onClick: () => {
        localStorage.setItem("currentLesson", JSON.stringify(lesson));
        navigate("/video");
      }, children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
        TiltedCard,
        {
          imageSrc: lesson.high,
          altText: lesson.title,
          captionText: lesson.title,
          containerHeight: "300px",
          containerWidth: "400px",
          imageHeight: "300px",
          imageWidth: "400px",
          rotateAmplitude: 12,
          scaleOnHover: 1.2,
          showMobileWarning: false,
          showTooltip: true,
          displayOverlayContent: true,
          overlayContent: /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("p", { className: "tilted--demo-text", children: [
            lesson.title,
            "card"
          ] })
        }
      ) }, index)) }),
      /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
        "input",
        {
          className: "search-input",
          type: "text",
          placeholder: "What do you want to learn?",
          value: inputValue,
          onChange: (e) => setInputValue(e.target.value),
          onKeyDown: (e) => e.key === "Enter" && handleEnter(e.target.value) && e.currentTarget.classList.toggle("clicked-style")
        }
      ),
      loading && /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("p", { children: "Searching\u2026" }),
      error && /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("p", { role: "alert", children: [
        "Error: ",
        error
      ] }),
      results.length > 0 && (console.log(results), /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("ul", { children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("div", { className: "results-container", children: results.map((item, idx) => /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("div", { className: "result-items", children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("div", { onClick: () => selectlesson(item.title, item.high, item.videoId), children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
        TiltedCard,
        {
          imageSrc: item.high,
          altText: item.title,
          captionText: item.title,
          containerHeight: "300px",
          containerWidth: "400px",
          imageHeight: "300px",
          imageWidth: "400px",
          rotateAmplitude: 12,
          scaleOnHover: 1.2,
          showMobileWarning: false,
          showTooltip: true,
          displayOverlayContent: true,
          overlayContent: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("p", { className: "tilted-card-demo-text", children: item.title })
        }
      ) }) }, idx)) }) })),
      /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("div", { style: { marginTop: "40px", borderTop: "1px solid #333", paddingTop: "20px" }, children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("button", { onClick: () => navigate("/credits"), style: {
        background: "linear-gradient(135deg, #667eea 0%, #764ba2 100%)",
        border: "none",
        padding: "12px 24px",
        color: "white",
        fontWeight: "bold",
        cursor: "pointer",
        borderRadius: "8px",
        fontSize: "14px"
      }, children: "Credit" }) }),
      isdevmodeenabled && /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { style: { marginTop: "20px", display: "flex", gap: "10px", flexWrap: "wrap" }, children: [
        /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("button", { onClick: handleBack, children: "BTM WIP (clear skip)" }),
        /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("button", { onClick: () => navigate("/video"), children: "GOTOVID (go to test video feed page)" }),
        /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("button", { onClick: () => {
          if (window.confirm("Are you sure you want to clear all data? This will delete all lessons and progress.")) {
            localStorage.clear();
            navigate("/");
            window.location.reload();
          }
        }, children: "Flush All Memory" })
      ] })
    ] });
  }
  var App = () => /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(HashRouter, { children: /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)(Routes, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(Route, { path: "/video", element: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(VideoPage, {}) }),
    /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(Route, { path: "/", element: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(HomePage, {}) }),
    /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(Route, { path: "/main", element: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(MainPage, {}) }),
    /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(Route, { path: "/credits", element: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(CreditsPage, {}) })
  ] }) });
  var App_default = App;

  // frontend/src/index.jsx
  var import_jsx_runtime10 = __toESM(require_jsx_runtime());
  var container = document.getElementById("root");
  var root = (0, import_client.createRoot)(container);
  root.render(
    /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(import_react36.default.StrictMode, { children: /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(App_default, {}) })
  );
})();
/*! Bundled license information:

react/cjs/react.development.js:
  (**
   * @license React
   * react.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

scheduler/cjs/scheduler.development.js:
  (**
   * @license React
   * scheduler.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom.development.js:
  (**
   * @license React
   * react-dom.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
  (**
   * Checks if an event is supported in the current execution environment.
   *
   * NOTE: This will not work correctly for non-generic events such as `change`,
   * `reset`, `load`, `error`, and `select`.
   *
   * Borrows from Modernizr.
   *
   * @param {string} eventNameSuffix Event name, e.g. "click".
   * @return {boolean} True if the event is supported.
   * @internal
   * @license Modernizr 3.0.0pre (Custom Build) | MIT
   *)

react/cjs/react-jsx-runtime.development.js:
  (**
   * @license React
   * react-jsx-runtime.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@remix-run/router/dist/router.js:
  (**
   * @remix-run/router v1.23.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

react-router/dist/index.js:
  (**
   * React Router v6.30.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

react-router-dom/dist/index.js:
  (**
   * React Router DOM v6.30.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

gsap/gsap-core.js:
  (*!
   * GSAP 3.13.0
   * https://gsap.com
   *
   * @license Copyright 2008-2025, GreenSock. All rights reserved.
   * Subject to the terms at https://gsap.com/standard-license
   * @author: Jack Doyle, jack@greensock.com
  *)

gsap/CSSPlugin.js:
  (*!
   * CSSPlugin 3.13.0
   * https://gsap.com
   *
   * Copyright 2008-2025, GreenSock. All rights reserved.
   * Subject to the terms at https://gsap.com/standard-license
   * @author: Jack Doyle, jack@greensock.com
  *)

gsap/Observer.js:
  (*!
   * Observer 3.13.0
   * https://gsap.com
   *
   * @license Copyright 2008-2025, GreenSock. All rights reserved.
   * Subject to the terms at https://gsap.com/standard-license
   * @author: Jack Doyle, jack@greensock.com
  *)

gsap/ScrollTrigger.js:
  (*!
   * ScrollTrigger 3.13.0
   * https://gsap.com
   *
   * @license Copyright 2008-2025, GreenSock. All rights reserved.
   * Subject to the terms at https://gsap.com/standard-license
   * @author: Jack Doyle, jack@greensock.com
  *)

gsap/SplitText.js:
  (*!
   * SplitText 3.13.0
   * https://gsap.com
   *
   * @license Copyright 2025, GreenSock. All rights reserved. Subject to the terms at https://gsap.com/standard-license.
   * @author: Jack Doyle
   *)

@gsap/react/src/index.js:
  (*!
   * @gsap/react 2.1.2
   * https://gsap.com
   *
   * Copyright 2008-2025, GreenSock. All rights reserved.
   * Subject to the terms at https://gsap.com/standard-license or for
   * Club GSAP members, the agreement issued with that membership.
   * @author: Jack Doyle, jack@greensock.com
  *)

gsap/utils/strings.js:
  (*!
   * strings: 3.13.0
   * https://gsap.com
   *
   * Copyright 2008-2025, GreenSock. All rights reserved.
   * Subject to the terms at https://gsap.com/standard-license
   * @author: Jack Doyle, jack@greensock.com
  *)

gsap/ScrambleTextPlugin.js:
  (*!
   * ScrambleTextPlugin 3.13.0
   * https://gsap.com
   *
   * @license Copyright 2008-2025, GreenSock. All rights reserved.
   * Subject to the terms at https://gsap.com/standard-license
   * @author: Jack Doyle, jack@greensock.com
  *)
*/
//# sourceMappingURL=renderer.js.map
